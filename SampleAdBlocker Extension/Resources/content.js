/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _asyncToGenerator)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./src/pages/common/constants.ts":
/*!***************************************!*\
  !*** ./src/pages/common/constants.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MessagesToNativeApp": () => (/* binding */ MessagesToNativeApp),
/* harmony export */   "MessagesToBackgroundPage": () => (/* binding */ MessagesToBackgroundPage),
/* harmony export */   "MessagesToContentScript": () => (/* binding */ MessagesToContentScript)
/* harmony export */ });
var MessagesToNativeApp;

(function (MessagesToNativeApp) {
  MessagesToNativeApp["GetJsonRules"] = "get_json_rules";
  MessagesToNativeApp["WriteInNativeLog"] = "write_in_native_log";
  MessagesToNativeApp["AddToUserrules"] = "add_to_userrules";
  MessagesToNativeApp["GetBlockingData"] = "get_blocking_data";
})(MessagesToNativeApp || (MessagesToNativeApp = {}));

var MessagesToBackgroundPage;

(function (MessagesToBackgroundPage) {
  MessagesToBackgroundPage["OpenAssistant"] = "open_assistant";
  MessagesToBackgroundPage["GetScriptsAndSelectors"] = "get_scripts_and_selectors";
  MessagesToBackgroundPage["AddRule"] = "add_rule";
  MessagesToBackgroundPage["GetAdvancedJson"] = "get_advanced_json";
})(MessagesToBackgroundPage || (MessagesToBackgroundPage = {}));

var MessagesToContentScript;

(function (MessagesToContentScript) {
  MessagesToContentScript["InitAssistant"] = "init_assistant";
})(MessagesToContentScript || (MessagesToContentScript = {}));

/***/ }),

/***/ "./src/pages/content/content.ts":
/*!**************************************!*\
  !*** ./src/pages/content/content.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "content": () => (/* binding */ content)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var webextension_polyfill_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! webextension-polyfill-ts */ "./node_modules/webextension-polyfill-ts/lib/index.js");
/* harmony import */ var extended_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! extended-css */ "./node_modules/extended-css/dist/extended-css.esm.js");
/* harmony import */ var scriptlets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! scriptlets */ "./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js");
/* harmony import */ var scriptlets__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(scriptlets__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _common_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/constants */ "./src/pages/common/constants.ts");



/* eslint-disable no-console */





/**
 * Logs a message if verbose is true
 *
 * @param verbose
 * @param message
 */
var logMessage = function logMessage(verbose, message) {
  if (verbose) {
    console.log("(AG) ".concat(message));
  }
};

var getSelectorsAndScripts = /*#__PURE__*/function () {
  var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee() {
    var response;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return webextension_polyfill_ts__WEBPACK_IMPORTED_MODULE_2__.browser.runtime.sendMessage({
              type: _common_constants__WEBPACK_IMPORTED_MODULE_5__.MessagesToBackgroundPage.GetScriptsAndSelectors,
              data: {
                url: window.location.href
              }
            });

          case 2:
            response = _context.sent;

            if (!(response === null)) {
              _context.next = 6;
              break;
            }

            console.log('AG: no scripts and selectors received');
            return _context.abrupt("return", null);

          case 6:
            _context.prev = 6;
            return _context.abrupt("return", JSON.parse(response));

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](6);
            console.log('AG: error occurred on selectors and script json parse', _context.t0);
            return _context.abrupt("return", null);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[6, 10]]);
  }));

  return function getSelectorsAndScripts() {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Execute scripts in a page context and cleanup itself when execution completes
 * @param scripts Scripts array to execute
 */


var executeScripts = function executeScripts(scripts) {
  // Wrap with try catch
  scripts.unshift('( function () { try {');
  scripts.push("} catch (ex) { console.error('Error executing AG js: ' + ex); } })();");
  var scriptTag = document.createElement('script');
  scriptTag.setAttribute('type', 'text/javascript');
  scriptTag.textContent = scripts.join('\r\n');
  var parent = document.head || document.documentElement;
  parent.appendChild(scriptTag);

  if (scriptTag.parentNode) {
    scriptTag.parentNode.removeChild(scriptTag);
  }
};
/**
 * Applies JS injections.
 * @param scripts Array with JS scripts
 * @param verbose logging
 */


var applyScripts = function applyScripts(scripts, verbose) {
  if (!scripts || scripts.length === 0) {
    return;
  }

  logMessage(verbose, "scripts length: ".concat(scripts.length));
  executeScripts(scripts.reverse());
};
/**
 * Protects specified style element from changes to the current document
 * Add a mutation observer, which is adds our rules again if it was removed
 *
 * @param protectStyleEl protected style element
 */


var protectStyleElementContent = function protectStyleElementContent(protectStyleEl) {
  // @ts-ignore
  var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;

  if (!MutationObserver) {
    return;
  }
  /* observer, which observe protectStyleEl inner changes, without deleting styleEl */


  var innerObserver = new MutationObserver(function (mutations) {
    for (var i = 0; i < mutations.length; i += 1) {
      var m = mutations[i]; // @ts-ignore

      if (protectStyleEl.hasAttribute('mod') && protectStyleEl.getAttribute('mod') === 'inner') {
        // @ts-ignore
        protectStyleEl.removeAttribute('mod');
        break;
      } // @ts-ignore


      protectStyleEl.setAttribute('mod', 'inner');
      var isProtectStyleElModified = false;
      /**
       * further, there are two mutually exclusive situations: either there were changes
       * the text of protectStyleEl, either there was removes a whole child "text"
       * element of protectStyleEl we'll process both of them
       */

      if (m.removedNodes.length > 0) {
        for (var j = 0; j < m.removedNodes.length; j += 1) {
          isProtectStyleElModified = true;
          protectStyleEl.appendChild(m.removedNodes[j]);
        }
      } else if (m.oldValue) {
        isProtectStyleElModified = true; // eslint-disable-next-line no-param-reassign

        protectStyleEl.textContent = m.oldValue;
      }

      if (!isProtectStyleElModified) {
        // @ts-ignore
        protectStyleEl.removeAttribute('mod');
      }
    }
  });
  innerObserver.observe(protectStyleEl, {
    childList: true,
    characterData: true,
    subtree: true,
    characterDataOldValue: true
  });
};
/**
 * Applies css stylesheet
 * @param styleSelectors Array of stylesheets or selectors
 * @param verbose logging
 */


var applyCss = function applyCss(styleSelectors, verbose) {
  console.log(styleSelectors);

  if (!styleSelectors || !styleSelectors.length) {
    return;
  }

  console.log(styleSelectors);
  logMessage(verbose, "css length: ".concat(styleSelectors.length));
  var styleElement = document.createElement('style');
  styleElement.setAttribute('type', 'text/css');
  (document.head || document.documentElement).appendChild(styleElement);
  var selectors = styleSelectors.map(function (s) {
    return s.trim();
  });
  console.log(selectors);
  selectors.forEach(function (selector) {
    styleElement.sheet.insertRule(selector);
  });
  protectStyleElementContent(styleElement);
};
/**
 * Applies Extended Css stylesheet
 *
 * @param extendedCss Array with ExtendedCss stylesheets
 * @param verbose logging
 */


var applyExtendedCss = function applyExtendedCss(extendedCss, verbose) {
  if (!extendedCss || !extendedCss.length) {
    return;
  }

  logMessage(verbose, "extended css length: ".concat(extendedCss.length));
  var extcss = new extended_css__WEBPACK_IMPORTED_MODULE_3__.default({
    styleSheet: extendedCss.filter(function (s) {
      return s.length > 0;
    }).map(function (s) {
      return s.trim();
    }).map(function (s) {
      return s[s.length - 1] !== '}' ? "".concat(s, " {display:none!important;}") : s;
    }).join('\n')
  });
  extcss.apply();
};
/**
 * Applies scriptlets
 *
 * @param scriptletsData Array with scriptlets data
 * @param verbose logging
 */


var applyScriptlets = function applyScriptlets(scriptletsData, verbose) {
  if (!scriptletsData || !scriptletsData.length) {
    return;
  }

  logMessage(verbose, "scriptlets length: ".concat(scriptletsData.length));
  var scriptletExecutableScripts = scriptletsData.map(function (s) {
    var param = JSON.parse(s);
    param.engine = 'safari-extension';

    if (verbose) {
      param.verbose = true;
    }

    var code = (scriptlets__WEBPACK_IMPORTED_MODULE_4___default()) && scriptlets__WEBPACK_IMPORTED_MODULE_4___default().invoke(param);
    return code || '';
  });
  console.log(scriptletExecutableScripts);
  executeScripts(scriptletExecutableScripts); // @ts-ignore

  console.log(window.adg);
};
/**
 * Applies injected script and css
 *
 * @param selectorsAndScripts
 * @param verbose
 */


var applyAdvancedBlockingData = function applyAdvancedBlockingData(selectorsAndScripts) {
  var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  logMessage(verbose, 'Applying scripts and css..');
  logMessage(verbose, "Frame url: ".concat(window.location.href));
  applyScripts(selectorsAndScripts.scripts, verbose);
  applyCss(selectorsAndScripts.cssInject, verbose);
  applyExtendedCss(selectorsAndScripts.cssExtended, verbose);
  applyScriptlets(selectorsAndScripts.scriptlets, verbose);
  logMessage(verbose, 'Applying scripts and css - done');
};

var init = /*#__PURE__*/function () {
  var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2() {
    var startGettingScripts, selectorsAndScripts;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(document instanceof HTMLDocument)) {
              _context2.next = 14;
              break;
            }

            if (!(window.location.href && window.location.href.indexOf('http') === 0)) {
              _context2.next = 14;
              break;
            }

            startGettingScripts = Date.now();
            _context2.prev = 3;
            _context2.next = 6;
            return getSelectorsAndScripts();

          case 6:
            selectorsAndScripts = _context2.sent;
            _context2.next = 12;
            break;

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](3);
            console.log(_context2.t0);

          case 12:
            console.log("Time to get selectors and scripts from native page to content script: ".concat(Date.now() - startGettingScripts, " ms"));

            if (selectorsAndScripts) {
              applyAdvancedBlockingData(selectorsAndScripts, false);
            }

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 9]]);
  }));

  return function init() {
    return _ref2.apply(this, arguments);
  };
}();

var content = {
  init: init
};

/***/ }),

/***/ "./src/pages/content/index.ts":
/*!************************************!*\
  !*** ./src/pages/content/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "content": () => (/* reexport safe */ _content__WEBPACK_IMPORTED_MODULE_0__.content)
/* harmony export */ });
/* harmony import */ var _content__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content */ "./src/pages/content/content.ts");


/***/ }),

/***/ "./node_modules/extended-css/dist/extended-css.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/extended-css/dist/extended-css.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*! extended-css - v1.3.12 - Mon May 31 2021
* https://github.com/AdguardTeam/ExtendedCss
* Copyright (c) 2021 AdGuard. Licensed LGPL-3.0
*/
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/**
 * Copyright 2016 Adguard Software Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-console */
var utils = {};
utils.MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
/**
 * Stores native Node textContent getter to be used for contains pseudo-class
 * because elements' 'textContent' and 'innerText' properties might be mocked
 * https://github.com/AdguardTeam/ExtendedCss/issues/127
 */

utils.nodeTextContentGetter = function () {
  var nativeNode = window.Node || Node;
  return Object.getOwnPropertyDescriptor(nativeNode.prototype, 'textContent').get;
}();

utils.isSafariBrowser = function () {
  var isChrome = navigator.userAgent.indexOf('Chrome') > -1;
  var isSafari = navigator.userAgent.indexOf('Safari') > -1;

  if (isSafari) {
    if (isChrome) {
      // Chrome seems to have both Chrome and Safari userAgents
      return false;
    }

    return true;
  }

  return false;
}();
/**
 * Converts regular expressions passed as pseudo class arguments into RegExp instances.
 * Have to unescape doublequote " as well, because we escape them while enclosing such
 * arguments with doublequotes, and sizzle does not automatically unescapes them.
 */


utils.pseudoArgToRegex = function (regexSrc, flag) {
  flag = flag || 'i';
  regexSrc = regexSrc.trim().replace(/\\(["\\])/g, '$1');
  return new RegExp(regexSrc, flag);
};
/**
 * Converts string to the regexp
 * @param {string} str
 * @returns {RegExp}
 */


utils.toRegExp = function (str) {
  if (str[0] === '/' && str[str.length - 1] === '/') {
    return new RegExp(str.slice(1, -1));
  }

  var escaped = str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  return new RegExp(escaped);
};

utils.startsWith = function (str, prefix) {
  // if str === '', (str && false) will return ''
  // that's why it has to be !!str
  return !!str && str.indexOf(prefix) === 0;
};

utils.endsWith = function (str, postfix) {
  if (!str || !postfix) {
    return false;
  }

  if (str.endsWith) {
    return str.endsWith(postfix);
  }

  var t = String(postfix);
  var index = str.lastIndexOf(t);
  return index >= 0 && index === str.length - t.length;
};
/**
 * Helper function for creating regular expression from a url filter rule syntax.
 */


utils.createURLRegex = function () {
  // Constants
  var regexConfiguration = {
    maskStartUrl: '||',
    maskPipe: '|',
    maskSeparator: '^',
    maskAnySymbol: '*',
    regexAnySymbol: '.*',
    regexSeparator: '([^ a-zA-Z0-9.%_-]|$)',
    regexStartUrl: '^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?',
    regexStartString: '^',
    regexEndString: '$'
  }; // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
  // should be escaped . * + ? ^ $ { } ( ) | [ ] / \
  // except of * | ^

  var specials = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '\\', '/'];
  var specialsRegex = new RegExp("[".concat(specials.join('\\'), "]"), 'g');
  /**
   * Escapes regular expression string
   */

  var escapeRegExp = function escapeRegExp(str) {
    return str.replace(specialsRegex, '\\$&');
  };

  var replaceAll = function replaceAll(str, find, replace) {
    if (!str) {
      return str;
    }

    return str.split(find).join(replace);
  };
  /**
   * Main function that converts a url filter rule string to a regex.
   * @param {string} str
   * @return {RegExp}
   */


  var createRegexText = function createRegexText(str) {
    var regex = escapeRegExp(str);

    if (utils.startsWith(regex, regexConfiguration.maskStartUrl)) {
      regex = regex.substring(0, regexConfiguration.maskStartUrl.length) + replaceAll(regex.substring(regexConfiguration.maskStartUrl.length, regex.length - 1), '\|', '\\|') + regex.substring(regex.length - 1);
    } else if (utils.startsWith(regex, regexConfiguration.maskPipe)) {
      regex = regex.substring(0, regexConfiguration.maskPipe.length) + replaceAll(regex.substring(regexConfiguration.maskPipe.length, regex.length - 1), '\|', '\\|') + regex.substring(regex.length - 1);
    } else {
      regex = replaceAll(regex.substring(0, regex.length - 1), '\|', '\\|') + regex.substring(regex.length - 1);
    } // Replacing special url masks


    regex = replaceAll(regex, regexConfiguration.maskAnySymbol, regexConfiguration.regexAnySymbol);
    regex = replaceAll(regex, regexConfiguration.maskSeparator, regexConfiguration.regexSeparator);

    if (utils.startsWith(regex, regexConfiguration.maskStartUrl)) {
      regex = regexConfiguration.regexStartUrl + regex.substring(regexConfiguration.maskStartUrl.length);
    } else if (utils.startsWith(regex, regexConfiguration.maskPipe)) {
      regex = regexConfiguration.regexStartString + regex.substring(regexConfiguration.maskPipe.length);
    }

    if (utils.endsWith(regex, regexConfiguration.maskPipe)) {
      regex = regex.substring(0, regex.length - 1) + regexConfiguration.regexEndString;
    }

    return new RegExp(regex, 'i');
  };

  return createRegexText;
}();
/**
 * Creates an object implementing Location interface from a url.
 * An alternative to URL.
 * https://github.com/AdguardTeam/FingerprintingBlocker/blob/master/src/shared/url.ts#L64
 */


utils.createLocation = function (href) {
  var anchor = document.createElement('a');
  anchor.href = href;

  if (anchor.host === '') {
    anchor.href = anchor.href; // eslint-disable-line no-self-assign
  }

  return anchor;
};
/**
 * Checks whether A has the same origin as B.
 * @param {string} urlA location.href of A.
 * @param {Location} locationB location of B.
 * @param {string} domainB document.domain of B.
 * @return {boolean}
 */


utils.isSameOrigin = function (urlA, locationB, domainB) {
  var locationA = utils.createLocation(urlA); // eslint-disable-next-line no-script-url

  if (locationA.protocol === 'javascript:' || locationA.href === 'about:blank') {
    return true;
  }

  if (locationA.protocol === 'data:' || locationA.protocol === 'file:') {
    return false;
  }

  return locationA.hostname === domainB && locationA.port === locationB.port && locationA.protocol === locationB.protocol;
};
/**
 * A helper class to throttle function calls with setTimeout and requestAnimationFrame.
 */


utils.AsyncWrapper = function () {
  /**
   * PhantomJS passes a wrong timestamp to the requestAnimationFrame callback and that breaks the AsyncWrapper logic
   * https://github.com/ariya/phantomjs/issues/14832
   */
  var supported = typeof window.requestAnimationFrame !== 'undefined' && !/phantom/i.test(navigator.userAgent);
  var rAF = supported ? requestAnimationFrame : setTimeout;
  var cAF = supported ? cancelAnimationFrame : clearTimeout;
  var perf = supported ? performance : Date;
  /**
   * @param {Function} callback
   * @param {number} throttle number, the provided callback should be executed twice
   * in this time frame.
   * @constructor
   */

  function AsyncWrapper(callback, throttle) {
    this.callback = callback;
    this.throttle = throttle;
    this.wrappedCallback = this.wrappedCallback.bind(this);

    if (this.wrappedAsapCallback) {
      this.wrappedAsapCallback = this.wrappedAsapCallback.bind(this);
    }
  }
  /** @private */


  AsyncWrapper.prototype.wrappedCallback = function (ts) {
    this.lastRun = isNumber(ts) ? ts : perf.now();
    delete this.rAFid;
    delete this.timerId;
    delete this.asapScheduled;
    this.callback();
  };
  /** @private Indicates whether there is a scheduled callback. */


  AsyncWrapper.prototype.hasPendingCallback = function () {
    return isNumber(this.rAFid) || isNumber(this.timerId);
  };
  /**
   * Schedules a function call before the next animation frame.
   */


  AsyncWrapper.prototype.run = function () {
    if (this.hasPendingCallback()) {
      // There is a pending execution scheduled.
      return;
    }

    if (typeof this.lastRun !== 'undefined') {
      var elapsed = perf.now() - this.lastRun;

      if (elapsed < this.throttle) {
        this.timerId = setTimeout(this.wrappedCallback, this.throttle - elapsed);
        return;
      }
    }

    this.rAFid = rAF(this.wrappedCallback);
  };
  /**
   * Schedules a function call in the most immenent microtask.
   * This cannot be canceled.
   */


  AsyncWrapper.prototype.runAsap = function () {
    if (this.asapScheduled) {
      return;
    }

    this.asapScheduled = true;
    cAF(this.rAFid);
    clearTimeout(this.timerId);

    if (utils.MutationObserver) {
      /**
       * Using MutationObservers to access microtask queue is a standard technique,
       * used in ASAP library
       * {@link https://github.com/kriskowal/asap/blob/master/browser-raw.js#L140}
       */
      if (!this.mo) {
        this.mo = new utils.MutationObserver(this.wrappedCallback);
        this.node = document.createTextNode(1);
        this.mo.observe(this.node, {
          characterData: true
        });
      }

      this.node.nodeValue = -this.node.nodeValue;
    } else {
      setTimeout(this.wrappedCallback);
    }
  };
  /**
   * Runs scheduled execution immediately, if there were any.
   */


  AsyncWrapper.prototype.runImmediately = function () {
    if (this.hasPendingCallback()) {
      cAF(this.rAFid);
      clearTimeout(this.timerId);
      delete this.rAFid;
      delete this.timerId;
      this.wrappedCallback();
    }
  };

  AsyncWrapper.now = function () {
    return perf.now();
  };

  return AsyncWrapper;
}();
/**
 * Stores native OdP to be used in WeakMap and Set polyfills.
 */


utils.defineProperty = Object.defineProperty;
utils.WeakMap = typeof WeakMap !== 'undefined' ? WeakMap : function () {
  /** Originally based on {@link https://github.com/Polymer/WeakMap} */
  var counter = Date.now() % 1e9;

  var WeakMap = function WeakMap() {
    this.name = "__st".concat(Math.random() * 1e9 >>> 0).concat(counter++, "__");
  };

  WeakMap.prototype = {
    set: function set(key, value) {
      var entry = key[this.name];

      if (entry && entry[0] === key) {
        entry[1] = value;
      } else {
        utils.defineProperty(key, this.name, {
          value: [key, value],
          writable: true
        });
      }

      return this;
    },
    get: function get(key) {
      var entry = key[this.name];
      return entry && entry[0] === key ? entry[1] : undefined;
    },
    delete: function _delete(key) {
      var entry = key[this.name];

      if (!entry) {
        return false;
      }

      var hasValue = entry[0] === key;
      delete entry[0];
      delete entry[1];
      return hasValue;
    },
    has: function has(key) {
      var entry = key[this.name];

      if (!entry) {
        return false;
      }

      return entry[0] === key;
    }
  };
  return WeakMap;
}();
utils.Set = typeof Set !== 'undefined' ? Set : function () {
  var counter = Date.now() % 1e9;
  /**
   * A polyfill which covers only the basic usage.
   * Only supports methods that are supported in IE11.
   * {@link https://docs.microsoft.com/en-us/scripting/javascript/reference/set-object-javascript}
   * Assumes that 'key's are all objects, not primitives such as a number.
   *
   * @param {Array} items Initial items in this set
   */

  var Set = function Set(items) {
    this.name = "__st".concat(Math.random() * 1e9 >>> 0).concat(counter++, "__");
    this.keys = [];

    if (items && items.length) {
      var iItems = items.length;

      while (iItems--) {
        this.add(items[iItems]);
      }
    }
  };

  Set.prototype = {
    add: function add(key) {
      if (!isNumber(key[this.name])) {
        var index = this.keys.push(key) - 1;
        utils.defineProperty(key, this.name, {
          value: index,
          writable: true
        });
      }
    },
    delete: function _delete(key) {
      if (isNumber(key[this.name])) {
        var index = key[this.name];
        delete this.keys[index];
        key[this.name] = undefined;
      }
    },
    has: function has(key) {
      return isNumber(key[this.name]);
    },
    clear: function clear() {
      this.keys.forEach(function (key) {
        key[this.name] = undefined;
      });
      this.keys.length = 0;
    },
    forEach: function forEach(cb) {
      var that = this;
      this.keys.forEach(function (value) {
        cb(value, value, that);
      });
    }
  };
  utils.defineProperty(Set.prototype, 'size', {
    get: function get() {
      // Skips holes.
      return this.keys.reduce(function (acc) {
        return acc + 1;
      }, 0);
    }
  });
  return Set;
}();
/**
 * Vendor-specific Element.prototype.matches
 */

utils.matchesPropertyName = function () {
  var props = ['matches', 'matchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector', 'webkitMatchesSelector'];

  for (var i = 0; i < 6; i++) {
    if (Element.prototype.hasOwnProperty(props[i])) {
      return props[i];
    }
  }
}();
/**
 * Provides stats information
 */


utils.Stats = function () {
  /** @member {Array<number>} */
  this.array = [];
  /** @member {number} */

  this.length = 0;
  var zeroDescriptor = {
    value: 0,
    writable: true
  };
  /** @member {number} @private */

  Object.defineProperty(this, 'sum', zeroDescriptor);
  /** @member {number} @private */

  Object.defineProperty(this, 'squaredSum', zeroDescriptor);
};
/**
 * @param {number} dataPoint data point
 */


utils.Stats.prototype.push = function (dataPoint) {
  this.array.push(dataPoint);
  this.length++;
  this.sum += dataPoint;
  this.squaredSum += dataPoint * dataPoint;
  /** @member {number} */

  this.mean = this.sum / this.length;
  /** @member {number} */
  // eslint-disable-next-line no-restricted-properties

  this.stddev = Math.sqrt(this.squaredSum / this.length - Math.pow(this.mean, 2));
};
/** Safe console.error version */


utils.logError = typeof console !== 'undefined' && console.error && Function.prototype.bind && console.error.bind ? console.error.bind(window.console) : console.error;
/** Safe console.info version */

utils.logInfo = typeof console !== 'undefined' && console.info && Function.prototype.bind && console.info.bind ? console.info.bind(window.console) : console.info;

function isNumber(obj) {
  return typeof obj === 'number';
}
/**
 * Returns path to element we will use as element identifier
 * @param {Element} inputEl
 * @returns {string} - path to the element
 */


utils.getNodeSelector = function (inputEl) {
  if (!(inputEl instanceof Element)) {
    throw new Error('Function received argument with wrong type');
  }

  var el = inputEl;
  var path = []; // we need to check '!!el' first because it is possible
  // that some ancestor of the inputEl was removed before it

  while (!!el && el.nodeType === Node.ELEMENT_NODE) {
    var selector = el.nodeName.toLowerCase();

    if (el.id && typeof el.id === 'string') {
      selector += "#".concat(el.id);
      path.unshift(selector);
      break;
    } else {
      var sibling = el;
      var nth = 1;

      while (sibling.previousSibling) {
        sibling = sibling.previousSibling;

        if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName.toLowerCase() === selector) {
          nth++;
        }
      }

      if (nth !== 1) {
        selector += ":nth-of-type(".concat(nth, ")");
      }
    }

    path.unshift(selector);
    el = el.parentNode;
  }

  return path.join(' > ');
};

/**
 * Copyright 2016 Adguard Software Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Helper class css utils
 *
 * @type {{normalize}}
 */
var cssUtils = function () {
  /**
   * Regex that matches AdGuard's backward compatible syntaxes.
   */
  var reAttrFallback = /\[-(?:ext|abp)-([a-z-_]+)=(["'])((?:(?=(\\?))\4.)*?)\2\]/g;
  /**
   * Complex replacement function.
   * Unescapes quote characters inside of an extended selector.
   *
   * @param match     Whole matched string
   * @param name      Group 1
   * @param quoteChar Group 2
   * @param value     Group 3
   */

  var evaluateMatch = function evaluateMatch(match, name, quoteChar, value) {
    // Unescape quotes
    var re = new RegExp("([^\\\\]|^)\\\\".concat(quoteChar), 'g');
    value = value.replace(re, "$1".concat(quoteChar));
    return ":".concat(name, "(").concat(value, ")");
  }; // Sizzle's parsing of pseudo class arguments is buggy on certain circumstances
  // We support following form of arguments:
  // 1. for :matches-css, those of a form {propertyName}: /.*/
  // 2. for :contains, those of a form /.*/
  // We transform such cases in a way that Sizzle has no ambiguity in parsing arguments.


  var reMatchesCss = /\:(matches-css(?:-after|-before)?)\(([a-z-\s]*\:\s*\/(?:\\.|[^\/])*?\/\s*)\)/g;
  var reContains = /:(?:-abp-)?(contains|has-text)\((\s*\/(?:\\.|[^\/])*?\/\s*)\)/g;
  var reScope = /\(\:scope >/g; // Note that we require `/` character in regular expressions to be escaped.

  /**
   * Used for pre-processing pseudo-classes values with above two regexes.
   */

  var addQuotes = function addQuotes(_, c1, c2) {
    return ":".concat(c1, "(\"").concat(c2.replace(/["\\]/g, '\\$&'), "\")");
  };

  var SCOPE_REPLACER = '(>';
  /**
   * Normalizes specified css text in a form that can be parsed by the
   * Sizzle engine.
   * Normalization means
   *  1. transforming [-ext-*=""] attributes to pseudo classes
   *  2. enclosing possibly ambiguous arguments of `:contains`,
   *     `:matches-css` pseudo classes with quotes.
   * @param {string} cssText
   * @return {string}
   */

  var normalize = function normalize(cssText) {
    var normalizedCssText = cssText.replace(reAttrFallback, evaluateMatch).replace(reMatchesCss, addQuotes).replace(reContains, addQuotes).replace(reScope, SCOPE_REPLACER);
    return normalizedCssText;
  };

  var isSimpleSelectorValid = function isSimpleSelectorValid(selector) {
    try {
      document.querySelectorAll(selector);
    } catch (e) {
      return false;
    }

    return true;
  };

  return {
    normalize: normalize,
    isSimpleSelectorValid: isSimpleSelectorValid
  };
}();

/*!
 * Sizzle CSS Selector Engine v2.3.4-pre-adguard
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-08-04
 */

/**
 * Version of Sizzle patched by AdGuard in order to be used in the ExtendedCss module.
 * https://github.com/AdguardTeam/sizzle-extcss
 *
 * Look for [AdGuard Patch] and ADGUARD_EXTCSS markers to find out what exactly was changed by us.
 *
 * Global changes:
 * 1. Added additional parameters to the "Sizzle.tokenize" method so that it can be used for stylesheets parsing and validation.
 * 2. Added tokens re-sorting mechanism forcing slow pseudos to be matched last  (see sortTokenGroups).
 * 3. Fix the nonnativeSelectorCache caching -- there was no value corresponding to a key.
 * 4. Added Sizzle.compile call to the `:has` pseudo definition.
 *
 * Changes that are applied to the ADGUARD_EXTCSS build only:
 * 1. Do not expose Sizzle to the global scope. Initialize it lazily via initializeSizzle().
 * 2. Removed :contains pseudo declaration -- its syntax is changed and declared outside of Sizzle.
 * 3. Removed declarations for the following non-standard pseudo classes:
 * :parent, :header, :input, :button, :text, :first, :last, :eq,
 * :even, :odd, :lt, :gt, :nth, :radio, :checkbox, :file,
 * :password, :image, :submit, :reset
 * 4. Added es6 module export
 */
var Sizzle;
/**
 * Initializes Sizzle object.
 * In the case of AdGuard ExtendedCss we want to avoid initializing Sizzle right away
 * and exposing it to the global scope.
 */

var initializeSizzle = function initializeSizzle() {
  // jshint ignore:line
  if (!Sizzle) {
    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    Sizzle = function (window) {
      var support,
          Expr,
          getText,
          isXML,
          tokenize,
          compile,
          select,
          outermostContext,
          sortInput,
          hasDuplicate,
          // Local document vars
      setDocument,
          document,
          docElem,
          documentIsHTML,
          rbuggyQSA,
          rbuggyMatches,
          matches,
          contains,
          // Instance-specific data
      expando = "sizzle" + 1 * new Date(),
          preferredDoc = window.document,
          dirruns = 0,
          done = 0,
          classCache = createCache(),
          tokenCache = createCache(),
          compilerCache = createCache(),
          nonnativeSelectorCache = createCache(),
          sortOrder = function sortOrder(a, b) {
        if (a === b) {
          hasDuplicate = true;
        }

        return 0;
      },
          // Instance methods
      hasOwn = {}.hasOwnProperty,
          arr = [],
          pop = arr.pop,
          push_native = arr.push,
          push = arr.push,
          slice = arr.slice,
          // Use a stripped-down indexOf as it's faster than native
      // https://jsperf.com/thor-indexof-vs-for/5
      indexOf = function indexOf(list, elem) {
        var i = 0,
            len = list.length;

        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }

        return -1;
      },
          booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
          // Regular expressions
      // http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = "[\\x20\\t\\r\\n\\f]",
          // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
      identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
          // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
      "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
      "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
          pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
      // 1. quoted (capture 3; capture 4 or capture 5)
      "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
      "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
      ".*" + ")\\)|)",
          // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rwhitespace = new RegExp(whitespace + "+", "g"),
          rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
          rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
          rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
          rpseudo = new RegExp(pseudos),
          ridentifier = new RegExp("^" + identifier + "$"),
          matchExpr = {
        "ID": new RegExp("^#(" + identifier + ")"),
        "CLASS": new RegExp("^\\.(" + identifier + ")"),
        "TAG": new RegExp("^(" + identifier + "|[*])"),
        "ATTR": new RegExp("^" + attributes),
        "PSEUDO": new RegExp("^" + pseudos),
        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      },
          rnative = /^[^{]+\{\s*\[native \w/,
          // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
          rsibling = /[+~]/,
          // CSS escapes
      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
          funescape = function funescape(_, escaped, escapedWhitespace) {
        var high = "0x" + escaped - 0x10000; // NaN means non-codepoint
        // Support: Firefox<24
        // Workaround erroneous numeric interpretation of +"0x"

        return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
        String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
      },
          // CSS string/identifier serialization
      // https://drafts.csswg.org/cssom/#common-serializing-idioms
      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
          fcssescape = function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === "\0") {
            return "\uFFFD";
          } // Control characters and (dependent upon position) numbers get escaped as code points


          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        } // Other potentially-special ASCII characters get backslash-escaped


        return "\\" + ch;
      },
          // Used for iframes
      // See setDocument()
      // Removing the function wrapper causes a "Permission Denied"
      // error in IE
      unloadHandler = function unloadHandler() {
        setDocument();
      },
          inDisabledFieldset = addCombinator(function (elem) {
        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
      }, {
        dir: "parentNode",
        next: "legend"
      }); // Optimize for push.apply( _, NodeList )


      try {
        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
        // Detect silently failing push.apply

        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ? // Leverage slice if possible
          function (target, els) {
            push_native.apply(target, slice.call(els));
          } : // Support: IE<9
          // Otherwise append directly
          function (target, els) {
            var j = target.length,
                i = 0; // Can't trust NodeList.length

            while (target[j++] = els[i++]) {}

            target.length = j - 1;
          }
        };
      }

      function Sizzle(selector, context, results, seed) {
        var m,
            i,
            elem,
            nid,
            match,
            groups,
            newSelector,
            newContext = context && context.ownerDocument,
            // nodeType defaults to 9, since context defaults to document
        nodeType = context ? context.nodeType : 9;
        results = results || []; // Return early from calls with invalid selector or context

        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        } // Try to shortcut find operations (as opposed to filters) in HTML documents


        if (!seed) {
          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
            setDocument(context);
          }

          context = context || document;

          if (documentIsHTML) {
            // If the selector is sufficiently simple, try using a "get*By*" DOM method
            // (excepting DocumentFragment context, where the methods don't exist)
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
              // ID selector
              if (m = match[1]) {
                // Document context
                if (nodeType === 9) {
                  if (elem = context.getElementById(m)) {
                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  } // Element context

                } else {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } // Type selector

              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results; // Class selector
              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            } // Take advantage of querySelectorAll


            if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              if (nodeType !== 1) {
                newContext = context;
                newSelector = selector; // qSA looks outside Element context, which is not what we want
                // Thanks to Andrew Dupont for this workaround technique
                // Support: IE <=8
                // Exclude object elements
              } else if (context.nodeName.toLowerCase() !== "object") {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                } // Prefix every selector in the list


                groups = tokenize(selector);
                i = groups.length;

                while (i--) {
                  groups[i] = "#" + nid + " " + toSelector(groups[i]);
                }

                newSelector = groups.join(","); // Expand context for sibling selectors

                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              }

              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {
                  // [AdGuard Path]: Fix the cache value
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
        } // All others


        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }
      /**
       * Create key-value caches of limited size
       * @returns {function(string, object)} Returns the Object data after storing it on itself with
       *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *	deleting the oldest entry
       */


      function createCache() {
        var keys = [];

        function cache(key, value) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if (keys.push(key + " ") > Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }

          return cache[key + " "] = value;
        }

        return cache;
      }
      /**
       * Mark a function for special use by Sizzle
       * @param {Function} fn The function to mark
       */


      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      /**
       * Support testing using an element
       * @param {Function} fn Passed the created element and returns a boolean result
       */


      function assert(fn) {
        var el = document.createElement("fieldset");

        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {
          // Remove from its parent by default
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          } // release memory in IE


          el = null;
        }
      }
      /**
       * Adds the same handler for all of the specified attrs
       * @param {String} attrs Pipe-separated list of attributes
       * @param {Function} handler The method that will be applied
       */


      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
            i = arr.length;

        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }
      /**
       * Checks document order of two siblings
       * @param {Element} a
       * @param {Element} b
       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
       */


      function siblingCheck(a, b) {
        var cur = b && a,
            diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

        if (diff) {
          return diff;
        } // Check if b follows a


        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b) {
              return -1;
            }
          }
        }

        return a ? 1 : -1;
      }
      /**
       * Returns a function to use in pseudos for :enabled/:disabled
       * @param {Boolean} disabled true for :disabled; false for :enabled
       */


      function createDisabledPseudo(disabled) {
        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function (elem) {
          // Only certain elements can match :enabled or :disabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
          if ("form" in elem) {
            // Check for inherited disabledness on relevant non-disabled elements:
            // * listed form-associated elements in a disabled fieldset
            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
            // * option elements in a disabled optgroup
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
            // All such elements have a "form" property.
            if (elem.parentNode && elem.disabled === false) {
              // Option elements defer to a parent optgroup if present
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              } // Support: IE 6 - 11
              // Use the isDisabled shortcut property to check for disabled fieldset ancestors


              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

              /* jshint -W018 */
              elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
            }

            return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
            // even exist on them, let alone have a boolean value.
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          } // Remaining elements are neither :enabled nor :disabled


          return false;
        };
      }
      /**
       * Checks a node for validity as a Sizzle context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */


      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      } // Expose support vars for convenience


      support = Sizzle.support = {};
      /**
       * Detects XML nodes
       * @param {Element|Object} elem An element or a document
       * @returns {Boolean} True iff elem is a non-HTML XML node
       */

      isXML = Sizzle.isXML = function (elem) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };
      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [doc] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */


      setDocument = Sizzle.setDocument = function (node) {
        var hasCompare,
            subWindow,
            doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected

        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        } // Update global variables


        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML(document); // Support: IE 9-11, Edge
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)

        if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
          // Support: IE 11, Edge
          if (subWindow.addEventListener) {
            subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
          } else if (subWindow.attachEvent) {
            subWindow.attachEvent("onunload", unloadHandler);
          }
        }
        /* Attributes
        ---------------------------------------------------------------------- */
        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)


        support.attributes = assert(function (el) {
          el.className = "i";
          return !el.getAttribute("className");
        });
        /* getElement(s)By*
        ---------------------------------------------------------------------- */
        // Check if getElementsByTagName("*") returns only elements

        support.getElementsByTagName = assert(function (el) {
          el.appendChild(document.createComment(""));
          return !el.getElementsByTagName("*").length;
        }); // Support: IE<9

        support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programmatically-set names,
        // so use a roundabout getElementsByName test

        support.getById = assert(function (el) {
          docElem.appendChild(el).id = expando;
          return !document.getElementsByName || !document.getElementsByName(expando).length;
        }); // ID filter and find

        if (support.getById) {
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              return elem.getAttribute("id") === attrId;
            };
          };

          Expr.find["ID"] = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var elem = context.getElementById(id);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          }; // Support: IE 6 - 7 only
          // getElementById is not reliable as a find shortcut


          Expr.find["ID"] = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var node,
                  i,
                  elems,
                  elem = context.getElementById(id);

              if (elem) {
                // Verify the id attribute
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                } // Fall back on getElementsByName


                elems = context.getElementsByName(id);
                i = 0;

                while (elem = elems[i++]) {
                  node = elem.getAttributeNode("id");

                  if (node && node.value === id) {
                    return [elem];
                  }
                }
              }

              return [];
            }
          };
        } // Tag


        Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
          } else if (support.qsa) {
            return context.querySelectorAll(tag);
          }
        } : function (tag, context) {
          var elem,
              tmp = [],
              i = 0,
              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
          results = context.getElementsByTagName(tag); // Filter out possible comments

          if (tag === "*") {
            while (elem = results[i++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }

            return tmp;
          }

          return results;
        }; // Class

        Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        /* QSA/matchesSelector
        ---------------------------------------------------------------------- */
        // QSA and matchesSelector support
        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


        rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See https://bugs.jquery.com/ticket/13378

        rbuggyQSA = [];

        if (support.qsa = rnative.test(document.querySelectorAll)) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function (el) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // https://bugs.jquery.com/ticket/12359
            docElem.appendChild(el).innerHTML = AGPolicy.createHTML("<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"); // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

            if (el.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            } // Support: IE8
            // Boolean attributes and "value" are not treated correctly


            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            } // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests


            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            } // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibling-combinator selector` fails


            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });
          assert(function (el) {
            el.innerHTML = AGPolicy.createHTML("<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"); // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment

            var input = document.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D"); // Support: IE8
            // Enforce case-sensitivity of name attribute

            if (el.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests


            if (el.querySelectorAll(":enabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Support: IE9-11+
            // IE's :disabled selector does not pick up the children of disabled fieldsets


            docElem.appendChild(el).disabled = true;

            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Opera 10-11 does not throw on post-comma invalid pseudos


            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }

        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function (el) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
            // Gecko does not error, returns false instead

            matches.call(el, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        /* Contains
        ---------------------------------------------------------------------- */

        hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself

        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a,
              bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function (a, b) {
          if (b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
          }

          return false;
        };
        /* Sorting
        ---------------------------------------------------------------------- */
        // Document order sorting

        sortOrder = hasCompare ? function (a, b) {
          // Flag for duplicate removal
          if (a === b) {
            hasDuplicate = true;
            return 0;
          } // Sort on method existence if only one input has compareDocumentPosition


          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

          if (compare) {
            return compare;
          } // Calculate position if both inputs belong to the same document


          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
          1; // Disconnected nodes

          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            // Choose the first element that is related to our preferred document
            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
              return -1;
            }

            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
              return 1;
            } // Maintain original order


            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
          }

          return compare & 4 ? -1 : 1;
        } : function (a, b) {
          // Exit early if the nodes are identical
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }

          var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [a],
              bp = [b]; // Parentless nodes are either documents or disconnected

          if (!aup || !bup) {
            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
          } else if (aup === bup) {
            return siblingCheck(a, b);
          } // Otherwise we need full lists of their ancestors for comparison


          cur = a;

          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }

          cur = b;

          while (cur = cur.parentNode) {
            bp.unshift(cur);
          } // Walk down the tree looking for a discrepancy


          while (ap[i] === bp[i]) {
            i++;
          }

          return i ? // Do a sibling check if the nodes have a common ancestor
          siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
          ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
        };
        return document;
      };

      Sizzle.matches = function (expr, elements) {
        return Sizzle(expr, null, null, elements);
      };

      Sizzle.matchesSelector = function (elem, expr) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {
            // [AdGuard Path]: Fix the cache value
            nonnativeSelectorCache(expr, true);
          }
        }

        return Sizzle(expr, document, null, [elem]).length > 0;
      };

      Sizzle.contains = function (context, elem) {
        // Set document vars if needed
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }

        return contains(context, elem);
      };

      Sizzle.attr = function (elem, name) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        var fn = Expr.attrHandle[name.toLowerCase()],
            // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      };

      Sizzle.escape = function (sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };

      Sizzle.error = function (msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */


      Sizzle.uniqueSort = function (results) {
        var elem,
            duplicates = [],
            j = 0,
            i = 0; // Unless we *know* we can detect duplicates, assume their presence

        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);

        if (hasDuplicate) {
          while (elem = results[i++]) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }

          while (j--) {
            results.splice(duplicates[j], 1);
          }
        } // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225


        sortInput = null;
        return results;
      };
      /**
       * Utility function for retrieving the text value of an array of DOM nodes
       * @param {Array|Element} elem
       */


      getText = Sizzle.getText = function (elem) {
        var node,
            ret = "",
            i = 0,
            nodeType = elem.nodeType;

        if (!nodeType) {
          // If no nodeType, this is expected to be an array
          while (node = elem[i++]) {
            // Do not traverse comment nodes
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            // Traverse its children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        } // Do not include comment or processing instruction nodes


        return ret;
      };

      Expr = Sizzle.selectors = {
        // Can be adjusted by the user
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: true
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: true
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          "ATTR": function ATTR(match) {
            match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }

            return match.slice(0, 4);
          },
          "CHILD": function CHILD(match) {
            /* matches from matchExpr["CHILD"]
            	1 type (only|nth|...)
            	2 what (child|of-type)
            	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            	4 xn-component of xn+y argument ([+-]?\d*n|)
            	5 sign of xn-component
            	6 x of xn-component
            	7 sign of y-component
            	8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if (match[1].slice(0, 3) === "nth") {
              // nth-* requires argument
              if (!match[3]) {
                Sizzle.error(match[0]);
              } // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1


              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }

            return match;
          },
          "PSEUDO": function PSEUDO(match) {
            var excess,
                unquoted = !match[6] && match[2];

            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            } // Accept quoted arguments as-is


            if (match[3]) {
              match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
            } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
            excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            } // Return only captures needed by the pseudo filter method (type and argument)


            return match.slice(0, 3);
          }
        },
        filter: {
          "TAG": function TAG(nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function () {
              return true;
            } : function (elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
          },
          "CLASS": function CLASS(className) {
            var pattern = classCache[className + " "];
            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
            });
          },
          "ATTR": function ATTR(name, operator, check) {
            return function (elem) {
              var result = Sizzle.attr(elem, name);

              if (result == null) {
                return operator === "!=";
              }

              if (!operator) {
                return true;
              }

              result += "";
              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            };
          },
          "CHILD": function CHILD(type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
                forward = type.slice(-4) !== "last",
                ofType = what === "of-type";
            return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
            function (elem) {
              return !!elem.parentNode;
            } : function (elem, context, xml) {
              var cache,
                  uniqueCache,
                  outerCache,
                  node,
                  nodeIndex,
                  start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType,
                  diff = false;

              if (parent) {
                // :(first|last|only)-(child|of-type)
                if (simple) {
                  while (dir) {
                    node = elem;

                    while (node = node[dir]) {
                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                        return false;
                      }
                    } // Reverse direction for :only-* (if we haven't yet done so)


                    start = dir = type === "only" && !start && "nextSibling";
                  }

                  return true;
                }

                start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

                if (forward && useCache) {
                  // Seek `elem` from a previously-cached index
                  // ...in a gzip-friendly way
                  node = parent;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex && cache[2];
                  node = nodeIndex && parent.childNodes[nodeIndex];

                  while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                  diff = nodeIndex = 0) || start.pop()) {
                    // When found, cache indexes on `parent` and break
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      uniqueCache[type] = [dirruns, nodeIndex, diff];
                      break;
                    }
                  }
                } else {
                  // Use previously-cached element index if available
                  if (useCache) {
                    // ...in a gzip-friendly way
                    node = elem;
                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)

                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex;
                  } // xml :nth-child(...)
                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                  if (diff === false) {
                    // Use the same loop as above to seek `elem` from the start
                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                        // Cache the index of each encountered element
                        if (useCache) {
                          outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                          // Defend against cloned attroperties (jQuery gh-1709)

                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                          uniqueCache[type] = [dirruns, diff];
                        }

                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                } // Incorporate the offset, then check against cycle size


                diff -= last;
                return diff === first || diff % first === 0 && diff / first >= 0;
              }
            };
          },
          "PSEUDO": function PSEUDO(pseudo, argument) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does

            if (fn[expando]) {
              return fn(argument);
            } // But maintain support for old signatures


            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                var idx,
                    matched = fn(seed, argument),
                    i = matched.length;

                while (i--) {
                  idx = indexOf(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) : function (elem) {
                return fn(elem, 0, args);
              };
            }

            return fn;
          }
        },
        pseudos: {
          // Potentially complex pseudos
          "not": markFunction(function (selector) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile(selector.replace(rtrim, "$1"));
            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
              var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length; // Match elements unmatched by `matcher`

              while (i--) {
                if (elem = unmatched[i]) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) : function (elem, context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results); // Don't keep the element (issue #299)

              input[0] = null;
              return !results.pop();
            };
          }),
          "has": markFunction(function (selector) {
            if (typeof selector === "string") {
              Sizzle.compile(selector);
            }

            return function (elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),
          // Removed :contains pseudo-class declaration
          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          "lang": markFunction(function (lang) {
            // lang value must be a valid identifier
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }

            lang = lang.replace(runescape, funescape).toLowerCase();
            return function (elem) {
              var elemLang;

              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);

              return false;
            };
          }),
          // Miscellaneous
          "target": function target(elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          "root": function root(elem) {
            return elem === docElem;
          },
          "focus": function focus(elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          // Boolean properties
          "enabled": createDisabledPseudo(false),
          "disabled": createDisabledPseudo(true),
          "checked": function checked(elem) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
          },
          "selected": function selected(elem) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },
          // Contents
          "empty": function empty(elem) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }

            return true;
          } // Removed custom pseudo-classes

        }
      }; // Removed custom pseudo-classes
      // Easy API for creating new setFilters

      function setFilters() {}

      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      /**
       * [AdGuard Patch]:
       * Sorts the tokens in order to mitigate the performance issues caused by matching slow pseudos first:
       * https://github.com/AdguardTeam/ExtendedCss/issues/55#issuecomment-364058745
       */

      var sortTokenGroups = function () {
        /**
         * Splits compound selector into a list of simple selectors
         *
         * @param {*} tokens Tokens to split into groups
         * @returns an array consisting of token groups (arrays) and relation tokens.
         */
        var splitCompoundSelector = function splitCompoundSelector(tokens) {
          var groups = [];
          var currentTokensGroup = [];
          var maxIdx = tokens.length - 1;

          for (var i = 0; i <= maxIdx; i++) {
            var token = tokens[i];
            var relative = Sizzle.selectors.relative[token.type];

            if (relative) {
              groups.push(currentTokensGroup);
              groups.push(token);
              currentTokensGroup = [];
            } else {
              currentTokensGroup.push(token);
            }

            if (i === maxIdx) {
              groups.push(currentTokensGroup);
            }
          }

          return groups;
        };

        var TOKEN_TYPES_VALUES = {
          // nth-child, etc, always go last
          "CHILD": 100,
          "ID": 90,
          "CLASS": 80,
          "TAG": 70,
          "ATTR": 70,
          "PSEUDO": 60
        };
        var POSITIONAL_PSEUDOS = ["nth", "first", "last", "eq", "even", "odd", "lt", "gt", "not"];
        /**
         * A function that defines the sort order.
         * Returns a value lesser than 0 if "left" is less than "right".
         */

        var compareFunction = function compareFunction(left, right) {
          var leftValue = TOKEN_TYPES_VALUES[left.type];
          var rightValue = TOKEN_TYPES_VALUES[right.type];
          return leftValue - rightValue;
        };
        /**
         * Checks if the specified tokens group is sortable.
         * We do not re-sort tokens in case of any positional or child pseudos in the group
         */


        var isSortable = function isSortable(tokens) {
          var iTokens = tokens.length;

          while (iTokens--) {
            var token = tokens[iTokens];

            if (token.type === "PSEUDO" && POSITIONAL_PSEUDOS.indexOf(token.matches[0]) !== -1) {
              return false;
            }

            if (token.type === "CHILD") {
              return false;
            }
          }

          return true;
        };
        /**
         * Sorts the tokens in order to mitigate the issues caused by the left-to-right matching.
         * The idea is change the tokens order so that Sizzle was matching fast selectors first (id, class),
         * and slow selectors after that (and here I mean our slow custom pseudo classes).
         *
         * @param {Array} tokens An array of tokens to sort
         * @returns {Array} A new re-sorted array
         */


        var sortTokens = function sortTokens(tokens) {
          if (!tokens || tokens.length === 1) {
            return tokens;
          }

          var sortedTokens = [];
          var groups = splitCompoundSelector(tokens);

          for (var i = 0; i < groups.length; i++) {
            var group = groups[i];

            if (group instanceof Array) {
              if (isSortable(group)) {
                group.sort(compareFunction);
              }

              sortedTokens = sortedTokens.concat(group);
            } else {
              sortedTokens.push(group);
            }
          }

          return sortedTokens;
        };
        /**
         * Sorts every tokens array inside of the specified "groups" array.
         * See "sortTokens" methods for more information on how tokens are sorted.
         *
         * @param {Array} groups An array of tokens arrays.
         * @returns {Array} A new array that consists of the same tokens arrays after sorting
         */


        var sortTokenGroups = function sortTokenGroups(groups) {
          var sortedGroups = [];
          var len = groups.length;
          var i = 0;

          for (; i < len; i++) {
            sortedGroups.push(sortTokens(groups[i]));
          }

          return sortedGroups;
        }; // Expose


        return sortTokenGroups;
      }();
      /**
       * Creates custom policy to use TrustedTypes CSP policy
       * https://w3c.github.io/webappsec-trusted-types/dist/spec/
       */


      var AGPolicy = function createPolicy() {
        var defaultPolicy = {
          createHTML: function createHTML(input) {
            return input;
          },
          createScript: function createScript(input) {
            return input;
          },
          createScriptURL: function createScriptURL(input) {
            return input;
          }
        };

        if (window.trustedTypes && window.trustedTypes.createPolicy) {
          return window.trustedTypes.createPolicy("AGPolicy", defaultPolicy);
        }

        return defaultPolicy;
      }();
      /**
       * [AdGuard Patch]:
       * Removes trailing spaces from the tokens list
       *
       * @param {*} tokens An array of Sizzle tokens to post-process
       */


      function removeTrailingSpaces(tokens) {
        var iTokens = tokens.length;

        while (iTokens--) {
          var token = tokens[iTokens];

          if (token.type === " ") {
            tokens.length = iTokens;
          } else {
            break;
          }
        }
      }
      /**
       * [AdGuard Patch]:
       * An object with the information about selectors and their token representation
       * @typedef {{selectorText: string, groups: Array}} SelectorData
       * @property {string} selectorText A CSS selector text
       * @property {Array} groups An array of token groups corresponding to that selector
       */

      /**
       * [AdGuard Patch]:
       * This method processes parsed token groups, divides them into a number of selectors
       * and makes sure that each selector's tokens are cached properly in Sizzle.
       *
       * @param {*} groups Token groups (see {@link Sizzle.tokenize})
       * @returns {Array.<SelectorData>} An array of selectors data we got from the groups
       */


      function tokenGroupsToSelectors(groups) {
        // Remove trailing spaces which we can encounter in tolerant mode
        // We're doing it in tolerant mode only as this is the only case when
        // encountering trailing spaces is expected
        removeTrailingSpaces(groups[groups.length - 1]); // We need sorted tokens to make cache work properly

        var sortedGroups = sortTokenGroups(groups);
        var selectors = [];

        for (var i = 0; i < groups.length; i++) {
          var tokenGroups = groups[i];
          var selectorText = toSelector(tokenGroups);
          selectors.push({
            // Sizzle expects an array of token groups when compiling a selector
            groups: [tokenGroups],
            selectorText: selectorText
          }); // Now make sure that selector tokens are cached

          var tokensCacheItem = {
            groups: tokenGroups,
            sortedGroups: [sortedGroups[i]]
          };
          tokenCache(selectorText, tokensCacheItem);
        }

        return selectors;
      }
      /**
       * [AdGuard Patch]:
       * Add an additional argument for Sizzle.tokenize which indicates that it
       * should not throw on invalid tokens, and instead should return tokens
       * that it has produced so far.
       *
       * One more additional argument that allow to choose if you want to receive sorted or unsorted tokens
       * The problem is that the re-sorted selectors are valid for Sizzle, but not for the browser.
       * options.returnUnsorted -- return unsorted tokens if true.
       * options.cacheOnly -- return cached result only. Required for unit-tests.
       *
       * @param {*} options Optional configuration object with two additional flags
       * (options.tolerant, options.returnUnsorted, options.cacheOnly) -- see patches #5 and #6 notes
       */


      tokenize = Sizzle.tokenize = function (selector, parseOnly, options) {
        var matched,
            match,
            tokens,
            type,
            soFar,
            groups,
            preFilters,
            cached = tokenCache[selector + " "];
        var tolerant = options && options.tolerant;
        var returnUnsorted = options && options.returnUnsorted;
        var cacheOnly = options && options.cacheOnly;

        if (cached) {
          if (parseOnly) {
            return 0;
          } else {
            return (returnUnsorted ? cached.groups : cached.sortedGroups).slice(0);
          }
        }

        if (cacheOnly) {
          return null;
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while (soFar) {
          // Comma and first run
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }

            groups.push(tokens = []);
          }

          matched = false; // Combinators

          if (match = rcombinators.exec(soFar)) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          } // Filters


          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }

          if (!matched) {
            break;
          }
        } // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens


        var invalidLen = soFar.length;

        if (parseOnly) {
          return invalidLen;
        }

        if (invalidLen !== 0 && !tolerant) {
          Sizzle.error(selector); // Throws an error.
        }

        if (tolerant) {
          /**
           * [AdGuard Patch]:
           * In tolerant mode we return a special object that constists of
           * an array of parsed selectors (and their tokens) and a "nextIndex" field
           * that points to an index after which we're not able to parse selectors farther.
           */
          var nextIndex = selector.length - invalidLen;
          var selectors = tokenGroupsToSelectors(groups);
          return {
            selectors: selectors,
            nextIndex: nextIndex
          };
        }
        /** [AdGuard Patch]: Sorting tokens */


        var sortedGroups = sortTokenGroups(groups);
        /** [AdGuard Patch]: Change the way tokens are cached */

        var tokensCacheItem = {
          groups: groups,
          sortedGroups: sortedGroups
        };
        tokensCacheItem = tokenCache(selector, tokensCacheItem);
        return (returnUnsorted ? tokensCacheItem.groups : tokensCacheItem.sortedGroups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
            len = tokens.length,
            selector = "";

        for (; i < len; i++) {
          selector += tokens[i].value;
        }

        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
            skip = combinator.next,
            key = skip || dir,
            checkNonElements = base && key === "parentNode",
            doneName = done++;
        return combinator.first ? // Check against closest ancestor/preceding element
        function (elem, context, xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }

          return false;
        } : // Check against all ancestor/preceding elements
        function (elem, context, xml) {
          var oldCache,
              uniqueCache,
              outerCache,
              newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

          if (xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir] || elem;
                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  // Assign to newCache so results back-propagate to previous elements
                  return newCache[2] = oldCache[2];
                } else {
                  // Reuse newcache so results back-propagate to previous elements
                  uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                  if (newCache[2] = matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            }
          }

          return false;
        };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1 ? function (elem, context, xml) {
          var i = matchers.length;

          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }

          return true;
        } : matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
            len = contexts.length;

        for (; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }

        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
            newUnmatched = [],
            i = 0,
            len = unmatched.length,
            mapped = map != null;

        for (; i < len; i++) {
          if (elem = unmatched[i]) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);

              if (mapped) {
                map.push(i);
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }

        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }

        return markFunction(function (seed, results, context, xml) {
          var temp,
              i,
              elem,
              preMap = [],
              postMap = [],
              preexisting = results.length,
              // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
              // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
              matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
          [] : // ...otherwise use results directly
          results : matcherIn; // Find primary matches

          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          } // Apply postFilter


          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

            i = temp.length;

            while (i--) {
              if (elem = temp[i]) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }

          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;

                while (i--) {
                  if (elem = matcherOut[i]) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push(matcherIn[i] = elem);
                  }
                }

                postFinder(null, matcherOut = [], temp, xml);
              } // Move matched elements from seed to results to keep them synchronized


              i = matcherOut.length;

              while (i--) {
                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            } // Add elements to results, through postFinder if defined

          } else {
            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext,
            matcher,
            j,
            len = tokens.length,
            leadingRelative = Expr.relative[tokens[0].type],
            implicitRelative = leadingRelative || Expr.relative[" "],
            i = leadingRelative ? 1 : 0,
            // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true),
            matchAnyContext = addCombinator(function (elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true),
            matchers = [function (elem, context, xml) {
          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

          checkContext = null;
          return ret;
        }];

        for (; i < len; i++) {
          if (matcher = Expr.relative[tokens[i].type]) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

            if (matcher[expando]) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;

              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }

              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
              tokens.slice(0, i - 1).concat({
                value: tokens[i - 2].type === " " ? "*" : ""
              })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
            }

            matchers.push(matcher);
          }
        }

        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
            byElement = elementMatchers.length > 0,
            superMatcher = function superMatcher(seed, context, xml, results, outermost) {
          var elem,
              j,
              matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
          elems = seed || byElement && Expr.find["TAG"]("*", outermost),
              // Use integer dirruns iff this is the outermost matcher
          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
              len = elems.length;

          if (outermost) {
            outermostContext = context === document || context || outermost;
          } // Add elements passing elementMatchers directly to results
          // Support: IE<9, Safari
          // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;

              if (!context && elem.ownerDocument !== document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }

              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }

              if (outermost) {
                dirruns = dirrunsUnique;
              }
            } // Track unmatched elements for set filters


            if (bySet) {
              // They will have gone through all possible matchers
              if (elem = !matcher && elem) {
                matchedCount--;
              } // Lengthen the array for every element, matched or not


              if (seed) {
                unmatched.push(elem);
              }
            }
          } // `i` is now the count of elements visited above, and adding it to `matchedCount`
          // makes the latter nonnegative.


          matchedCount += i; // Apply set filters to unmatched elements
          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
          // no element matchers and no seed.
          // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
          // case, which will result in a "00" `matchedCount` that differs from `i` but is also
          // numerically zero.

          if (bySet && i !== matchedCount) {
            j = 0;

            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }

            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              } // Discard index placeholder values to get only actual matches


              setMatched = condense(setMatched);
            } // Add matches to results


            push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          } // Override manipulation of globals by nested matchers


          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          return unmatched;
        };

        return bySet ? markFunction(superMatcher) : superMatcher;
      }

      compile = Sizzle.compile = function (selector, match
      /* Internal Use Only */
      ) {
        var i,
            setMatchers = [],
            elementMatchers = [],
            cached = compilerCache[selector + " "];

        if (!cached) {
          // Generate a function of recursive functions that can be used to check each element
          if (!match) {
            match = tokenize(selector);
          }

          i = match.length;

          while (i--) {
            cached = matcherFromTokens(match[i]);

            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          } // Cache the compiled function


          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

          cached.selector = selector;
        }

        return cached;
      };
      /**
       * A low-level selection function that works with Sizzle's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with Sizzle.compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */


      select = Sizzle.select = function (selector, context, results, seed) {
        var i,
            tokens,
            token,
            type,
            find,
            compiled = typeof selector === "function" && selector,
            match = !seed && tokenize(selector = compiled.selector || selector);
        results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)

        if (match.length === 1) {
          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice(0);

          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

            if (!context) {
              return results; // Precompiled matchers will still verify ancestry, so step up a level
            } else if (compiled) {
              context = context.parentNode;
            }

            selector = selector.slice(tokens.shift().value.length);
          } // Fetch a seed set for right-to-left matching


          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

          while (i--) {
            token = tokens[i]; // Abort if we hit a combinator

            if (Expr.relative[type = token.type]) {
              break;
            }

            if (find = Expr.find[type]) {
              // Search, expanding context for leading sibling combinators
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);

                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        } // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above


        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
        return results;
      }; // One-time assignments
      // Sort stability


      support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function

      support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

      setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*

      support.sortDetached = assert(function (el) {
        // Should return 1, but returns 4 (following)
        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
      }); // Support: IE<8
      // Prevent attribute/property "interpolation"
      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

      if (!assert(function (el) {
        el.innerHTML = AGPolicy.createHTML("<a href='#'></a>");
        return el.firstChild.getAttribute("href") === "#";
      })) {
        addHandle("type|href|height|width", function (elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      } // Support: IE<9
      // Use defaultValue in place of getAttribute("value")


      if (!support.attributes || !assert(function (el) {
        el.innerHTML = AGPolicy.createHTML("<input/>");
        el.firstChild.setAttribute("value", "");
        return el.firstChild.getAttribute("value") === "";
      })) {
        addHandle("value", function (elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      } // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies


      if (!assert(function (el) {
        return el.getAttribute("disabled") == null;
      })) {
        addHandle(booleans, function (elem, name, isXML) {
          var val;

          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          }
        });
      } // EXPOSE
      // Do not expose Sizzle to the global scope in the case of AdGuard ExtendedCss build


      return Sizzle; // EXPOSE
    }(window); //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  }

  return Sizzle;
};

/* jshint ignore:end */

/**
 * Copyright 2016 Adguard Software Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Class that extends Sizzle and adds support for "matches-css" pseudo element.
 */

var StylePropertyMatcher = function (window) {
  var isPhantom = !!window._phantom;
  var useFallback = isPhantom && !!window.getMatchedCSSRules;
  /**
   * Unquotes specified value
   * Webkit-based browsers singlequotes <string> content property values
   * Other browsers doublequotes content property values.
   */

  var removeContentQuotes = function removeContentQuotes(value) {
    if (typeof value === 'string') {
      return value.replace(/^(["'])([\s\S]*)\1$/, '$2');
    }

    return value;
  };

  var getComputedStyle = window.getComputedStyle.bind(window);
  var getMatchedCSSRules = useFallback ? window.getMatchedCSSRules.bind(window) : null;
  /**
   * There is an issue in browsers based on old webkit:
   * getComputedStyle(el, ":before") is empty if element is not visible.
   *
   * To circumvent this issue we use getMatchedCSSRules instead.
   *
   * It appears that getMatchedCSSRules sorts the CSS rules
   * in increasing order of specifities of corresponding selectors.
   * We pick the css rule that is being applied to an element based on this assumption.
   *
   * @param element       DOM node
   * @param pseudoElement Optional pseudoElement name
   * @param propertyName  CSS property name
   */

  var getComputedStylePropertyValue = function getComputedStylePropertyValue(element, pseudoElement, propertyName) {
    var value = '';

    if (useFallback && pseudoElement) {
      var cssRules = getMatchedCSSRules(element, pseudoElement) || [];
      var i = cssRules.length;

      while (i-- > 0 && !value) {
        value = cssRules[i].style.getPropertyValue(propertyName);
      }
    } else {
      var style = getComputedStyle(element, pseudoElement);

      if (style) {
        value = style.getPropertyValue(propertyName); // https://bugs.webkit.org/show_bug.cgi?id=93445

        if (propertyName === 'opacity' && utils.isSafariBrowser) {
          value = (Math.round(parseFloat(value) * 100) / 100).toString();
        }
      }
    }

    if (propertyName === 'content') {
      value = removeContentQuotes(value);
    }

    return value;
  };
  /**
   * Adds url parameter quotes for non-regex pattern
   * @param {string} pattern
   */


  var addUrlQuotes = function addUrlQuotes(pattern) {
    // for regex patterns
    if (pattern[0] === '/' && pattern[pattern.length - 1] === '/' && pattern.indexOf('\\"') < 10) {
      // e.g. /^url\\([a-z]{4}:[a-z]{5}/
      // or /^url\\(data\\:\\image\\/gif;base64.+/
      var re = /(\^)?url(\\)?\\\((\w|\[\w)/g;
      return pattern.replace(re, '$1url$2\\\(\\"?$3');
    } // for non-regex patterns


    if (pattern.indexOf('url("') === -1) {
      var _re = /url\((.*?)\)/g;
      return pattern.replace(_re, 'url("$1")');
    }

    return pattern;
  };
  /**
   * Class that matches element style against the specified expression
   * @member {string} propertyName
   * @member {string} pseudoElement
   * @member {RegExp} regex
   */


  var Matcher = function Matcher(propertyFilter, pseudoElement) {
    this.pseudoElement = pseudoElement;

    try {
      var index = propertyFilter.indexOf(':');
      this.propertyName = propertyFilter.substring(0, index).trim();
      var pattern = propertyFilter.substring(index + 1).trim();
      pattern = addUrlQuotes(pattern); // Unescaping pattern
      // For non-regex patterns, (,),[,] should be unescaped, because we require escaping them in filter rules.
      // For regex patterns, ",\ should be escaped, because we manually escape those in extended-css-selector.js.

      if (/^\/.*\/$/.test(pattern)) {
        pattern = pattern.slice(1, -1);
        this.regex = utils.pseudoArgToRegex(pattern);
      } else {
        pattern = pattern.replace(/\\([\\()[\]"])/g, '$1');
        this.regex = utils.createURLRegex(pattern);
      }
    } catch (ex) {
      utils.logError("StylePropertyMatcher: invalid match string ".concat(propertyFilter));
    }
  };
  /**
   * Function to check if element CSS property matches filter pattern
   * @param {Element} element to check
   */


  Matcher.prototype.matches = function (element) {
    if (!this.regex || !this.propertyName) {
      return false;
    }

    var value = getComputedStylePropertyValue(element, this.pseudoElement, this.propertyName);
    return value && this.regex.test(value);
  };
  /**
   * Creates a new pseudo-class and registers it in Sizzle
   */


  var extendSizzle = function extendSizzle(sizzle) {
    // First of all we should prepare Sizzle engine
    sizzle.selectors.pseudos['matches-css'] = sizzle.selectors.createPseudo(function (propertyFilter) {
      var matcher = new Matcher(propertyFilter);
      return function (element) {
        return matcher.matches(element);
      };
    });
    sizzle.selectors.pseudos['matches-css-before'] = sizzle.selectors.createPseudo(function (propertyFilter) {
      var matcher = new Matcher(propertyFilter, ':before');
      return function (element) {
        return matcher.matches(element);
      };
    });
    sizzle.selectors.pseudos['matches-css-after'] = sizzle.selectors.createPseudo(function (propertyFilter) {
      var matcher = new Matcher(propertyFilter, ':after');
      return function (element) {
        return matcher.matches(element);
      };
    });
  }; // EXPOSE


  return {
    extendSizzle: extendSizzle
  };
}(window);

/**
 * Copyright 2016 Adguard Software Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var matcherUtils = {};
matcherUtils.MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
/**
 * Parses argument of matcher pseudo (for matches-attr and matches-property)
 * @param {string} matcherFilter argument of pseudo class
 * @returns {Array}
 */

matcherUtils.parseMatcherFilter = function (matcherFilter) {
  var FULL_MATCH_MARKER = '"="';
  var rawArgs = [];

  if (matcherFilter.indexOf(FULL_MATCH_MARKER) === -1) {
    // if there is only one pseudo arg
    // e.g. :matches-attr("data-name") or :matches-property("inner.prop")
    // Sizzle will parse it and get rid of quotes
    // so it might be valid arg already without them
    rawArgs.push(matcherFilter);
  } else {
    matcherFilter.split('=').forEach(function (arg) {
      if (arg[0] === '"' && arg[arg.length - 1] === '"') {
        rawArgs.push(arg.slice(1, -1));
      }
    });
  }

  return rawArgs;
};
/**
 * @typedef {Object} ArgData
 * @property {string} arg
 * @property {boolean} isRegexp
 */

/**
 * Parses raw matcher arg
 * @param {string} rawArg
 * @returns {ArgData}
 */


matcherUtils.parseRawMatcherArg = function (rawArg) {
  var arg = rawArg;
  var isRegexp = !!rawArg && rawArg[0] === '/' && rawArg[rawArg.length - 1] === '/';

  if (isRegexp) {
    // to avoid at least such case — :matches-property("//")
    if (rawArg.length > 2) {
      arg = utils.toRegExp(rawArg);
    } else {
      throw new Error("Invalid regexp: ".concat(rawArg));
    }
  }

  return {
    arg: arg,
    isRegexp: isRegexp
  };
};
/**
 * @typedef Chain
 * @property {Object} base
 * @property {string} prop
 * @property {string} value
 */

/**
 * Checks if the property exists in the base object (recursively).
 * @param {Object} base
 * @param {ArgData[]} chain array of objects - parsed string property chain
 * @param {Array} [output=[]] result acc
 * @returns {Chain[]} array of objects
 */


matcherUtils.filterRootsByRegexpChain = function (base, chain) {
  var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var tempProp = chain[0];

  if (chain.length === 1) {
    // eslint-disable-next-line no-restricted-syntax
    for (var key in base) {
      if (tempProp.isRegexp) {
        if (tempProp.arg.test(key)) {
          output.push({
            base: base,
            prop: key,
            value: base[key]
          });
        }
      } else if (tempProp.arg === key) {
        output.push({
          base: base,
          prop: tempProp.arg,
          value: base[key]
        });
      }
    }

    return output;
  } // if there is a regexp prop in input chain
  // e.g. 'unit./^ad.+/.src' for 'unit.ad-1gf2.src unit.ad-fgd34.src'),
  // every base keys should be tested by regexp and it can be more that one results


  if (tempProp.isRegexp) {
    var nextProp = chain.slice(1);
    var baseKeys = []; // eslint-disable-next-line no-restricted-syntax

    for (var _key in base) {
      if (tempProp.arg.test(_key)) {
        baseKeys.push(_key);
      }
    }

    baseKeys.forEach(function (key) {
      var item = base[key];
      matcherUtils.filterRootsByRegexpChain(item, nextProp, output);
    });
  } // avoid TypeError while accessing to null-prop's child


  if (base === null) {
    return;
  }

  var nextBase = base[tempProp.arg];
  chain = chain.slice(1);

  if (nextBase !== undefined) {
    matcherUtils.filterRootsByRegexpChain(nextBase, chain, output);
  }

  return output;
};
/**
 * Validates parsed args of matches-property pseudo
 * @param {...ArgData} args
 */


matcherUtils.validatePropMatcherArgs = function () {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }

  for (var i = 0; i < args.length; i += 1) {
    if (args[i].isRegexp) {
      if (!utils.startsWith(args[i].arg.toString(), '/') || !utils.endsWith(args[i].arg.toString(), '/')) {
        return false;
      } // simple arg check if it is not a regexp

    } else if (!/^[\w-]+$/.test(args[i].arg)) {
      return false;
    }
  }

  return true;
};

/**
 * Class that extends Sizzle and adds support for "matches-attr" pseudo element.
 */

var AttributesMatcher = function () {
  /**
   * Class that matches element attributes against the specified expressions
   * @param {ArgData} nameArg - parsed name argument
   * @param {ArgData} valueArg - parsed value argument
   * @param {string} pseudoElement
   * @constructor
   *
   * @member {string|RegExp} attrName
   * @member {boolean} isRegexpName
   * @member {string|RegExp} attrValue
   * @member {boolean} isRegexpValue
   */
  var AttrMatcher = function AttrMatcher(nameArg, valueArg, pseudoElement) {
    this.pseudoElement = pseudoElement;
    this.attrName = nameArg.arg;
    this.isRegexpName = nameArg.isRegexp;
    this.attrValue = valueArg.arg;
    this.isRegexpValue = valueArg.isRegexp;
  };
  /**
   * Function to check if element attributes matches filter pattern
   * @param {Element} element to check
   */


  AttrMatcher.prototype.matches = function (element) {
    var elAttrs = element.attributes;

    if (elAttrs.length === 0 || !this.attrName) {
      return false;
    }

    var i = 0;

    while (i < elAttrs.length) {
      var attr = elAttrs[i];
      var matched = false;
      var attrNameMatched = this.isRegexpName ? this.attrName.test(attr.name) : this.attrName === attr.name;

      if (!this.attrValue) {
        // for :matches-attr("/regex/") or :matches-attr("attr-name")
        matched = attrNameMatched;
      } else {
        var attrValueMatched = this.isRegexpValue ? this.attrValue.test(attr.value) : this.attrValue === attr.value;
        matched = attrNameMatched && attrValueMatched;
      }

      if (matched) {
        return true;
      }

      i += 1;
    }
  };
  /**
   * Creates a new pseudo-class and registers it in Sizzle
   */


  var extendSizzle = function extendSizzle(sizzle) {
    // First of all we should prepare Sizzle engine
    sizzle.selectors.pseudos['matches-attr'] = sizzle.selectors.createPseudo(function (attrFilter) {
      var _matcherUtils$parseMa = matcherUtils.parseMatcherFilter(attrFilter),
          _matcherUtils$parseMa2 = _slicedToArray(_matcherUtils$parseMa, 2),
          rawName = _matcherUtils$parseMa2[0],
          rawValue = _matcherUtils$parseMa2[1];

      var nameArg = matcherUtils.parseRawMatcherArg(rawName);
      var valueArg = matcherUtils.parseRawMatcherArg(rawValue);

      if (!attrFilter || !matcherUtils.validatePropMatcherArgs(nameArg, valueArg)) {
        throw new Error("Invalid argument of :matches-attr pseudo class: ".concat(attrFilter));
      }

      var matcher = new AttrMatcher(nameArg, valueArg);
      return function (element) {
        return matcher.matches(element);
      };
    });
  }; // EXPOSE


  return {
    extendSizzle: extendSizzle
  };
}();

/**
 * Parses raw property arg
 * @param {string} input
 * @returns {ArgData[]} array of objects
 */

var parseRawPropChain = function parseRawPropChain(input) {
  var PROPS_DIVIDER = '.';
  var REGEXP_MARKER = '/';
  var propsArr = [];
  var str = input;

  while (str.length > 0) {
    if (utils.startsWith(str, PROPS_DIVIDER)) {
      // for cases like '.prop.id' and 'nested..test'
      throw new Error("Invalid chain property: ".concat(input));
    }

    if (!utils.startsWith(str, REGEXP_MARKER)) {
      var isRegexp = false;
      var dividerIndex = str.indexOf(PROPS_DIVIDER);

      if (str.indexOf(PROPS_DIVIDER) === -1) {
        // if there is no '.' left in str
        // take the rest of str as prop
        propsArr.push({
          arg: str,
          isRegexp: isRegexp
        });
        return propsArr;
      } // else take prop from str


      var prop = str.slice(0, dividerIndex); // for cases like 'asadf.?+/.test'

      if (prop.indexOf(REGEXP_MARKER) > -1) {
        // prop is '?+/'
        throw new Error("Invalid chain property: ".concat(prop));
      }

      propsArr.push({
        arg: prop,
        isRegexp: isRegexp
      }); // delete prop from str

      str = str.slice(dividerIndex);
    } else {
      // deal with regexp
      var propChunks = [];
      propChunks.push(str.slice(0, 1)); // if str starts with '/', delete it from str and find closing regexp slash.
      // note that chained property name can not include '/' or '.'
      // so there is no checking for escaped characters

      str = str.slice(1);
      var regexEndIndex = str.indexOf(REGEXP_MARKER);

      if (regexEndIndex < 1) {
        // regexp should be at least === '/./'
        // so we should avoid args like '/id' and 'test.//.id'
        throw new Error("Invalid regexp: ".concat(REGEXP_MARKER).concat(str));
      }

      var _isRegexp = true; // take the rest regexp part

      propChunks.push(str.slice(0, regexEndIndex + 1));

      var _prop = utils.toRegExp(propChunks.join(''));

      propsArr.push({
        arg: _prop,
        isRegexp: _isRegexp
      }); // delete prop from str

      str = str.slice(regexEndIndex + 1);
    }

    if (!str) {
      return propsArr;
    } // str should be like '.nextProp' now
    // so 'zx.prop' or '.' is invalid


    if (!utils.startsWith(str, PROPS_DIVIDER) || utils.startsWith(str, PROPS_DIVIDER) && str.length === 1) {
      throw new Error("Invalid chain property: ".concat(input));
    }

    str = str.slice(1);
  }
};

var convertTypeFromStr = function convertTypeFromStr(value) {
  var numValue = Number(value);
  var output;

  if (!Number.isNaN(numValue)) {
    output = numValue;
  } else {
    switch (value) {
      case 'undefined':
        output = undefined;
        break;

      case 'null':
        output = null;
        break;

      case 'true':
        output = true;
        break;

      case 'false':
        output = false;
        break;

      default:
        output = value;
    }
  }

  return output;
};

var convertTypeIntoStr = function convertTypeIntoStr(value) {
  var output;

  switch (value) {
    case undefined:
      output = 'undefined';
      break;

    case null:
      output = 'null';
      break;

    default:
      output = value.toString();
  }

  return output;
};
/**
 * Class that extends Sizzle and adds support for "matches-property" pseudo element.
 */


var ElementPropertyMatcher = function () {
  /**
   * Class that matches element properties against the specified expressions
   * @param {ArgData[]} propsChainArg - array of parsed props chain objects
   * @param {ArgData} valueArg - parsed value argument
   * @param {string} pseudoElement
   * @constructor
   *
   * @member {Array} chainedProps
   * @member {boolean} isRegexpName
   * @member {string|RegExp} propValue
   * @member {boolean} isRegexpValue
   */
  var PropMatcher = function PropMatcher(propsChainArg, valueArg, pseudoElement) {
    this.pseudoElement = pseudoElement;
    this.chainedProps = propsChainArg;
    this.propValue = valueArg.arg;
    this.isRegexpValue = valueArg.isRegexp;
  };
  /**
   * Function to check if element properties matches filter pattern
   * @param {Element} element to check
   */


  PropMatcher.prototype.matches = function (element) {
    var ownerObjArr = matcherUtils.filterRootsByRegexpChain(element, this.chainedProps);

    if (ownerObjArr.length === 0) {
      return false;
    }

    var matched = true;

    if (this.propValue) {
      for (var i = 0; i < ownerObjArr.length; i += 1) {
        var realValue = ownerObjArr[i].value;

        if (this.isRegexpValue) {
          matched = this.propValue.test(convertTypeIntoStr(realValue));
        } else {
          // handle 'null' and 'undefined' property values set as string
          if (realValue === 'null' || realValue === 'undefined') {
            matched = this.propValue === realValue;
            break;
          }

          matched = convertTypeFromStr(this.propValue) === realValue;
        }

        if (matched) {
          break;
        }
      }
    }

    return matched;
  };
  /**
   * Creates a new pseudo-class and registers it in Sizzle
   */


  var extendSizzle = function extendSizzle(sizzle) {
    // First of all we should prepare Sizzle engine
    sizzle.selectors.pseudos['matches-property'] = sizzle.selectors.createPseudo(function (propertyFilter) {
      if (!propertyFilter) {
        throw new Error('No argument is given for :matches-property pseudo class');
      }

      var _matcherUtils$parseMa = matcherUtils.parseMatcherFilter(propertyFilter),
          _matcherUtils$parseMa2 = _slicedToArray(_matcherUtils$parseMa, 2),
          rawProp = _matcherUtils$parseMa2[0],
          rawValue = _matcherUtils$parseMa2[1]; // chained property name can not include '/' or '.'
      // so regex prop names with such escaped characters are invalid


      if (rawProp.indexOf('\\/') > -1 || rawProp.indexOf('\\.') > -1) {
        throw new Error("Invalid property name: ".concat(rawProp));
      }

      var propsChainArg = parseRawPropChain(rawProp);
      var valueArg = matcherUtils.parseRawMatcherArg(rawValue);
      var propsToValidate = [].concat(_toConsumableArray(propsChainArg), [valueArg]);

      if (!matcherUtils.validatePropMatcherArgs(propsToValidate)) {
        throw new Error("Invalid argument of :matches-property pseudo class: ".concat(propertyFilter));
      }

      var matcher = new PropMatcher(propsChainArg, valueArg);
      return function (element) {
        return matcher.matches(element);
      };
    });
  }; // EXPOSE


  return {
    extendSizzle: extendSizzle
  };
}();

/**
 * Copyright 2020 Adguard Software Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Class that extends Sizzle and adds support for :is() pseudo element.
 */

var IsAnyMatcher = function () {
  /**
   * Class that matches element by one of the selectors
   * https://developer.mozilla.org/en-US/docs/Web/CSS/:is
   * @param {Array} selectors
   * @param {string} pseudoElement
   * @constructor
   */
  var IsMatcher = function IsMatcher(selectors, pseudoElement) {
    this.selectors = selectors;
    this.pseudoElement = pseudoElement;
  };
  /**
   * Function to check if element can be matched by any passed selector
   * @param {Element} element to check
   */


  IsMatcher.prototype.matches = function (element) {
    var isMatched = !!this.selectors.find(function (selector) {
      var nodes = document.querySelectorAll(selector);
      return Array.from(nodes).find(function (node) {
        return node === element;
      });
    });
    return isMatched;
  };
  /**
   * Creates a new pseudo-class and registers it in Sizzle
   */


  var extendSizzle = function extendSizzle(sizzle) {
    // First of all we should prepare Sizzle engine
    sizzle.selectors.pseudos['is'] = sizzle.selectors.createPseudo(function (input) {
      if (input === '') {
        throw new Error("Invalid argument of :is pseudo-class: ".concat(input));
      }

      var selectors = input.split(',').map(function (s) {
        return s.trim();
      }); // collect valid selectors and log about invalid ones

      var validSelectors = selectors.reduce(function (acc, selector) {
        if (cssUtils.isSimpleSelectorValid(selector)) {
          acc.push(selector);
        } else {
          utils.logInfo("Invalid selector passed to :is() pseudo-class: '".concat(selector, "'"));
        }

        return acc;
      }, []);
      var matcher = new IsMatcher(validSelectors);
      return function (element) {
        return matcher.matches(element);
      };
    });
  };

  return {
    extendSizzle: extendSizzle
  };
}();

/**
 * Copyright 2021 Adguard Software Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Extended selector factory module, for creating extended selector classes.
 *
 * Extended selection capabilities description:
 * https://github.com/AdguardTeam/ExtendedCss/blob/master/README.md
 */

var ExtendedSelectorFactory = function () {
  // while adding new markers, constants in other AdGuard repos should be corrected
  // AdGuard browser extension : CssFilterRule.SUPPORTED_PSEUDO_CLASSES and CssFilterRule.EXTENDED_CSS_MARKERS
  // tsurlfilter, SafariConverterLib : EXT_CSS_PSEUDO_INDICATORS
  var PSEUDO_EXTENSIONS_MARKERS = [':has', ':contains', ':has-text', ':matches-css', ':-abp-has', ':-abp-has-text', ':if', ':if-not', ':xpath', ':nth-ancestor', ':upward', ':remove', ':matches-attr', ':matches-property', ':-abp-contains', ':is'];
  var initialized = false;
  var Sizzle;
  /**
   * Lazy initialization of the ExtendedSelectorFactory and objects that might be necessary for creating and applying styles.
   * This method extends Sizzle engine that we use under the hood with our custom pseudo-classes.
   */

  function initialize() {
    if (initialized) {
      return;
    }

    initialized = true; // Our version of Sizzle is initialized lazily as well

    Sizzle = initializeSizzle(); // Add :matches-css-*() support

    StylePropertyMatcher.extendSizzle(Sizzle); // Add :matches-attr() support

    AttributesMatcher.extendSizzle(Sizzle); // Add :matches-property() support

    ElementPropertyMatcher.extendSizzle(Sizzle); // Add :is() support

    IsAnyMatcher.extendSizzle(Sizzle); // Add :contains, :has-text, :-abp-contains support

    var containsPseudo = Sizzle.selectors.createPseudo(function (text) {
      if (/^\s*\/.*\/[gmisuy]*\s*$/.test(text)) {
        text = text.trim();
        var flagsIndex = text.lastIndexOf('/');
        var flags = text.substring(flagsIndex + 1);
        text = text.substr(0, flagsIndex + 1).slice(1, -1).replace(/\\([\\"])/g, '$1');
        var regex;

        try {
          regex = new RegExp(text, flags);
        } catch (e) {
          throw new Error("Invalid argument of :contains pseudo class: ".concat(text));
        }

        return function (elem) {
          var elemTextContent = utils.nodeTextContentGetter.apply(elem);
          return regex.test(elemTextContent);
        };
      }

      text = text.replace(/\\([\\()[\]"])/g, '$1');
      return function (elem) {
        var elemTextContent = utils.nodeTextContentGetter.apply(elem);
        return elemTextContent.indexOf(text) > -1;
      };
    });
    Sizzle.selectors.pseudos['contains'] = containsPseudo;
    Sizzle.selectors.pseudos['has-text'] = containsPseudo;
    Sizzle.selectors.pseudos['-abp-contains'] = containsPseudo; // Add :if, :-abp-has support

    Sizzle.selectors.pseudos['if'] = Sizzle.selectors.pseudos['has'];
    Sizzle.selectors.pseudos['-abp-has'] = Sizzle.selectors.pseudos['has']; // Add :if-not support

    Sizzle.selectors.pseudos['if-not'] = Sizzle.selectors.createPseudo(function (selector) {
      if (typeof selector === 'string') {
        Sizzle.compile(selector);
      }

      return function (elem) {
        return Sizzle(selector, elem).length === 0;
      };
    });
    registerParserOnlyTokens();
  }
  /**
   * Registrate custom tokens for parser.
   * Needed for proper work of pseudos:
   * for checking if the token is last and pseudo-class arguments validation
   */


  function registerParserOnlyTokens() {
    Sizzle.selectors.pseudos['xpath'] = Sizzle.selectors.createPseudo(function (selector) {
      try {
        document.createExpression(selector, null);
      } catch (e) {
        throw new Error("Invalid argument of :xpath pseudo class: ".concat(selector));
      }

      return function () {
        return true;
      };
    });
    Sizzle.selectors.pseudos['nth-ancestor'] = Sizzle.selectors.createPseudo(function (selector) {
      var deep = Number(selector);

      if (Number.isNaN(deep) || deep < 1 || deep >= 256) {
        throw new Error("Invalid argument of :nth-ancestor pseudo class: ".concat(selector));
      }

      return function () {
        return true;
      };
    });
    Sizzle.selectors.pseudos['upward'] = Sizzle.selectors.createPseudo(function (input) {
      if (input === '') {
        throw new Error("Invalid argument of :upward pseudo class: ".concat(input));
      } else if (Number.isInteger(+input) && (+input < 1 || +input >= 256)) {
        throw new Error("Invalid argument of :upward pseudo class: ".concat(input));
      }

      return function () {
        return true;
      };
    });
    Sizzle.selectors.pseudos['remove'] = Sizzle.selectors.createPseudo(function (input) {
      if (input !== '') {
        throw new Error("Invalid argument of :remove pseudo class: ".concat(input));
      }

      return function () {
        return true;
      };
    });
  }
  /**
   * Checks if specified token can be used by document.querySelectorAll.
   */


  function isSimpleToken(token) {
    var type = token.type;

    if (type === 'ID' || type === 'CLASS' || type === 'ATTR' || type === 'TAG' || type === 'CHILD') {
      // known simple tokens
      return true;
    }

    if (type === 'PSEUDO') {
      // check if value contains any of extended pseudo classes
      var i = PSEUDO_EXTENSIONS_MARKERS.length;

      while (i--) {
        if (token.value.indexOf(PSEUDO_EXTENSIONS_MARKERS[i]) >= 0) {
          return false;
        }
      }

      return true;
    } // all others aren't simple


    return false;
  }
  /**
   * Checks if specified token is a combinator
   */


  function isRelationToken(token) {
    var type = token.type;
    return type === ' ' || type === '>' || type === '+' || type === '~';
  }
  /**
   * ExtendedSelectorParser is a helper class for creating various selector instances which
   * all shares a method `querySelectorAll()` and `matches()` implementing different search strategies
   * depending on a type of selector.
   *
   * Currently, there are 3 types:
   *  A trait-less extended selector
   *    - we directly feed selector strings to Sizzle.
   *  A splitted extended selector
   *    - such as #container #feedItem:has(.ads), where it is splitted to `#container` and `#feedItem:has(.ads)`.
   */


  function ExtendedSelectorParser(selectorText, tokens, debug) {
    initialize();

    if (typeof tokens === 'undefined') {
      this.selectorText = cssUtils.normalize(selectorText); // Passing `returnUnsorted` in order to receive tokens in the order that's valid for the browser
      // In Sizzle internally, the tokens are re-sorted: https://github.com/AdguardTeam/ExtendedCss/issues/55

      this.tokens = Sizzle.tokenize(this.selectorText, false, {
        returnUnsorted: true
      });
    } else {
      this.selectorText = selectorText;
      this.tokens = tokens;
    }

    if (debug === true) {
      this.debug = true;
    }
  }

  ExtendedSelectorParser.prototype = {
    /**
     * The main method, creates a selector instance depending on the type of a selector.
     * @public
     */
    createSelector: function createSelector() {
      var debug = this.debug;
      var tokens = this.tokens;
      var selectorText = this.selectorText;

      if (tokens.length !== 1) {
        // Comma-separate selector - can't optimize further
        return new TraitLessSelector(selectorText, debug);
      }

      var xpathPart = this.getXpathPart();

      if (typeof xpathPart !== 'undefined') {
        return new XpathSelector(selectorText, xpathPart, debug);
      }

      var upwardPart = this.getUpwardPart();

      if (typeof upwardPart !== 'undefined') {
        var output;
        var upwardDeep = parseInt(upwardPart, 10); // if upward parameter is not a number, we consider it as a selector

        if (Number.isNaN(upwardDeep)) {
          output = new UpwardSelector(selectorText, upwardPart, debug);
        } else {
          // upward works like nth-ancestor
          var xpath = this.convertNthAncestorToken(upwardDeep);
          output = new XpathSelector(selectorText, xpath, debug);
        }

        return output;
      } // argument of pseudo-class remove;
      // it's defined only if remove is parsed as last token
      // and it's valid only if remove arg is empty string


      var removePart = this.getRemovePart();

      if (typeof removePart !== 'undefined') {
        var hasValidRemovePart = removePart === '';
        return new RemoveSelector(selectorText, hasValidRemovePart, debug);
      }

      tokens = tokens[0];
      var l = tokens.length;
      var lastRelTokenInd = this.getSplitPoint();

      if (typeof lastRelTokenInd === 'undefined') {
        try {
          document.querySelector(selectorText);
        } catch (e) {
          return new TraitLessSelector(selectorText, debug);
        }

        return new NotAnExtendedSelector(selectorText, debug);
      }

      var simple = '';
      var relation = null;
      var complex = '';
      var i = 0;

      for (; i < lastRelTokenInd; i++) {
        // build simple part
        simple += tokens[i].value;
      }

      if (i > 0) {
        // build relation part
        relation = tokens[i++].type;
      } // i is pointing to the start of a complex part.


      for (; i < l; i++) {
        complex += tokens[i].value;
      }

      return lastRelTokenInd === -1 ? new TraitLessSelector(selectorText, debug) : new SplittedSelector(selectorText, simple, relation, complex, debug);
    },

    /**
     * @private
     * @return {number|undefined} An index of a token that is split point.
     * returns undefined if the selector does not contain any complex tokens
     * or it is not eligible for splitting.
     * Otherwise returns an integer indicating the index of the last relation token.
     */
    getSplitPoint: function getSplitPoint() {
      var tokens = this.tokens[0]; // We split selector only when the last compound selector
      // is the only extended selector.

      var latestRelationTokenIndex = -1;
      var haveMetComplexToken = false;

      for (var i = 0, l = tokens.length; i < l; i++) {
        var token = tokens[i];

        if (isRelationToken(token)) {
          if (haveMetComplexToken) {
            return;
          }

          latestRelationTokenIndex = i;
        } else if (!isSimpleToken(token)) {
          haveMetComplexToken = true;
        }
      }

      if (!haveMetComplexToken) {
        return;
      }

      return latestRelationTokenIndex;
    },

    /**
     * @private
     * @return {string|undefined} xpath selector part if exists
     * returns undefined if the selector does not contain xpath tokens
     */
    getXpathPart: function getXpathPart() {
      var tokens = this.tokens[0];

      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {
        var token = tokens[i];

        if (token.type === 'PSEUDO') {
          var matches = token.matches;

          if (matches && matches.length > 1) {
            if (matches[0] === 'xpath') {
              if (this.isLastToken(tokens, i)) {
                throw new Error('Invalid pseudo: \':xpath\' should be at the end of the selector');
              }

              return matches[1];
            }

            if (matches[0] === 'nth-ancestor') {
              if (this.isLastToken(tokens, i)) {
                throw new Error('Invalid pseudo: \':nth-ancestor\' should be at the end of the selector');
              }

              var deep = matches[1];

              if (deep > 0 && deep < 256) {
                return this.convertNthAncestorToken(deep);
              }
            }
          }
        }
      }
    },

    /**
     * converts nth-ancestor/upward deep value to xpath equivalent
     * @param {number} deep
     * @return {string}
     */
    convertNthAncestorToken: function convertNthAncestorToken(deep) {
      var result = '..';

      while (deep > 1) {
        result += '/..';
        deep--;
      }

      return result;
    },

    /**
     * Checks if the token is last,
     * except of remove pseudo-class
     * @param {Array} tokens
     * @param {number} i index of token
     * @returns {boolean}
     */
    isLastToken: function isLastToken(tokens, i) {
      // check id the next parsed token is remove pseudo
      var isNextRemoveToken = tokens[i + 1] && tokens[i + 1].type === 'PSEUDO' && tokens[i + 1].matches && tokens[i + 1].matches[0] === 'remove'; // check if the token is last
      // and if it is not check if it is remove one
      // which should be skipped

      return i + 1 !== tokens.length && !isNextRemoveToken;
    },

    /**
     * @private
     * @return {string|undefined} upward parameter
     * or undefined if the input does not contain upward tokens
     */
    getUpwardPart: function getUpwardPart() {
      var tokens = this.tokens[0];

      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {
        var token = tokens[i];

        if (token.type === 'PSEUDO') {
          var matches = token.matches;

          if (matches && matches.length > 1) {
            if (matches[0] === 'upward') {
              if (this.isLastToken(tokens, i)) {
                throw new Error('Invalid pseudo: \':upward\' should be at the end of the selector');
              }

              return matches[1];
            }
          }
        }
      }
    },

    /**
     * @private
     * @return {string|undefined} remove parameter
     * or undefined if the input does not contain remove tokens
     */
    getRemovePart: function getRemovePart() {
      var tokens = this.tokens[0];

      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {
        var token = tokens[i];

        if (token.type === 'PSEUDO') {
          var matches = token.matches;

          if (matches && matches.length > 1) {
            if (matches[0] === 'remove') {
              if (i + 1 !== tokensLength) {
                throw new Error('Invalid pseudo: \':remove\' should be at the end of the selector');
              }

              return matches[1];
            }
          }
        }
      }
    }
  };
  var globalDebuggingFlag = false;

  function isDebugging() {
    return globalDebuggingFlag || this.debug;
  }
  /**
   * This class represents a selector which is not an extended selector.
   * @param {string} selectorText
   * @param {boolean=} debug
   * @final
   */


  function NotAnExtendedSelector(selectorText, debug) {
    this.selectorText = selectorText;
    this.debug = debug;
  }

  NotAnExtendedSelector.prototype = {
    querySelectorAll: function querySelectorAll() {
      return document.querySelectorAll(this.selectorText);
    },
    matches: function matches(element) {
      return element[utils.matchesPropertyName](this.selectorText);
    },
    isDebugging: isDebugging
  };
  /**
   * A trait-less extended selector class.
   * @param {string} selectorText
   * @param {boolean=} debug
   * @constructor
   */

  function TraitLessSelector(selectorText, debug) {
    this.selectorText = selectorText;
    this.debug = debug;
    Sizzle.compile(selectorText);
  }

  TraitLessSelector.prototype = {
    querySelectorAll: function querySelectorAll() {
      return Sizzle(this.selectorText);
    },

    /** @final */
    matches: function matches(element) {
      return Sizzle.matchesSelector(element, this.selectorText);
    },

    /** @final */
    isDebugging: isDebugging
  };
  /**
   * Parental class for such pseudo-classes as xpath, upward, remove
   * which are limited to be the last one token in selector
   *
   * @param {string} selectorText
   * @param {string} pseudoClassArg pseudo-class arg
   * @param {boolean=} debug
   * @constructor
   */

  function BaseLastArgumentSelector(selectorText, pseudoClassArg, debug) {
    this.selectorText = selectorText;
    this.pseudoClassArg = pseudoClassArg;
    this.debug = debug;
    Sizzle.compile(this.selectorText);
  }

  BaseLastArgumentSelector.prototype = {
    querySelectorAll: function querySelectorAll() {
      var _this = this;

      var resultNodes = [];
      var simpleNodes;

      if (this.selectorText) {
        simpleNodes = Sizzle(this.selectorText);

        if (!simpleNodes || !simpleNodes.length) {
          return resultNodes;
        }
      } else {
        simpleNodes = [document];
      }

      simpleNodes.forEach(function (node) {
        _this.searchResultNodes(node, _this.pseudoClassArg, resultNodes);
      });
      return Sizzle.uniqueSort(resultNodes);
    },

    /** @final */
    matches: function matches(element) {
      var results = this.querySelectorAll();
      return results.indexOf(element) > -1;
    },

    /** @final */
    isDebugging: isDebugging,

    /**
     * Primitive method that returns all nodes if pseudo-class arg is defined.
     * That logic works for remove pseudo-class,
     * but for others it should be overridden.
     * @param {Object} node context element
     * @param {string} pseudoClassArg pseudo-class argument
     * @param {Array} result
     */
    searchResultNodes: function searchResultNodes(node, pseudoClassArg, result) {
      if (pseudoClassArg) {
        result.push(node);
      }
    }
  };
  /**
   * Xpath selector class
   * Limited to support 'xpath' to be only the last one token in selector
   * @param {string} selectorText
   * @param {string} xpath value
   * @param {boolean=} debug
   * @constructor
   * @augments BaseLastArgumentSelector
   */

  function XpathSelector(selectorText, xpath, debug) {
    var NO_SELECTOR_MARKER = ':xpath(//';
    var BODY_SELECTOR_REPLACER = 'body:xpath(//';
    var modifiedSelectorText = selectorText; // Normally, a pseudo-class is applied to nodes selected by a selector -- selector:xpath(...).
    // However, :xpath is special as the selector can be ommited.
    // For any other pseudo-class that would mean "apply to ALL DOM nodes",
    // but in case of :xpath it just means "apply me to the document".

    if (utils.startsWith(selectorText, NO_SELECTOR_MARKER)) {
      modifiedSelectorText = selectorText.replace(NO_SELECTOR_MARKER, BODY_SELECTOR_REPLACER);
    }

    BaseLastArgumentSelector.call(this, modifiedSelectorText, xpath, debug);
  }

  XpathSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);
  XpathSelector.prototype.constructor = XpathSelector;
  /**
   * Applies xpath pseudo-class to provided context node
   * @param {Object} node context element
   * @param {string} pseudoClassArg xpath
   * @param {Array} result
   * @override
   */

  XpathSelector.prototype.searchResultNodes = function (node, pseudoClassArg, result) {
    var xpathResult = document.evaluate(pseudoClassArg, node, null, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);
    var iNode; // eslint-disable-next-line no-cond-assign

    while (iNode = xpathResult.iterateNext()) {
      result.push(iNode);
    }
  };
  /**
   * Upward selector class
   * Limited to support 'upward' to be only the last one token in selector
   * @param {string} selectorText
   * @param {string} upwardSelector value
   * @param {boolean=} debug
   * @constructor
   * @augments BaseLastArgumentSelector
   */


  function UpwardSelector(selectorText, upwardSelector, debug) {
    BaseLastArgumentSelector.call(this, selectorText, upwardSelector, debug);
  }

  UpwardSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);
  UpwardSelector.prototype.constructor = UpwardSelector;
  /**
   * Applies upward pseudo-class to provided context node
   * @param {Object} node context element
   * @param {string} upwardSelector upward selector
   * @param {Array} result
   * @override
   */

  UpwardSelector.prototype.searchResultNodes = function (node, upwardSelector, result) {
    if (upwardSelector !== '') {
      var parent = node.parentElement;

      if (parent === null) {
        return;
      }

      node = parent.closest(upwardSelector);

      if (node === null) {
        return;
      }
    }

    result.push(node);
  };
  /**
   * Remove selector class
   * Limited to support 'remove' to be only the last one token in selector
   * @param {string} selectorText
   * @param {boolean} hasValidRemovePart
   * @param {boolean=} debug
   * @constructor
   * @augments BaseLastArgumentSelector
   */


  function RemoveSelector(selectorText, hasValidRemovePart, debug) {
    var REMOVE_PSEUDO_MARKER = ':remove()';
    var removeMarkerIndex = selectorText.indexOf(REMOVE_PSEUDO_MARKER); // deleting remove part of rule instead of which
    // pseudo-property property 'remove' will be added by ExtendedCssParser

    var modifiedSelectorText = selectorText.slice(0, removeMarkerIndex);
    BaseLastArgumentSelector.call(this, modifiedSelectorText, hasValidRemovePart, debug); // mark extendedSelector as Remove one for ExtendedCssParser

    this.isRemoveSelector = true;
  }

  RemoveSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);
  RemoveSelector.prototype.constructor = RemoveSelector;
  /**
   * A splitted extended selector class.
   *
   * #container #feedItem:has(.ads)
   * +--------+                     simple
   *           +                    relation
   *            +-----------------+ complex
   * We split selector only when the last selector is complex
   * @param {string} selectorText
   * @param {string} simple
   * @param {string} relation
   * @param {string} complex
   * @param {boolean=} debug
   * @constructor
   * @extends TraitLessSelector
   */

  function SplittedSelector(selectorText, simple, relation, complex, debug) {
    TraitLessSelector.call(this, selectorText, debug);
    this.simple = simple;
    this.relation = relation;
    this.complex = complex;
    Sizzle.compile(complex);
  }

  SplittedSelector.prototype = Object.create(TraitLessSelector.prototype);
  SplittedSelector.prototype.constructor = SplittedSelector;
  /** @override */

  SplittedSelector.prototype.querySelectorAll = function () {
    var _this2 = this;

    var resultNodes = [];
    var simpleNodes;
    var simple = this.simple;
    var relation;

    if (simple) {
      // First we use simple selector to narrow our search
      simpleNodes = document.querySelectorAll(simple);

      if (!simpleNodes || !simpleNodes.length) {
        return resultNodes;
      }

      relation = this.relation;
    } else {
      simpleNodes = [document];
      relation = ' ';
    }

    switch (relation) {
      case ' ':
        simpleNodes.forEach(function (node) {
          _this2.relativeSearch(node, resultNodes);
        });
        break;

      case '>':
        {
          simpleNodes.forEach(function (node) {
            Object.values(node.children).forEach(function (childNode) {
              if (_this2.matches(childNode)) {
                resultNodes.push(childNode);
              }
            });
          });
          break;
        }

      case '+':
        {
          simpleNodes.forEach(function (node) {
            var parentNode = node.parentNode;
            Object.values(parentNode.children).forEach(function (childNode) {
              if (_this2.matches(childNode) && childNode.previousElementSibling === node) {
                resultNodes.push(childNode);
              }
            });
          });
          break;
        }

      case '~':
        {
          simpleNodes.forEach(function (node) {
            var parentNode = node.parentNode;
            Object.values(parentNode.children).forEach(function (childNode) {
              if (_this2.matches(childNode) && node.compareDocumentPosition(childNode) === 4) {
                resultNodes.push(childNode);
              }
            });
          });
          break;
        }
    }

    return Sizzle.uniqueSort(resultNodes);
  };
  /**
   * Performs a search of "complex" part relative to results for the "simple" part.
   * @param {Node} node a node matching the "simple" part.
   * @param {Node[]} result an array to append search result.
   */


  SplittedSelector.prototype.relativeSearch = function (node, results) {
    Sizzle(this.complex, node, results);
  };

  return {
    /**
     * Wraps the inner class so that the instance is not exposed.
     */
    createSelector: function createSelector(selector, tokens, debug) {
      return new ExtendedSelectorParser(selector, tokens, debug).createSelector();
    },

    /**
     * Mark every selector as a selector being debugged, so that timing information
     * for the selector is printed to the console.
     */
    enableGlobalDebugging: function enableGlobalDebugging() {
      globalDebuggingFlag = true;
    }
  };
}();

/**
 * Copyright 2016 Adguard Software Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A helper class that parses stylesheets containing extended selectors
 * into ExtendedSelector instances and key-value maps of style declarations.
 * Please note, that it does not support any complex things like media queries and such.
 */

var ExtendedCssParser = function () {
  var reDeclEnd = /[;}]/g;
  var reDeclDivider = /[;:}]/g;
  var reNonWhitespace = /\S/g;
  var Sizzle;
  /**
   * @param {string} cssText
   * @constructor
   */

  function Parser(cssText) {
    this.cssText = cssText;
  }

  Parser.prototype = {
    error: function error(position) {
      throw new Error("CssParser: parse error at position ".concat(this.posOffset + position));
    },

    /**
     * Validates that the tokens correspond to a valid selector.
     * Sizzle is different from browsers and some selectors that it tolerates aren't actually valid.
     * For instance, "div >" won't work in a browser, but it will in Sizzle (it'd be the same as "div > *").
     *
     * @param {*} selectors An array of SelectorData (selector, groups)
     * @returns {boolean} false if any of the groups are invalid
     */
    validateSelectors: function validateSelectors(selectors) {
      var iSelectors = selectors.length;

      while (iSelectors--) {
        var groups = selectors[iSelectors].groups;
        var iGroups = groups.length;

        while (iGroups--) {
          var tokens = groups[iGroups];
          var lastToken = tokens[tokens.length - 1];

          if (Sizzle.selectors.relative[lastToken.type]) {
            return false;
          }
        }
      }

      return true;
    },

    /**
     * Parses a stylesheet and returns a list of pairs of an ExtendedSelector and a styles map.
     * This method will throw an error in case of an obviously invalid input.
     * If any of the selectors used in the stylesheet cannot be compiled into an ExtendedSelector,
     * it will be ignored.
     *
     * @typedef {Object} ExtendedStyle
     * @property {Object} selector An instance of the {@link ExtendedSelector} class
     * @property {Object} styleMap A map of styles parsed
     *
     * @returns {Array.<ExtendedStyle>} An array of the styles parsed
     */
    parseCss: function parseCss() {
      this.posOffset = 0;

      if (!this.cssText) {
        this.error(0);
      }

      var results = [];

      while (this.cssText) {
        // Apply tolerant tokenization.
        var parseResult = Sizzle.tokenize(this.cssText, false, {
          tolerant: true,
          returnUnsorted: true
        });
        var selectorData = parseResult.selectors;
        this.nextIndex = parseResult.nextIndex;

        if (this.cssText.charCodeAt(this.nextIndex) !== 123 ||
        /* charCode of '{' */
        !this.validateSelectors(selectorData)) {
          this.error(this.nextIndex);
        }

        this.nextIndex++; // Move the pointer to the start of style declaration.

        var styleMap = this.parseNextStyle();
        var debug = false; // If there is a style property 'debug', mark the selector
        // as a debuggable selector, and delete the style declaration.

        var debugPropertyValue = styleMap['debug'];

        if (typeof debugPropertyValue !== 'undefined') {
          if (debugPropertyValue === 'global') {
            ExtendedSelectorFactory.enableGlobalDebugging();
          }

          debug = true;
          delete styleMap['debug'];
        } // Creating an ExtendedSelector instance for every selector we got from Sizzle.tokenize.
        // This is quite important as Sizzle does a poor job at executing selectors like "selector1, selector2".


        for (var i = 0, l = selectorData.length; i < l; i++) {
          var data = selectorData[i];

          try {
            var extendedSelector = ExtendedSelectorFactory.createSelector(data.selectorText, data.groups, debug);

            if (extendedSelector.pseudoClassArg && extendedSelector.isRemoveSelector) {
              // if there is remove pseudo-class in rule,
              // the element will be removed and no other styles will be applied
              styleMap['remove'] = 'true';
            }

            results.push({
              selector: extendedSelector,
              style: styleMap
            });
          } catch (ex) {
            utils.logError("ExtendedCssParser: ignoring invalid selector ".concat(data.selectorText));
          }
        }
      }

      return results;
    },
    parseNextStyle: function parseNextStyle() {
      var styleMap = Object.create(null);
      var bracketPos = this.parseUntilClosingBracket(styleMap); // Cut out matched portion from cssText.

      reNonWhitespace.lastIndex = bracketPos + 1;
      var match = reNonWhitespace.exec(this.cssText);

      if (match === null) {
        this.cssText = '';
        return styleMap;
      }

      var matchPos = match.index;
      this.cssText = this.cssText.slice(matchPos);
      this.posOffset += matchPos;
      return styleMap;
    },

    /**
     * @return {number} an index of the next '}' in `this.cssText`.
     */
    parseUntilClosingBracket: function parseUntilClosingBracket(styleMap) {
      // Expects ":", ";", and "}".
      reDeclDivider.lastIndex = this.nextIndex;
      var match = reDeclDivider.exec(this.cssText);

      if (match === null) {
        this.error(this.nextIndex);
      }

      var matchPos = match.index;
      var matched = match[0];

      if (matched === '}') {
        return matchPos;
      }

      if (matched === ':') {
        var colonIndex = matchPos; // Expects ";" and "}".

        reDeclEnd.lastIndex = colonIndex;
        match = reDeclEnd.exec(this.cssText);

        if (match === null) {
          this.error(colonIndex);
        }

        matchPos = match.index;
        matched = match[0]; // Populates the `styleMap` key-value map.

        var property = this.cssText.slice(this.nextIndex, colonIndex).trim();
        var value = this.cssText.slice(colonIndex + 1, matchPos).trim();
        styleMap[property] = value; // If found "}", re-run the outer loop.

        if (matched === '}') {
          return matchPos;
        }
      } // matchPos is the position of the next ';'.
      // Increase 'nextIndex' and re-run the loop.


      this.nextIndex = matchPos + 1;
      return this.parseUntilClosingBracket(styleMap); // Should be a subject of tail-call optimization.
    }
  };
  return {
    parseCss: function parseCss(cssText) {
      Sizzle = initializeSizzle();
      return new Parser(cssUtils.normalize(cssText)).parseCss();
    }
  };
}();

/**
 * This callback is used to get affected node elements and handle style properties
 * before they are applied to them if it is necessary
 * @callback beforeStyleApplied
 * @param {object} affectedElement - Object containing DOM node and rule to be applied
 * @return {object} affectedElement - Same or modified object containing DOM node and rule to be applied
 */

/**
 * Extended css class
 *
 * @param {Object} configuration
 * @param {string} configuration.styleSheet - the CSS stylesheet text
 * @param {beforeStyleApplied} [configuration.beforeStyleApplied] - the callback that handles affected elements
 * @constructor
 */

function ExtendedCss(configuration) {
  if (!configuration) {
    throw new Error('Configuration is not provided.');
  }

  var styleSheet = configuration.styleSheet;
  var beforeStyleApplied = configuration.beforeStyleApplied;

  if (beforeStyleApplied && typeof beforeStyleApplied !== 'function') {
    // eslint-disable-next-line max-len
    throw new Error("Wrong configuration. Type of 'beforeStyleApplied' field should be a function, received: ".concat(_typeof(beforeStyleApplied)));
  } // We use EventTracker to track the event that is likely to cause the mutation.
  // The problem is that we cannot use `window.event` directly from the mutation observer call
  // as we're not in the event handler context anymore.


  var EventTracker = function () {
    var ignoredEventTypes = ['mouseover', 'mouseleave', 'mouseenter', 'mouseout'];
    var LAST_EVENT_TIMEOUT_MS = 10;
    var EVENTS = [// keyboard events
    'keydown', 'keypress', 'keyup', // mouse events
    'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel']; // 'wheel' event makes scrolling in Safari twitchy
    // https://github.com/AdguardTeam/ExtendedCss/issues/120

    var safariProblematicEvents = ['wheel'];
    var trackedEvents = utils.isSafariBrowser ? EVENTS.filter(function (el) {
      return !(safariProblematicEvents.indexOf(el) > -1);
    }) : EVENTS;
    var lastEventType;
    var lastEventTime;

    var trackEvent = function trackEvent(e) {
      lastEventType = e.type;
      lastEventTime = Date.now();
    };

    trackedEvents.forEach(function (evName) {
      document.documentElement.addEventListener(evName, trackEvent, true);
    });

    var getLastEventType = function getLastEventType() {
      return lastEventType;
    };

    var getTimeSinceLastEvent = function getTimeSinceLastEvent() {
      return Date.now() - lastEventTime;
    };

    return {
      isIgnoredEventType: function isIgnoredEventType() {
        return ignoredEventTypes.indexOf(getLastEventType()) > -1 && getTimeSinceLastEvent() < LAST_EVENT_TIMEOUT_MS;
      }
    };
  }();

  var rules = [];
  var affectedElements = [];
  var removalsStatistic = {};
  var domObserved;
  var eventListenerSupported = window.addEventListener;
  var domMutationObserver;

  function observeDocument(callback) {
    // We are trying to limit the number of callback calls by not calling it on all kind of "hover" events.
    // The rationale behind this is that "hover" events often cause attributes modification,
    // but re-applying extCSS rules will be useless as these attribute changes are usually transient.
    var isIgnoredMutation = function isIgnoredMutation(mutations) {
      for (var i = 0; i < mutations.length; i += 1) {
        if (mutations.type !== 'attributes') {
          return false;
        }
      }

      return true;
    };

    if (utils.MutationObserver) {
      domMutationObserver = new utils.MutationObserver(function (mutations) {
        if (!mutations || mutations.length === 0) {
          return;
        }

        if (EventTracker.isIgnoredEventType() && isIgnoredMutation(mutations)) {
          return;
        }

        callback();
      });
      domMutationObserver.observe(document, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['id', 'class']
      });
    } else if (eventListenerSupported) {
      document.addEventListener('DOMNodeInserted', callback, false);
      document.addEventListener('DOMNodeRemoved', callback, false);
      document.addEventListener('DOMAttrModified', callback, false);
    }
  }

  function disconnectDocument(callback) {
    if (domMutationObserver) {
      domMutationObserver.disconnect();
    } else if (eventListenerSupported) {
      document.removeEventListener('DOMNodeInserted', callback, false);
      document.removeEventListener('DOMNodeRemoved', callback, false);
      document.removeEventListener('DOMAttrModified', callback, false);
    }
  }

  var MAX_STYLE_PROTECTION_COUNT = 50;
  var protectionObserverOption = {
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ['style']
  };
  /**
   * Creates MutationObserver protection function
   *
   * @param styles
   * @return {protectionFunction}
   */

  function createProtectionFunction(styles) {
    function protectionFunction(mutations, observer) {
      if (!mutations.length) {
        return;
      }

      var mutation = mutations[0];
      var target = mutation.target;
      observer.disconnect();
      styles.forEach(function (style) {
        setStyleToElement(target, style);
      });

      if (++observer.styleProtectionCount < MAX_STYLE_PROTECTION_COUNT) {
        observer.observe(target, protectionObserverOption);
      } else {
        utils.logError('ExtendedCss: infinite loop protection for style');
      }
    }

    return protectionFunction;
  }
  /**
   * Sets up a MutationObserver which protects style attributes from changes
   * @param node DOM node
   * @param rules rules
   * @returns Mutation observer used to protect attribute or null if there's nothing to protect
   */


  function protectStyleAttribute(node, rules) {
    if (!utils.MutationObserver) {
      return null;
    }

    var styles = rules.map(function (r) {
      return r.style;
    });
    var protectionObserver = new utils.MutationObserver(createProtectionFunction(styles));
    protectionObserver.observe(node, protectionObserverOption); // Adds an expando to the observer to keep 'style fix counts'.

    protectionObserver.styleProtectionCount = 0;
    return protectionObserver;
  }

  function removeSuffix(str, suffix) {
    var index = str.indexOf(suffix, str.length - suffix.length);

    if (index >= 0) {
      return str.substring(0, index);
    }

    return str;
  }
  /**
   * Finds affectedElement object for the specified DOM node
   * @param node  DOM node
   * @returns     affectedElement found or null
   */


  function findAffectedElement(node) {
    for (var i = 0; i < affectedElements.length; i += 1) {
      if (affectedElements[i].node === node) {
        return affectedElements[i];
      }
    }

    return null;
  }

  function removeElement(affectedElement) {
    var node = affectedElement.node;
    affectedElement.removed = true;
    var elementSelector = utils.getNodeSelector(node); // check if the element has been already removed earlier

    var elementRemovalsCounter = removalsStatistic[elementSelector] || 0; // if removals attempts happened more than specified we do not try to remove node again

    if (elementRemovalsCounter > MAX_STYLE_PROTECTION_COUNT) {
      utils.logError('ExtendedCss: infinite loop protection for SELECTOR', elementSelector);
      return;
    }

    if (node.parentNode) {
      node.parentNode.removeChild(node);
      removalsStatistic[elementSelector] = elementRemovalsCounter + 1;
    }
  }
  /**
   * Applies style to the specified DOM node
   * @param affectedElement Object containing DOM node and rule to be applied
   */


  function applyStyle(affectedElement) {
    if (affectedElement.protectionObserver) {
      // Style is already applied and protected by the observer
      return;
    }

    if (beforeStyleApplied) {
      affectedElement = beforeStyleApplied(affectedElement);

      if (!affectedElement) {
        return;
      }
    }

    var _affectedElement = affectedElement,
        node = _affectedElement.node;

    for (var i = 0; i < affectedElement.rules.length; i++) {
      var style = affectedElement.rules[i].style;

      if (style['remove'] === 'true') {
        removeElement(affectedElement);
        return;
      }

      setStyleToElement(node, style);
    }
  }
  /**
   * Sets style to the specified DOM node
   * @param node element
   * @param style style
   */


  function setStyleToElement(node, style) {
    Object.keys(style).forEach(function (prop) {
      // Apply this style only to existing properties
      // We can't use hasOwnProperty here (does not work in FF)
      if (typeof node.style.getPropertyValue(prop) !== 'undefined') {
        var value = style[prop]; // First we should remove !important attribute (or it won't be applied')

        value = removeSuffix(value.trim(), '!important').trim();
        node.style.setProperty(prop, value, 'important');
      }
    });
  }
  /**
   * Reverts style for the affected object
   */


  function revertStyle(affectedElement) {
    if (affectedElement.protectionObserver) {
      affectedElement.protectionObserver.disconnect();
    }

    affectedElement.node.style.cssText = affectedElement.originalStyle;
  }
  /**
   * Applies specified rule and returns list of elements affected
   * @param rule Rule to apply
   * @returns List of elements affected by this rule
   */


  function applyRule(rule) {
    var debug = rule.selector.isDebugging();
    var start;

    if (debug) {
      start = utils.AsyncWrapper.now();
    }

    var selector = rule.selector;
    var nodes = selector.querySelectorAll();
    nodes.forEach(function (node) {
      var affectedElement = findAffectedElement(node);

      if (affectedElement) {
        affectedElement.rules.push(rule);
        applyStyle(affectedElement);
      } else {
        // Applying style first time
        var originalStyle = node.style.cssText;
        affectedElement = {
          node: node,
          // affected DOM node
          rules: [rule],
          // rules to be applied
          originalStyle: originalStyle,
          // original node style
          protectionObserver: null // style attribute observer

        };
        applyStyle(affectedElement);
        affectedElements.push(affectedElement);
      }
    });

    if (debug) {
      var elapsed = utils.AsyncWrapper.now() - start;

      if (!('timingStats' in rule)) {
        rule.timingStats = new utils.Stats();
      }

      rule.timingStats.push(elapsed);
    }

    return nodes;
  }
  /**
   * Applies filtering rules
   */


  function applyRules() {
    var elementsIndex = []; // some rules could make call - selector.querySelectorAll() temporarily to change node id attribute
    // this caused MutationObserver to call recursively
    // https://github.com/AdguardTeam/ExtendedCss/issues/81

    stopObserve();
    rules.forEach(function (rule) {
      var nodes = applyRule(rule);
      Array.prototype.push.apply(elementsIndex, nodes);
    }); // Now revert styles for elements which are no more affected

    var l = affectedElements.length; // do nothing if there is no elements to process

    if (elementsIndex.length > 0) {
      while (l--) {
        var obj = affectedElements[l];

        if (elementsIndex.indexOf(obj.node) === -1) {
          // Time to revert style
          revertStyle(obj);
          affectedElements.splice(l, 1);
        } else if (!obj.removed) {
          // Add style protection observer
          // Protect "style" attribute from changes
          if (!obj.protectionObserver) {
            obj.protectionObserver = protectStyleAttribute(obj.node, obj.rules);
          }
        }
      }
    } // After styles are applied we can start observe again


    observe();
    printTimingInfo();
  }

  var APPLY_RULES_DELAY = 150;
  var applyRulesScheduler = new utils.AsyncWrapper(applyRules, APPLY_RULES_DELAY);
  var mainCallback = applyRulesScheduler.run.bind(applyRulesScheduler);

  function observe() {
    if (domObserved) {
      return;
    } // Handle dynamically added elements


    domObserved = true;
    observeDocument(mainCallback);
  }

  function stopObserve() {
    if (!domObserved) {
      return;
    }

    domObserved = false;
    disconnectDocument(mainCallback);
  }

  function apply() {
    applyRules();

    if (document.readyState !== 'complete') {
      document.addEventListener('DOMContentLoaded', applyRules);
    }
  }
  /**
   * Disposes ExtendedCss and removes our styles from matched elements
   */


  function dispose() {
    stopObserve();
    affectedElements.forEach(function (obj) {
      revertStyle(obj);
    });
  }

  var timingsPrinted = false;
  /**
   * Prints timing information for all selectors marked as "debug"
   */

  function printTimingInfo() {
    if (timingsPrinted) {
      return;
    }

    timingsPrinted = true;
    var timings = rules.filter(function (rule) {
      return rule.selector.isDebugging();
    }).map(function (rule) {
      return {
        selectorText: rule.selector.selectorText,
        timingStats: rule.timingStats
      };
    });

    if (timings.length === 0) {
      return;
    } // Add location.href to the message to distinguish frames


    utils.logInfo('[ExtendedCss] Timings for %o:\n%o (in milliseconds)', window.location.href, timings);
  } // First of all parse the stylesheet


  rules = ExtendedCssParser.parseCss(styleSheet); // EXPOSE

  this.dispose = dispose;
  this.apply = apply;
  /** Exposed for testing purposes only */

  this._getAffectedElements = function () {
    return affectedElements;
  };
}
/**
 * Expose querySelectorAll for debugging and validating selectors
 *
 * @param {string} selectorText selector text
 * @param {boolean} noTiming if true -- do not print the timing to the console
 * @returns {Array<Node>|NodeList} a list of elements found
 * @throws Will throw an error if the argument is not a valid selector
 */


ExtendedCss.query = function (selectorText, noTiming) {
  if (typeof selectorText !== 'string') {
    throw new Error('Selector text is empty');
  }

  var now = utils.AsyncWrapper.now;
  var start = now();

  try {
    return ExtendedSelectorFactory.createSelector(selectorText).querySelectorAll();
  } finally {
    var end = now();

    if (!noTiming) {
      utils.logInfo("[ExtendedCss] Elapsed: ".concat(Math.round((end - start) * 1000), " \u03BCs."));
    }
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendedCss);


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js":
/*!************************************************************!*\
  !*** ./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js ***!
  \************************************************************/
/***/ ((module) => {


/**
 * AdGuard Scriptlets
 * Version 1.3.20
 */

/**
 * Returns wildcard symbol
 * @returns {string} '*'
 */
var getWildcardSymbol = function getWildcardSymbol() {
  return '*';
};

/**
 * Generate random six symbols id
 */
function randomId() {
  return Math.random().toString(36).substr(2, 9);
}

/**
 * Set getter and setter to property if it's configurable
 * @param {Object} object target object with property
 * @param {string} property property name
 * @param {Object} descriptor contains getter and setter functions
 * @returns {boolean} is operation successful
 */
function setPropertyAccess(object, property, descriptor) {
  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);

  if (currentDescriptor && !currentDescriptor.configurable) {
    return false;
  }

  Object.defineProperty(object, property, descriptor);
  return true;
}

/**
 * @typedef Chain
 * @property {Object} base
 * @property {string} prop
 * @property {string} [chain]
 */

/**
 * Check if the property exists in the base object (recursively)
 *
 * If property doesn't exist in base object,
 * defines this property as 'undefined'
 * and returns base, property name and remaining part of property chain
 *
 * @param {Object} base
 * @param {string} chain
 * @returns {Chain}
 */
function getPropertyInChain(base, chain) {
  var pos = chain.indexOf('.');

  if (pos === -1) {
    return {
      base: base,
      prop: chain
    };
  }

  var prop = chain.slice(0, pos); // https://github.com/AdguardTeam/Scriptlets/issues/128

  if (base === null) {
    // if base is null, return 'null' as base.
    // it's needed for triggering the reason logging while debugging
    return {
      base: base,
      prop: prop,
      chain: chain
    };
  }

  var nextBase = base[prop];
  chain = chain.slice(pos + 1);

  if (nextBase !== undefined) {
    return getPropertyInChain(nextBase, chain);
  }

  Object.defineProperty(base, prop, {
    configurable: true
  });
  return {
    base: nextBase,
    prop: prop,
    chain: chain
  };
}

/**
 * @typedef Chain
 * @property {Object} base
 * @property {string} prop
 * @property {string} [chain]
 */

/**
 * Check if the property exists in the base object (recursively).
 * Similar to getPropertyInChain but upgraded for json-prune:
 * handle wildcard properties and does not define nonexistent base property as 'undefined'
 *
 * @param {Object} base
 * @param {string} chain
 * @param {boolean} [lookThrough=false]
 * should the method look through it's props in order to wildcard
 * @param {Array} [output=[]] result acc
 * @returns {Chain[]} array of objects
 */

function getWildcardPropertyInChain(base, chain) {
  var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var pos = chain.indexOf('.');

  if (pos === -1) {
    // for paths like 'a.b.*' every final nested prop should be processed
    if (chain === getWildcardSymbol() || chain === '[]') {
      // eslint-disable-next-line no-restricted-syntax
      for (var key in base) {
        // to process each key in base except inherited ones
        if (Object.prototype.hasOwnProperty.call(base, key)) {
          output.push({
            base: base,
            prop: key
          });
        }
      }
    } else {
      output.push({
        base: base,
        prop: chain
      });
    }

    return output;
  }

  var prop = chain.slice(0, pos);
  var shouldLookThrough = prop === '[]' && Array.isArray(base) || prop === getWildcardSymbol() && base instanceof Object;

  if (shouldLookThrough) {
    var nextProp = chain.slice(pos + 1);
    var baseKeys = Object.keys(base); // if there is a wildcard prop in input chain (e.g. 'ad.*.src' for 'ad.0.src ad.1.src'),
    // each one of base keys should be considered as a potential chain prop in final path

    baseKeys.forEach(function (key) {
      var item = base[key];
      getWildcardPropertyInChain(item, nextProp, lookThrough, output);
    });
  }

  var nextBase = base[prop];
  chain = chain.slice(pos + 1);

  if (nextBase !== undefined) {
    getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
  }

  return output;
}

/**
 * Determines whether the passed value is NaN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
 * @param {*} num
 * @returns {boolean}
 */
var nativeIsNaN = function nativeIsNaN(num) {
  var native = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

  return native(num);
};
/**
 * Determines whether the passed value is a finite number
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite
 * @param {*} num
 * @returns {boolean}
 */

var nativeIsFinite = function nativeIsFinite(num) {
  var native = Number.isFinite || window.isFinite; // eslint-disable-line compat/compat

  return native(num);
};

/**
 * Converts object to array of pairs.
 * Object.entries() polyfill because it is not supported by IE
 * https://caniuse.com/?search=Object.entries
 * @param {Object} object
 * @returns {Array} array of pairs
 */
var getObjectEntries = function getObjectEntries(object) {
  var keys = Object.keys(object);
  var entries = [];
  keys.forEach(function (key) {
    return entries.push([key, object[key]]);
  });
  return entries;
};
/**
 * Converts array of pairs to object.
 * Object.fromEntries() polyfill because it is not supported by IE
 * https://caniuse.com/?search=Object.fromEntries
 * @param {Array} entries - array of pairs
 * @returns {Object}
 */

var getObjectFromEntries = function getObjectFromEntries(entries) {
  var output = entries.reduce(function (acc, el) {
    var key = el[0];
    var value = el[1];
    acc[key] = value;
    return acc;
  }, {});
  return output;
};
/**
 * Checks whether the obj is an empty object
 * @param {Object} obj
 * @returns {boolean}
 */

var isEmptyObject = function isEmptyObject(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * String.prototype.replaceAll polifill
 * @param {string} input input string
 * @param {string} substr to look for
 * @param {string} newSubstr replacement
 * @returns {string}
 */

var replaceAll = function replaceAll(input, substr, newSubstr) {
  return input.split(substr).join(newSubstr);
};
/**
 * Escapes special chars in string
 * @param {string} str
 * @returns {string}
 */

var escapeRegExp = function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};
/**
 * Converts search string to the regexp
 * TODO think about nested dependencies, but be careful with dependency loops
 * @param {string} str search string
 * @returns {RegExp}
 */

var toRegExp = function toRegExp(str) {
  if (!str || str === '') {
    var DEFAULT_VALUE = '.?';
    return new RegExp(DEFAULT_VALUE);
  }

  if (str[0] === '/' && str[str.length - 1] === '/') {
    return new RegExp(str.slice(1, -1));
  }

  var escaped = str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  return new RegExp(escaped);
};
/**
 * Get string before regexp first match
 * @param {string} str
 * @param {RegExp} rx
 */

var getBeforeRegExp = function getBeforeRegExp(str, rx) {
  var index = str.search(rx);
  return str.substring(0, index);
};
/**
 * Checks whether the string starts with the substring
 * @param {string} str full string
 * @param {string} prefix substring
 * @returns {boolean}
 */

var startsWith = function startsWith(str, prefix) {
  // if str === '', (str && false) will return ''
  // that's why it has to be !!str
  return !!str && str.indexOf(prefix) === 0;
};
/**
 * Checks whether the string ends with the substring
 * @param {string} str full string
 * @param {string} ending substring
 * @returns {boolean}
 */

var endsWith = function endsWith(str, ending) {
  // if str === '', (str && false) will return ''
  // that's why it has to be !!str
  return !!str && str.indexOf(ending) === str.length - ending.length;
};
var substringAfter = function substringAfter(str, separator) {
  if (!str) {
    return str;
  }

  var index = str.indexOf(separator);
  return index < 0 ? '' : str.substring(index + separator.length);
};
var substringBefore = function substringBefore(str, separator) {
  if (!str || !separator) {
    return str;
  }

  var index = str.indexOf(separator);
  return index < 0 ? str : str.substring(0, index);
};
/**
 * Wrap str in single qoutes and replaces single quotes to doudle one
 * @param {string} str
 */

var wrapInSingleQuotes = function wrapInSingleQuotes(str) {
  if (str[0] === '\'' && str[str.length - 1] === '\'' || str[0] === '"' && str[str.length - 1] === '"') {
    str = str.substring(1, str.length - 1);
  } // eslint-disable-next-line no-useless-escape


  str = str.replace(/\'/g, '"');
  return "'".concat(str, "'");
};
/**
 * Returns substring enclosed in the widest braces
 * @param {string} str
 */

var getStringInBraces = function getStringInBraces(str) {
  var firstIndex = str.indexOf('(');
  var lastIndex = str.lastIndexOf(')');
  return str.substring(firstIndex + 1, lastIndex);
};
/**
 * Prepares RTCPeerConnection config as string for proper logging
 * @param {*} config
 * @returns {string} stringified config
*/

var convertRtcConfigToString = function convertRtcConfigToString(config) {
  var UNDEF_STR = 'undefined';
  var str = UNDEF_STR;

  if (config === null) {
    str = 'null';
  } else if (config instanceof Object) {
    var SERVERS_PROP_NAME = 'iceServers';
    var URLS_PROP_NAME = 'urls';
    /*
        const exampleConfig = {
            'iceServers': [
                'urls': ['stun:35.66.206.188:443'],
            ],
        };
    */

    if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {
      str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();
    }
  }

  return str;
};
/**
 * @typedef {Object} MatchData
 * @property {boolean} isInvertedMatch
 * @property {RegExp} matchRegexp
 */

/**
 * Parses match arg with possible negation for no matching.
 * Needed for prevent-setTimeout, prevent-setInterval,
 * prevent-requestAnimationFrame and prevent-window-open
 * @param {string} match
 * @returns {MatchData}
 */

var parseMatchArg = function parseMatchArg(match) {
  var INVERT_MARKER = '!';
  var isInvertedMatch = startsWith(match, INVERT_MARKER);
  var matchValue = isInvertedMatch ? match.slice(1) : match;
  var matchRegexp = toRegExp(matchValue);
  return {
    isInvertedMatch: isInvertedMatch,
    matchRegexp: matchRegexp
  };
};
/**
 * @typedef {Object} DelayData
 * @property {boolean} isInvertedDelayMatch
 * @property {number|null} delayMatch
 */

/**
 * Parses delay arg with possible negation for no matching.
 * Needed for prevent-setTimeout and prevent-setInterval
 * @param {string} delay
 * @returns {DelayData}
 */

var parseDelayArg = function parseDelayArg(delay) {
  var INVERT_MARKER = '!';
  var isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);
  var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;
  delayValue = parseInt(delayValue, 10);
  var delayMatch = nativeIsNaN(delayValue) ? null : delayValue;
  return {
    isInvertedDelayMatch: isInvertedDelayMatch,
    delayMatch: delayMatch
  };
};
/**
 * Converts object to string for logging
 * @param {Object} obj data object
 * @returns {string}
 */

var objectToString = function objectToString(obj) {
  return isEmptyObject(obj) ? '{}' : getObjectEntries(obj).map(function (pair) {
    var key = pair[0];
    var value = pair[1];
    var recordValueStr = value;

    if (value instanceof Object) {
      recordValueStr = "{ ".concat(objectToString(value), " }");
    }

    return "".concat(key, ":\"").concat(recordValueStr, "\"");
  }).join(' ');
};
/**
 * Converts types into a string
 * @param {*} value
 * @returns {string}
 */

var convertTypeToString = function convertTypeToString(value) {
  var output;

  if (typeof value === 'undefined') {
    output = 'undefined';
  } else if (typeof value === 'object') {
    if (value === null) {
      output = 'null';
    } else {
      output = objectToString(value);
    }
  } else {
    output = value.toString();
  }

  return output;
};

/**
 * Generates function which silents global errors on page generated by scriptlet
 * If error doesn't belong to our error we transfer it to the native onError handler
 * @param {string} rid - unique identifier of scriptlet
 * @return {onError}
 */
function createOnErrorHandler(rid) {
  // eslint-disable-next-line consistent-return
  var nativeOnError = window.onerror;
  return function onError(error) {
    if (typeof error === 'string' && error.indexOf(rid) !== -1) {
      return true;
    }

    if (nativeOnError instanceof Function) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return nativeOnError.apply(this, [error].concat(args));
    }

    return false;
  };
}

/**
 * Noop function
 * @return {undefined} undefined
 */
var noopFunc = function noopFunc() {};
/**
 * Function returns null
 * @return {null} null
 */

var noopNull = function noopNull() {
  return null;
};
/**
 * Function returns true
 * @return {boolean} true
 */

var trueFunc = function trueFunc() {
  return true;
};
/**
 * Function returns false
 * @return {boolean} false
 */

var falseFunc = function falseFunc() {
  return false;
};
/**
 * Function returns this
 */

function noopThis() {
  return this;
}
/**
 * Function returns empty string
 * @return {string} empty string
 */

var noopStr = function noopStr() {
  return '';
};
/**
 * Function returns empty array
 * @return {Array} empty array
 */

var noopArray = function noopArray() {
  return [];
};
/**
 * Function returns empty object
 * @return {Object} empty object
 */

var noopObject = function noopObject() {
  return {};
};
/**
 * Function returns Promise.reject()
 */

var noopPromiseReject = function noopPromiseReject() {
  return Promise.reject();
}; // eslint-disable-line compat/compat

/**
 * Returns Promise object that is resolved with an empty response
 */
// eslint-disable-next-line compat/compat

var noopPromiseResolve = function noopPromiseResolve() {
  return Promise.resolve(new Response());
};

/* eslint-disable no-console, no-underscore-dangle */

/**
 * Hit used only for debug purposes now
 * @param {Source} source
 * @param {string} [message] - optional message;
 * use LOG_MARKER = 'log: ' at the start of a message
 * for logging scriptlets
 */
var hit = function hit(source, message) {
  if (source.verbose !== true) {
    return;
  }

  try {
    var log = console.log.bind(console);
    var trace = console.trace.bind(console); // eslint-disable-line compat/compat

    var prefix = source.ruleText || '';

    if (source.domainName) {
      var AG_SCRIPTLET_MARKER = '#%#//';
      var UBO_SCRIPTLET_MARKER = '##+js';
      var ruleStartIndex;

      if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
        ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
      } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
        ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
      } // delete all domains from ruleText and leave just rule part


      var rulePart = source.ruleText.slice(ruleStartIndex); // prepare applied scriptlet rule for specific domain

      prefix = "".concat(source.domainName).concat(rulePart);
    } // Used to check if scriptlet uses 'hit' function for logging


    var LOG_MARKER = 'log: ';

    if (message) {
      if (message.indexOf(LOG_MARKER) === -1) {
        log("".concat(prefix, " message:\n").concat(message));
      } else {
        log(message.slice(LOG_MARKER.length));
      }
    }

    log("".concat(prefix, " trace start"));

    if (trace) {
      trace();
    }

    log("".concat(prefix, " trace end"));
  } catch (e) {// try catch for Edge 15
    // In according to this issue https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14495220/
    // console.log throws an error
  } // This is necessary for unit-tests only!


  if (typeof window.__debug === 'function') {
    window.__debug(source);
  }
};

/**
 * DOM tree changes observer. Used for 'remove-attr' and 'remove-class' scriptlets
 * @param {Function} callback
 * @param {Boolean} observeAttrs - optional parameter - should observer check attibutes changes
 */
var observeDOMChanges = function observeDOMChanges(callback) {
  var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var attrsToObserv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  /**
   * Returns a wrapper, passing the call to 'method' at maximum once per 'delay' milliseconds.
   * Those calls that fall into the "cooldown" period, are ignored
   * @param {Function} method
   * @param {Number} delay - milliseconds
   */
  var throttle = function throttle(method, delay) {
    var wait = false;
    var savedArgs;

    var wrapper = function wrapper() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (wait) {
        savedArgs = args;
        return;
      }

      method.apply(void 0, args);
      wait = true;
      setTimeout(function () {
        wait = false;

        if (savedArgs) {
          wrapper(savedArgs);
          savedArgs = null;
        }
      }, delay);
    };

    return wrapper;
  };
  /**
   * 'delay' in milliseconds for 'throttle' method
   */


  var THROTTLE_DELAY_MS = 20;
  /**
   * Used for remove-class
   */
  // eslint-disable-next-line no-use-before-define, compat/compat

  var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));

  var connect = function connect() {
    if (attrsToObserv.length > 0) {
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true,
        attributes: observeAttrs,
        attributeFilter: attrsToObserv
      });
    } else {
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true,
        attributes: observeAttrs
      });
    }
  };

  var disconnect = function disconnect() {
    observer.disconnect();
  };

  function callbackWrapper() {
    disconnect();
    callback();
    connect();
  }

  connect();
};

/**
 * Checks if the stackTrace contains stackRegexp
 * // https://github.com/AdguardTeam/Scriptlets/issues/82
 * @param {string|undefined} stackMatch - input stack value to match
 * @param {string} stackTrace - script error stack trace
 * @returns {boolean}
 */

var matchStackTrace = function matchStackTrace(stackMatch, stackTrace) {
  if (!stackMatch || stackMatch === '') {
    return true;
  }

  var stackRegexp = toRegExp(stackMatch);
  var refinedStackTrace = stackTrace.split('\n').slice(2) // get rid of our own functions in the stack trace
  .map(function (line) {
    return line.trim();
  }) // trim the lines
  .join('\n');
  return stackRegexp.test(refinedStackTrace);
};

/**
 * Some browsers do not support Array.prototype.flat()
 * for example, Opera 42 which is used for browserstack tests
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
 * @param {Array} input
 */
var flatten = function flatten(input) {
  var stack = [];
  input.forEach(function (el) {
    return stack.push(el);
  });
  var res = [];

  while (stack.length) {
    // pop value from stack
    var next = stack.pop();

    if (Array.isArray(next)) {
      // push back array items, won't modify the original input
      next.forEach(function (el) {
        return stack.push(el);
      });
    } else {
      res.push(next);
    }
  } // reverse to restore input order


  return res.reverse();
};

/**
 * Finds shadow-dom host (elements with shadowRoot property) in DOM of rootElement.
 * @param {HTMLElement} rootElement
 * @returns {HTMLElement[]} shadow-dom hosts
 */

var findHostElements = function findHostElements(rootElement) {
  var hosts = []; // Element.querySelectorAll() returns list of elements
  // which are defined in DOM of Element.
  // Meanwhile, inner DOM of the element with shadowRoot property
  // is absolutely another DOM and which can not be reached by querySelectorAll('*')

  var domElems = rootElement.querySelectorAll('*');
  domElems.forEach(function (el) {
    if (el.shadowRoot) {
      hosts.push(el);
    }
  });
  return hosts;
};
/**
 * A collection of nodes.
 *
 * @external NodeList
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/NodeList NodeList}
 */

/**
 * @typedef {Object} PierceData
 * @property {HTMLElement[]} targets found elements that match the specified selector
 * @property {HTMLElement[]} innerHosts inner shadow-dom hosts
 */

/**
 * Pierces open shadow-dom in order to find:
 * - elements by 'selector' matching
 * - inner shadow-dom hosts
 * @param {string} selector
 * @param {HTMLElement[]|external:NodeList} hostElements
 * @returns {PierceData}
 */

var pierceShadowDom = function pierceShadowDom(selector, hostElements) {
  var targets = [];
  var innerHostsAcc = []; // it's possible to get a few hostElements found by baseSelector on the page

  hostElements.forEach(function (host) {
    // check presence of selector element inside base element if it's not in shadow-dom
    var simpleElems = host.querySelectorAll(selector);
    targets = targets.concat([].slice.call(simpleElems));
    var shadowRootElem = host.shadowRoot;
    var shadowChildren = shadowRootElem.querySelectorAll(selector);
    targets = targets.concat([].slice.call(shadowChildren)); // find inner shadow-dom hosts inside processing shadow-dom

    innerHostsAcc.push(findHostElements(shadowRootElem));
  }); // if there were more than one host element,
  // innerHostsAcc is an array of arrays and should be flatten

  var innerHosts = flatten(innerHostsAcc);
  return {
    targets: targets,
    innerHosts: innerHosts
  };
};

/**
 * Prepares cookie string if given parameters are ok
 * @param {string} name cookie name to set
 * @param {string} value cookie value to set
 * @returns {string|null} cookie string if ok OR null if not
 */

var prepareCookie = function prepareCookie(name, value) {
  if (!name || !value) {
    return null;
  }

  var valueToSet;

  if (value === 'true') {
    valueToSet = 'true';
  } else if (value === 'True') {
    valueToSet = 'True';
  } else if (value === 'false') {
    valueToSet = 'false';
  } else if (value === 'False') {
    valueToSet = 'False';
  } else if (value === 'yes') {
    valueToSet = 'yes';
  } else if (value === 'Yes') {
    valueToSet = 'Yes';
  } else if (value === 'Y') {
    valueToSet = 'Y';
  } else if (value === 'no') {
    valueToSet = 'no';
  } else if (value === 'ok') {
    valueToSet = 'ok';
  } else if (value === 'OK') {
    valueToSet = 'OK';
  } else if (/^\d+$/.test(value)) {
    valueToSet = parseFloat(value);

    if (nativeIsNaN(valueToSet)) {
      return null;
    }

    if (Math.abs(valueToSet) < 0 || Math.abs(valueToSet) > 15) {
      return null;
    }
  } else {
    return null;
  }

  var pathToSet = 'path=/;';
  var cookieData = "".concat(encodeURIComponent(name), "=").concat(encodeURIComponent(valueToSet), "; ").concat(pathToSet);
  return cookieData;
};

var shouldMatchAnyDelay = function shouldMatchAnyDelay(delay) {
  return delay === getWildcardSymbol();
};
/**
 * Handles input delay value
 * @param {*} delay
 * @returns {number} proper number delay value
 */

var getMatchDelay = function getMatchDelay(delay) {
  var DEFAULT_DELAY = 1000;
  var parsedDelay = parseInt(delay, 10);
  var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY // default scriptlet value
  : parsedDelay;
  return delayMatch;
};
/**
 * Checks delay match condition
 * @param {*} inputDelay
 * @param {number} realDelay
 * @returns {boolean}
 */

var isDelayMatched = function isDelayMatched(inputDelay, realDelay) {
  return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);
};
/**
 * Handles input boost value
 * @param {*} boost
 * @returns {number} proper number boost multiplier value
 */

var getBoostMultiplier = function getBoostMultiplier(boost) {
  var DEFAULT_MULTIPLIER = 0.05;
  var MIN_MULTIPLIER = 0.02;
  var MAX_MULTIPLIER = 50;
  var parsedBoost = parseFloat(boost);
  var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER // default scriptlet value
  : parsedBoost;

  if (boostMultiplier < MIN_MULTIPLIER) {
    boostMultiplier = MIN_MULTIPLIER;
  }

  if (boostMultiplier > MAX_MULTIPLIER) {
    boostMultiplier = MAX_MULTIPLIER;
  }

  return boostMultiplier;
};

/**
 * Collects Request options to object
 * @param {Request} request
 * @returns {Object} data object
 */

var getRequestData = function getRequestData(request) {
  var REQUEST_INIT_OPTIONS = ['url', 'method', 'headers', 'body', 'mode', 'credentials', 'cache', 'redirect', 'referrer', 'integrity'];
  var entries = REQUEST_INIT_OPTIONS.map(function (key) {
    // if request has no such option, value will be undefined
    var value = request[key];
    return [key, value];
  });
  return getObjectFromEntries(entries);
};
/**
 * Collects fetch args to object
 * @param {*} args fetch args
 * @returns {Object} data object
 */

var getFetchData = function getFetchData(args) {
  var fetchPropsObj = {};
  var fetchUrl;
  var fetchInit;

  if (args[0] instanceof Request) {
    // if Request passed to fetch, it will be in array
    var requestData = getRequestData(args[0]);
    fetchUrl = requestData.url;
    fetchInit = requestData;
  } else {
    fetchUrl = args[0]; // eslint-disable-line prefer-destructuring

    fetchInit = args[1]; // eslint-disable-line prefer-destructuring
  }

  fetchPropsObj.url = fetchUrl;

  if (fetchInit instanceof Object) {
    Object.keys(fetchInit).forEach(function (prop) {
      fetchPropsObj[prop] = fetchInit[prop];
    });
  }

  return fetchPropsObj;
};
/**
 * Converts prevent-fetch propsToMatch input string to object
 * @param {string} propsToMatchStr
 * @returns {Object} object where 'key' is prop name and 'value' is prop value
 */

var convertMatchPropsToObj = function convertMatchPropsToObj(propsToMatchStr) {
  var PROPS_DIVIDER = ' ';
  var PAIRS_MARKER = ':';
  var propsObj = {};
  var props = propsToMatchStr.split(PROPS_DIVIDER);
  props.forEach(function (prop) {
    var dividerInd = prop.indexOf(PAIRS_MARKER);

    if (dividerInd === -1) {
      propsObj.url = toRegExp(prop);
    } else {
      var key = prop.slice(0, dividerInd);
      var value = prop.slice(dividerInd + 1);
      propsObj[key] = toRegExp(value);
    }
  });
  return propsObj;
};

var handleOldReplacement = function handleOldReplacement(replacement) {
  var result; // defaults to return noopFunc instead of window.open

  if (!replacement) {
    result = noopFunc;
  } else if (replacement === 'trueFunc') {
    result = trueFunc;
  } else if (replacement.indexOf('=') > -1) {
    // We should return noopFunc instead of window.open
    // but with some property if website checks it (examples 5, 6)
    // https://github.com/AdguardTeam/Scriptlets/issues/71
    var isProp = startsWith(replacement, '{') && endsWith(replacement, '}');

    if (isProp) {
      var propertyPart = replacement.slice(1, -1);
      var propertyName = substringBefore(propertyPart, '=');
      var propertyValue = substringAfter(propertyPart, '=');

      if (propertyValue === 'noopFunc') {
        result = {};
        result[propertyName] = noopFunc;
      }
    }
  }

  return result;
};
var createDecoy = function createDecoy(args) {
  var OBJECT_TAG_NAME = 'object';
  var OBJECT_URL_PROP_NAME = 'data';
  var IFRAME_TAG_NAME = 'iframe';
  var IFRAME_URL_PROP_NAME = 'src';
  var replacement = args.replacement,
      url = args.url,
      delay = args.delay;
  var tag;
  var urlProp;

  if (replacement === 'obj') {
    tag = OBJECT_TAG_NAME;
    urlProp = OBJECT_URL_PROP_NAME;
  } else {
    tag = IFRAME_TAG_NAME;
    urlProp = IFRAME_URL_PROP_NAME;
  }

  var decoy = document.createElement(tag);
  decoy[urlProp] = url;
  decoy.style.setProperty('height', '1px', 'important');
  decoy.style.setProperty('position', 'fixed', 'important');
  decoy.style.setProperty('top', '-1px', 'important');
  decoy.style.setProperty('width', '1px', 'important');
  document.body.appendChild(decoy);
  setTimeout(function () {
    return decoy.remove();
  }, delay * 1000);
  return decoy;
};
var getPreventGetter = function getPreventGetter(nativeGetter) {
  var preventGetter = function preventGetter(target, prop) {
    if (prop && prop === 'closed') {
      return false;
    }

    if (typeof nativeGetter === 'function') {
      return noopFunc;
    }

    return prop && target[prop];
  };

  return preventGetter;
};

/**
 * Validates event type
 * @param {*} type
 * @returns {boolean}
 */
var validateType = function validateType(type) {
  // https://github.com/AdguardTeam/Scriptlets/issues/125
  return typeof type !== 'undefined';
};
/**
 * Validates event listener
 * @param {*} listener
 * @returns {boolean}
 */

var validateListener = function validateListener(listener) {
  // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters
  return typeof listener !== 'undefined' && (typeof listener === 'function' || typeof listener === 'object' // https://github.com/AdguardTeam/Scriptlets/issues/76
  && listener !== null && typeof listener.handleEvent === 'function');
};
/**
 * Serialize valid event listener
 * https://developer.mozilla.org/en-US/docs/Web/API/EventListener
 * @param {EventListener} listener valid listener
 * @returns {string}
 */

var listenerToString = function listenerToString(listener) {
  return typeof listener === 'function' ? listener.toString() : listener.handleEvent.toString();
};

/**
 * This file must export all used dependencies
 */

var dependencies = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getWildcardSymbol: getWildcardSymbol,
    randomId: randomId,
    setPropertyAccess: setPropertyAccess,
    getPropertyInChain: getPropertyInChain,
    getWildcardPropertyInChain: getWildcardPropertyInChain,
    replaceAll: replaceAll,
    escapeRegExp: escapeRegExp,
    toRegExp: toRegExp,
    getBeforeRegExp: getBeforeRegExp,
    startsWith: startsWith,
    endsWith: endsWith,
    substringAfter: substringAfter,
    substringBefore: substringBefore,
    wrapInSingleQuotes: wrapInSingleQuotes,
    getStringInBraces: getStringInBraces,
    convertRtcConfigToString: convertRtcConfigToString,
    parseMatchArg: parseMatchArg,
    parseDelayArg: parseDelayArg,
    objectToString: objectToString,
    convertTypeToString: convertTypeToString,
    createOnErrorHandler: createOnErrorHandler,
    noopFunc: noopFunc,
    noopNull: noopNull,
    trueFunc: trueFunc,
    falseFunc: falseFunc,
    noopThis: noopThis,
    noopStr: noopStr,
    noopArray: noopArray,
    noopObject: noopObject,
    noopPromiseReject: noopPromiseReject,
    noopPromiseResolve: noopPromiseResolve,
    hit: hit,
    observeDOMChanges: observeDOMChanges,
    matchStackTrace: matchStackTrace,
    findHostElements: findHostElements,
    pierceShadowDom: pierceShadowDom,
    flatten: flatten,
    prepareCookie: prepareCookie,
    nativeIsNaN: nativeIsNaN,
    nativeIsFinite: nativeIsFinite,
    shouldMatchAnyDelay: shouldMatchAnyDelay,
    getMatchDelay: getMatchDelay,
    isDelayMatched: isDelayMatched,
    getBoostMultiplier: getBoostMultiplier,
    getRequestData: getRequestData,
    getFetchData: getFetchData,
    convertMatchPropsToObj: convertMatchPropsToObj,
    getObjectEntries: getObjectEntries,
    getObjectFromEntries: getObjectFromEntries,
    isEmptyObject: isEmptyObject,
    handleOldReplacement: handleOldReplacement,
    createDecoy: createDecoy,
    getPreventGetter: getPreventGetter,
    validateType: validateType,
    validateListener: validateListener,
    listenerToString: listenerToString
});

/**
 * Concat dependencies to scriptlet code
 * @param {string} scriptlet string view of scriptlet
 */

function attachDependencies(scriptlet) {
  var _scriptlet$injections = scriptlet.injections,
      injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;
  return injections.reduce(function (accum, dep) {
    return "".concat(accum, "\n").concat(dependencies[dep.name]);
  }, scriptlet.toString());
}
/**
 * Add scriptlet call to existing code
 * @param {Function} scriptlet
 * @param {string} code
 */

function addCall(scriptlet, code) {
  return "".concat(code, ";\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        ").concat(scriptlet.name, ".apply(this, updatedArgs);\n    ");
}
/**
 * Wrap function into IIFE (Immediately invoked function expression)
 *
 * @param {Source} source - object with scriptlet properties
 * @param {string} code - scriptlet source code with dependencies
 *
 * @returns {string} full scriptlet code
 *
 * @example
 * const source = {
 *      args: ["aaa", "bbb"],
 *      name: 'noeval',
 * };
 * const code = "function noeval(source, args) { alert(source); } noeval.apply(this, args);"
 * const result = wrapInIIFE(source, code);
 *
 * // result
 * `(function(source, args) {
 *      function noeval(source) { alert(source); }
 *      noeval.apply(this, args);
 * )({"args": ["aaa", "bbb"], "name":"noeval"}, ["aaa", "bbb"])`
 */

function passSourceAndProps(source, code) {
  if (source.hit) {
    source.hit = source.hit.toString();
  }

  var sourceString = JSON.stringify(source);
  var argsString = source.args ? "[".concat(source.args.map(JSON.stringify), "]") : undefined;
  var params = argsString ? "".concat(sourceString, ", ").concat(argsString) : sourceString;
  return "(function(source, args){\n".concat(code, "\n})(").concat(params, ");");
}
/**
 * Wrap code in no name function
 * @param {string} code which must be wrapped
 */

function wrapInNonameFunc(code) {
  return "function(source, args){\n".concat(code, "\n}");
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

/**
 * Iterate over iterable argument and evaluate current state with transitions
 * @param {string} init first transition name
 * @param {Array|Collection|string} iterable
 * @param {Object} transitions transtion functions
 * @param {any} args arguments which should be passed to transition functions
 */
function iterateWithTransitions(iterable, transitions, init, args) {
  var state = init || Object.keys(transitions)[0];

  for (var i = 0; i < iterable.length; i += 1) {
    state = transitions[state](iterable, i, args);
  }

  return state;
}
/**
 * AdGuard scriptlet rule mask
 */


var ADG_SCRIPTLET_MASK = '#//scriptlet';
/**
 * Helper to accumulate an array of strings char by char
 */

var wordSaver = function wordSaver() {
  var str = '';
  var strs = [];

  var saveSymb = function saveSymb(s) {
    str += s;
    return str;
  };

  var saveStr = function saveStr() {
    strs.push(str);
    str = '';
  };

  var getAll = function getAll() {
    return [].concat(strs);
  };

  return {
    saveSymb: saveSymb,
    saveStr: saveStr,
    getAll: getAll
  };
};

var substringAfter$1 = function substringAfter(str, separator) {
  if (!str) {
    return str;
  }

  var index = str.indexOf(separator);
  return index < 0 ? '' : str.substring(index + separator.length);
};
/**
 * Parse and validate scriptlet rule
 * @param {*} ruleText
 * @returns {{name: string, args: Array<string>}}
 */


var parseRule = function parseRule(ruleText) {
  var _transitions;

  ruleText = substringAfter$1(ruleText, ADG_SCRIPTLET_MASK);
  /**
   * Transition names
   */

  var TRANSITION = {
    OPENED: 'opened',
    PARAM: 'param',
    CLOSED: 'closed'
  };
  /**
   * Transition function: the current index position in start, end or between params
   * @param {string} rule
   * @param {number} index
   * @param {Object} Object
   * @property {Object} Object.sep contains prop symb with current separator char
   */

  var opened = function opened(rule, index, _ref) {
    var sep = _ref.sep;
    var char = rule[index];
    var transition;

    switch (char) {
      case ' ':
      case '(':
      case ',':
        {
          transition = TRANSITION.OPENED;
          break;
        }

      case '\'':
      case '"':
        {
          sep.symb = char;
          transition = TRANSITION.PARAM;
          break;
        }

      case ')':
        {
          transition = index === rule.length - 1 ? TRANSITION.CLOSED : TRANSITION.OPENED;
          break;
        }

      default:
        {
          throw new Error('The rule is not a scriptlet');
        }
    }

    return transition;
  };
  /**
   * Transition function: the current index position inside param
   * @param {string} rule
   * @param {number} index
   * @param {Object} Object
   * @property {Object} Object.sep contains prop `symb` with current separator char
   * @property {Object} Object.saver helper which allow to save strings by car by char
   */


  var param = function param(rule, index, _ref2) {
    var saver = _ref2.saver,
        sep = _ref2.sep;
    var char = rule[index];

    switch (char) {
      case '\'':
      case '"':
        {
          var preIndex = index - 1;
          var before = rule[preIndex];

          if (char === sep.symb && before !== '\\') {
            sep.symb = null;
            saver.saveStr();
            return TRANSITION.OPENED;
          }
        }
      // eslint-disable-next-line no-fallthrough

      default:
        {
          saver.saveSymb(char);
          return TRANSITION.PARAM;
        }
    }
  };

  var transitions = (_transitions = {}, defineProperty(_transitions, TRANSITION.OPENED, opened), defineProperty(_transitions, TRANSITION.PARAM, param), defineProperty(_transitions, TRANSITION.CLOSED, function () {}), _transitions);
  var sep = {
    symb: null
  };
  var saver = wordSaver();
  var state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, {
    sep: sep,
    saver: saver
  });

  if (state !== 'closed') {
    throw new Error("Invalid scriptlet rule ".concat(ruleText));
  }

  var args = saver.getAll();
  return {
    name: args[0],
    args: args.slice(1)
  };
};

/* eslint-disable max-len */

/**
 * @scriptlet abort-on-property-read
 *
 * @description
 * Aborts a script when it attempts to **read** the specified property.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-readjs-
 *
 * Related ABP source:
 * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L864
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('abort-on-property-read', property[, stack])
 * ```
 *
 * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`
 * - `stack` - optional, string or regular expression that must match the current function call stack trace
 *
 * **Examples**
 * ```
 * ! Aborts script when it tries to access `window.alert`
 * example.org#%#//scriptlet('abort-on-property-read', 'alert')
 *
 * ! Aborts script when it tries to access `navigator.language`
 * example.org#%#//scriptlet('abort-on-property-read', 'navigator.language')
 *
 * ! Aborts script when it tries to access `window.adblock` and it's error stack trace contains `test.js`
 * example.org#%#//scriptlet('abort-on-property-read', 'adblock', 'test.js')
 * ```
 */

/* eslint-enable max-len */

function abortOnPropertyRead(source, property, stack) {
  if (!property || !matchStackTrace(stack, new Error().stack)) {
    return;
  }

  var rid = randomId();

  var abort = function abort() {
    hit(source);
    throw new ReferenceError(rid);
  };

  var setChainPropAccess = function setChainPropAccess(owner, property) {
    var chainInfo = getPropertyInChain(owner, property);
    var base = chainInfo.base;
    var prop = chainInfo.prop,
        chain = chainInfo.chain;

    if (chain) {
      var setter = function setter(a) {
        base = a;

        if (a instanceof Object) {
          setChainPropAccess(a, chain);
        }
      };

      Object.defineProperty(owner, prop, {
        get: function get() {
          return base;
        },
        set: setter
      });
      return;
    }

    setPropertyAccess(base, prop, {
      get: abort,
      set: function set() {}
    });
  };

  setChainPropAccess(window, property);
  window.onerror = createOnErrorHandler(rid).bind();
}
abortOnPropertyRead.names = ['abort-on-property-read', // aliases are needed for matching the related scriptlet converted into our syntax
'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'ubo-abort-on-property-read', 'ubo-aopr', 'abp-abort-on-property-read'];
abortOnPropertyRead.injections = [randomId, toRegExp, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, matchStackTrace];

/* eslint-disable max-len */

/**
 * @scriptlet abort-on-property-write
 *
 * @description
 * Aborts a script when it attempts to **write** the specified property.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-writejs-
 *
 * Related ABP source:
 * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L896
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('abort-on-property-write', property[, stack])
 * ```
 *
 * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`
 * - `stack` - optional, string or regular expression that must match the current function call stack trace
 *
 * **Examples**
 * ```
 * ! Aborts script when it tries to set `window.adblock` value
 * example.org#%#//scriptlet('abort-on-property-write', 'adblock')
 *
 * ! Aborts script when it tries to set `window.adblock` value and it's error stack trace contains `checking.js`
 * example.org#%#//scriptlet('abort-on-property-write', 'adblock', 'checking.js')
 * ```
 */

/* eslint-enable max-len */

function abortOnPropertyWrite(source, property, stack) {
  if (!property || !matchStackTrace(stack, new Error().stack)) {
    return;
  }

  var rid = randomId();

  var abort = function abort() {
    hit(source);
    throw new ReferenceError(rid);
  };

  var setChainPropAccess = function setChainPropAccess(owner, property) {
    var chainInfo = getPropertyInChain(owner, property);
    var base = chainInfo.base;
    var prop = chainInfo.prop,
        chain = chainInfo.chain;

    if (chain) {
      var setter = function setter(a) {
        base = a;

        if (a instanceof Object) {
          setChainPropAccess(a, chain);
        }
      };

      Object.defineProperty(owner, prop, {
        get: function get() {
          return base;
        },
        set: setter
      });
      return;
    }

    setPropertyAccess(base, prop, {
      set: abort
    });
  };

  setChainPropAccess(window, property);
  window.onerror = createOnErrorHandler(rid).bind();
}
abortOnPropertyWrite.names = ['abort-on-property-write', // aliases are needed for matching the related scriptlet converted into our syntax
'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'ubo-abort-on-property-write', 'ubo-aopw', 'abp-abort-on-property-write'];
abortOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace];

/* eslint-disable max-len */

/**
 * @scriptlet prevent-setTimeout
 *
 * @description
 * Prevents a `setTimeout` call if:
 * 1) the text of the callback is matching the specified search string/regexp which does not start with `!`;
 * otherwise mismatched calls should be defused;
 * 2) the timeout is matching the specified delay; otherwise mismatched calls should be defused.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-settimeout-ifjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-setTimeout'[, search[, delay]])
 * ```
 *
 * Call with no arguments will log calls to setTimeout while debugging (`log-setTimeout` superseding),
 * so production filter lists' rules definitely require at least one of the parameters:
 * - `search` - optional, string or regular expression.
 * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
 * If do not start with `!`, the stringified callback will be matched.
 * If not set, prevents all `setTimeout` calls due to specified `delay`.
 * - `delay` - optional, must be an integer.
 * If starts with `!`, scriptlet will not match the delay but all other will be defused.
 * If do not start with `!`, the delay passed to the `setTimeout` call will be matched.
 *
 * > If `prevent-setTimeout` without parameters logs smth like `setTimeout(undefined, 1000)`,
 * it means that no callback was passed to setTimeout() and that's not scriptlet issue
 *
 * **Examples**
 * 1. Prevents `setTimeout` calls if the callback matches `/\.test/` regardless of the delay.
 *     ```bash
 *     example.org#%#//scriptlet('prevent-setTimeout', '/\.test/')
 *     ```
 *
 *     For instance, the following call will be prevented:
 *     ```javascript
 *     setTimeout(function () {
 *         window.test = "value";
 *     }, 100);
 *     ```
 *
 * 2. Prevents `setTimeout` calls if the callback does not contain `value`.
 *     ```
 *     example.org#%#//scriptlet('prevent-setTimeout', '!value')
 *     ```
 *
 *     For instance, only the first of the following calls will be prevented:
 *     ```javascript
 *     setTimeout(function () {
 *         window.test = "test -- prevented";
 *     }, 300);
 *     setTimeout(function () {
 *         window.test = "value -- executed";
 *     }, 400);
 *     setTimeout(function () {
 *         window.value = "test -- executed";
 *     }, 500);
 *     ```
 *
 * 3. Prevents `setTimeout` calls if the callback contains `value` and the delay is not set to `300`.
 *     ```
 *     example.org#%#//scriptlet('prevent-setTimeout', 'value', '!300')
 *     ```
 *
 *     For instance, only the first of the following calls will not be prevented:
 *     ```javascript
 *     setTimeout(function () {
 *         window.test = "value 1 -- executed";
 *     }, 300);
 *     setTimeout(function () {
 *         window.test = "value 2 -- prevented";
 *     }, 400);
 *     setTimeout(function () {
 *         window.test = "value 3 -- prevented";
 *     }, 500);
 *     ```
 *
 * 4. Prevents `setTimeout` calls if the callback does not contain `value` and the delay is not set to `300`.
 *     ```
 *     example.org#%#//scriptlet('prevent-setTimeout', '!value', '!300')
 *     ```
 *
 *     For instance, only the second of the following calls will be prevented:
 *     ```javascript
 *     setTimeout(function () {
 *         window.test = "test -- executed";
 *     }, 300);
 *     setTimeout(function () {
 *         window.test = "test -- prevented";
 *     }, 400);
 *     setTimeout(function () {
 *         window.test = "value -- executed";
 *     }, 400);
 *     setTimeout(function () {
 *         window.value = "test -- executed";
 *     }, 500);
 *     ```
 */

/* eslint-enable max-len */

function preventSetTimeout(source, match, delay) {
  var nativeTimeout = window.setTimeout;
  var log = console.log.bind(console); // eslint-disable-line no-console
  // logs setTimeouts to console if no arguments have been specified

  var shouldLog = typeof match === 'undefined' && typeof delay === 'undefined';

  var _parseMatchArg = parseMatchArg(match),
      isInvertedMatch = _parseMatchArg.isInvertedMatch,
      matchRegexp = _parseMatchArg.matchRegexp;

  var _parseDelayArg = parseDelayArg(delay),
      isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
      delayMatch = _parseDelayArg.delayMatch;

  var timeoutWrapper = function timeoutWrapper(callback, timeout) {
    var shouldPrevent = false; // https://github.com/AdguardTeam/Scriptlets/issues/105

    var cbString = String(callback);

    if (shouldLog) {
      hit(source);
      log("setTimeout(".concat(cbString, ", ").concat(timeout, ")"));
    } else if (!delayMatch) {
      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch;
    } else if (!match) {
      shouldPrevent = timeout === delayMatch !== isInvertedDelayMatch;
    } else {
      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch && timeout === delayMatch !== isInvertedDelayMatch;
    }

    if (shouldPrevent) {
      hit(source);
      return nativeTimeout(noopFunc, timeout);
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return nativeTimeout.apply(window, [callback, timeout].concat(args));
  };

  window.setTimeout = timeoutWrapper;
}
preventSetTimeout.names = ['prevent-setTimeout', // aliases are needed for matching the related scriptlet converted into our syntax
'no-setTimeout-if.js', // new implementation of setTimeout-defuser.js
'ubo-no-setTimeout-if.js', 'nostif.js', // new short name of no-setTimeout-if
'ubo-nostif.js', 'ubo-no-setTimeout-if', 'ubo-nostif', // old scriptlet names which should be supported as well.
// should be removed eventually.
// do not remove until other filter lists maintainers use them
'setTimeout-defuser.js', 'ubo-setTimeout-defuser.js', 'ubo-setTimeout-defuser', 'std.js', 'ubo-std.js', 'ubo-std'];
preventSetTimeout.injections = [hit, noopFunc, parseMatchArg, parseDelayArg, toRegExp, startsWith, nativeIsNaN];

/* eslint-disable max-len */

/**
 * @scriptlet prevent-setInterval
 *
 * @description
 * Prevents a `setInterval` call if:
 * 1) the text of the callback is matching the specified `search` string/regexp which does not start with `!`;
 * otherwise mismatched calls should be defused;
 * 2) the interval is matching the specified `delay`; otherwise mismatched calls should be defused.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setinterval-ifjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-setInterval'[, search[, delay]])
 * ```
 *
 * Call with no arguments will log calls to setInterval while debugging (`log-setInterval` superseding),
 * so production filter lists' rules definitely require at least one of the parameters:
 * - `search` - optional, string or regular expression.
 * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
 * If do not start with `!`, the stringified callback will be matched.
 * If not set, prevents all `setInterval` calls due to specified `delay`.
 * - `delay` - optional, must be an integer.
 * If starts with `!`, scriptlet will not match the delay but all other will be defused.
 * If do not start with `!`, the delay passed to the `setInterval` call will be matched.
 *
 * > If `prevent-setInterval` without parameters logs smth like `setInterval(undefined, 1000)`,
 * it means that no callback was passed to setInterval() and that's not scriptlet issue

 *  **Examples**
 * 1. Prevents `setInterval` calls if the callback matches `/\.test/` regardless of the delay.
 *     ```bash
 *     example.org#%#//scriptlet('prevent-setInterval', '/\.test/')
 *     ```
 *
 *     For instance, the following call will be prevented:
 *     ```javascript
 *     setInterval(function () {
 *         window.test = "value";
 *     }, 100);
 *     ```
 *
 * 2. Prevents `setInterval` calls if the callback does not contain `value`.
 *     ```
 *     example.org#%#//scriptlet('prevent-setInterval', '!value')
 *     ```
 *
 *     For instance, only the first of the following calls will be prevented:
 *     ```javascript
 *     setInterval(function () {
 *         window.test = "test -- prevented";
 *     }, 300);
 *     setInterval(function () {
 *         window.test = "value -- executed";
 *     }, 400);
 *     setInterval(function () {
 *         window.value = "test -- executed";
 *     }, 500);
 *     ```
 *
 * 3. Prevents `setInterval` calls if the callback contains `value` and the delay is not set to `300`.
 *     ```
 *     example.org#%#//scriptlet('prevent-setInterval', 'value', '!300')
 *     ```
 *
 *     For instance, only the first of the following calls will not be prevented:
 *     ```javascript
 *     setInterval(function () {
 *         window.test = "value 1 -- executed";
 *     }, 300);
 *     setInterval(function () {
 *         window.test = "value 2 -- prevented";
 *     }, 400);
 *     setInterval(function () {
 *         window.test = "value 3 -- prevented";
 *     }, 500);
 *     ```
 *
 * 4. Prevents `setInterval` calls if the callback does not contain `value` and the delay is not set to `300`.
 *     ```
 *     example.org#%#//scriptlet('prevent-setInterval', '!value', '!300')
 *     ```
 *
 *     For instance, only the second of the following calls will be prevented:
 *     ```javascript
 *     setInterval(function () {
 *         window.test = "test -- executed";
 *     }, 300);
 *     setInterval(function () {
 *         window.test = "test -- prevented";
 *     }, 400);
 *     setInterval(function () {
 *         window.test = "value -- executed";
 *     }, 400);
 *     setInterval(function () {
 *         window.value = "test -- executed";
 *     }, 500);
 *     ```
 */

/* eslint-enable max-len */

function preventSetInterval(source, match, delay) {
  var nativeInterval = window.setInterval;
  var log = console.log.bind(console); // eslint-disable-line no-console
  // logs setIntervals to console if no arguments have been specified

  var shouldLog = typeof match === 'undefined' && typeof delay === 'undefined';

  var _parseMatchArg = parseMatchArg(match),
      isInvertedMatch = _parseMatchArg.isInvertedMatch,
      matchRegexp = _parseMatchArg.matchRegexp;

  var _parseDelayArg = parseDelayArg(delay),
      isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,
      delayMatch = _parseDelayArg.delayMatch;

  var intervalWrapper = function intervalWrapper(callback, interval) {
    var shouldPrevent = false; // https://github.com/AdguardTeam/Scriptlets/issues/105

    var cbString = String(callback);

    if (shouldLog) {
      hit(source);
      log("setInterval(".concat(cbString, ", ").concat(interval, ")"));
    } else if (!delayMatch) {
      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch;
    } else if (!match) {
      shouldPrevent = interval === delayMatch !== isInvertedDelayMatch;
    } else {
      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch && interval === delayMatch !== isInvertedDelayMatch;
    }

    if (shouldPrevent) {
      hit(source);
      return nativeInterval(noopFunc, interval);
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return nativeInterval.apply(window, [callback, interval].concat(args));
  };

  window.setInterval = intervalWrapper;
}
preventSetInterval.names = ['prevent-setInterval', // aliases are needed for matching the related scriptlet converted into our syntax
'no-setInterval-if.js', // new implementation of setInterval-defuser.js
'ubo-no-setInterval-if.js', 'setInterval-defuser.js', // old name should be supported as well
'ubo-setInterval-defuser.js', 'nosiif.js', // new short name of no-setInterval-if
'ubo-nosiif.js', 'sid.js', // old short scriptlet name
'ubo-sid.js', 'ubo-no-setInterval-if', 'ubo-setInterval-defuser', 'ubo-nosiif', 'ubo-sid'];
preventSetInterval.injections = [hit, noopFunc, parseMatchArg, parseDelayArg, toRegExp, startsWith, nativeIsNaN];

/* eslint-disable max-len */

/**
 * @scriptlet prevent-window-open
 *
 * @description
 * Prevents `window.open` calls when URL either matches or not matches the specified string/regexp. Using it without parameters prevents all `window.open` calls.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#windowopen-defuserjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-window-open'[, match[, delay[, replacement]]])
 * ```
 *
 * - `match` - optional, string or regular expression. If not set, all window.open calls will be matched.
 * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
 * If do not start with `!`, the stringified callback will be matched.
 * - `delay` - optional, number of seconds. If not set, scriptlet will return `null`,
 * otherwise valid sham window object as injected `iframe` will be returned
 * for accessing it's methods (blur(), focus() etc.) and will be removed after the delay.
 * - `replacement` - optional, string; one of the predefined constants:
 *     - `obj` - for returning an object instead of default iframe;
 *        for cases when the page requires a valid `window` instance to be returned
 *     - `log` - for logging window.open calls; permitted for production filter lists.
 *
 * **Examples**
 * 1. Prevent all `window.open` calls:
 * ```
 *     example.org#%#//scriptlet('prevent-window-open')
 * ```
 *
 * 2. Prevent `window.open` for all URLs containing `example`:
 * ```
 *     example.org#%#//scriptlet('prevent-window-open', 'example')
 * ```
 *
 * 3. Prevent `window.open` for all URLs matching RegExp `/example\./`:
 * ```
 *     example.org#%#//scriptlet('prevent-window-open', '/example\./')
 * ```
 *
 * 4. Prevent `window.open` for all URLs **NOT** containing `example`:
 * ```
 *     example.org#%#//scriptlet('prevent-window-open', '!example')
 * ```
 *
 * Old syntax of prevent-window-open parameters:
 * - `match` - optional, defaults to "matching", any positive number or nothing for "matching", 0 or empty string for "not matching"
 * - `search` - optional, string or regexp for matching the URL passed to `window.open` call; defaults to search all `window.open` call
 * - `replacement` - optional, string to return prop value or property instead of window.open; defaults to return noopFunc.
 * **Examples**
 * ```
 *     example.org#%#//scriptlet('prevent-window-open', '1', '/example\./'
 *     example.org#%#//scriptlet('prevent-window-open', '0', 'example')
 *     example.org#%#//scriptlet('prevent-window-open', '', '', 'trueFunc')
 *     example.org#%#//scriptlet('prevent-window-open', '1', '', '{propName=noopFunc}')
 * ```
 *
 * > For better compatibility with uBO, old syntax is not recommended to use.
 */

/* eslint-enable max-len */

function preventWindowOpen(source) {
  var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getWildcardSymbol();
  var delay = arguments.length > 2 ? arguments[2] : undefined;
  var replacement = arguments.length > 3 ? arguments[3] : undefined;
  // default match value is needed for preventing all window.open calls
  // if scriptlet runs without args
  var nativeOpen = window.open;
  var isNewSyntax = match !== '0' && match !== '1';

  var oldOpenWrapper = function oldOpenWrapper(str) {
    match = Number(match) > 0; // 'delay' was 'search' prop for matching in old syntax

    var searchRegexp = toRegExp(delay);

    if (match !== searchRegexp.test(str)) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return nativeOpen.apply(window, [str].concat(args));
    }

    hit(source);
    return handleOldReplacement(replacement);
  };

  var newOpenWrapper = function newOpenWrapper(url) {
    var shouldLog = replacement && replacement.indexOf('log') > -1;

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (shouldLog) {
      var argsStr = args && args.length > 0 ? ", ".concat(args.join(', ')) : '';
      var logMessage = "log: window-open: ".concat(url).concat(argsStr);
      hit(source, logMessage);
    }

    var shouldPrevent = false;

    if (match === getWildcardSymbol()) {
      shouldPrevent = true;
    } else {
      var _parseMatchArg = parseMatchArg(match),
          isInvertedMatch = _parseMatchArg.isInvertedMatch,
          matchRegexp = _parseMatchArg.matchRegexp;

      shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;
    }

    if (shouldPrevent) {
      var parsedDelay = parseInt(delay, 10);
      var result;

      if (nativeIsNaN(parsedDelay)) {
        result = noopNull();
      } else {
        var decoyArgs = {
          replacement: replacement,
          url: url,
          delay: parsedDelay
        };
        var decoy = createDecoy(decoyArgs);
        var popup = decoy.contentWindow;

        if (typeof popup === 'object' && popup !== null) {
          Object.defineProperty(popup, 'closed', {
            value: false
          });
        } else {
          var nativeGetter = decoy.contentWindow && decoy.contentWindow.get;
          Object.defineProperty(decoy, 'contentWindow', {
            get: getPreventGetter(nativeGetter)
          });
          popup = decoy.contentWindow;
        }

        result = popup;
      }

      hit(source);
      return result;
    }

    return nativeOpen.apply(window, [url].concat(args));
  };

  window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;
}
preventWindowOpen.names = ['prevent-window-open', // aliases are needed for matching the related scriptlet converted into our syntax
'window.open-defuser.js', 'ubo-window.open-defuser.js', 'ubo-window.open-defuser', 'nowoif.js', 'ubo-nowoif.js', 'ubo-nowoif'];
preventWindowOpen.injections = [hit, toRegExp, nativeIsNaN, parseMatchArg, handleOldReplacement, createDecoy, getPreventGetter, noopNull, getWildcardSymbol, noopFunc, trueFunc, startsWith, endsWith, substringBefore, substringAfter];

/* eslint-disable max-len */

/**
 * @scriptlet abort-current-inline-script
 *
 * @description
 * Aborts an inline script when it attempts to **read** the specified property
 * AND when the contents of the `<script>` element contains the specified
 * text or matches the regular expression.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-current-inline-scriptjs-
 *
 * Related ABP source:
 * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L928
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('abort-current-inline-script', property[, search])
 * ```
 *
 * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`
 * - `search` - optional, string or regular expression that must match the inline script contents. If not set, abort all inline scripts which are trying to access the specified property
 *
 * > Note please that for inline script with addEventListener in it
 * `property` should be set as `EventTarget.prototype.addEventListener`,
 * not just `addEventListener`.
 *
 * **Examples**
 * 1. Aborts all inline scripts trying to access `window.alert`
 *     ```
 *     example.org#%#//scriptlet('abort-current-inline-script', 'alert')
 *     ```
 *
 * 2. Aborts inline scripts which are trying to access `window.alert` and contain `Hello, world`.
 *     ```
 *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', 'Hello, world')
 *     ```
 *
 *     For instance, the following script will be aborted
 *     ```html
 *     <script>alert("Hello, world");</script>
 *     ```
 *
 * 3. Aborts inline scripts which are trying to access `window.alert` and match this regexp: `/Hello.+world/`.
 *     ```
 *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', '/Hello.+world/')
 *     ```
 *
 *     For instance, the following scripts will be aborted:
 *     ```html
 *     <script>alert("Hello, big world");</script>
 *     ```
 *     ```html
 *     <script>alert("Hello, little world");</script>
 *     ```
 *
 *     This script will not be aborted:
 *     ```html
 *     <script>alert("Hi, little world");</script>
 *     ```
 */

/* eslint-enable max-len */

function abortCurrentInlineScript(source, property, search) {
  var searchRegexp = toRegExp(search);
  var rid = randomId();

  var getCurrentScript = function getCurrentScript() {
    if ('currentScript' in document) {
      return document.currentScript; // eslint-disable-line compat/compat
    }

    var scripts = document.getElementsByTagName('script');
    return scripts[scripts.length - 1];
  };

  var ourScript = getCurrentScript();

  var abort = function abort() {
    var scriptEl = getCurrentScript();

    if (!scriptEl) {
      return;
    }

    var content = scriptEl.textContent; // We are using Node.prototype.textContent property descriptor
    // to get the real script content
    // even when document.currentScript.textContent is replaced.
    // https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-593638991

    try {
      var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
      content = textContentGetter.call(scriptEl);
    } catch (e) {} // eslint-disable-line no-empty


    if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
      hit(source);
      throw new ReferenceError(rid);
    }
  };

  var setChainPropAccess = function setChainPropAccess(owner, property) {
    var chainInfo = getPropertyInChain(owner, property);
    var base = chainInfo.base;
    var prop = chainInfo.prop,
        chain = chainInfo.chain; // The scriptlet might be executed before the chain property has been created
    // (for instance, document.body before the HTML body was loaded).
    // In this case we're checking whether the base element exists or not
    // and if not, we simply exit without overriding anything.
    // e.g. https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-575841092

    if (base instanceof Object === false && base === null) {
      var props = property.split('.');
      var propIndex = props.indexOf(prop);
      var baseName = props[propIndex - 1];
      console.log("The scriptlet had been executed before the ".concat(baseName, " was loaded.")); // eslint-disable-line no-console

      return;
    }

    if (chain) {
      var setter = function setter(a) {
        base = a;

        if (a instanceof Object) {
          setChainPropAccess(a, chain);
        }
      };

      Object.defineProperty(owner, prop, {
        get: function get() {
          return base;
        },
        set: setter
      });
      return;
    }

    var currentValue = base[prop];
    setPropertyAccess(base, prop, {
      set: function set(value) {
        abort();
        currentValue = value;
      },
      get: function get() {
        abort();
        return currentValue;
      }
    });
  };

  setChainPropAccess(window, property);
  window.onerror = createOnErrorHandler(rid).bind();
}
abortCurrentInlineScript.names = ['abort-current-inline-script', // aliases are needed for matching the related scriptlet converted into our syntax
'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'ubo-abort-current-inline-script', 'ubo-acis', 'abp-abort-current-inline-script'];
abortCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];

/* eslint-disable max-len */

/**
 * @scriptlet set-constant
 *
 * @description
 * Creates a constant property and assigns it one of the values from the predefined list.
 *
 * > Actually, it's not a constant. Please note, that it can be rewritten with a value of a different type.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#set-constantjs-
 *
 * Related ABP snippet:
 * https://github.com/adblockplus/adblockpluscore/blob/adblockpluschrome-3.9.4/lib/content/snippets.js#L1361
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('set-constant', property, value[, stack])
 * ```
 *
 * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`.
 * - `value` - required. Possible values:
 *     - positive decimal integer `<= 32767`
 *     - one of the predefined constants:
 *         - `undefined`
 *         - `false`
 *         - `true`
 *         - `null`
 *         - `emptyObj` - empty object
 *         - `emptyArr` - empty array
 *         - `noopFunc` - function with empty body
 *         - `trueFunc` - function returning true
 *         - `falseFunc` - function returning false
 *         - `''` - empty string
 *         - `-1` - number value `-1`
 * - `stack` - optional, string or regular expression that must match the current function call stack trace
 *
 * **Examples**
 * ```
 * ! window.firstConst === false // this comparision will return false
 * example.org#%#//scriptlet('set-constant', 'firstConst', 'false')
 *
 * ! window.second() === trueFunc // 'second' call will return true
 * example.org#%#//scriptlet('set-constant', 'secondConst', 'trueFunc')
 *
 * ! document.third() === falseFunc  // 'third' call will return false if the method is related to checking.js
 * example.org#%#//scriptlet('set-constant', 'secondConst', 'trueFunc', 'checking.js')
 * ```
 */

/* eslint-enable max-len */

function setConstant(source, property, value, stack) {
  if (!property || !matchStackTrace(stack, new Error().stack)) {
    return;
  }

  var emptyArr = noopArray();
  var emptyObj = noopObject();
  var constantValue;

  if (value === 'undefined') {
    constantValue = undefined;
  } else if (value === 'false') {
    constantValue = false;
  } else if (value === 'true') {
    constantValue = true;
  } else if (value === 'null') {
    constantValue = null;
  } else if (value === 'emptyArr') {
    constantValue = emptyArr;
  } else if (value === 'emptyObj') {
    constantValue = emptyObj;
  } else if (value === 'noopFunc') {
    constantValue = noopFunc;
  } else if (value === 'trueFunc') {
    constantValue = trueFunc;
  } else if (value === 'falseFunc') {
    constantValue = falseFunc;
  } else if (/^\d+$/.test(value)) {
    constantValue = parseFloat(value);

    if (nativeIsNaN(constantValue)) {
      return;
    }

    if (Math.abs(constantValue) > 0x7FFF) {
      return;
    }
  } else if (value === '-1') {
    constantValue = -1;
  } else if (value === '') {
    constantValue = '';
  } else {
    return;
  }

  var canceled = false;

  var mustCancel = function mustCancel(value) {
    if (canceled) {
      return canceled;
    }

    canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;
    return canceled;
  };

  var setChainPropAccess = function setChainPropAccess(owner, property) {
    var chainInfo = getPropertyInChain(owner, property);
    var base = chainInfo.base;
    var prop = chainInfo.prop,
        chain = chainInfo.chain; // The scriptlet might be executed before the chain property has been created.
    // In this case we're checking whether the base element exists or not
    // and if not, we simply exit without overriding anything

    if (base instanceof Object === false && base === null) {
      // log the reason only while debugging
      if (source.verbose) {
        var props = property.split('.');
        var propIndex = props.indexOf(prop);
        var baseName = props[propIndex - 1];
        console.log("set-constant failed because the property '".concat(baseName, "' does not exist")); // eslint-disable-line no-console
      }

      return;
    }

    if (chain) {
      var setter = function setter(a) {
        base = a;

        if (a instanceof Object) {
          setChainPropAccess(a, chain);
        }
      };

      Object.defineProperty(owner, prop, {
        get: function get() {
          return base;
        },
        set: setter
      });
      return;
    }

    if (mustCancel(base[prop])) {
      return;
    }

    hit(source);
    setPropertyAccess(base, prop, {
      get: function get() {
        return constantValue;
      },
      set: function set(a) {
        if (mustCancel(a)) {
          constantValue = a;
        }
      }
    });
  };

  setChainPropAccess(window, property);
}
setConstant.names = ['set-constant', // aliases are needed for matching the related scriptlet converted into our syntax
'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set', 'abp-override-property-read'];
setConstant.injections = [hit, noopArray, noopObject, noopFunc, trueFunc, falseFunc, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN];

/* eslint-disable max-len */

/**
 * @scriptlet remove-cookie
 *
 * @description
 * Removes current page cookies by passed string matching with name. For current domain and subdomains. Runs on load and before unload.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#cookie-removerjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('remove-cookie'[, match])
 * ```
 *
 * - `match` - optional, string or regex matching the cookie name. If not specified all accessible cookies will be removed.
 *
 * **Examples**
 * 1. Removes all cookies:
 * ```
 *     example.org#%#//scriptlet('remove-cookie')
 * ```
 *
 * 2. Removes cookies which name contains `example` string.
 * ```
 *     example.org#%#//scriptlet('remove-cookie', 'example')
 * ```
 *
 *     For instance this cookie will be removed
 *     ```javascript
 *     document.cookie = '__example=randomValue';
 *     ```
 */

/* eslint-enable max-len */

function removeCookie(source, match) {
  var matchRegexp = toRegExp(match);

  var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
    var cookieSpec = "".concat(cookieName, "=");
    var domain1 = "; domain=".concat(hostName);
    var domain2 = "; domain=.".concat(hostName);
    var path = '; path=/';
    var expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';
    document.cookie = cookieSpec + expiration;
    document.cookie = cookieSpec + domain1 + expiration;
    document.cookie = cookieSpec + domain2 + expiration;
    document.cookie = cookieSpec + path + expiration;
    document.cookie = cookieSpec + domain1 + path + expiration;
    document.cookie = cookieSpec + domain2 + path + expiration;
    hit(source);
  };

  var rmCookie = function rmCookie() {
    document.cookie.split(';').forEach(function (cookieStr) {
      var pos = cookieStr.indexOf('=');

      if (pos === -1) {
        return;
      }

      var cookieName = cookieStr.slice(0, pos).trim();

      if (!matchRegexp.test(cookieName)) {
        return;
      }

      var hostParts = document.location.hostname.split('.');

      for (var i = 0; i <= hostParts.length - 1; i += 1) {
        var hostName = hostParts.slice(i).join('.');

        if (hostName) {
          removeCookieFromHost(cookieName, hostName);
        }
      }
    });
  };

  rmCookie();
  window.addEventListener('beforeunload', rmCookie);
}
removeCookie.names = ['remove-cookie', // aliases are needed for matching the related scriptlet converted into our syntax
'cookie-remover.js', 'ubo-cookie-remover.js', 'ubo-cookie-remover'];
removeCookie.injections = [toRegExp, hit];

/* eslint-disable max-len */

/**
 * @scriptlet prevent-addEventListener
 *
 * @description
 * Prevents adding event listeners for the specified events and callbacks.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-defuserjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-addEventListener'[, eventSearch[, functionSearch]])
 * ```
 *
 * - `eventSearch` - optional, string or regex matching the event name. If not specified, the scriptlets prevents all event listeners
 * - `functionSearch` - optional, string or regex matching the event listener function body. If not set, the scriptlet prevents all event listeners with event name matching `eventSearch`
 *
 * **Examples**
 * 1. Prevent all `click` listeners:
 * ```
 *     example.org#%#//scriptlet('prevent-addEventListener', 'click')
 * ```

2. Prevent 'click' listeners with the callback body containing `searchString`.
 * ```
 *     example.org#%#//scriptlet('prevent-addEventListener', 'click', 'searchString')
 * ```
 *
 *     For instance, this listener will not be called:
 * ```javascript
 *     el.addEventListener('click', () => {
 *         window.test = 'searchString';
 *     });
 * ```
 */

/* eslint-enable max-len */

function preventAddEventListener(source, eventSearch, funcSearch) {
  var eventSearchRegexp = toRegExp(eventSearch);
  var funcSearchRegexp = toRegExp(funcSearch);
  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;

  function addEventListenerWrapper(type, listener) {
    var shouldPrevent = false;

    if (validateType(type) && validateListener(listener)) {
      shouldPrevent = eventSearchRegexp.test(type.toString()) && funcSearchRegexp.test(listenerToString(listener));
    }

    if (shouldPrevent) {
      hit(source);
      return undefined;
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return nativeAddEventListener.apply(this, [type, listener].concat(args));
  }

  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
}
preventAddEventListener.names = ['prevent-addEventListener', // aliases are needed for matching the related scriptlet converted into our syntax
'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js', 'ubo-addEventListener-defuser', 'ubo-aeld'];
preventAddEventListener.injections = [hit, toRegExp, validateType, validateListener, listenerToString];

/* eslint-disable consistent-return, no-eval */
/**
 * @scriptlet prevent-bab
 *
 * @description
 * Prevents BlockAdblock script from detecting an ad blocker.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#bab-defuserjs-
 *
 * It also can be used as `$redirect` sometimes.
 * See [redirect description](../wiki/about-redirects.md#prevent-bab).
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-bab')
 * ```
 */

function preventBab(source) {
  var nativeSetTimeout = window.setTimeout;
  var babRegex = /\.bab_elementid.$/;

  var timeoutWrapper = function timeoutWrapper(callback) {
    if (typeof callback !== 'string' || !babRegex.test(callback)) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return nativeSetTimeout.apply(window, [callback].concat(args));
    }

    hit(source);
  };

  window.setTimeout = timeoutWrapper;
  var signatures = [['blockadblock'], ['babasbm'], [/getItem\('babn'\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];

  var check = function check(str) {
    for (var i = 0; i < signatures.length; i += 1) {
      var tokens = signatures[i];
      var match = 0;

      for (var j = 0; j < tokens.length; j += 1) {
        var token = tokens[j];
        var found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;

        if (found) {
          match += 1;
        }
      }

      if (match / tokens.length >= 0.8) {
        return true;
      }
    }

    return false;
  };

  var nativeEval = window.eval;

  var evalWrapper = function evalWrapper(str) {
    if (!check(str)) {
      return nativeEval(str);
    }

    hit(source);
    var bodyEl = document.body;

    if (bodyEl) {
      bodyEl.style.removeProperty('visibility');
    }

    var el = document.getElementById('babasbmsgx');

    if (el) {
      el.parentNode.removeChild(el);
    }
  };

  window.eval = evalWrapper.bind(window);
}
preventBab.names = ['prevent-bab', // aliases are needed for matching the related scriptlet converted into our syntax
'nobab.js', 'ubo-nobab.js', 'bab-defuser.js', 'ubo-bab-defuser.js', 'ubo-nobab', 'ubo-bab-defuser'];
preventBab.injections = [hit];

/* eslint-disable no-unused-vars, no-extra-bind, func-names */
/* eslint-disable max-len */

/**
 * @scriptlet nowebrtc
 *
 * @description
 * Disables WebRTC by overriding `RTCPeerConnection`. The overriden function will log every attempt to create a new connection.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('nowebrtc')
 * ```
 */

/* eslint-enable max-len */

function nowebrtc(source) {
  var propertyName = '';

  if (window.RTCPeerConnection) {
    propertyName = 'RTCPeerConnection';
  } else if (window.webkitRTCPeerConnection) {
    propertyName = 'webkitRTCPeerConnection';
  }

  if (propertyName === '') {
    return;
  }

  var rtcReplacement = function rtcReplacement(config) {
    hit(source, "Document tried to create an RTCPeerConnection: ".concat(convertRtcConfigToString(config)));
  };

  rtcReplacement.prototype = {
    close: noopFunc,
    createDataChannel: noopFunc,
    createOffer: noopFunc,
    setRemoteDescription: noopFunc
  };
  var rtc = window[propertyName];
  window[propertyName] = rtcReplacement;

  if (rtc.prototype) {
    rtc.prototype.createDataChannel = function (a, b) {
      return {
        close: noopFunc,
        send: noopFunc
      };
    }.bind(null);
  }
}
nowebrtc.names = ['nowebrtc', // aliases are needed for matching the related scriptlet converted into our syntax
'nowebrtc.js', 'ubo-nowebrtc.js', 'ubo-nowebrtc'];
nowebrtc.injections = [hit, noopFunc, convertRtcConfigToString];

/**
 * @scriptlet log-addEventListener
 *
 * @description
 * Logs all addEventListener calls to the console.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-loggerjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('log-addEventListener')
 * ```
 */

function logAddEventListener(source) {
  // eslint-disable-next-line no-console
  var log = console.log.bind(console);
  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;

  function addEventListenerWrapper(type, listener) {
    if (validateType(type) && validateListener(listener)) {
      var logMessage = "log: addEventListener(\"".concat(type, "\", ").concat(listenerToString(listener), ")");
      hit(source, logMessage);
    } else if (source.verbose) {
      // logging while debugging
      var _logMessage = "Invalid event type or listener passed to addEventListener:\ntype: ".concat(convertTypeToString(type), "\nlistener: ").concat(convertTypeToString(listener));

      log(_logMessage);
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return nativeAddEventListener.apply(this, [type, listener].concat(args));
  }

  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
}
logAddEventListener.names = ['log-addEventListener', // aliases are needed for matching the related scriptlet converted into our syntax
'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js', 'ubo-addEventListener-logger', 'ubo-aell'];
logAddEventListener.injections = [hit, validateType, validateListener, listenerToString, convertTypeToString, objectToString, isEmptyObject, getObjectEntries];

/* eslint-disable no-console, no-eval */
/**
 * @scriptlet log-eval
 *
 * @description
 * Logs all `eval()` or `new Function()` calls to the console.
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('log-eval')
 * ```
 */

function logEval(source) {
  var log = console.log.bind(console); // wrap eval function

  var nativeEval = window.eval;

  function evalWrapper(str) {
    hit(source);
    log("eval(\"".concat(str, "\")"));
    return nativeEval(str);
  }

  window.eval = evalWrapper; // wrap new Function

  var nativeFunction = window.Function;

  function FunctionWrapper() {
    hit(source);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    log("new Function(".concat(args.join(', '), ")"));
    return nativeFunction.apply(this, [].concat(args));
  }

  FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
  FunctionWrapper.prototype.constructor = FunctionWrapper;
  window.Function = FunctionWrapper;
}
logEval.names = ['log-eval'];
logEval.injections = [hit];

/**
 * @scriptlet log
 *
 * @description
 * A simple scriptlet which only purpose is to print arguments to console.
 * This scriptlet can be helpful for debugging and troubleshooting other scriptlets.
 *
 * **Example**
 * ```
 * example.org#%#//scriptlet('log', 'arg1', 'arg2')
 * ```
 */
function log() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  console.log(args); // eslint-disable-line no-console
}
log.names = ['log'];

/* eslint-disable no-eval, no-extra-bind */
/**
 * @scriptlet noeval
 *
 * @description
 * Prevents page to use eval.
 * Notifies about attempts in the console
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#noevaljs-
 *
 * It also can be used as `$redirect` rules sometimes.
 * See [redirect description](../wiki/about-redirects.md#noeval).
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('noeval')
 * ```
 */

function noeval(source) {
  window.eval = function evalWrapper(s) {
    hit(source, "AdGuard has prevented eval:\n".concat(s));
  }.bind();
}
noeval.names = ['noeval', // aliases are needed for matching the related scriptlet converted into our syntax
'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js', 'ubo-noeval', 'ubo-silent-noeval'];
noeval.injections = [hit];

/* eslint-disable no-eval, no-extra-bind, func-names */
/**
 * @scriptlet prevent-eval-if
 *
 * @description
 * Prevents page to use eval matching payload.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#noeval-ifjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-eval-if'[, search])
 * ```
 *
 * - `search` - optional, string or regexp for matching stringified eval payload.
 * If 'search is not specified — all stringified eval payload will be matched
 *
 * **Examples**
 * ```
 * ! Prevents eval if it matches 'test'
 * example.org#%#//scriptlet('prevent-eval-if', 'test')
 * ```
 *
 * @param {string|RegExp} [search] string or regexp matching stringified eval payload
 */

function preventEvalIf(source, search) {
  var searchRegexp = toRegExp(search);
  var nativeEval = window.eval;

  window.eval = function (payload) {
    if (!searchRegexp.test(payload.toString())) {
      return nativeEval.call(window, payload);
    }

    hit(source, payload);
    return undefined;
  }.bind(window);
}
preventEvalIf.names = ['prevent-eval-if', // aliases are needed for matching the related scriptlet converted into our syntax
'noeval-if.js', 'ubo-noeval-if.js', 'ubo-noeval-if'];
preventEvalIf.injections = [toRegExp, hit];

/* eslint-disable no-console, func-names, no-multi-assign */
/**
 * @scriptlet prevent-fab-3.2.0
 *
 * @description
 * Prevents execution of the FAB script v3.2.0.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#fuckadblockjs-320-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-fab-3.2.0')
 * ```
 */

function preventFab(source) {
  hit(source); // redefines Fab function for adblock detection

  var Fab = function Fab() {};

  Fab.prototype.check = noopFunc;
  Fab.prototype.clearEvent = noopFunc;
  Fab.prototype.emitEvent = noopFunc;

  Fab.prototype.on = function (a, b) {
    if (!a) {
      b();
    }

    return this;
  };

  Fab.prototype.onDetected = noopThis;

  Fab.prototype.onNotDetected = function (a) {
    a();
    return this;
  };

  Fab.prototype.setOption = noopFunc;
  Fab.prototype.options = {
    set: noopFunc,
    get: noopFunc
  };
  var fab = new Fab();
  var getSetFab = {
    get: function get() {
      return Fab;
    },
    set: function set() {}
  };
  var getsetfab = {
    get: function get() {
      return fab;
    },
    set: function set() {}
  }; // redefined Fab data properties which if 'FuckAdBlock' variable exists

  if (Object.prototype.hasOwnProperty.call(window, 'FuckAdBlock')) {
    window.FuckAdBlock = Fab;
  } else {
    // or redefined Fab accessor properties
    Object.defineProperty(window, 'FuckAdBlock', getSetFab);
  }

  if (Object.prototype.hasOwnProperty.call(window, 'BlockAdBlock')) {
    window.BlockAdBlock = Fab;
  } else {
    Object.defineProperty(window, 'BlockAdBlock', getSetFab);
  }

  if (Object.prototype.hasOwnProperty.call(window, 'SniffAdBlock')) {
    window.SniffAdBlock = Fab;
  } else {
    Object.defineProperty(window, 'SniffAdBlock', getSetFab);
  }

  if (Object.prototype.hasOwnProperty.call(window, 'fuckAdBlock')) {
    window.fuckAdBlock = fab;
  } else {
    Object.defineProperty(window, 'fuckAdBlock', getsetfab);
  }

  if (Object.prototype.hasOwnProperty.call(window, 'blockAdBlock')) {
    window.blockAdBlock = fab;
  } else {
    Object.defineProperty(window, 'blockAdBlock', getsetfab);
  }

  if (Object.prototype.hasOwnProperty.call(window, 'sniffAdBlock')) {
    window.sniffAdBlock = fab;
  } else {
    Object.defineProperty(window, 'sniffAdBlock', getsetfab);
  }
}
preventFab.names = ['prevent-fab-3.2.0', // aliases are needed for matching the related scriptlet converted into our syntax
'nofab.js', 'ubo-nofab.js', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'ubo-nofab'];
preventFab.injections = [hit, noopFunc, noopThis];

/* eslint-disable no-console, func-names, no-multi-assign */
/**
 * @scriptlet set-popads-dummy
 *
 * @description
 * Sets static properties PopAds and popns.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#popads-dummyjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('set-popads-dummy')
 * ```
 */

function setPopadsDummy(source) {
  delete window.PopAds;
  delete window.popns;
  Object.defineProperties(window, {
    PopAds: {
      get: function get() {
        hit(source);
        return {};
      }
    },
    popns: {
      get: function get() {
        hit(source);
        return {};
      }
    }
  });
}
setPopadsDummy.names = ['set-popads-dummy', // aliases are needed for matching the related scriptlet converted into our syntax
'popads-dummy.js', 'ubo-popads-dummy.js', 'ubo-popads-dummy'];
setPopadsDummy.injections = [hit];

/**
 * @scriptlet prevent-popads-net
 *
 * @description
 * Aborts on property write (PopAds, popns), throws reference error with random id.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#popadsnetjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-popads-net')
 * ```
 */

function preventPopadsNet(source) {
  var rid = randomId();

  var throwError = function throwError() {
    throw new ReferenceError(rid);
  };

  delete window.PopAds;
  delete window.popns;
  Object.defineProperties(window, {
    PopAds: {
      set: throwError
    },
    popns: {
      set: throwError
    }
  });
  window.onerror = createOnErrorHandler(rid).bind();
  hit(source);
}
preventPopadsNet.names = ['prevent-popads-net', // aliases are needed for matching the related scriptlet converted into our syntax
'popads.net.js', 'ubo-popads.net.js', 'ubo-popads.net'];
preventPopadsNet.injections = [createOnErrorHandler, randomId, hit];

/* eslint-disable func-names */
/**
 * @scriptlet prevent-adfly
 *
 * @description
 * Prevents anti-adblock scripts on adfly short links.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#adfly-defuserjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-adfly')
 * ```
 */

function preventAdfly(source) {
  var isDigit = function isDigit(data) {
    return /^\d$/.test(data);
  };

  var handler = function handler(encodedURL) {
    var evenChars = '';
    var oddChars = '';

    for (var i = 0; i < encodedURL.length; i += 1) {
      if (i % 2 === 0) {
        evenChars += encodedURL.charAt(i);
      } else {
        oddChars = encodedURL.charAt(i) + oddChars;
      }
    }

    var data = (evenChars + oddChars).split('');

    for (var _i = 0; _i < data.length; _i += 1) {
      if (isDigit(data[_i])) {
        for (var ii = _i + 1; ii < data.length; ii += 1) {
          if (isDigit(data[ii])) {
            // eslint-disable-next-line no-bitwise
            var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);

            if (temp < 10) {
              data[_i] = temp.toString();
            }

            _i = ii;
            break;
          }
        }
      }
    }

    data = data.join('');
    var decodedURL = window.atob(data).slice(16, -16);
    /* eslint-disable compat/compat */

    if (window.stop) {
      window.stop();
    }
    /* eslint-enable compat/compat */


    window.onbeforeunload = null;
    window.location.href = decodedURL;
  };

  var val; // Do not apply handler more than one time

  var applyHandler = true;
  var result = setPropertyAccess(window, 'ysmm', {
    configurable: false,
    set: function set(value) {
      if (applyHandler) {
        applyHandler = false;

        try {
          if (typeof value === 'string') {
            handler(value);
          }
        } catch (err) {} // eslint-disable-line no-empty

      }

      val = value;
    },
    get: function get() {
      return val;
    }
  });

  if (result) {
    hit(source);
  } else {
    window.console.error('Failed to set up prevent-adfly scriptlet');
  }
}
preventAdfly.names = ['prevent-adfly', // aliases are needed for matching the related scriptlet converted into our syntax
'adfly-defuser.js', 'ubo-adfly-defuser.js', 'ubo-adfly-defuser'];
preventAdfly.injections = [setPropertyAccess, hit];

/* eslint-disable max-len */

/**
 * @scriptlet debug-on-property-read
 *
 * @description
 * This scriptlet is basically the same as [abort-on-property-read](#abort-on-property-read), but instead of aborting it starts the debugger.
 *
 * **It is not supposed to be used in production filter lists!**
 *
 * **Syntax**
 * ```
 * ! Debug script if it tries to access `window.alert`
 * example.org#%#//scriptlet('debug-on-property-read', 'alert')
 * ! of `window.open`
 * example.org#%#//scriptlet('debug-on-property-read', 'open')
 * ```
 */

/* eslint-enable max-len */

function debugOnPropertyRead(source, property, stack) {
  if (!property || !matchStackTrace(stack, new Error().stack)) {
    return;
  }

  var rid = randomId();

  var abort = function abort() {
    hit(source);
    debugger; // eslint-disable-line no-debugger
  };

  var setChainPropAccess = function setChainPropAccess(owner, property) {
    var chainInfo = getPropertyInChain(owner, property);
    var base = chainInfo.base;
    var prop = chainInfo.prop,
        chain = chainInfo.chain;

    if (chain) {
      var setter = function setter(a) {
        base = a;

        if (a instanceof Object) {
          setChainPropAccess(a, chain);
        }
      };

      Object.defineProperty(owner, prop, {
        get: function get() {
          return base;
        },
        set: setter
      });
      return;
    }

    setPropertyAccess(base, prop, {
      get: abort,
      set: noopFunc
    });
  };

  setChainPropAccess(window, property);
  window.onerror = createOnErrorHandler(rid).bind();
}
debugOnPropertyRead.names = ['debug-on-property-read'];
debugOnPropertyRead.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace, noopFunc];

/* eslint-disable max-len */

/**
 * @scriptlet debug-on-property-write
 *
 * @description
 * This scriptlet is basically the same as [abort-on-property-write](#abort-on-property-write), but instead of aborting it starts the debugger.
 *
 * **It is not supposed to be used in production filter lists!**
 *
 * **Syntax**
 * ```
 * ! Aborts script when it tries to write in property `window.test`
 * example.org#%#//scriptlet('debug-on-property-write', 'test')
 * ```
 */

/* eslint-enable max-len */

function debugOnPropertyWrite(source, property, stack) {
  if (!property || !matchStackTrace(stack, new Error().stack)) {
    return;
  }

  var rid = randomId();

  var abort = function abort() {
    hit(source);
    debugger; // eslint-disable-line no-debugger
  };

  var setChainPropAccess = function setChainPropAccess(owner, property) {
    var chainInfo = getPropertyInChain(owner, property);
    var base = chainInfo.base;
    var prop = chainInfo.prop,
        chain = chainInfo.chain;

    if (chain) {
      var setter = function setter(a) {
        base = a;

        if (a instanceof Object) {
          setChainPropAccess(a, chain);
        }
      };

      Object.defineProperty(owner, prop, {
        get: function get() {
          return base;
        },
        set: setter
      });
      return;
    }

    setPropertyAccess(base, prop, {
      set: abort
    });
  };

  setChainPropAccess(window, property);
  window.onerror = createOnErrorHandler(rid).bind();
}
debugOnPropertyWrite.names = ['debug-on-property-write'];
debugOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace];

/* eslint-disable max-len */

/**
 * @scriptlet debug-current-inline-script
 *
 * @description
 * This scriptlet is basically the same as [abort-current-inline-script](#abort-current-inline-script), but instead of aborting it starts the debugger.
 *
 * **It is not supposed to be used in production filter lists!**
 *
 * **Syntax**
 *```
 * ! Aborts script when it tries to access `window.alert`
 * example.org#%#//scriptlet('debug-current-inline-script', 'alert')
 * ```
 */

/* eslint-enable max-len */

function debugCurrentInlineScript(source, property) {
  var search = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var searchRegexp = toRegExp(search);
  var rid = randomId();

  var getCurrentScript = function getCurrentScript() {
    if ('currentScript' in document) {
      return document.currentScript; // eslint-disable-line compat/compat
    }

    var scripts = document.getElementsByTagName('script');
    return scripts[scripts.length - 1];
  };

  var ourScript = getCurrentScript();

  var abort = function abort() {
    var scriptEl = getCurrentScript();

    if (scriptEl instanceof HTMLScriptElement && scriptEl.textContent.length > 0 && scriptEl !== ourScript && (!search || searchRegexp.test(scriptEl.textContent))) {
      hit(source);
      debugger; // eslint-disable-line no-debugger
    }
  };

  var setChainPropAccess = function setChainPropAccess(owner, property) {
    var chainInfo = getPropertyInChain(owner, property);
    var base = chainInfo.base;
    var prop = chainInfo.prop,
        chain = chainInfo.chain;

    if (chain) {
      var setter = function setter(a) {
        base = a;

        if (a instanceof Object) {
          setChainPropAccess(a, chain);
        }
      };

      Object.defineProperty(owner, prop, {
        get: function get() {
          return base;
        },
        set: setter
      });
      return;
    }

    var currentValue = base[prop];
    setPropertyAccess(base, prop, {
      set: function set(value) {
        abort();
        currentValue = value;
      },
      get: function get() {
        abort();
        return currentValue;
      }
    });
  };

  setChainPropAccess(window, property);
  window.onerror = createOnErrorHandler(rid).bind();
}
debugCurrentInlineScript.names = ['debug-current-inline-script'];
debugCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];

/* eslint-disable max-len */

/**
 * @scriptlet remove-attr
 *
 * @description
 * Removes the specified attributes from DOM nodes. This scriptlet runs once when the page loads
 * and after that periodically in order to DOM tree changes.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-attrjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('remove-attr', attrs[, selector])
 * ```
 *
 * - `attrs` — required, attribute or list of attributes joined by '|'
 * - `selector` — optional, CSS selector, specifies DOM nodes from which the attributes will be removed
 *
 * **Examples**
 * 1.  Removes by attribute
 *     ```
 *     example.org#%#//scriptlet('remove-attr', 'example|test')
 *     ```
 *
 *     ```html
 *     <!-- before  -->
 *     <div example="true" test="true">Some text</div>
 *
 *     <!-- after -->
 *     <div>Some text</div>
 *     ```
 *
 * 2. Removes with specified selector
 *     ```
 *     example.org#%#//scriptlet('remove-attr', 'example', 'div[class="inner"]')
 *     ```
 *
 *     ```html
 *     <!-- before -->
 *     <div class="wrapper" example="true">
 *         <div class="inner" example="true">Some text</div>
 *     </div>
 *
 *     <!-- after -->
 *     <div class="wrapper" example="true">
 *         <div class="inner">Some text</div>
 *     </div>
 *     ```
 */

/* eslint-enable max-len */

function removeAttr(source, attrs, selector) {
  if (!attrs) {
    return;
  }

  attrs = attrs.split(/\s*\|\s*/);

  if (!selector) {
    selector = "[".concat(attrs.join('],['), "]");
  }

  var rmattr = function rmattr() {
    var nodes = [].slice.call(document.querySelectorAll(selector));
    var removed = false;
    nodes.forEach(function (node) {
      attrs.forEach(function (attr) {
        node.removeAttribute(attr);
        removed = true;
      });
    });

    if (removed) {
      hit(source);
    }
  };

  rmattr(); // 'true' for observing attributes

  observeDOMChanges(rmattr, true);
}
removeAttr.names = ['remove-attr', // aliases are needed for matching the related scriptlet converted into our syntax
'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js', 'ubo-remove-attr', 'ubo-ra'];
removeAttr.injections = [hit, observeDOMChanges];

/* eslint-disable max-len */

/**
 * @scriptlet remove-class
 *
 * @description
 * Removes the specified classes from DOM nodes. This scriptlet runs once after the page loads
 * and after that periodically in order to DOM tree changes.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-classjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('remove-class', classes[, selector])
 * ```
 *
 * - `classes` — required, class or list of classes separated by '|'
 * - `selector` — optional, CSS selector, specifies DOM nodes from which the classes will be removed.
 * If there is no `selector`, each class of `classes` independently will be removed from all nodes which has one
 *
 * **Examples**
 * 1.  Removes by classes
 *     ```
 *     example.org#%#//scriptlet('remove-class', 'example|test')
 *     ```
 *
 *     ```html
 *     <!-- before  -->
 *     <div id="first" class="nice test">Some text</div>
 *     <div id="second" class="rare example for test">Some text</div>
 *     <div id="third" class="testing better example">Some text</div>
 *
 *     <!-- after -->
 *     <div id="first" class="nice">Some text</div>
 *     <div id="second" class="rare for">Some text</div>
 *     <div id="third" class="testing better">Some text</div>
 *     ```
 *
 * 2. Removes with specified selector
 *     ```
 *     example.org#%#//scriptlet('remove-class', 'branding', 'div[class^="inner"]')
 *     ```
 *
 *     ```html
 *     <!-- before -->
 *     <div class="wrapper true branding">
 *         <div class="inner bad branding">Some text</div>
 *     </div>
 *
 *     <!-- after -->
 *     <div class="wrapper true branding">
 *         <div class="inner bad">Some text</div>
 *     </div>
 *     ```
 */

/* eslint-enable max-len */

function removeClass(source, classNames, selector) {
  if (!classNames) {
    return;
  }

  classNames = classNames.split(/\s*\|\s*/);
  var selectors = [];

  if (!selector) {
    selectors = classNames.map(function (className) {
      return ".".concat(className);
    });
  }

  var removeClassHandler = function removeClassHandler() {
    var nodes = new Set();

    if (selector) {
      var foundedNodes = [].slice.call(document.querySelectorAll(selector));
      foundedNodes.forEach(function (n) {
        return nodes.add(n);
      });
    } else if (selectors.length > 0) {
      selectors.forEach(function (s) {
        var elements = document.querySelectorAll(s);

        for (var i = 0; i < elements.length; i += 1) {
          var element = elements[i];
          nodes.add(element);
        }
      });
    }

    var removed = false;
    nodes.forEach(function (node) {
      classNames.forEach(function (className) {
        if (node.classList.contains(className)) {
          node.classList.remove(className);
          removed = true;
        }
      });
    });

    if (removed) {
      hit(source);
    }
  };

  removeClassHandler();
  var CLASS_ATTR_NAME = ['class']; // 'true' for observing attributes
  // 'class' for observing only classes

  observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
}
removeClass.names = ['remove-class', // aliases are needed for matching the related scriptlet converted into our syntax
'remove-class.js', 'ubo-remove-class.js', 'rc.js', 'ubo-rc.js', 'ubo-remove-class', 'ubo-rc'];
removeClass.injections = [hit, observeDOMChanges];

/**
 * @scriptlet disable-newtab-links
 *
 * @description
 * Prevents opening new tabs and windows if there is `target` attribute in element.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#disable-newtab-linksjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('disable-newtab-links')
 * ```
 */

function disableNewtabLinks(source) {
  document.addEventListener('click', function (ev) {
    var target = ev.target;

    while (target !== null) {
      if (target.localName === 'a' && target.hasAttribute('target')) {
        ev.stopPropagation();
        ev.preventDefault();
        hit(source);
        break;
      }

      target = target.parentNode;
    }
  });
}
disableNewtabLinks.names = ['disable-newtab-links', // aliases are needed for matching the related scriptlet converted into our syntax
'disable-newtab-links.js', 'ubo-disable-newtab-links.js', 'ubo-disable-newtab-links'];
disableNewtabLinks.injections = [hit];

/* eslint-disable max-len */

/**
 * @scriptlet adjust-setInterval
 *
 * @description
 * Adjusts interval for specified setInterval() callbacks.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-setinterval-boosterjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('adjust-setInterval'[, match [, interval[, boost]]])
 * ```
 *
 * - `match` - optional, string/regular expression, matching in stringified callback function
 * - `interval` - optional, defaults to 1000, matching setInterval delay; decimal integer OR '*' for any delay
 * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down (0.02...50), interval multiplier
 *
 * **Examples**
 * 1. Adjust all setInterval() x20 times where interval equal 1000ms:
 *     ```
 *     example.org#%#//scriptlet('adjust-setInterval')
 *     ```
 *
 * 2. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 1000ms
 *     ```
 *     example.org#%#//scriptlet('adjust-setInterval', 'example')
 *     ```
 *
 * 3. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 400ms
 *     ```
 *     example.org#%#//scriptlet('adjust-setInterval', 'example', '400')
 *     ```
 *
 * 4. Slow down setInterval() x2 times where callback matched with `example` and interval equal 1000ms
 *     ```
 *     example.org#%#//scriptlet('adjust-setInterval', 'example', '', '2')
 *     ```
 * 5. Adjust all setInterval() x50 times where interval equal 2000ms
 *     ```
 *     example.org#%#//scriptlet('adjust-setInterval', '', '2000', '0.02')
 *     ```
 * 6. Adjust all setInterval() x50 times where interval is randomized
 *     ```
 *     example.org#%#//scriptlet('adjust-setInterval', '', '*', '0.02')
 *     ```
 */

/* eslint-enable max-len */

function adjustSetInterval(source, match, interval, boost) {
  var nativeSetInterval = window.setInterval;
  var matchRegexp = toRegExp(match);

  var intervalWrapper = function intervalWrapper(cb, d) {
    if (matchRegexp.test(cb.toString()) && isDelayMatched(interval, d)) {
      d *= getBoostMultiplier(boost);
      hit(source);
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return nativeSetInterval.apply(window, [cb, d].concat(args));
  };

  window.setInterval = intervalWrapper;
}
adjustSetInterval.names = ['adjust-setInterval', // aliases are needed for matching the related scriptlet converted into our syntax
'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js', 'ubo-nano-setInterval-booster', 'ubo-nano-sib'];
adjustSetInterval.injections = [hit, toRegExp, getBoostMultiplier, isDelayMatched, nativeIsNaN, nativeIsFinite, getMatchDelay, getWildcardSymbol, shouldMatchAnyDelay];

/* eslint-disable max-len */

/**
 * @scriptlet adjust-setTimeout
 *
 * @description
 * Adjusts timeout for specified setTimout() callbacks.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-settimeout-boosterjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('adjust-setTimeout'[, match [, timeout[, boost]]])
 * ```
 *
 * - `match` - optional, string/regular expression, matching in stringified callback function
 * - `timeout` - optional, defaults to 1000, matching setTimout delay; decimal integer OR '*' for any delay
 * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down (0.02...50), timeout multiplier
 *
 * **Examples**
 * 1. Adjust all setTimeout() x20 times where timeout equal 1000ms:
 *     ```
 *     example.org#%#//scriptlet('adjust-setTimeout')
 *     ```
 *
 * 2. Adjust all setTimeout() x20 times where callback mathed with `example` and timeout equal 1000ms
 *     ```
 *     example.org#%#//scriptlet('adjust-setTimeout', 'example')
 *     ```
 *
 * 3. Adjust all setTimeout() x20 times where callback mathed with `example` and timeout equal 400ms
 *     ```
 *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '400')
 *     ```
 *
 * 4. Slow down setTimeout() x2 times where callback matched with `example` and timeout equal 1000ms
 *     ```
 *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '', '2')
 *     ```
 * 5. Adjust all setTimeout() x50 times where timeout equal 2000ms
 *     ```
 *     example.org#%#//scriptlet('adjust-setTimeout', '', '2000', '0.02')
 *     ```
 * 6. Adjust all setTimeout() x20 times where callback mathed with `test` and timeout is randomized
 *     ```
 *     example.org#%#//scriptlet('adjust-setTimeout', 'test', '*')
 *     ```
 */

/* eslint-enable max-len */

function adjustSetTimeout(source, match, timeout, boost) {
  var nativeSetTimeout = window.setTimeout;
  var matchRegexp = toRegExp(match);

  var timeoutWrapper = function timeoutWrapper(cb, d) {
    if (matchRegexp.test(cb.toString()) && isDelayMatched(timeout, d)) {
      d *= getBoostMultiplier(boost);
      hit(source);
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return nativeSetTimeout.apply(window, [cb, d].concat(args));
  };

  window.setTimeout = timeoutWrapper;
}
adjustSetTimeout.names = ['adjust-setTimeout', // aliases are needed for matching the related scriptlet converted into our syntax
'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js', 'ubo-nano-setTimeout-booster', 'ubo-nano-stb'];
adjustSetTimeout.injections = [hit, toRegExp, getBoostMultiplier, isDelayMatched, nativeIsNaN, nativeIsFinite, getMatchDelay, getWildcardSymbol, shouldMatchAnyDelay];

/* eslint-disable max-len */

/**
 * @scriptlet dir-string
 *
 * @description
 * Wraps the `console.dir` API to call the `toString` method of the argument.
 * There are several adblock circumvention systems that detect browser devtools
 * and hide themselves. Therefore, if we force them to think
 * that devtools are open (using this scrciptlet),
 * it will automatically disable the adblock circumvention script.
 *
 * Related ABP source:
 * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L766
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('dir-string'[, times])
 * ```
 * - `times` - optional, the number of times to call the `toString` method of the argument to `console.dir`
 *
 * **Example**
 * ```
 * ! Run 2 times
 * example.org#%#//scriptlet('dir-string', '2')
 * ```
 */

/* eslint-enable max-len */

function dirString(source, times) {
  var _console = console,
      dir = _console.dir;
  times = parseInt(times, 10);

  function dirWrapper(object) {
    // eslint-disable-next-line no-unused-vars
    var temp;

    for (var i = 0; i < times; i += 1) {
      // eslint-disable-next-line no-unused-expressions
      temp = "".concat(object);
    }

    if (typeof dir === 'function') {
      dir.call(this, object);
    }

    hit(source, temp);
  } // eslint-disable-next-line no-console


  console.dir = dirWrapper;
}
dirString.names = ['dir-string', 'abp-dir-string'];
dirString.injections = [hit];

/* eslint-disable max-len */

/**
 * @scriptlet json-prune
 *
 * @description
 * Removes specified properties from the result of calling JSON.parse and returns the caller
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prunejs-
 *
 * Related ABP source:
 * https://github.com/adblockplus/adblockpluscore/blob/master/lib/content/snippets.js#L1285
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('json-prune'[, propsToRemove [, obligatoryProps [, stack]]])
 * ```
 *
 * - `propsToRemove` - optional, string of space-separated properties to remove
 * - `obligatoryProps` - optional, string of space-separated properties which must be all present for the pruning to occur
 * - `stack` - optional, string or regular expression that must match the current function call stack trace
 *
 * > Note please that you can use wildcard `*` for chain property name.
 * e.g. 'ad.*.src' instead of 'ad.0.src ad.1.src ad.2.src ...'
 *
 * **Examples**
 * 1. Removes property `example` from the results of JSON.parse call
 *     ```
 *     example.org#%#//scriptlet('json-prune', 'example')
 *     ```
 *
 *     For instance, the following call will return `{ one: 1}`
 *
 *     ```html
 *     JSON.parse('{"one":1,"example":true}')
 *     ```
 *
 * 2. If there are no specified properties in the result of JSON.parse call, pruning will NOT occur
 *     ```
 *     example.org#%#//scriptlet('json-prune', 'one', 'obligatoryProp')
 *     ```
 *
 *     For instance, the following call will return `{ one: 1, two: 2}`
 *
 *     ```html
 *     JSON.parse('{"one":1,"two":2}')
 *     ```
 *
 * 3. A property in a list of properties can be a chain of properties
 *
 *     ```
 *     example.org#%#//scriptlet('json-prune', 'a.b', 'adpath.url.first')
 *     ```
 *
 * 4. Removes property `content.ad` from the results of JSON.parse call it's error stack trace contains `test.js`
 *     ```
 *     example.org#%#//scriptlet('json-prune', 'content.ad', '', 'test.js')
 *     ```
 *
 * 5. A property in a list of properties can be a chain of properties with wildcard in it
 *
 *     ```
 *     example.org#%#//scriptlet('json-prune', 'content.*.media.src', 'content.*.media.preroll')
 *     ```
 *
 * 6. Call with no arguments will log the current hostname and json payload at the console
 *     ```
 *     example.org#%#//scriptlet('json-prune')
 *     ```
 */

/* eslint-enable max-len */

function jsonPrune(source, propsToRemove, requiredInitialProps, stack) {
  if (!!stack && !matchStackTrace(stack, new Error().stack)) {
    return;
  } // eslint-disable-next-line no-console


  var log = console.log.bind(console);
  var prunePaths = propsToRemove !== undefined && propsToRemove !== '' ? propsToRemove.split(/ +/) : [];
  var requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== '' ? requiredInitialProps.split(/ +/) : [];

  function isPruningNeeded(root) {
    if (!root) {
      return false;
    }

    var shouldProcess;

    for (var i = 0; i < requiredPaths.length; i += 1) {
      var requiredPath = requiredPaths[i];
      var lastNestedPropName = requiredPath.split('.').pop();
      var hasWildcard = requiredPath.indexOf('.*.') > -1 || requiredPath.indexOf('*.') > -1 || requiredPath.indexOf('.*') > -1 || requiredPath.indexOf('.[].') > -1 || requiredPath.indexOf('[].') > -1 || requiredPath.indexOf('.[]') > -1; // if the path has wildcard, getPropertyInChain should 'look through' chain props

      var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard); // start value of 'shouldProcess' due to checking below

      shouldProcess = !hasWildcard;

      for (var _i = 0; _i < details.length; _i += 1) {
        if (hasWildcard) {
          // if there is a wildcard,
          // at least one (||) of props chain should be present in object
          shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) || shouldProcess;
        } else {
          // otherwise each one (&&) of them should be there
          shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) && shouldProcess;
        }
      }
    }

    return shouldProcess;
  }
  /**
   * Prunes properties of 'root' object
   * @param {Object} root
   */


  var jsonPruner = function jsonPruner(root) {
    if (prunePaths.length === 0) {
      log(window.location.hostname, root);
      return root;
    }

    try {
      if (isPruningNeeded(root) === false) {
        return root;
      } // if pruning is needed, we check every input pathToRemove
      // and delete it if root has it


      prunePaths.forEach(function (path) {
        var ownerObjArr = getWildcardPropertyInChain(root, path, true);
        ownerObjArr.forEach(function (ownerObj) {
          if (ownerObj !== undefined && ownerObj.base) {
            delete ownerObj.base[ownerObj.prop];
            hit(source);
          }
        });
      });
    } catch (e) {
      log(e.toString());
    }

    return root;
  };

  var nativeJSONParse = JSON.parse;

  var jsonParseWrapper = function jsonParseWrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // dealing with stringified json in args, which should be parsed.
    // so we call nativeJSONParse as JSON.parse which is bound to JSON object
    var root = nativeJSONParse.apply(JSON, args);
    return jsonPruner(root);
  }; // JSON.parse mocking


  jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);
  JSON.parse = jsonParseWrapper; // eslint-disable-next-line compat/compat

  var nativeResponseJson = Response.prototype.json; // eslint-disable-next-line func-names

  var responseJsonWrapper = function responseJsonWrapper() {
    var promise = nativeResponseJson.apply(this);
    return promise.then(function (obj) {
      return jsonPruner(obj);
    });
  }; // do nothing if browser does not support Response (e.g. Internet Explorer)
  // https://developer.mozilla.org/en-US/docs/Web/API/Response


  if (typeof Response === 'undefined') {
    return;
  } // eslint-disable-next-line compat/compat


  Response.prototype.json = responseJsonWrapper;
}
jsonPrune.names = ['json-prune', // aliases are needed for matching the related scriptlet converted into our syntax
'json-prune.js', 'ubo-json-prune.js', 'ubo-json-prune', 'abp-json-prune'];
jsonPrune.injections = [hit, matchStackTrace, getWildcardPropertyInChain, toRegExp, getWildcardSymbol];

/* eslint-disable max-len */

/**
 * @scriptlet prevent-requestAnimationFrame
 *
 * @description
 * Prevents a `requestAnimationFrame` call
 * if the text of the callback is matching the specified search string which does not start with `!`;
 * otherwise mismatched calls should be defused.
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-requestanimationframe-ifjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-requestAnimationFrame'[, search])
 * ```
 *
 * - `search` - optional, string or regular expression.
 * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
 * If do not start with `!`, the stringified callback will be matched.
 *
 * Call with no argument will log all requestAnimationFrame calls while debugging.
 * So do not use the scriptlet without any parameter in production filter lists.
 *
 * **Examples**
 * 1. Prevents `requestAnimationFrame` calls if the callback matches `/\.test/`.
 *     ```bash
 *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '/\.test/')
 *     ```
 *
 *     For instance, the following call will be prevented:
 *     ```javascript
 *     var times = 0;
 *     requestAnimationFrame(function change() {
 *         window.test = 'new value';
 *         if (times < 2) {
 *             times += 1;
 *             requestAnimationFrame(change);
 *         }
 *     });
 *     ```
 * 2. Prevents `requestAnimationFrame` calls if **does not match** 'check'.
 *     ```bash
 *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '!check')
 *     ```
 *
 *     For instance, only the first call will be prevented:
 *
 *     ```javascript
 *     var timesFirst = 0;
 *     requestAnimationFrame(function changeFirst() {
 *         window.check = 'should not be prevented';
 *         if (timesFirst < 2) {
 *             timesFirst += 1;
 *             requestAnimationFrame(changeFirst);
 *         }
 *     });
 *
 *     var timesSecond = 0;
 *     requestAnimationFrame(function changeSecond() {
 *         window.second = 'should be prevented';
 *         if (timesSecond < 2) {
 *             timesSecond += 1;
 *             requestAnimationFrame(changeSecond);
 *         }
 *     });
 *     ```
 */

/* eslint-enable max-len */

function preventRequestAnimationFrame(source, match) {
  var nativeRequestAnimationFrame = window.requestAnimationFrame; // logs requestAnimationFrame to console if no arguments have been specified

  var shouldLog = typeof match === 'undefined';

  var _parseMatchArg = parseMatchArg(match),
      isInvertedMatch = _parseMatchArg.isInvertedMatch,
      matchRegexp = _parseMatchArg.matchRegexp;

  var rafWrapper = function rafWrapper(callback) {
    var shouldPrevent = false;

    if (shouldLog) {
      var logMessage = "log: requestAnimationFrame(\"".concat(callback.toString(), "\")");
      hit(source, logMessage);
    } else {
      shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;
    }

    if (shouldPrevent) {
      hit(source);
      return nativeRequestAnimationFrame(noopFunc);
    }

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return nativeRequestAnimationFrame.apply(window, [callback].concat(args));
  };

  window.requestAnimationFrame = rafWrapper;
}
preventRequestAnimationFrame.names = ['prevent-requestAnimationFrame', // aliases are needed for matching the related scriptlet converted into our syntax
'no-requestAnimationFrame-if.js', 'ubo-no-requestAnimationFrame-if.js', 'norafif.js', 'ubo-norafif.js', 'ubo-no-requestAnimationFrame-if', 'ubo-norafif'];
preventRequestAnimationFrame.injections = [hit, noopFunc, parseMatchArg, toRegExp, startsWith];

/* eslint-disable max-len */

/**
 * @scriptlet set-cookie
 *
 * @description
 * Sets a cookie with the specified name and value. Cookie path defaults to root.
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('set-cookie', name, value)
 * ```
 *
 * - `name` - required, cookie name to be set
 * - `value` - required, cookie value; possible values:
 *     - number `>= 0 && <= 15`
 *     - one of the predefined constants:
 *         - `true` / `True`
 *         - `false` / `False`
 *         - `yes` / `Yes` / `Y`
 *         - `no`
 *         - `ok` / `OK`
 *
 * **Examples**
 * ```
 * example.org#%#//scriptlet('set-cookie', 'ReadlyCookieConsent', '1'
 *
 * example.org#%#//scriptlet('set-cookie', 'gdpr-settings-cookie', 'true')
 * ```
 */

/* eslint-enable max-len */

function setCookie(source, name, value) {
  var cookieData = prepareCookie(name, value);

  if (cookieData) {
    hit(source);
    document.cookie = cookieData;
  }
}
setCookie.names = ['set-cookie'];
setCookie.injections = [hit, nativeIsNaN, prepareCookie];

/**
 * @scriptlet set-cookie-reload
 *
 * @description
 * Sets a cookie with the specified name and value, and then reloads the current page.
 * If reloading option is not needed, use [set-cookie](#set-cookie) scriptlet.
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('set-cookie-reload', name, value)
 * ```
 *
 * - `name` - required, cookie name to be set
 * - `value` - required, cookie value; possible values:
 *     - number `>= 0 && <= 15`
 *     - one of the predefined constants:
 *         - `true` / `True`
 *         - `false` / `False`
 *         - `yes` / `Yes` / `Y`
 *         - `no`
 *         - `ok` / `OK`
 *
 * **Examples**
 * ```
 * example.org#%#//scriptlet('set-cookie-reload', 'checking', 'ok')
 *
 * example.org#%#//scriptlet('set-cookie-reload', 'gdpr-settings-cookie', '1')
 * ```
 */

function setCookieReload(source, name, value) {
  var isCookieAlreadySet = document.cookie.split(';').some(function (cookieStr) {
    var pos = cookieStr.indexOf('=');

    if (pos === -1) {
      return false;
    }

    var cookieName = cookieStr.slice(0, pos).trim();
    var cookieValue = cookieStr.slice(pos + 1).trim();
    return name === cookieName && value === cookieValue;
  });
  var shouldReload = !isCookieAlreadySet;
  var cookieData = prepareCookie(name, value);

  if (cookieData) {
    hit(source);
    document.cookie = cookieData;

    if (shouldReload) {
      window.location.reload();
    }
  }
}
setCookieReload.names = ['set-cookie-reload'];
setCookieReload.injections = [hit, nativeIsNaN, prepareCookie];

/**
 * @scriptlet hide-in-shadow-dom
 *
 * @description
 * Hides elements inside open shadow DOM elements.
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('hide-in-shadow-dom', selector[, baseSelector])
 * ```
 *
 * - `selector` — required, CSS selector of element in shadow-dom to hide
 * - `baseSelector` — optional, selector of specific page DOM element,
 * narrows down the part of the page DOM where shadow-dom host supposed to be,
 * defaults to document.documentElement
 *
 * > `baseSelector` should match element of the page DOM, but not of shadow DOM
 *
 * **Examples**
 * ```
 * ! hides menu bar
 * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')
 *
 * ! hides floating element
 * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'vt-ui-contact-fab')
 * ```
 */

function hideInShadowDom(source, selector, baseSelector) {
  // do nothing if browser does not support ShadowRoot
  // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot
  if (!Element.prototype.attachShadow) {
    return;
  }

  var hideElement = function hideElement(targetElement) {
    var DISPLAY_NONE_CSS = 'display:none!important;';
    targetElement.style.cssText = DISPLAY_NONE_CSS;
  };
  /**
   * Handles shadow-dom piercing and hiding of found elements
   */


  var hideHandler = function hideHandler() {
    // start value of shadow-dom hosts for the page dom
    var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector); // if there is shadow-dom host, they should be explored

    while (hostElements.length !== 0) {
      var isHidden = false;

      var _pierceShadowDom = pierceShadowDom(selector, hostElements),
          targets = _pierceShadowDom.targets,
          innerHosts = _pierceShadowDom.innerHosts;

      targets.forEach(function (targetEl) {
        hideElement(targetEl);
        isHidden = true;
      });

      if (isHidden) {
        hit(source);
      } // continue to pierce for inner shadow-dom hosts
      // and search inside them while the next iteration


      hostElements = innerHosts;
    }
  };

  hideHandler();
  observeDOMChanges(hideHandler, true);
}
hideInShadowDom.names = ['hide-in-shadow-dom'];
hideInShadowDom.injections = [hit, observeDOMChanges, flatten, findHostElements, pierceShadowDom];

/**
 * @scriptlet remove-in-shadow-dom
 *
 * @description
 * Removes elements inside open shadow DOM elements.
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('remove-in-shadow-dom', selector[, baseSelector])
 * ```
 *
 * - `selector` — required, CSS selector of element in shadow-dom to remove
 * - `baseSelector` — optional, selector of specific page DOM element,
 * narrows down the part of the page DOM where shadow-dom host supposed to be,
 * defaults to document.documentElement
 *
 * > `baseSelector` should match element of the page DOM, but not of shadow DOM
 *
 * **Examples**
 * ```
 * ! removes menu bar
 * virustotal.com#%#//scriptlet('remove-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')
 *
 * ! removes floating element
 * virustotal.com#%#//scriptlet('remove-in-shadow-dom', 'vt-ui-contact-fab')
 * ```
 */

function removeInShadowDom(source, selector, baseSelector) {
  // do nothing if browser does not support ShadowRoot
  // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot
  if (!Element.prototype.attachShadow) {
    return;
  }

  var removeElement = function removeElement(targetElement) {
    targetElement.remove();
  };
  /**
   * Handles shadow-dom piercing and removing of found elements
   */


  var removeHandler = function removeHandler() {
    // start value of shadow-dom hosts for the page dom
    var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector); // if there is shadow-dom host, they should be explored

    while (hostElements.length !== 0) {
      var isRemoved = false;

      var _pierceShadowDom = pierceShadowDom(selector, hostElements),
          targets = _pierceShadowDom.targets,
          innerHosts = _pierceShadowDom.innerHosts;

      targets.forEach(function (targetEl) {
        removeElement(targetEl);
        isRemoved = true;
      });

      if (isRemoved) {
        hit(source);
      } // continue to pierce for inner shadow-dom hosts
      // and search inside them while the next iteration


      hostElements = innerHosts;
    }
  };

  removeHandler();
  observeDOMChanges(removeHandler, true);
}
removeInShadowDom.names = ['remove-in-shadow-dom'];
removeInShadowDom.injections = [hit, observeDOMChanges, flatten, findHostElements, pierceShadowDom];

/**
 * @scriptlet no-floc
 *
 * @description
 * Prevents using Google Chrome tracking feature called Federated Learning of Cohorts (aka "FLoC")
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-flocjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('no-floc')
 * ```
 */

function noFloc(source) {
  var FLOC_PROPERTY_NAME = 'interestCohort';

  if (Document instanceof Object === false) {
    return;
  }

  if (!Object.prototype.hasOwnProperty.call(Document.prototype, FLOC_PROPERTY_NAME) || Document.prototype[FLOC_PROPERTY_NAME] instanceof Function === false) {
    return;
  } // document.interestCohort() is async function so it's better to return Promise.reject()
  // https://github.com/WICG/floc/blob/dcd4c042fa6a81b048e04a78b184ea4203a75219/README.md


  Document.prototype[FLOC_PROPERTY_NAME] = noopPromiseReject;
  hit(source);
}
noFloc.names = ['no-floc', // aliases are needed for matching the related scriptlet converted into our syntax
'no-floc.js', 'ubo-no-floc.js', 'ubo-no-floc'];
noFloc.injections = [hit, noopPromiseReject];

/* eslint-disable max-len */

/**
 * @scriptlet prevent-fetch
 *
 * @description
 * Prevents `fetch` calls if **all** given parameters match
 *
 * Related UBO scriptlet:
 * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-fetch-ifjs-
 *
 * **Syntax**
 * ```
 * example.org#%#//scriptlet('prevent-fetch'[, propsToMatch])
 * ```
 *
 * - `propsToMatch` - optional, string of space-separated properties to match; possible props:
 *   - string or regular expression for matching the URL passed to fetch call; empty string or wildcard `*` for all fetch calls match
 *   - colon-separated pairs `name:value` where
 *     - `name` is [`init` option name](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters)
 *     - `value` is string or regular expression for matching the value of the option passed to fetch call
 *
 * > Usage with no arguments will log fetch calls to browser console;
 * which is usefull for debugging but permitted for production filter lists.
 *
 * **Examples**
 * 1. Prevent all fetch calls
 *     ```
 *     example.org#%#//scriptlet('prevent-fetch', '*')
 *     ```
 *
 * 2. Prevent fetch call for specific url
 *     ```
 *     example.org#%#//scriptlet('prevent-fetch', '/url\\.part/')
 *     ```
 *
 * 3. Prevent fetch call for specific request method
 *     ```
 *     example.org#%#//scriptlet('prevent-fetch', 'method:HEAD')
 *     ```
 *
 * 4. Prevent fetch call for specific url and request method
 *     ```
 *     example.org#%#//scriptlet('prevent-fetch', '/specified_url_part/ method:/HEAD|GET/')
 *     ```
 */

/* eslint-enable max-len */

function preventFetch(source, propsToMatch) {
  // do nothing if browser does not support fetch or Proxy (e.g. Internet Explorer)
  // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
  if (typeof fetch === 'undefined' || typeof Proxy === 'undefined') {
    return;
  }

  var handlerWrapper = function handlerWrapper(target, thisArg, args) {
    var shouldPrevent = false;
    var fetchData = getFetchData(args);

    if (typeof propsToMatch === 'undefined') {
      // log if no propsToMatch given
      var logMessage = "log: fetch( ".concat(objectToString(fetchData), " )");
      hit(source, logMessage);
    } else if (propsToMatch === '' || propsToMatch === getWildcardSymbol()) {
      // prevent all fetch calls
      shouldPrevent = true;
    } else {
      var matchData = convertMatchPropsToObj(propsToMatch); // prevent only if all props match

      shouldPrevent = Object.keys(matchData).every(function (matchKey) {
        var matchValue = matchData[matchKey];
        return Object.prototype.hasOwnProperty.call(fetchData, matchKey) && matchValue.test(fetchData[matchKey]);
      });
    }

    if (shouldPrevent) {
      hit(source);
      return noopPromiseResolve();
    }

    return Reflect.apply(target, thisArg, args);
  };

  var fetchHandler = {
    apply: handlerWrapper
  };
  fetch = new Proxy(fetch, fetchHandler); // eslint-disable-line no-global-assign
}
preventFetch.names = ['prevent-fetch', // aliases are needed for matching the related scriptlet converted into our syntax
'no-fetch-if.js', 'ubo-no-fetch-if.js', 'ubo-no-fetch-if'];
preventFetch.injections = [hit, getFetchData, objectToString, convertMatchPropsToObj, noopPromiseResolve, getWildcardSymbol, toRegExp, isEmptyObject, getRequestData, getObjectEntries, getObjectFromEntries];

/**
 * This file must export all scriptlets which should be accessible
 */

var scriptletList = /*#__PURE__*/Object.freeze({
    __proto__: null,
    abortOnPropertyRead: abortOnPropertyRead,
    abortOnPropertyWrite: abortOnPropertyWrite,
    preventSetTimeout: preventSetTimeout,
    preventSetInterval: preventSetInterval,
    preventWindowOpen: preventWindowOpen,
    abortCurrentInlineScript: abortCurrentInlineScript,
    setConstant: setConstant,
    removeCookie: removeCookie,
    preventAddEventListener: preventAddEventListener,
    preventBab: preventBab,
    nowebrtc: nowebrtc,
    logAddEventListener: logAddEventListener,
    logEval: logEval,
    log: log,
    noeval: noeval,
    preventEvalIf: preventEvalIf,
    preventFab: preventFab,
    setPopadsDummy: setPopadsDummy,
    preventPopadsNet: preventPopadsNet,
    preventAdfly: preventAdfly,
    debugOnPropertyRead: debugOnPropertyRead,
    debugOnPropertyWrite: debugOnPropertyWrite,
    debugCurrentInlineScript: debugCurrentInlineScript,
    removeAttr: removeAttr,
    removeClass: removeClass,
    disableNewtabLinks: disableNewtabLinks,
    adjustSetInterval: adjustSetInterval,
    adjustSetTimeout: adjustSetTimeout,
    dirString: dirString,
    jsonPrune: jsonPrune,
    preventRequestAnimationFrame: preventRequestAnimationFrame,
    setCookie: setCookie,
    setCookieReload: setCookieReload,
    hideInShadowDom: hideInShadowDom,
    removeInShadowDom: removeInShadowDom,
    noFloc: noFloc,
    preventFetch: preventFetch
});

/**
 * Store of ADG redirects names and thier analogs.
 * As it is not a compatibility table, no need to keep in redirects array third-party redirects.
 *
 * Needed only for converion purposes.
 * e.g. googletagmanager-gtm is removed and should be removed from compatibility table as well
 * but now it works as alias for google-analytics so it should stay valid for compiler
 */
var redirects = [{
  adg: '1x1-transparent.gif',
  ubo: '1x1.gif',
  abp: '1x1-transparent-gif'
}, {
  adg: '2x2-transparent.png',
  ubo: '2x2.png',
  abp: '2x2-transparent-png'
}, {
  adg: '3x2-transparent.png',
  ubo: '3x2.png',
  abp: '3x2-transparent-png'
}, {
  adg: '32x32-transparent.png',
  ubo: '32x32.png',
  abp: '32x32-transparent-png'
}, {
  adg: 'amazon-apstag',
  ubo: 'amazon_apstag.js'
}, {
  adg: 'google-analytics',
  ubo: 'google-analytics_analytics.js'
}, {
  adg: 'google-analytics-ga',
  ubo: 'google-analytics_ga.js'
}, {
  adg: 'googlesyndication-adsbygoogle',
  ubo: 'googlesyndication_adsbygoogle.js'
}, {
  // https://github.com/AdguardTeam/Scriptlets/issues/127
  adg: 'googletagmanager-gtm',
  ubo: 'google-analytics_ga.js'
}, {
  adg: 'googletagservices-gpt',
  ubo: 'googletagservices_gpt.js'
}, {
  adg: 'metrika-yandex-watch'
}, {
  adg: 'metrika-yandex-tag'
}, {
  adg: 'noeval',
  ubo: 'noeval-silent.js'
}, {
  adg: 'noopcss',
  abp: 'blank-css'
}, {
  adg: 'noopframe',
  ubo: 'noop.html',
  abp: 'blank-html'
}, {
  adg: 'noopjs',
  ubo: 'noop.js',
  abp: 'blank-js'
}, {
  adg: 'nooptext',
  ubo: 'noop.txt',
  abp: 'blank-text'
}, {
  adg: 'noopmp3-0.1s',
  ubo: 'noop-0.1s.mp3',
  abp: 'blank-mp3'
}, {
  adg: 'noopmp4-1s',
  ubo: 'noop-1s.mp4',
  abp: 'blank-mp4'
}, {
  adg: 'noopvmap-1.0',
  ubo: 'noop-vmap1.0.xml'
}, {
  adg: 'noopvast-2.0'
}, {
  adg: 'noopvast-3.0'
}, {
  adg: 'prevent-bab',
  ubo: 'nobab.js'
}, {
  adg: 'prevent-fab-3.2.0',
  ubo: 'nofab.js'
}, {
  adg: 'prevent-popads-net',
  ubo: 'popads.js'
}, {
  adg: 'scorecardresearch-beacon',
  ubo: 'scorecardresearch_beacon.js'
}, {
  adg: 'set-popads-dummy',
  ubo: 'popads-dummy.js'
}, {
  adg: 'empty',
  ubo: 'empty'
}];

var JS_RULE_MARKER = '#%#';
var COMMENT_MARKER = '!';
/**
 * Checks if rule text is comment e.g. !!example.org##+js(set-constant.js, test, false)
 * @param {string} rule
 * @return {boolean}
 */

var isComment = function isComment(rule) {
  return startsWith(rule, COMMENT_MARKER);
};
/* ************************************************************************
 *
 * Scriptlets
 *
 ************************************************************************** */

/**
 * uBlock scriptlet rule mask
 */


var UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\s*\+js/;
var UBO_SCRIPTLET_MASK_1 = '##+js';
var UBO_SCRIPTLET_MASK_2 = '##script:inject';
var UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';
var UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';
/**
 * AdBlock Plus snippet rule mask
 */

var ABP_SCRIPTLET_MASK = '#$#';
var ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';
/**
 * AdGuard CSS rule mask
 */

var ADG_CSS_MASK_REG = /#@?\$#.+?\s*\{.*\}\s*$/g;
/**
 * Checks if the `rule` is AdGuard scriptlet rule
 * @param {string} rule - rule text
 */

var isAdgScriptletRule = function isAdgScriptletRule(rule) {
  return !isComment(rule) && rule.indexOf(ADG_SCRIPTLET_MASK) > -1;
};
/**
 * Checks if the `rule` is uBO scriptlet rule
 * @param {string} rule rule text
 */


var isUboScriptletRule = function isUboScriptletRule(rule) {
  return (rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);
};
/**
 * Checks if the `rule` is AdBlock Plus snippet
 * @param {string} rule rule text
 */


var isAbpSnippetRule = function isAbpSnippetRule(rule) {
  return (rule.indexOf(ABP_SCRIPTLET_MASK) > -1 || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);
};
/**
 * Finds scriptlet by it's name
 * @param {string} name - scriptlet name
 */


var getScriptletByName = function getScriptletByName(name) {
  var scriptlets = Object.keys(scriptletList).map(function (key) {
    return scriptletList[key];
  });
  return scriptlets.find(function (s) {
    return s.names // full match name checking
    && (s.names.indexOf(name) > -1 // or check ubo alias name without '.js' at the end
    || !endsWith(name, '.js') && s.names.indexOf("".concat(name, ".js")) > -1);
  });
};
/**
 * Checks if the scriptlet name is valid
 * @param {string} name - Scriptlet name
 */


var isValidScriptletName = function isValidScriptletName(name) {
  if (!name) {
    return false;
  }

  var scriptlet = getScriptletByName(name);

  if (!scriptlet) {
    return false;
  }

  return true;
};
/* ************************************************************************
 *
 * Redirects
 *
 ************************************************************************** */

/**
 * Redirect resources markers
 */


var ADG_UBO_REDIRECT_MARKER = 'redirect=';
var ABP_REDIRECT_MARKER = 'rewrite=abp-resource:';
var EMPTY_REDIRECT_MARKER = 'empty';
var VALID_SOURCE_TYPES = ['image', 'media', 'subdocument', 'stylesheet', 'script', 'xmlhttprequest', 'other'];
/**
 * Source types for redirect rules if there is no one of them.
 * Used for ADG -> UBO conversion.
 */

var ABSENT_SOURCE_TYPE_REPLACEMENT = [{
  NAME: 'nooptext',
  TYPES: VALID_SOURCE_TYPES
}, {
  NAME: 'noopjs',
  TYPES: ['script']
}, {
  NAME: 'noopframe',
  TYPES: ['subdocument']
}, {
  NAME: '1x1-transparent.gif',
  TYPES: ['image']
}, {
  NAME: 'noopmp3-0.1s',
  TYPES: ['media']
}, {
  NAME: 'noopmp4-1s',
  TYPES: ['media']
}, {
  NAME: 'googlesyndication-adsbygoogle',
  TYPES: ['xmlhttprequest', 'script']
}, {
  NAME: 'google-analytics',
  TYPES: ['script']
}, {
  NAME: 'googletagservices-gpt',
  TYPES: ['script']
}];
var validAdgRedirects = redirects.filter(function (el) {
  return el.adg;
});
/**
 * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names
 * It's used for UBO -> ADG converting
 */

var uboToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
  return el.ubo;
}).map(function (el) {
  return [el.ubo, el.adg];
}));
/**
 * Compatibility object where KEYS = ABP redirect names and VALUES = ADG redirect names
 * It's used for ABP -> ADG converting
 */

var abpToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
  return el.abp;
}).map(function (el) {
  return [el.abp, el.adg];
}));
/**
 * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names
 * It's used for ADG -> UBO converting
 */

var adgToUboCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {
  return el.ubo;
}).map(function (el) {
  return [el.adg, el.ubo];
}));
/**
 * Needed for AdGuard redirect names validation where KEYS = **valid** AdGuard redirect names
 * 'adgToUboCompatibility' is still needed for ADG -> UBO converting
 */

var validAdgCompatibility = getObjectFromEntries(validAdgRedirects.map(function (el) {
  return [el.adg, 'valid adg redirect'];
}));
var REDIRECT_RULE_TYPES = {
  VALID_ADG: {
    marker: ADG_UBO_REDIRECT_MARKER,
    compatibility: validAdgCompatibility
  },
  ADG: {
    marker: ADG_UBO_REDIRECT_MARKER,
    compatibility: adgToUboCompatibility
  },
  UBO: {
    marker: ADG_UBO_REDIRECT_MARKER,
    compatibility: uboToAdgCompatibility
  },
  ABP: {
    marker: ABP_REDIRECT_MARKER,
    compatibility: abpToAdgCompatibility
  }
};
/**
 * Parses redirect rule modifiers
 * @param {string} rule
 * @returns {Array}
 */

var parseModifiers = function parseModifiers(rule) {
  return substringAfter(rule, '$').split(',');
};
/**
 * Gets redirect resource name
 * @param {string} rule
 * @param {string} marker - specific Adg/Ubo or Abp redirect resources marker
 * @returns {string} - redirect resource name
 */


var getRedirectName = function getRedirectName(rule, marker) {
  var ruleModifiers = parseModifiers(rule);
  var redirectNamePart = ruleModifiers.find(function (el) {
    return el.indexOf(marker) > -1;
  });
  return substringAfter(redirectNamePart, marker);
};
/**
 * Checks if the `rule` is AdGuard redirect rule.
 * Discards comments and JS rules and checks if the `rule` has 'redirect' modifier.
 * @param {string} rule - rule text
 */


var isAdgRedirectRule = function isAdgRedirectRule(rule) {
  var MARKER_IN_BASE_PART_MASK = '/((?!\\$|\\,).{1})redirect=(.{0,}?)\\$(popup)?/';
  return !isComment(rule) && rule.indexOf(REDIRECT_RULE_TYPES.ADG.marker) > -1 // some js rules may have 'redirect=' in it, so we should get rid of them
  && rule.indexOf(JS_RULE_MARKER) === -1 // get rid of rules like '_redirect=*://look.$popup'
  && !toRegExp(MARKER_IN_BASE_PART_MASK).test(rule);
};
/**
 * Checks if the `rule` satisfies the `type`
 * @param {string} rule - rule text
 * @param {'VALID_ADG'|'ADG'|'UBO'|'ABP'} type - type of a redirect rule
 */


var isRedirectRuleByType = function isRedirectRuleByType(rule, type) {
  var _REDIRECT_RULE_TYPES$ = REDIRECT_RULE_TYPES[type],
      marker = _REDIRECT_RULE_TYPES$.marker,
      compatibility = _REDIRECT_RULE_TYPES$.compatibility;

  if (rule && !isComment(rule) && rule.indexOf(marker) > -1) {
    var redirectName = getRedirectName(rule, marker);

    if (!redirectName) {
      return false;
    }

    return redirectName === Object.keys(compatibility).find(function (el) {
      return el === redirectName;
    });
  }

  return false;
};
/**
* Checks if the `rule` is **valid** AdGuard redirect resource rule
* @param {string} rule - rule text
* @returns {boolean}
*/


var isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {
  return isRedirectRuleByType(rule, 'VALID_ADG');
};
/**
* Checks if the AdGuard redirect `rule` has Ubo analog. Needed for Adg->Ubo conversion
* @param {string} rule - AdGuard rule text
* @returns {boolean} - true if the rule can be converted to Ubo
*/


var isAdgRedirectCompatibleWithUbo = function isAdgRedirectCompatibleWithUbo(rule) {
  return isAdgRedirectRule(rule) && isRedirectRuleByType(rule, 'ADG');
};
/**
* Checks if the Ubo redirect `rule` has AdGuard analog. Needed for Ubo->Adg conversion
* @param {string} rule - Ubo rule text
* @returns {boolean} - true if the rule can be converted to AdGuard
*/


var isUboRedirectCompatibleWithAdg = function isUboRedirectCompatibleWithAdg(rule) {
  return isRedirectRuleByType(rule, 'UBO');
};
/**
* Checks if the Abp redirect `rule` has AdGuard analog. Needed for Abp->Adg conversion
* @param {string} rule - Abp rule text
* @returns {boolean} - true if the rule can be converted to AdGuard
*/


var isAbpRedirectCompatibleWithAdg = function isAbpRedirectCompatibleWithAdg(rule) {
  return isRedirectRuleByType(rule, 'ABP');
};
/**
 * Checks if the rule has specified content type before Adg -> Ubo conversion.
 *
 * Used ONLY for Adg -> Ubo conversion
 * because Ubo redirect rules must contain content type, but Adg and Abp must not.
 *
 * Also source type can not be added automatically because of such valid rules:
 * ! Abp:
 * $rewrite=abp-resource:blank-js,xmlhttprequest
 * ! Adg:
 * $script,redirect=noopvast-2.0
 * $xmlhttprequest,redirect=noopvast-2.0
 *
 * @param {string} rule
 * @returns {boolean}
 */


var hasValidContentType = function hasValidContentType(rule) {
  var ruleModifiers = parseModifiers(rule); // rule can have more than one source type modifier

  var sourceTypes = ruleModifiers.filter(function (el) {
    return VALID_SOURCE_TYPES.indexOf(el) > -1;
  });
  var isSourceTypeSpecified = sourceTypes.length > 0;
  var isEmptyRedirect = ruleModifiers.indexOf("".concat(ADG_UBO_REDIRECT_MARKER).concat(EMPTY_REDIRECT_MARKER)) > -1;

  if (isEmptyRedirect) {
    // no source type for 'empty' is allowed
    return true;
  }

  return isSourceTypeSpecified;
};

var validator = {
  UBO_SCRIPTLET_MASK_REG: UBO_SCRIPTLET_MASK_REG,
  ABP_SCRIPTLET_MASK: ABP_SCRIPTLET_MASK,
  ABP_SCRIPTLET_EXCEPTION_MASK: ABP_SCRIPTLET_EXCEPTION_MASK,
  isComment: isComment,
  isAdgScriptletRule: isAdgScriptletRule,
  isUboScriptletRule: isUboScriptletRule,
  isAbpSnippetRule: isAbpSnippetRule,
  getScriptletByName: getScriptletByName,
  isValidScriptletName: isValidScriptletName,
  REDIRECT_RULE_TYPES: REDIRECT_RULE_TYPES,
  ABSENT_SOURCE_TYPE_REPLACEMENT: ABSENT_SOURCE_TYPE_REPLACEMENT,
  isAdgRedirectRule: isAdgRedirectRule,
  isValidAdgRedirectRule: isValidAdgRedirectRule,
  isAdgRedirectCompatibleWithUbo: isAdgRedirectCompatibleWithUbo,
  isUboRedirectCompatibleWithAdg: isUboRedirectCompatibleWithAdg,
  isAbpRedirectCompatibleWithAdg: isAbpRedirectCompatibleWithAdg,
  parseModifiers: parseModifiers,
  getRedirectName: getRedirectName,
  hasValidContentType: hasValidContentType
};

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var arrayLikeToArray = _arrayLikeToArray;

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

var unsupportedIterableToArray = _unsupportedIterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var nonIterableRest = _nonIterableRest;

function _toArray(arr) {
  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
}

var toArray = _toArray;

/**
 * AdGuard scriptlet rule
 */

var ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\/\/scriptlet\(.+\)/; // eslint-disable-next-line no-template-curly-in-string

var ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})'; // eslint-disable-next-line no-template-curly-in-string

var ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';
/**
 * uBlock scriptlet rule mask
 */
// eslint-disable-next-line no-template-curly-in-string

var UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})'; // eslint-disable-next-line no-template-curly-in-string

var UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';
var UBO_ALIAS_NAME_MARKER = 'ubo-';
var UBO_SCRIPTLET_JS_ENDING = '.js'; // https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#xhr

var UBO_XHR_TYPE = 'xhr';
var ADG_XHR_TYPE = 'xmlhttprequest';
var ADG_SET_CONSTANT_NAME = 'set-constant';
var ADG_SET_CONSTANT_EMPTY_STRING = '';
var UBO_SET_CONSTANT_EMPTY_STRING = '\'\'';
var ADG_PREVENT_FETCH_NAME = 'prevent-fetch';
var ADG_PREVENT_FETCH_EMPTY_STRING = '';
var ADG_PREVENT_FETCH_WILDCARD = getWildcardSymbol();
var UBO_NO_FETCH_IF_WILDCARD = '/^/';
var ESCAPED_COMMA_SEPARATOR = '\\,';
var COMMA_SEPARATOR = ',';
var MAX_REMOVE_ATTR_CLASS_ARGS_COUNT = 3;
var REMOVE_ATTR_METHOD = 'removeAttr';
var REMOVE_CLASS_METHOD = 'removeClass';
var REMOVE_ATTR_ALIASES = scriptletList[REMOVE_ATTR_METHOD].names;
var REMOVE_CLASS_ALIASES = scriptletList[REMOVE_CLASS_METHOD].names;
var ADG_REMOVE_ATTR_NAME = REMOVE_ATTR_ALIASES[0];
var ADG_REMOVE_CLASS_NAME = REMOVE_CLASS_ALIASES[0];
/**
 * Returns array of strings separated by space which not in quotes
 * @param {string} str
 */

var getSentences = function getSentences(str) {
  var reg = /'.*?'|".*?"|\S+/g;
  return str.match(reg);
};
/**
 * Replaces string with data by placeholders
 * @param {string} str
 * @param {Object} data - where keys are placeholders names
 */


var replacePlaceholders = function replacePlaceholders(str, data) {
  return Object.keys(data).reduce(function (acc, key) {
    var reg = new RegExp("\\$\\{".concat(key, "\\}"), 'g');
    acc = acc.replace(reg, data[key]);
    return acc;
  }, str);
};
/**
 * Converts string of UBO scriptlet rule to AdGuard scritlet rule
 * @param {string} rule - UBO scriptlet rule
 * @returns {Array} - array with one AdGuard scriptlet rule
 */


var convertUboScriptletToAdg = function convertUboScriptletToAdg(rule) {
  var domains = getBeforeRegExp(rule, validator.UBO_SCRIPTLET_MASK_REG);
  var mask = rule.match(validator.UBO_SCRIPTLET_MASK_REG)[0];
  var template;

  if (mask.indexOf('@') > -1) {
    template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
  } else {
    template = ADGUARD_SCRIPTLET_TEMPLATE;
  }

  var parsedArgs = getStringInBraces(rule).split(/,\s/g);

  if (parsedArgs.length === 1) {
    // Most probably this is not correct separator, in this case we use ','
    parsedArgs = getStringInBraces(rule).split(/,/g);
  }

  var scriptletName = parsedArgs[0].indexOf(UBO_SCRIPTLET_JS_ENDING) > -1 ? "ubo-".concat(parsedArgs[0]) : "ubo-".concat(parsedArgs[0]).concat(UBO_SCRIPTLET_JS_ENDING);

  if ((REMOVE_ATTR_ALIASES.indexOf(scriptletName) > -1 || REMOVE_CLASS_ALIASES.indexOf(scriptletName) > -1) && parsedArgs.length > MAX_REMOVE_ATTR_CLASS_ARGS_COUNT) {
    parsedArgs = [parsedArgs[0], parsedArgs[1], // if there are more than 3 args for remove-attr/class scriptlet,
    // ubo rule has maltiple selector separated by comma. so we should:
    // 1. join them into a single string
    // 2. replace escaped commas by regular ones
    // https://github.com/AdguardTeam/Scriptlets/issues/133
    replaceAll(parsedArgs.slice(2).join("".concat(COMMA_SEPARATOR, " ")), ESCAPED_COMMA_SEPARATOR, COMMA_SEPARATOR)];
  }

  var args = parsedArgs.map(function (arg, index) {
    var outputArg = arg;

    if (index === 0) {
      outputArg = scriptletName;
    } // for example: dramaserial.xyz##+js(abort-current-inline-script, $, popup)


    if (arg === '$') {
      outputArg = '$$';
    }

    return outputArg;
  }).map(function (arg) {
    return wrapInSingleQuotes(arg);
  }).join("".concat(COMMA_SEPARATOR, " "));
  var adgRule = replacePlaceholders(template, {
    domains: domains,
    args: args
  });
  return [adgRule];
};
/**
 * Convert string of ABP snippet rule to AdGuard scritlet rule
 * @param {string} rule - ABP snippet rule
 * @returns {Array} - array of AdGuard scriptlet rules -
 * one or few items depends on Abp-rule
 */

var convertAbpSnippetToAdg = function convertAbpSnippetToAdg(rule) {
  var SEMICOLON_DIVIDER = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/g;
  var mask = rule.indexOf(validator.ABP_SCRIPTLET_MASK) > -1 ? validator.ABP_SCRIPTLET_MASK : validator.ABP_SCRIPTLET_EXCEPTION_MASK;
  var template = mask === validator.ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
  var domains = substringBefore(rule, mask);
  var args = substringAfter(rule, mask);
  return args.split(SEMICOLON_DIVIDER).map(function (args) {
    return getSentences(args).filter(function (arg) {
      return arg;
    }).map(function (arg, index) {
      return index === 0 ? "abp-".concat(arg) : arg;
    }).map(function (arg) {
      return wrapInSingleQuotes(arg);
    }).join("".concat(COMMA_SEPARATOR, " "));
  }).map(function (args) {
    return replacePlaceholders(template, {
      domains: domains,
      args: args
    });
  });
};
/**
 * Converts scriptlet rule to AdGuard one
 * @param {string} rule
 * @returns {Array} - array of AdGuard scriptlet rules -
 * one item for Adg and Ubo or few items for Abp
 */

var convertScriptletToAdg = function convertScriptletToAdg(rule) {
  var result;

  if (validator.isUboScriptletRule(rule)) {
    result = convertUboScriptletToAdg(rule);
  } else if (validator.isAbpSnippetRule(rule)) {
    result = convertAbpSnippetToAdg(rule);
  } else if (validator.isAdgScriptletRule(rule) || validator.isComment(rule)) {
    result = [rule];
  }

  return result;
};
/**
 * Converts UBO scriptlet rule to AdGuard one
 * @param {string} rule - AdGuard scriptlet rule
 * @returns {string} - UBO scriptlet rule
 */

var convertAdgScriptletToUbo = function convertAdgScriptletToUbo(rule) {
  var res;

  if (validator.isAdgScriptletRule(rule)) {
    var _parseRule = parseRule(rule),
        parsedName = _parseRule.name,
        parsedParams = _parseRule.args;

    var preparedParams; // https://github.com/AdguardTeam/FiltersCompiler/issues/102

    if (parsedName === ADG_SET_CONSTANT_NAME && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_STRING) {
      preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_STRING];
    } else if (parsedName === ADG_PREVENT_FETCH_NAME // https://github.com/AdguardTeam/Scriptlets/issues/109
    && (parsedParams[0] === ADG_PREVENT_FETCH_WILDCARD || parsedParams[0] === ADG_PREVENT_FETCH_EMPTY_STRING)) {
      preparedParams = [UBO_NO_FETCH_IF_WILDCARD];
    } else if ((parsedName === ADG_REMOVE_ATTR_NAME || parsedName === ADG_REMOVE_CLASS_NAME) && parsedParams[1] && parsedParams[1].indexOf(COMMA_SEPARATOR) > -1) {
      preparedParams = [parsedParams[0], replaceAll(parsedParams[1], COMMA_SEPARATOR, ESCAPED_COMMA_SEPARATOR)];
    } else {
      preparedParams = parsedParams;
    } // object of name and aliases for the Adg-scriptlet


    var adgScriptletObject = Object.keys(scriptletList).map(function (el) {
      return scriptletList[el];
    }).map(function (s) {
      var _s$names = toArray(s.names),
          name = _s$names[0],
          aliases = _s$names.slice(1);

      return {
        name: name,
        aliases: aliases
      };
    }).find(function (el) {
      return el.name === parsedName || el.aliases.indexOf(parsedName) >= 0;
    });
    var aliases = adgScriptletObject.aliases;

    if (aliases.length > 0) {
      var uboAlias = adgScriptletObject.aliases // eslint-disable-next-line no-restricted-properties
      .find(function (alias) {
        return alias.includes(UBO_ALIAS_NAME_MARKER);
      });

      if (uboAlias) {
        var mask = rule.match(ADGUARD_SCRIPTLET_MASK_REG)[0];
        var template;

        if (mask.indexOf('@') > -1) {
          template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;
        } else {
          template = UBO_SCRIPTLET_TEMPLATE;
        }

        var domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);
        var uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '') // '.js' in the Ubo scriptlet name can be omitted
        // https://github.com/gorhill/uBlock/wiki/Resources-Library#general-purpose-scriptlets
        .replace(UBO_SCRIPTLET_JS_ENDING, '');
        var args = preparedParams.length > 0 ? "".concat(uboName, ", ").concat(preparedParams.join("".concat(COMMA_SEPARATOR, " "))) : uboName;
        var uboRule = replacePlaceholders(template, {
          domains: domains,
          args: args
        });
        res = uboRule;
      }
    }
  }

  return res;
};
/**
 * Checks whether the ADG scriptlet exists or UBO/ABP scriptlet is compatible to ADG
 * @param {string} input - can be ADG or UBO or ABP scriptlet rule
 * @returns {boolean}
 */

var isValidScriptletRule = function isValidScriptletRule(input) {
  if (!input) {
    return false;
  } // ABP 'input' rule may contain more than one snippet


  var rulesArray = convertScriptletToAdg(input); // checking if each of parsed scriptlets is valid
  // if at least one of them is not valid - whole 'input' rule is not valid too

  var isValid = rulesArray.every(function (rule) {
    var parsedRule = parseRule(rule);
    return validator.isValidScriptletName(parsedRule.name);
  });
  return isValid;
};
/**
 * Converts Ubo redirect rule to Adg one
 * @param {string} rule
 * @returns {string}
 */

var convertUboRedirectToAdg = function convertUboRedirectToAdg(rule) {
  var firstPartOfRule = substringBefore(rule, '$');
  var uboModifiers = validator.parseModifiers(rule);
  var adgModifiers = uboModifiers.map(function (el) {
    if (el.indexOf(validator.REDIRECT_RULE_TYPES.UBO.marker) > -1) {
      var uboName = substringAfter(el, validator.REDIRECT_RULE_TYPES.UBO.marker);
      var adgName = validator.REDIRECT_RULE_TYPES.UBO.compatibility[uboName];
      return "".concat(validator.REDIRECT_RULE_TYPES.ADG.marker).concat(adgName);
    }

    if (el === UBO_XHR_TYPE) {
      return ADG_XHR_TYPE;
    }

    return el;
  }).join(COMMA_SEPARATOR);
  return "".concat(firstPartOfRule, "$").concat(adgModifiers);
};
/**
 * Converts Abp redirect rule to Adg one
 * @param {string} rule
 * @returns {string}
 */

var convertAbpRedirectToAdg = function convertAbpRedirectToAdg(rule) {
  var firstPartOfRule = substringBefore(rule, '$');
  var abpModifiers = validator.parseModifiers(rule);
  var adgModifiers = abpModifiers.map(function (el) {
    if (el.indexOf(validator.REDIRECT_RULE_TYPES.ABP.marker) > -1) {
      var abpName = substringAfter(el, validator.REDIRECT_RULE_TYPES.ABP.marker);
      var adgName = validator.REDIRECT_RULE_TYPES.ABP.compatibility[abpName];
      return "".concat(validator.REDIRECT_RULE_TYPES.ADG.marker).concat(adgName);
    }

    return el;
  }).join(COMMA_SEPARATOR);
  return "".concat(firstPartOfRule, "$").concat(adgModifiers);
};
/**
 * Converts redirect rule to AdGuard one
 * @param {string} rule
 * @returns {string}
 */

var convertRedirectToAdg = function convertRedirectToAdg(rule) {
  var result;

  if (validator.isUboRedirectCompatibleWithAdg(rule)) {
    result = convertUboRedirectToAdg(rule);
  } else if (validator.isAbpRedirectCompatibleWithAdg(rule)) {
    result = convertAbpRedirectToAdg(rule);
  } else if (validator.isValidAdgRedirectRule(rule)) {
    result = rule;
  }

  return result;
};
/**
 * Converts Adg redirect rule to Ubo one
 * 1. Checks if there is Ubo analog for Adg rule
 * 2. Parses the rule and chechs if there are any source type modifiers which are required by Ubo
 *    and if there are no one we add it manually to the end.
 *    Source types are chosen according to redirect name
 *    e.g. ||ad.com^$redirect=<name>,important  ->>  ||ad.com^$redirect=<name>,important,script
 * 3. Replaces Adg redirect name by Ubo analog
 * @param {string} rule
 * @returns {string}
 */

var convertAdgRedirectToUbo = function convertAdgRedirectToUbo(rule) {
  if (!validator.isAdgRedirectCompatibleWithUbo(rule)) {
    throw new Error("Unable to convert for uBO - unsupported redirect in rule: ".concat(rule));
  }

  var basePart = substringBefore(rule, '$');
  var adgModifiers = validator.parseModifiers(rule);
  var adgRedirectModifier = adgModifiers.find(function (el) {
    return el.indexOf(validator.REDIRECT_RULE_TYPES.ADG.marker) > -1;
  });
  var adgRedirectName = adgRedirectModifier.slice(validator.REDIRECT_RULE_TYPES.ADG.marker.length);
  var uboRedirectName = validator.REDIRECT_RULE_TYPES.ADG.compatibility[adgRedirectName];
  var uboRedirectModifier = "".concat(validator.REDIRECT_RULE_TYPES.UBO.marker).concat(uboRedirectName);

  if (!validator.hasValidContentType(rule)) {
    // add missed source types as content type modifiers
    var sourceTypesData = validator.ABSENT_SOURCE_TYPE_REPLACEMENT.find(function (el) {
      return el.NAME === adgRedirectName;
    });

    if (typeof sourceTypesData === 'undefined') {
      throw new Error("Unable to convert for uBO - no types to add for specific redirect in rule: ".concat(rule));
    }

    var additionModifiers = sourceTypesData.TYPES;
    adgModifiers.push.apply(adgModifiers, toConsumableArray(additionModifiers));
  }

  var uboModifiers = adgModifiers.map(function (el) {
    if (el === adgRedirectModifier) {
      return uboRedirectModifier;
    }

    return el;
  }).join(COMMA_SEPARATOR);
  return "".concat(basePart, "$").concat(uboModifiers);
};

/**
 * @redirect google-analytics
 *
 * @description
 * Mocks Google's Analytics and Tag Manager APIs.
 * [Covers obsolete googletagmanager-gtm redirect functionality](https://github.com/AdguardTeam/Scriptlets/issues/127).
 *
 * Related UBO redirect resource:
 * https://github.com/gorhill/uBlock/blob/8cd2a1d263a96421487b39040c1d23eb01169484/src/web_accessible_resources/google-analytics_analytics.js
 *
 * **Example**
 * ```
 * ||google-analytics.com/analytics.js$script,redirect=google-analytics
 * ||googletagmanager.com/gtm.js$script,redirect=googletagmanager-gtm
 * ```
 */

function GoogleAnalytics(source) {
  // eslint-disable-next-line func-names
  var Tracker = function Tracker() {}; // constructor


  var proto = Tracker.prototype;
  proto.get = noopFunc;
  proto.set = noopFunc;
  proto.send = noopFunc;
  var googleAnalyticsName = window.GoogleAnalyticsObject || 'ga'; // a -- fake arg for 'ga.length < 1' antiadblock checking
  // eslint-disable-next-line no-unused-vars

  function ga(a) {
    var len = arguments.length;

    if (len === 0) {
      return;
    } // eslint-disable-next-line prefer-rest-params


    var lastArg = arguments[len - 1];
    var replacer;

    if (lastArg instanceof Object && lastArg !== null && typeof lastArg.hitCallback === 'function') {
      replacer = lastArg.hitCallback;
    } else if (typeof lastArg === 'function') {
      // https://github.com/AdguardTeam/Scriptlets/issues/98
      replacer = function replacer() {
        lastArg(ga.create());
      };
    }

    try {
      setTimeout(replacer, 1); // eslint-disable-next-line no-empty
    } catch (ex) {}
  }

  ga.create = function () {
    return new Tracker();
  };

  ga.getByName = noopNull;
  ga.getAll = noopArray;
  ga.remove = noopFunc;
  ga.loaded = true;
  window[googleAnalyticsName] = ga;
  var _window = window,
      dataLayer = _window.dataLayer,
      google_optimize = _window.google_optimize; // eslint-disable-line camelcase

  if (dataLayer instanceof Object === false) {
    return;
  }

  if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {
    dataLayer.hide.end();
  }

  if (typeof dataLayer.push === 'function') {
    dataLayer.push = function (data) {
      if (data instanceof Object && typeof data.eventCallback === 'function') {
        setTimeout(data.eventCallback, 1);
      }
    };
  } // https://github.com/AdguardTeam/Scriptlets/issues/81


  if (google_optimize instanceof Object && typeof google_optimize.get === 'function') {
    // eslint-disable-line camelcase
    var googleOptimizeWrapper = {};
    googleOptimizeWrapper.get = noopFunc;
    window.google_optimize = googleOptimizeWrapper;
  }

  hit(source);
}
GoogleAnalytics.names = ['google-analytics', 'ubo-google-analytics_analytics.js', 'google-analytics_analytics.js', // https://github.com/AdguardTeam/Scriptlets/issues/127
'googletagmanager-gtm', 'ubo-googletagmanager_gtm.js', 'googletagmanager_gtm.js'];
GoogleAnalytics.injections = [hit, noopFunc, noopNull, noopArray];

/* eslint-disable no-underscore-dangle */
/**
 * @redirect google-analytics-ga
 *
 * @description
 * Mocks old Google Analytics API.
 *
 * Related UBO redirect resource:
 * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/google-analytics_ga.js
 *
 * **Example**
 * ```
 * ||google-analytics.com/ga.js$script,redirect=google-analytics-ga
 * ```
 */

function GoogleAnalyticsGa(source) {
  // Gaq constructor
  function Gaq() {}

  Gaq.prototype.Na = noopFunc;
  Gaq.prototype.O = noopFunc;
  Gaq.prototype.Sa = noopFunc;
  Gaq.prototype.Ta = noopFunc;
  Gaq.prototype.Va = noopFunc;
  Gaq.prototype._createAsyncTracker = noopFunc;
  Gaq.prototype._getAsyncTracker = noopFunc;
  Gaq.prototype._getPlugin = noopFunc;

  Gaq.prototype.push = function (data) {
    if (typeof data === 'function') {
      data();
      return;
    }

    if (Array.isArray(data) === false) {
      return;
    } // https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiDomainDirectory#_gat.GA_Tracker_._link


    if (data[0] === '_link' && typeof data[1] === 'string') {
      window.location.assign(data[1]);
    } // https://github.com/gorhill/uBlock/issues/2162


    if (data[0] === '_set' && data[1] === 'hitCallback' && typeof data[2] === 'function') {
      data[2]();
    }
  };

  var gaq = new Gaq();
  var asyncTrackers = window._gaq || [];

  if (Array.isArray(asyncTrackers)) {
    while (asyncTrackers[0]) {
      gaq.push(asyncTrackers.shift());
    }
  } // eslint-disable-next-line no-multi-assign


  window._gaq = gaq.qf = gaq; // Gat constructor

  function Gat() {} // Mock tracker api


  var api = ['_addIgnoredOrganic', '_addIgnoredRef', '_addItem', '_addOrganic', '_addTrans', '_clearIgnoredOrganic', '_clearIgnoredRef', '_clearOrganic', '_cookiePathCopy', '_deleteCustomVar', '_getName', '_setAccount', '_getAccount', '_getClientInfo', '_getDetectFlash', '_getDetectTitle', '_getLinkerUrl', '_getLocalGifPath', '_getServiceMode', '_getVersion', '_getVisitorCustomVar', '_initData', '_link', '_linkByPost', '_setAllowAnchor', '_setAllowHash', '_setAllowLinker', '_setCampContentKey', '_setCampMediumKey', '_setCampNameKey', '_setCampNOKey', '_setCampSourceKey', '_setCampTermKey', '_setCampaignCookieTimeout', '_setCampaignTrack', '_setClientInfo', '_setCookiePath', '_setCookiePersistence', '_setCookieTimeout', '_setCustomVar', '_setDetectFlash', '_setDetectTitle', '_setDomainName', '_setLocalGifPath', '_setLocalRemoteServerMode', '_setLocalServerMode', '_setReferrerOverride', '_setRemoteServerMode', '_setSampleRate', '_setSessionTimeout', '_setSiteSpeedSampleRate', '_setSessionCookieTimeout', '_setVar', '_setVisitorCookieTimeout', '_trackEvent', '_trackPageLoadTime', '_trackPageview', '_trackSocial', '_trackTiming', '_trackTrans', '_visitCode'];
  var tracker = api.reduce(function (res, funcName) {
    res[funcName] = noopFunc;
    return res;
  }, {});

  tracker._getLinkerUrl = function (a) {
    return a;
  };

  Gat.prototype._anonymizeIP = noopFunc;
  Gat.prototype._createTracker = noopFunc;
  Gat.prototype._forceSSL = noopFunc;
  Gat.prototype._getPlugin = noopFunc;

  Gat.prototype._getTracker = function () {
    return tracker;
  };

  Gat.prototype._getTrackerByName = function () {
    return tracker;
  };

  Gat.prototype._getTrackers = noopFunc;
  Gat.prototype.aa = noopFunc;
  Gat.prototype.ab = noopFunc;
  Gat.prototype.hb = noopFunc;
  Gat.prototype.la = noopFunc;
  Gat.prototype.oa = noopFunc;
  Gat.prototype.pa = noopFunc;
  Gat.prototype.u = noopFunc;
  var gat = new Gat();
  window._gat = gat;
  hit(source);
}
GoogleAnalyticsGa.names = ['google-analytics-ga', 'ubo-google-analytics_ga.js', 'google-analytics_ga.js'];
GoogleAnalyticsGa.injections = [hit, noopFunc];

/* eslint-disable max-len */

/**
 * @redirect googlesyndication-adsbygoogle
 *
 * @description
 * Mocks Google AdSense API.
 *
 * Related UBO redirect resource:
 * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googlesyndication_adsbygoogle.js
 *
 * **Example**
 * ```
 * ||pagead2.googlesyndication.com/pagead/js/adsbygoogle.js$script,redirect=googlesyndication-adsbygoogle
 * ```
 */

/* eslint-enable max-len */

function GoogleSyndicationAdsByGoogle(source) {
  window.adsbygoogle = {
    // https://github.com/AdguardTeam/Scriptlets/issues/113
    // length: 0,
    loaded: true,
    push: function push() {
      if (typeof this.length === 'undefined') {
        this.length = 0;
        this.length += 1;
      }
    }
  };
  var adElems = document.querySelectorAll('.adsbygoogle');
  var css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';
  var statusAttrName = 'data-adsbygoogle-status';
  var ASWIFT_IFRAME_MARKER = 'aswift_';
  var GOOGLE_ADS_IFRAME_MARKER = 'google_ads_iframe_';
  var executed = false;

  for (var i = 0; i < adElems.length; i += 1) {
    var adElemChildNodes = adElems[i].childNodes;
    var childNodesQuantity = adElemChildNodes.length; // childNodes of .adsbygoogle can be defined if scriptlet was executed before
    // so we should check are that childNodes exactly defined by us
    // TODO: remake after scriptlets context developing in 1.3

    var areIframesDefined = false;

    if (childNodesQuantity > 0) {
      // it should be only 2 child iframes if scriptlet was executed
      areIframesDefined = childNodesQuantity === 2 // the first of child nodes should be aswift iframe
      && adElemChildNodes[0].tagName.toLowerCase() === 'iframe' && adElemChildNodes[0].id.indexOf(ASWIFT_IFRAME_MARKER) > -1 // the second of child nodes should be google_ads iframe
      && adElemChildNodes[1].tagName.toLowerCase() === 'iframe' && adElemChildNodes[1].id.indexOf(GOOGLE_ADS_IFRAME_MARKER) > -1;
    }

    if (!areIframesDefined) {
      // here we do the job if scriptlet has not been executed earlier
      adElems[i].setAttribute(statusAttrName, 'done');
      var aswiftIframe = document.createElement('iframe');
      aswiftIframe.id = "".concat(ASWIFT_IFRAME_MARKER).concat(i);
      aswiftIframe.style = css;
      adElems[i].appendChild(aswiftIframe);
      var innerAswiftIframe = document.createElement('iframe');
      aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);
      var googleadsIframe = document.createElement('iframe');
      googleadsIframe.id = "".concat(GOOGLE_ADS_IFRAME_MARKER).concat(i);
      googleadsIframe.style = css;
      adElems[i].appendChild(googleadsIframe);
      var innerGoogleadsIframe = document.createElement('iframe');
      googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);
      executed = true;
    }
  }

  if (executed) {
    hit(source);
  }
}
GoogleSyndicationAdsByGoogle.names = ['googlesyndication-adsbygoogle', 'ubo-googlesyndication_adsbygoogle.js', 'googlesyndication_adsbygoogle.js'];
GoogleSyndicationAdsByGoogle.injections = [hit];

/**
 * @redirect googletagservices-gpt
 *
 * @description
 * Mocks Google Publisher Tag API.
 *
 * Related UBO redirect resource:
 * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googletagservices_gpt.js
 *
 * **Example**
 * ```
 * ||googletagservices.com/tag/js/gpt.js$script,redirect=googletagservices-gpt
 * ```
 */

function GoogleTagServicesGpt(source) {
  var companionAdsService = {
    addEventListener: noopThis,
    enableSyncLoading: noopFunc,
    setRefreshUnfilledSlots: noopFunc
  };
  var contentService = {
    addEventListener: noopThis,
    setContent: noopFunc
  };

  function PassbackSlot() {} // constructor


  PassbackSlot.prototype.display = noopFunc;
  PassbackSlot.prototype.get = noopNull;
  PassbackSlot.prototype.set = noopThis;
  PassbackSlot.prototype.setClickUrl = noopThis;
  PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;
  PassbackSlot.prototype.setTargeting = noopThis;
  PassbackSlot.prototype.updateTargetingFromMap = noopThis;

  function SizeMappingBuilder() {} // constructor


  SizeMappingBuilder.prototype.addSize = noopThis;
  SizeMappingBuilder.prototype.build = noopNull;

  function Slot() {} // constructor


  Slot.prototype.addService = noopThis;
  Slot.prototype.clearCategoryExclusions = noopThis;
  Slot.prototype.clearTargeting = noopThis;
  Slot.prototype.defineSizeMapping = noopThis;
  Slot.prototype.get = noopNull;
  Slot.prototype.getAdUnitPath = noopArray;
  Slot.prototype.getAttributeKeys = noopArray;
  Slot.prototype.getCategoryExclusions = noopArray;
  Slot.prototype.getDomId = noopStr;
  Slot.prototype.getSlotElementId = noopStr;
  Slot.prototype.getSlotId = noopThis;
  Slot.prototype.getTargeting = noopArray;
  Slot.prototype.getTargetingKeys = noopArray;
  Slot.prototype.set = noopThis;
  Slot.prototype.setCategoryExclusion = noopThis;
  Slot.prototype.setClickUrl = noopThis;
  Slot.prototype.setCollapseEmptyDiv = noopThis;
  Slot.prototype.setTargeting = noopThis;
  var pubAdsService = {
    addEventListener: noopThis,
    clear: noopFunc,
    clearCategoryExclusions: noopThis,
    clearTagForChildDirectedTreatment: noopThis,
    clearTargeting: noopThis,
    collapseEmptyDivs: noopFunc,
    defineOutOfPagePassback: function defineOutOfPagePassback() {
      return new PassbackSlot();
    },
    definePassback: function definePassback() {
      return new PassbackSlot();
    },
    disableInitialLoad: noopFunc,
    display: noopFunc,
    enableAsyncRendering: noopFunc,
    enableSingleRequest: noopFunc,
    enableSyncRendering: noopFunc,
    enableVideoAds: noopFunc,
    get: noopNull,
    getAttributeKeys: noopArray,
    getTargeting: noopFunc,
    getTargetingKeys: noopArray,
    getSlots: noopArray,
    refresh: noopFunc,
    set: noopThis,
    setCategoryExclusion: noopThis,
    setCentering: noopFunc,
    setCookieOptions: noopThis,
    setForceSafeFrame: noopThis,
    setLocation: noopThis,
    setPublisherProvidedId: noopThis,
    setRequestNonPersonalizedAds: noopThis,
    setSafeFrameConfig: noopThis,
    setTagForChildDirectedTreatment: noopThis,
    setTargeting: noopThis,
    setVideoContent: noopThis,
    updateCorrelator: noopFunc
  };
  var _window = window,
      _window$googletag = _window.googletag,
      googletag = _window$googletag === void 0 ? {} : _window$googletag;
  var _googletag$cmd = googletag.cmd,
      cmd = _googletag$cmd === void 0 ? [] : _googletag$cmd;
  googletag.apiReady = true;
  googletag.cmd = [];

  googletag.cmd.push = function (a) {
    try {
      a(); // eslint-disable-next-line no-empty
    } catch (ex) {}

    return 1;
  };

  googletag.companionAds = function () {
    return companionAdsService;
  };

  googletag.content = function () {
    return contentService;
  };

  googletag.defineOutOfPageSlot = function () {
    return new Slot();
  };

  googletag.defineSlot = function () {
    return new Slot();
  };

  googletag.destroySlots = noopFunc;
  googletag.disablePublisherConsole = noopFunc;
  googletag.display = noopFunc;
  googletag.enableServices = noopFunc;
  googletag.getVersion = noopStr;

  googletag.pubads = function () {
    return pubAdsService;
  };

  googletag.pubadsReady = true;
  googletag.setAdIframeTitle = noopFunc;

  googletag.sizeMapping = function () {
    return new SizeMappingBuilder();
  };

  window.googletag = googletag;

  while (cmd.length !== 0) {
    googletag.cmd.push(cmd.shift());
  }

  hit(source);
}
GoogleTagServicesGpt.names = ['googletagservices-gpt', 'ubo-googletagservices_gpt.js', 'googletagservices_gpt.js'];
GoogleTagServicesGpt.injections = [hit, noopFunc, noopThis, noopNull, noopArray, noopStr];

/**
 * @redirect scorecardresearch-beacon
 *
 * @description
 * Mocks Scorecard Research API.
 *
 * Related UBO redirect resource:
 * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/scorecardresearch_beacon.js
 *
 * **Example**
 * ```
 * ||sb.scorecardresearch.com/beacon.js$script,redirect=scorecardresearch-beacon
 * ```
 */

function ScoreCardResearchBeacon(source) {
  window.COMSCORE = {
    purge: function purge() {
      // eslint-disable-next-line no-underscore-dangle
      window._comscore = [];
    },
    beacon: function beacon() {}
  };
  hit(source);
}
ScoreCardResearchBeacon.names = ['scorecardresearch-beacon', 'ubo-scorecardresearch_beacon.js', 'scorecardresearch_beacon.js'];
ScoreCardResearchBeacon.injections = [hit];

/**
 * @redirect metrika-yandex-tag
 *
 * @description
 * Mocks Yandex Metrika API.
 * https://yandex.ru/support/metrica/objects/method-reference.html
 *
 * **Example**
 * ```
 * ||mc.yandex.ru/metrika/tag.js$script,redirect=metrika-yandex-tag
 * ```
 */

function metrikaYandexTag(source) {
  var asyncCallbackFromOptions = function asyncCallbackFromOptions(param) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var callback = options.callback;
    var ctx = options.ctx;

    if (typeof callback === 'function') {
      callback = ctx !== undefined ? callback.bind(ctx) : callback;
      setTimeout(function () {
        return callback();
      });
    }
  };

  var init = noopFunc;
  /**
   * https://yandex.ru/support/metrica/objects/addfileextension.html
   */

  var addFileExtension = noopFunc;
  /**
   * https://yandex.ru/support/metrica/objects/extlink.html
   */

  var extLink = asyncCallbackFromOptions;
  /**
   * https://yandex.ru/support/metrica/objects/file.html
   */

  var file = asyncCallbackFromOptions;
  /**
   * https://yandex.ru/support/metrica/objects/get-client-id.html
   * @param {Function} cb
   */

  var getClientID = function getClientID(cb) {
    setTimeout(cb(null));
  };
  /**
   * https://yandex.ru/support/metrica/objects/hit.html
   */


  var hitFunc = asyncCallbackFromOptions;
  /**
   * https://yandex.ru/support/metrica/objects/notbounce.html
   */

  var notBounce = asyncCallbackFromOptions;
  /**
   * https://yandex.ru/support/metrica/objects/params-method.html
   */

  var params = noopFunc;
  /**
   * https://yandex.ru/support/metrica/objects/reachgoal.html
   * @param {string} target
   * @param {Object} params
   * @param {Function} callback
   * @param {any} ctx
   */

  var reachGoal = function reachGoal(target, params, callback, ctx) {
    asyncCallbackFromOptions(null, {
      callback: callback,
      ctx: ctx
    });
  };
  /**
   * https://yandex.ru/support/metrica/objects/set-user-id.html
   */


  var setUserID = noopFunc;
  /**
   * https://yandex.ru/support/metrica/objects/user-params.html
   */

  var userParams = noopFunc;
  var api = {
    init: init,
    addFileExtension: addFileExtension,
    extLink: extLink,
    file: file,
    getClientID: getClientID,
    hit: hitFunc,
    notBounce: notBounce,
    params: params,
    reachGoal: reachGoal,
    setUserID: setUserID,
    userParams: userParams
  };

  function ym(id, funcName) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return api[funcName] && api[funcName].apply(api, args);
  }

  window.ym = ym;
  hit(source);
}
metrikaYandexTag.names = ['metrika-yandex-tag'];
metrikaYandexTag.injections = [hit, noopFunc];

/**
 * @redirect metrika-yandex-watch
 *
 * @description
 * Mocks the old Yandex Metrika API.
 * https://yandex.ru/support/metrica/objects/_method-reference.html
 *
 * **Example**
 * ```
 * ||mc.yandex.ru/metrika/watch.js$script,redirect=metrika-yandex-watch
 * ```
 */

function metrikaYandexWatch(source) {
  var cbName = 'yandex_metrika_callbacks';
  /**
   * Gets callback and its context from options and call it in async way
   * @param {Object} options Yandex Metrika API options
   */

  var asyncCallbackFromOptions = function asyncCallbackFromOptions() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = options.callback;
    var ctx = options.ctx;

    if (typeof callback === 'function') {
      callback = ctx !== undefined ? callback.bind(ctx) : callback;
      setTimeout(function () {
        return callback();
      });
    }
  };

  function Metrika() {} // constructor
  // Methods without options


  Metrika.prototype.addFileExtension = noopFunc;
  Metrika.prototype.getClientID = noopFunc;
  Metrika.prototype.setUserID = noopFunc;
  Metrika.prototype.userParams = noopFunc; // Methods with options
  // The order of arguments should be kept in according to API

  Metrika.prototype.extLink = function (url, options) {
    asyncCallbackFromOptions(options);
  };

  Metrika.prototype.file = function (url, options) {
    asyncCallbackFromOptions(options);
  };

  Metrika.prototype.hit = function (url, options) {
    asyncCallbackFromOptions(options);
  };

  Metrika.prototype.reachGoal = function (target, params, cb, ctx) {
    asyncCallbackFromOptions({
      callback: cb,
      ctx: ctx
    });
  };

  Metrika.prototype.notBounce = asyncCallbackFromOptions;

  if (window.Ya) {
    window.Ya.Metrika = Metrika;
  } else {
    window.Ya = {
      Metrika: Metrika
    };
  }

  if (window[cbName] && Array.isArray(window[cbName])) {
    window[cbName].forEach(function (func) {
      if (typeof func === 'function') {
        func();
      }
    });
  }

  hit(source);
}
metrikaYandexWatch.names = ['metrika-yandex-watch'];
metrikaYandexWatch.injections = [hit, noopFunc];

/**
 * @redirect amazon-apstag
 *
 * @description
 * Mocks Amazon's apstag.js
 *
 * Related UBO redirect resource:
 * https://github.com/gorhill/uBlock/blob/f842ab6d3c1cf0394f95d27092bf59627262da40/src/web_accessible_resources/amazon_apstag.js
 *
 * **Example**
 * ```
 * ||amazon-adsystem.com/aax2/apstag.js$script,redirect=amazon-apstag
 * ```
 */

function AmazonApstag(source) {
  var apstagWrapper = {
    fetchBids: function fetchBids(a, b) {
      if (typeof b === 'function') {
        b([]);
      }
    },
    init: noopFunc,
    setDisplayBids: noopFunc,
    targetingKeys: noopFunc
  };
  window.apstag = apstagWrapper;
  hit(source);
}
AmazonApstag.names = ['amazon-apstag', 'ubo-amazon_apstag.js', 'amazon_apstag.js'];
AmazonApstag.injections = [hit, noopFunc];

var redirectsList = /*#__PURE__*/Object.freeze({
    __proto__: null,
    noeval: noeval,
    GoogleAnalytics: GoogleAnalytics,
    GoogleAnalyticsGa: GoogleAnalyticsGa,
    GoogleSyndicationAdsByGoogle: GoogleSyndicationAdsByGoogle,
    GoogleTagServicesGpt: GoogleTagServicesGpt,
    ScoreCardResearchBeacon: ScoreCardResearchBeacon,
    metrikaYandexTag: metrikaYandexTag,
    metrikaYandexWatch: metrikaYandexWatch,
    preventFab: preventFab,
    preventBab: preventBab,
    setPopadsDummy: setPopadsDummy,
    preventPopadsNet: preventPopadsNet,
    AmazonApstag: AmazonApstag
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var classCallCheck = _classCallCheck;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass;

function isNothing(subject) {
  return typeof subject === 'undefined' || subject === null;
}

function isObject(subject) {
  return typeof subject === 'object' && subject !== null;
}

function toArray$1(sequence) {
  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
  return [sequence];
}

function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}

function repeat(string, count) {
  var result = '',
      cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}

function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}

var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray$1;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};

// YAML error class. http://stackoverflow.com/questions/8458984

function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);
  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : ''); // Include stack trace in error object

  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = new Error().stack || '';
  }
} // Inherit from Error


YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;

YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';
  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};

var exception = YAMLException;

function Mark(name, buffer, position, line, column) {
  this.name = name;
  this.buffer = buffer;
  this.position = position;
  this.line = line;
  this.column = column;
}

Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;
  if (!this.buffer) return null;
  indent = indent || 4;
  maxLength = maxLength || 75;
  head = '';
  start = this.position;

  while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;

    if (this.position - start > maxLength / 2 - 1) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;

    if (end - this.position > maxLength / 2 - 1) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);
  return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
};

Mark.prototype.toString = function toString(compact) {
  var snippet,
      where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};

var mark = Mark;

var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  }); // TODO: Add tag format check.

  this.tag = tag;
  this.kind = options['kind'] || null;

  this.resolve = options['resolve'] || function () {
    return true;
  };

  this.construct = options['construct'] || function (data) {
    return data;
  };

  this.instanceOf = options['instanceOf'] || null;
  this.predicate = options['predicate'] || null;
  this.represent = options['represent'] || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type = Type;

/*eslint-disable max-len*/


function compileList(schema, name, result) {
  var exclude = [];
  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });
  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });
    result.push(currentType);
  });
  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}

function compileMap()
/* lists... */
{
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  },
      index,
      length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}

function Schema(definition) {
  this.include = definition.include || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];
  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });
  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}

Schema.DEFAULT = null;

Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new exception('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) {
    return schema instanceof Schema;
  })) {
    throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type$1) {
    return type$1 instanceof type;
  })) {
    throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};

var schema = Schema;

var str = new type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function construct(data) {
    return data !== null ? data : '';
  }
});

var seq = new type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function construct(data) {
    return data !== null ? data : [];
  }
});

var map = new type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function construct(data) {
    return data !== null ? data : {};
  }
});

var failsafe = new schema({
  explicit: [str, seq, map]
});

function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function canonical() {
      return '~';
    },
    lowercase: function lowercase() {
      return 'null';
    },
    uppercase: function uppercase() {
      return 'NULL';
    },
    camelcase: function camelcase() {
      return 'Null';
    }
  },
  defaultStyle: 'lowercase'
});

function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
}

function constructYamlBoolean(data) {
  return data === 'true' || data === 'True' || data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function lowercase(object) {
      return object ? 'true' : 'false';
    },
    uppercase: function uppercase(object) {
      return object ? 'TRUE' : 'FALSE';
    },
    camelcase: function camelcase(object) {
      return object ? 'True' : 'False';
    }
  },
  defaultStyle: 'lowercase'
});

function isHexCode(c) {
  return 0x30
  /* 0 */
  <= c && c <= 0x39
  /* 9 */
  || 0x41
  /* A */
  <= c && c <= 0x46
  /* F */
  || 0x61
  /* a */
  <= c && c <= 0x66
  /* f */
  ;
}

function isOctCode(c) {
  return 0x30
  /* 0 */
  <= c && c <= 0x37
  /* 7 */
  ;
}

function isDecCode(c) {
  return 0x30
  /* 0 */
  <= c && c <= 0x39
  /* 9 */
  ;
}

function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;
  if (!max) return false;
  ch = data[index]; // sign

  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index]; // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }

      return hasDigits && ch !== '_';
    }

    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }

      return hasDigits && ch !== '_';
    } // base 8


    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }

    return hasDigits && ch !== '_';
  } // base 10 (except 0) or base 60
  // value should not start with `_`;


  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;

    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }

    hasDigits = true;
  } // Should have digits and should not end with `_`


  if (!hasDigits || ch === '_') return false; // if !base60 - done;

  if (ch !== ':') return true; // base60 almost not used, no needs to optimize

  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data,
      sign = 1,
      ch,
      base,
      digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
}

var int = new type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function binary(obj) {
      return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
    },
    octal: function octal(obj) {
      return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
    },
    decimal: function decimal(obj) {
      return obj.toString(10);
    },

    /* eslint-disable max-len */
    hexadecimal: function hexadecimal(obj) {
      return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary: [2, 'bin'],
    octal: [8, 'oct'],
    decimal: [10, 'dec'],
    hexadecimal: [16, 'hex']
  }
});

var YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers
'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2
// special case, seems not from spec
'|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // 20:59
'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + // .inf
'|[-+]?\\.(?:inf|Inf|INF)' + // .nan
'|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;
  value = data.replace(/_/g, '').toLowerCase();
  sign = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === '.nan') {
    return NaN;
  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });
    value = 0.0;
    base = 1;
    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }

  return sign * parseFloat(value, 10);
}

var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase':
        return '.nan';

      case 'uppercase':
        return '.NAN';

      case 'camelcase':
        return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '.inf';

      case 'uppercase':
        return '.INF';

      case 'camelcase':
        return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase':
        return '-.inf';

      case 'uppercase':
        return '-.INF';

      case 'camelcase':
        return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
}

var float = new type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var json = new schema({
  include: [failsafe],
  implicit: [_null, bool, int, float]
});

var core = new schema({
  include: [json]
});

var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9])' + // [2] month
'-([0-9][0-9])$'); // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
'-([0-9][0-9]?)' + // [2] month
'-([0-9][0-9]?)' + // [3] day
'(?:[Tt]|[ \\t]+)' + // ...
'([0-9][0-9]?)' + // [4] hour
':([0-9][0-9])' + // [5] minute
':([0-9][0-9])' + // [6] second
'(?:\\.([0-9]*))?' + // [7] fraction
'(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
'(?::([0-9][0-9]))?))?$'); // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match,
      year,
      month,
      day,
      hour,
      minute,
      second,
      fraction = 0,
      delta = null,
      tz_hour,
      tz_minute,
      date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day

  year = +match[1];
  month = +match[2] - 1; // JS month starts with 0

  day = +match[3];

  if (!match[4]) {
    // no hour
    return new Date(Date.UTC(year, month, day));
  } // match: [4] hour [5] minute [6] second [7] fraction


  hour = +match[4];
  minute = +match[5];
  second = +match[6];

  if (match[7]) {
    fraction = match[7].slice(0, 3);

    while (fraction.length < 3) {
      // milli-seconds
      fraction += '0';
    }

    fraction = +fraction;
  } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute


  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds

    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}

function representYamlTimestamp(object
/*, style*/
) {
  return object.toISOString();
}

var timestamp = new type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

function commonjsRequire (target) {
	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
}

/*eslint-disable no-bitwise*/


var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = commonjsRequire;
  NodeBuffer = _require('buffer').Buffer;
} catch (__) {} // [ 64, 65, 66 ] -> [ padding, CR, LF ]


var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

function resolveYamlBinary(data) {
  if (data === null) return false;
  var code,
      idx,
      bitlen = 0,
      max = data.length,
      map = BASE64_MAP; // Convert one by one.

  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx)); // Skip CR/LF

    if (code > 64) continue; // Fail on illegal characters

    if (code < 0) return false;
    bitlen += 6;
  } // If there are any bits left, source was corrupted


  return bitlen % 8 === 0;
}

function constructYamlBinary(data) {
  var idx,
      tailbits,
      input = data.replace(/[\r\n=]/g, ''),
      // remove CR/LF & padding to simplify scan
  max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = []; // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = bits << 6 | map.indexOf(input.charAt(idx));
  } // Dump tail


  tailbits = max % 4 * 6;

  if (tailbits === 0) {
    result.push(bits >> 16 & 0xFF);
    result.push(bits >> 8 & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 0xFF);
    result.push(bits >> 2 & 0xFF);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 0xFF);
  } // Wrap into Buffer for NodeJS and leave Array for browser


  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object
/*, style*/
) {
  var result = '',
      bits = 0,
      idx,
      tail,
      max = object.length,
      map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  } // Dump tail


  tail = max % 3;

  if (tail === 0) {
    result += map[bits >> 18 & 0x3F];
    result += map[bits >> 12 & 0x3F];
    result += map[bits >> 6 & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[bits >> 10 & 0x3F];
    result += map[bits >> 4 & 0x3F];
    result += map[bits << 2 & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[bits >> 2 & 0x3F];
    result += map[bits << 4 & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

var binary = new type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [],
      index,
      length,
      pair,
      pairKey,
      pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;else return false;
      }
    }

    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;
  var index,
      length,
      pair,
      keys,
      result,
      object = data;
  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== '[object Object]') return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];
  var index,
      length,
      pair,
      keys,
      result,
      object = data;
  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }

  return result;
}

var pairs = new type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;
  var key,
      object = data;

  for (key in object) {
    if (_hasOwnProperty$1.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set = new type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var default_safe = new schema({
  include: [core],
  implicit: [timestamp, merge],
  explicit: [binary, omap, pairs, set]
});

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

var _undefined = new type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;
  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = ''; // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars

  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    if (modifiers.length > 3) return false; // if expression starts with /, is should be properly terminated

    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail = /\/([gim]*)$/.exec(data),
      modifiers = ''; // `/foo/gim` - tail can be maximum 4 chars

  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object
/*, style*/
) {
  var result = '/' + object.source + '/';
  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';
  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

var regexp = new type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

var esprima; // Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//

try {
  // workaround to exclude package from browserify list.
  var _require$1 = commonjsRequire;
  esprima = _require$1('esprima');
} catch (_) {
  /* eslint-disable no-redeclare */

  /* global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast = esprima.parse(source, {
      range: true
    });

    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/
  var source = '(' + data + ')',
      ast = esprima.parse(source, {
    range: true
  }),
      params = [],
      body;

  if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });
  body = ast.body[0].expression.body.range; // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.

  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  } // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.

  /*eslint-disable no-new-func*/


  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object
/*, style*/
) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

var _function = new type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

var default_full = schema.DEFAULT = new schema({
  include: [default_safe],
  explicit: [_undefined, regexp, _function]
});

/*eslint-disable max-len,no-use-before-define*/


var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function is_EOL(c) {
  return c === 0x0A
  /* LF */
  || c === 0x0D
  /* CR */
  ;
}

function is_WHITE_SPACE(c) {
  return c === 0x09
  /* Tab */
  || c === 0x20
  /* Space */
  ;
}

function is_WS_OR_EOL(c) {
  return c === 0x09
  /* Tab */
  || c === 0x20
  /* Space */
  || c === 0x0A
  /* LF */
  || c === 0x0D
  /* CR */
  ;
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C
  /* , */
  || c === 0x5B
  /* [ */
  || c === 0x5D
  /* ] */
  || c === 0x7B
  /* { */
  || c === 0x7D
  /* } */
  ;
}

function fromHexCode(c) {
  var lc;

  if (0x30
  /* 0 */
  <= c && c <= 0x39
  /* 9 */
  ) {
    return c - 0x30;
  }
  /*eslint-disable no-bitwise*/


  lc = c | 0x20;

  if (0x61
  /* a */
  <= lc && lc <= 0x66
  /* f */
  ) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78
  /* x */
  ) {
      return 2;
    }

  if (c === 0x75
  /* u */
  ) {
      return 4;
    }

  if (c === 0x55
  /* U */
  ) {
      return 8;
    }

  return 0;
}

function fromDecimalCode(c) {
  if (0x30
  /* 0 */
  <= c && c <= 0x39
  /* 9 */
  ) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return c === 0x30
  /* 0 */
  ? '\x00' : c === 0x61
  /* a */
  ? '\x07' : c === 0x62
  /* b */
  ? '\x08' : c === 0x74
  /* t */
  ? '\x09' : c === 0x09
  /* Tab */
  ? '\x09' : c === 0x6E
  /* n */
  ? '\x0A' : c === 0x76
  /* v */
  ? '\x0B' : c === 0x66
  /* f */
  ? '\x0C' : c === 0x72
  /* r */
  ? '\x0D' : c === 0x65
  /* e */
  ? '\x1B' : c === 0x20
  /* Space */
  ? ' ' : c === 0x22
  /* " */
  ? '\x22' : c === 0x2F
  /* / */
  ? '/' : c === 0x5C
  /* \ */
  ? '\x5C' : c === 0x4E
  /* N */
  ? '\x85' : c === 0x5F
  /* _ */
  ? '\xA0' : c === 0x4C
  /* L */
  ? "\u2028" : c === 0x50
  /* P */
  ? "\u2029" : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  } // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF


  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}

var simpleEscapeCheck = new Array(256); // integer, for fast access

var simpleEscapeMap = new Array(256);

for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}

function State(input, options) {
  this.input = input;
  this.filename = options['filename'] || null;
  this.schema = options['schema'] || default_full;
  this.onWarning = options['onWarning'] || null;
  this.legacy = options['legacy'] || false;
  this.json = options['json'] || false;
  this.listener = options['listener'] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.documents = [];
  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
}

function generateError(state, message) {
  return new exception(message, new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}

var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = minor < 2;

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty$2.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};

function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);

        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty$2.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity; // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).

  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  } // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)


  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }

  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$2.call(overridableKeys, keyNode) && _hasOwnProperty$2.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A
  /* LF */
  ) {
      state.position++;
    } else if (ch === 0x0D
  /* CR */
  ) {
      state.position++;

      if (state.input.charCodeAt(state.position) === 0x0A
      /* LF */
      ) {
          state.position++;
        }
    } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23
    /* # */
    ) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A
        /* LF */
        && ch !== 0x0D
        /* CR */
        && ch !== 0);
      }

    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20
      /* Space */
      ) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;
  ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.

  if ((ch === 0x2D
  /* - */
  || ch === 0x2E
  /* . */
  ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}

function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23
  /* # */
  || ch === 0x26
  /* & */
  || ch === 0x2A
  /* * */
  || ch === 0x21
  /* ! */
  || ch === 0x7C
  /* | */
  || ch === 0x3E
  /* > */
  || ch === 0x27
  /* ' */
  || ch === 0x22
  /* " */
  || ch === 0x25
  /* % */
  || ch === 0x40
  /* @ */
  || ch === 0x60
  /* ` */
  ) {
      return false;
    }

  if (ch === 0x3F
  /* ? */
  || ch === 0x2D
  /* - */
  ) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A
    /* : */
    ) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 0x23
    /* # */
    ) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27
  /* ' */
  ) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27
    /* ' */
    ) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27
        /* ' */
        ) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
          return true;
        }
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22
  /* " */
  ) {
      return false;
    }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22
    /* " */
    ) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 0x5C
    /* \ */
    ) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag = state.tag,
      _result,
      _anchor = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B
  /* [ */
  ) {
      terminator = 0x5D;
      /* ] */

      isMapping = false;
      _result = [];
    } else if (ch === 0x7B
  /* { */
  ) {
      terminator = 0x7D;
      /* } */

      isMapping = true;
      _result = {};
    } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F
    /* ? */
    ) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A
    /* : */
    ) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C
    /* , */
    ) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent = nodeIndent,
      emptyLines = 0,
      atMoreIndented = false,
      tmp,
      ch;
  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C
  /* | */
  ) {
      folding = false;
    } else if (ch === 0x3E
  /* > */
  ) {
      folding = true;
    } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B
    /* + */
    || ch === 0x2D
    /* - */
    ) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 0x2B
          /* + */
          ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }
    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));

    if (ch === 0x23
    /* # */
    ) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20
    /* Space */
    ) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    } // End of the scalar.


    if (state.lineIndent < textIndent) {
      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      } // Break this `while` cycle and go to the funciton's epilogue.


      break;
    } // Folded style: use fancy rules to handle line breaks.


    if (folding) {
      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true; // except for the first content line (cf. Example 8.1)

        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1); // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) {
          // i.e. only if we have already read some scalar content.
          state.result += ' ';
        } // Several line breaks - perceive as different lines.

      } else {
        state.result += common.repeat('\n', emptyLines);
      } // Literal style: just add exact number of line breaks between content lines.

    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = [],
      following,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (ch !== 0x2D
    /* - */
    ) {
        break;
      }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);

        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);

    _result.push(state.result);

    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }

  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag = state.tag,
      _anchor = state.anchor,
      _result = {},
      overridableKeys = {},
      keyTag = null,
      keyNode = null,
      valueNode = null,
      atExplicitKey = false,
      detected = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    _pos = state.position; //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //

    if ((ch === 0x3F
    /* ? */
    || ch === 0x3A
    /* : */
    ) && is_WS_OR_EOL(following)) {
      if (ch === 0x3F
      /* ? */
      ) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following; //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A
        /* : */
        ) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    } else {
        break; // Reading is done. Go to the epilogue.
      } //
    // Common reading code for both explicit and implicit notations.
    //


    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && ch !== 0) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  } //
  // Epilogue.
  //
  // Special case: last mapping's node contains only the key in explicit notation.


  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  } // Expose the resulting mapping.


  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x21
  /* ! */
  ) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C
  /* < */
  ) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21
  /* ! */
  ) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);
    } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 0x3E
    /* > */
    );

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 0x21
      /* ! */
      ) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$2.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;
  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position, ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x26
  /* & */
  ) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias, ch;

  ch = state.input.charCodeAt(state.position);
  if (ch !== 0x2A
  /* * */
  ) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty$2.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1,
      // 1: this>parent, 0: this=parent, -1: this<parent
  atNewLine = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) {
          // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }

          break;
        }
      }
    } else if (_hasOwnProperty$2.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) {
        // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }

  return state.tag !== null || state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25
    /* % */
    ) {
        break;
      }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23
      /* # */
      ) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));

          break;
        }

      if (is_EOL(ch)) break;
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty$2.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D
  /* - */
  && state.input.charCodeAt(state.position + 1) === 0x2D
  /* - */
  && state.input.charCodeAt(state.position + 2) === 0x2D
  /* - */
  ) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 0x2E
    /* . */
    ) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }

    return;
  }

  if (state.position < state.length - 1) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}

function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {
    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A
    /* LF */
    && input.charCodeAt(input.length - 1) !== 0x0D
    /* CR */
    ) {
        input += '\n';
      } // Strip BOM


    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);
  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  } // Use 0 as string terminator. That significantly simplifies bounds check.


  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20
  /* Space */
  ) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < state.length - 1) {
    readDocument(state);
  }

  return state.documents;
}

function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}

function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }

  throw new exception('expected a single document in the stream, but found more');
}

function safeLoadAll(input, iterator, options) {
  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  return loadAll(input, iterator, common.extend({
    schema: default_safe
  }, options));
}

function safeLoad(input, options) {
  return load(input, common.extend({
    schema: default_safe
  }, options));
}

var loadAll_1 = loadAll;
var load_1 = load;
var safeLoadAll_1 = safeLoadAll;
var safeLoad_1 = safeLoad;
var loader = {
  loadAll: loadAll_1,
  load: load_1,
  safeLoadAll: safeLoadAll_1,
  safeLoad: safeLoad_1
};

/*eslint-disable no-use-before-define*/


var _toString$2 = Object.prototype.toString;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var CHAR_TAB = 0x09;
/* Tab */

var CHAR_LINE_FEED = 0x0A;
/* LF */

var CHAR_CARRIAGE_RETURN = 0x0D;
/* CR */

var CHAR_SPACE = 0x20;
/* Space */

var CHAR_EXCLAMATION = 0x21;
/* ! */

var CHAR_DOUBLE_QUOTE = 0x22;
/* " */

var CHAR_SHARP = 0x23;
/* # */

var CHAR_PERCENT = 0x25;
/* % */

var CHAR_AMPERSAND = 0x26;
/* & */

var CHAR_SINGLE_QUOTE = 0x27;
/* ' */

var CHAR_ASTERISK = 0x2A;
/* * */

var CHAR_COMMA = 0x2C;
/* , */

var CHAR_MINUS = 0x2D;
/* - */

var CHAR_COLON = 0x3A;
/* : */

var CHAR_EQUALS = 0x3D;
/* = */

var CHAR_GREATER_THAN = 0x3E;
/* > */

var CHAR_QUESTION = 0x3F;
/* ? */

var CHAR_COMMERCIAL_AT = 0x40;
/* @ */

var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
/* [ */

var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
/* ] */

var CHAR_GRAVE_ACCENT = 0x60;
/* ` */

var CHAR_LEFT_CURLY_BRACKET = 0x7B;
/* { */

var CHAR_VERTICAL_LINE = 0x7C;
/* | */

var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
/* } */

var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0x00] = '\\0';
ESCAPE_SEQUENCES[0x07] = '\\a';
ESCAPE_SEQUENCES[0x08] = '\\b';
ESCAPE_SEQUENCES[0x09] = '\\t';
ESCAPE_SEQUENCES[0x0A] = '\\n';
ESCAPE_SEQUENCES[0x0B] = '\\v';
ESCAPE_SEQUENCES[0x0C] = '\\f';
ESCAPE_SEQUENCES[0x0D] = '\\r';
ESCAPE_SEQUENCES[0x1B] = '\\e';
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = '\\\\';
ESCAPE_SEQUENCES[0x85] = '\\N';
ESCAPE_SEQUENCES[0xA0] = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';
var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;
  if (map === null) return {};
  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty$3.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State$1(options) {
  this.schema = options['schema'] || default_full;
  this.indent = Math.max(1, options['indent'] || 2);
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys = options['sortKeys'] || false;
  this.lineWidth = options['lineWidth'] || 80;
  this.noRefs = options['noRefs'] || false;
  this.noCompatMode = options['noCompatMode'] || false;
  this.condenseFlow = options['condenseFlow'] || false;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = '';
  this.duplicates = [];
  this.usedDuplicates = null;
} // Indents every line in a string. Empty lines (\n only) are not indented.


function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);

    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;
    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
} // [33] s-white ::= s-space | s-tab


function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
} // Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.


function isPrintable(c) {
  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF
  /* BOM */
  || 0x10000 <= c && c <= 0x10FFFF;
} // [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF


function isNsChar(c) {
  return isPrintable(c) && !isWhitespace(c) // byte-order-mark
  && c !== 0xFEFF // b-char
  && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
} // Simplified test for values allowed after the first character in plain style.


function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF // - c-flow-indicator
  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // - ":" - "#"
  // /* An ns-char preceding */ "#"
  && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
} // Simplified test for values allowed as the first character in plain style.


function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
  // - (c-indicator ::=
  // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | “%” | “@” | “`”)
  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
} // Determines whether block indentation indicator is required.


function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN = 1,
    STYLE_SINGLE = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED = 4,
    STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).

function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth

  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly

  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);

      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }

      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);

      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true; // Check if any line can be folded.

        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }

      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    } // in case the end is missing a \n


    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
  } // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.


  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
  } // Edge case: block indentation indicator can only have one digit.


  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  } // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.


  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
} // Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.


function writeScalar(state, string, level, iskey) {
  state.dump = function () {
    if (string.length === 0) {
      return "''";
    }

    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.

    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.

    var singleLineOnly = iskey // No block styles in flow mode.
    || state.flowLevel > -1 && level >= state.flowLevel;

    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;

      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";

      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));

      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));

      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';

      default:
        throw new exception('impossible error: invalid scalar style');
    }
  }();
} // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.


function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\n' counts as a "trailing" empty line.

  var clip = string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : clip ? '' : '-';
  return indentIndicator + chomp + '\n';
} // (See the note for writeScalar.)


function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
} // Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.


function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g; // first line (possibly an empty line)

  var result = function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }(); // If we haven't reached the first content line yet, don't add an extra \n.


  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented; // rest of the lines

  var match;

  while (match = lineRe.exec(string)) {
    var prefix = match[1],
        line = match[2];
    moreIndented = line[0] === ' ';
    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
} // Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.


function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \n, breaks can't be followed by a space.

  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.

  var match; // start is an inclusive index. end, curr, and next are exclusive.

  var start = 0,
      end,
      curr = 0,
      next = 0;
  var result = ''; // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.

  while (match = breakRe.exec(line)) {
    next = match.index; // maintain invariant: curr - start <= width

    if (next - start > width) {
      end = curr > start ? curr : next; // derive end <= length-2

      result += '\n' + line.slice(start, end); // skip the space that was output as \n

      start = end + 1; // derive start <= length-1
    }

    curr = next;
  } // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.


  result += '\n'; // Insert a break if the remainder is too long and there is a break available.

  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
} // Escapes a double-quoted string.


function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").

    if (char >= 0xD800 && char <= 0xDBFF
    /* high surrogate */
    ) {
        nextChar = string.charCodeAt(i + 1);

        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF
        /* low surrogate */
        ) {
            // Combine the surrogate pair and store it escaped.
            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.

            i++;
            continue;
          }
      }

    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';
    if (index !== 0) pairBuffer += ', ';
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';
    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump; // Both key and value are valid.

    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result = '',
      _tag = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer; // Allow sorting keys so that the output file is deterministic

  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new exception('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump; // Both key and value are valid.

    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString$2.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty$3.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
} // Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//


function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString$2.call(state.dump);

  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }

    if (type === '[object Object]') {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;

      if (block && state.dump.length !== 0) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);

        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new exception('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;
  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }

  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);

    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};
  var state = new State$1(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({
    schema: default_safe
  }, options));
}

var dump_1 = dump;
var safeDump_1 = safeDump;
var dumper = {
  dump: dump_1,
  safeDump: safeDump_1
};

function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}

var Type$1 = type;
var Schema$1 = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SAFE_SCHEMA = default_safe;
var DEFAULT_FULL_SCHEMA = default_full;
var load$1 = loader.load;
var loadAll$1 = loader.loadAll;
var safeLoad$1 = loader.safeLoad;
var safeLoadAll$1 = loader.safeLoadAll;
var dump$1 = dumper.dump;
var safeDump$1 = dumper.safeDump;
var YAMLException$1 = exception; // Deprecated schema names from JS-YAML 2.0.x

var MINIMAL_SCHEMA = failsafe;
var SAFE_SCHEMA = default_safe;
var DEFAULT_SCHEMA = default_full; // Deprecated functions from JS-YAML 1.x.x

var scan = deprecated('scan');
var parse = deprecated('parse');
var compose = deprecated('compose');
var addConstructor = deprecated('addConstructor');
var jsYaml = {
  Type: Type$1,
  Schema: Schema$1,
  FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
  JSON_SCHEMA: JSON_SCHEMA,
  CORE_SCHEMA: CORE_SCHEMA,
  DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,
  DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,
  load: load$1,
  loadAll: loadAll$1,
  safeLoad: safeLoad$1,
  safeLoadAll: safeLoadAll$1,
  dump: dump$1,
  safeDump: safeDump$1,
  YAMLException: YAMLException$1,
  MINIMAL_SCHEMA: MINIMAL_SCHEMA,
  SAFE_SCHEMA: SAFE_SCHEMA,
  DEFAULT_SCHEMA: DEFAULT_SCHEMA,
  scan: scan,
  parse: parse,
  compose: compose,
  addConstructor: addConstructor
};

var jsYaml$1 = jsYaml;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Redirect - object used to redirect some requests
 * e.g.
 * {
 *      title: 1x1-transparent.gif
 *      comment: http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever
 *      contentType: image/gif;base64
 *      content: R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
 * }
 * @typedef {Object} Redirect
 * @property {string} title
 * @property {string} comment
 * @property {string} content
 * @property {string} contentType
 */

var Redirects = /*#__PURE__*/function () {
  /**
   * Converts rawYaml into JS object with sources titles used as keys
   * @param rawYaml
   * @returns {Object<Redirect>} - return object with titles in the keys and RedirectSources
   * in the values
   */
  function Redirects(rawYaml) {
    classCallCheck(this, Redirects);

    try {
      var arrOfRedirects = jsYaml$1.safeLoad(rawYaml);
      this.redirects = arrOfRedirects.reduce(function (acc, redirect) {
        return _objectSpread(_objectSpread({}, acc), {}, defineProperty({}, redirect.title, redirect));
      }, {});
    } catch (e) {
      // eslint-disable-next-line no-console
      console.log("Was unable to load YAML into JS due to: ".concat(e.message));
      throw e;
    }
  }
  /**
   * Returns redirect source object
   * @param {string} title
   * @return {Redirect}
   */


  createClass(Redirects, [{
    key: "getRedirect",
    value: function getRedirect(title) {
      var _this = this;

      if (Object.prototype.hasOwnProperty.call(this.redirects, title)) {
        return this.redirects[title];
      } // look title among aliases


      var values = Object.keys(this.redirects).map(function (key) {
        return _this.redirects[key];
      });
      return values.find(function (redirect) {
        var aliases = redirect.aliases;

        if (!aliases) {
          return false;
        }

        return aliases.indexOf(title) > -1;
      });
    }
  }]);

  return Redirects;
}();

/**
 * Finds redirect resource by it's name
 * @param {string} name - redirect name
 */

var getRedirectByName = function getRedirectByName(name) {
  var redirects = Object.keys(redirectsList).map(function (key) {
    return redirectsList[key];
  });
  return redirects.find(function (r) {
    return r.names && r.names.indexOf(name) > -1;
  });
};
/**
 * @typedef {Object} Source - redirect properties
 * @property {string} name redirect name
 * @property {Array<string>} args Arguments for redirect function
 * @property {'extension'|'test'} [engine] -
 * Defines the final form of redirect string presentation
 * @property {boolean} [verbose] flag to enable printing to console debug information
 */

/**
 * Returns redirect code by param
 * @param {Source} source
 * @returns {string} redirect code
 */


var getRedirectCode = function getRedirectCode(source) {
  var redirect = getRedirectByName(source.name);
  var result = attachDependencies(redirect);
  result = addCall(redirect, result); // redirect code for different sources is checked in tests
  // so it should be just a code without any source and props passed

  result = source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);
  return result;
};

var redirectsCjs = {
  Redirects: Redirects,
  getCode: getRedirectCode,
  isAdgRedirectRule: validator.isAdgRedirectRule,
  isValidAdgRedirectRule: validator.isValidAdgRedirectRule,
  isAdgRedirectCompatibleWithUbo: validator.isAdgRedirectCompatibleWithUbo,
  isUboRedirectCompatibleWithAdg: validator.isUboRedirectCompatibleWithAdg,
  isAbpRedirectCompatibleWithAdg: validator.isAbpRedirectCompatibleWithAdg,
  convertUboRedirectToAdg: convertUboRedirectToAdg,
  convertAbpRedirectToAdg: convertAbpRedirectToAdg,
  convertRedirectToAdg: convertRedirectToAdg,
  convertAdgRedirectToUbo: convertAdgRedirectToUbo
};

/**
 * @typedef {Object} Source - scriptlet properties
 * @property {string} name Scriptlet name
 * @property {Array<string>} args Arguments for scriptlet function
 * @property {'extension'|'corelibs'|'test'} engine -
 * Defines the final form of scriptlet string presentation
 * @property {string} [version]
 * @property {boolean} [verbose] flag to enable printing to console debug information
 * @property {string} [ruleText] Source rule text is used for debugging purposes
 * @property {string} [domainName] domain name where scriptlet is applied; for debugging purposes
 */

/**
 * Returns scriptlet code by param
 * @param {Source} source
 * @returns {string} scriptlet code
 */

function getScriptletCode(source) {
  if (!validator.isValidScriptletName(source.name)) {
    return null;
  }

  var scriptlet = validator.getScriptletByName(source.name);
  var result = attachDependencies(scriptlet);
  result = addCall(scriptlet, result);
  result = source.engine === 'corelibs' || source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);
  return result;
}
/**
 * Scriptlets variable
 *
 * @returns {Object} object with methods:
 * `invoke` method receives one argument with `Source` type
 * `validate` method receives one argument with `String` type
 */


var scriptletsObject = function () {
  return {
    invoke: getScriptletCode,
    isValidScriptletName: validator.isValidScriptletName,
    isValidScriptletRule: isValidScriptletRule,
    isAdgScriptletRule: validator.isAdgScriptletRule,
    isUboScriptletRule: validator.isUboScriptletRule,
    isAbpSnippetRule: validator.isAbpSnippetRule,
    convertUboToAdg: convertUboScriptletToAdg,
    convertAbpToAdg: convertAbpSnippetToAdg,
    convertScriptletToAdg: convertScriptletToAdg,
    convertAdgToUbo: convertAdgScriptletToUbo,
    redirects: redirectsCjs
  };
}();

/**
 * Add module exports to be used as node package
 */

module.exports = scriptletsObject;

/**
 * -------------------------------------------
 * |                                         |
 * |  If you want to add your own scriptlet  |
 * |  please put your code below             |
 * |                                         |
 * -------------------------------------------
 */


/***/ }),

/***/ "./node_modules/webextension-polyfill-ts/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/webextension-polyfill-ts/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));

exports.browser = __webpack_require__(/*! webextension-polyfill */ "./node_modules/webextension-polyfill/dist/browser-polyfill.js");


/***/ }),

/***/ "./node_modules/webextension-polyfill/dist/browser-polyfill.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webextension-polyfill/dist/browser-polyfill.js ***!
  \*********************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.7.0 - Tue Nov 10 2020 20:24:04 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (typeof browser === "undefined" || Object.getPrototypeOf(browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
    const SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.rejection
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {integer} metadata.maxResolvedArgs
       *        The maximum number of arguments which may be passed to the
       *        callback created by the wrapped async function.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(extensionAPIs.runtime.lastError);
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxResolvedArgs
       *        The maximum number of arguments which may be passed to the
       *        callback created by the wrapped async function.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      }); // Keep track if the deprecation warning has been logged at least once.


      let loggedSendResponseDeprecationWarning = false;
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              if (!loggedSendResponseDeprecationWarning) {
                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);
                loggedSendResponseDeprecationWarning = true;
              }

              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(extensionAPIs.runtime.lastError);
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    };

    if (typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id) {
      throw new Error("This script should only be loaded in a browser extension.");
    } // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = browser;
  }
});
//# sourceMappingURL=browser-polyfill.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**************************************!*\
  !*** ./src/targets/content/index.ts ***!
  \**************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pages_content__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../pages/content */ "./src/pages/content/index.ts");

console.log("Time from content script: ".concat(Date.now()));
_pages_content__WEBPACK_IMPORTED_MODULE_0__.content.init();
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL2FkdmFuY2VkLWFkYmxvY2tlci13ZWItZXh0ZW5zaW9uLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL2FkdmFuY2VkLWFkYmxvY2tlci13ZWItZXh0ZW5zaW9uLy4vc3JjL3BhZ2VzL2NvbW1vbi9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vYWR2YW5jZWQtYWRibG9ja2VyLXdlYi1leHRlbnNpb24vLi9zcmMvcGFnZXMvY29udGVudC9jb250ZW50LnRzIiwid2VicGFjazovL2FkdmFuY2VkLWFkYmxvY2tlci13ZWItZXh0ZW5zaW9uLy4vbm9kZV9tb2R1bGVzL2V4dGVuZGVkLWNzcy9kaXN0L2V4dGVuZGVkLWNzcy5lc20uanMiLCJ3ZWJwYWNrOi8vYWR2YW5jZWQtYWRibG9ja2VyLXdlYi1leHRlbnNpb24vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL2FkdmFuY2VkLWFkYmxvY2tlci13ZWItZXh0ZW5zaW9uLy4vbm9kZV9tb2R1bGVzL3NjcmlwdGxldHMvZGlzdC9janMvc2NyaXB0bGV0cy5janMuanMiLCJ3ZWJwYWNrOi8vYWR2YW5jZWQtYWRibG9ja2VyLXdlYi1leHRlbnNpb24vLi9ub2RlX21vZHVsZXMvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsLXRzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy93ZWJleHRlbnNpb24tcG9seWZpbGwvZGlzdC9icm93c2VyLXBvbHlmaWxsLmpzIiwid2VicGFjazovL2FkdmFuY2VkLWFkYmxvY2tlci13ZWItZXh0ZW5zaW9uL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2FkdmFuY2VkLWFkYmxvY2tlci13ZWItZXh0ZW5zaW9uL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2FkdmFuY2VkLWFkYmxvY2tlci13ZWItZXh0ZW5zaW9uL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2FkdmFuY2VkLWFkYmxvY2tlci13ZWItZXh0ZW5zaW9uL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vYWR2YW5jZWQtYWRibG9ja2VyLXdlYi1leHRlbnNpb24vLi9zcmMvdGFyZ2V0cy9jb250ZW50L2luZGV4LnRzIl0sIm5hbWVzIjpbIk1lc3NhZ2VzVG9OYXRpdmVBcHAiLCJNZXNzYWdlc1RvQmFja2dyb3VuZFBhZ2UiLCJNZXNzYWdlc1RvQ29udGVudFNjcmlwdCIsImxvZ01lc3NhZ2UiLCJ2ZXJib3NlIiwibWVzc2FnZSIsImNvbnNvbGUiLCJsb2ciLCJnZXRTZWxlY3RvcnNBbmRTY3JpcHRzIiwiYnJvd3NlciIsInR5cGUiLCJkYXRhIiwidXJsIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwicmVzcG9uc2UiLCJKU09OIiwicGFyc2UiLCJleGVjdXRlU2NyaXB0cyIsInNjcmlwdHMiLCJ1bnNoaWZ0IiwicHVzaCIsInNjcmlwdFRhZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInRleHRDb250ZW50Iiwiam9pbiIsInBhcmVudCIsImhlYWQiLCJkb2N1bWVudEVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGx5U2NyaXB0cyIsImxlbmd0aCIsInJldmVyc2UiLCJwcm90ZWN0U3R5bGVFbGVtZW50Q29udGVudCIsInByb3RlY3RTdHlsZUVsIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJpbm5lck9ic2VydmVyIiwibXV0YXRpb25zIiwiaSIsIm0iLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpc1Byb3RlY3RTdHlsZUVsTW9kaWZpZWQiLCJyZW1vdmVkTm9kZXMiLCJqIiwib2xkVmFsdWUiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJjaGFyYWN0ZXJEYXRhT2xkVmFsdWUiLCJhcHBseUNzcyIsInN0eWxlU2VsZWN0b3JzIiwic3R5bGVFbGVtZW50Iiwic2VsZWN0b3JzIiwibWFwIiwicyIsInRyaW0iLCJmb3JFYWNoIiwic2VsZWN0b3IiLCJzaGVldCIsImluc2VydFJ1bGUiLCJhcHBseUV4dGVuZGVkQ3NzIiwiZXh0ZW5kZWRDc3MiLCJleHRjc3MiLCJFeHRlbmRlZENzcyIsInN0eWxlU2hlZXQiLCJmaWx0ZXIiLCJhcHBseSIsImFwcGx5U2NyaXB0bGV0cyIsInNjcmlwdGxldHNEYXRhIiwic2NyaXB0bGV0RXhlY3V0YWJsZVNjcmlwdHMiLCJwYXJhbSIsImVuZ2luZSIsImNvZGUiLCJzY3JpcHRsZXRzIiwiYWRnIiwiYXBwbHlBZHZhbmNlZEJsb2NraW5nRGF0YSIsInNlbGVjdG9yc0FuZFNjcmlwdHMiLCJjc3NJbmplY3QiLCJjc3NFeHRlbmRlZCIsImluaXQiLCJIVE1MRG9jdW1lbnQiLCJpbmRleE9mIiwic3RhcnRHZXR0aW5nU2NyaXB0cyIsIkRhdGUiLCJub3ciLCJjb250ZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFZTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDJCQUEyQix5Q0FBeUM7QUFDcEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxL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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCOztB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O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsYUFBYTtBQUNsRjtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZTs7QUFFeEI7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlFQUFpRTs7QUFFakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDRIQUE0SDs7QUFFNUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDRIQUE0SDs7QUFFNUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFD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LGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7O0FBR3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsNkJBQTZCOztBQUU3QixtQkFBbUI7OztBQUduQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCLHdCQUF3QixvQkFBb0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBLHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOzs7QUFHbEM7QUFDQTs7QUFFQSxvQkFBb0I7OztBQUdwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdILDZDQUE2Qzs7QUFFN0MsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJDQUEyQyx5Q0FBeUMsaUJBQWlCO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQSxzQ0FBc0MsRUFBRSxlQUFlLEVBQUUsWUFBWTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBOztBQUVBLCtDQUErQyxrQkFBa0I7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGdCQUFnQixlQUFlO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRFQUE0RTtBQUM1RSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLDBGQUEwRjtBQUMxRixPQUFPO0FBQ1A7QUFDQSw0REFBNEQ7QUFDNUQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsT0FBTztBQUNQO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDREQUE0RCxzQkFBc0I7QUFDbEY7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxtRUFBbUU7QUFDbkUsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxPQUFPO0FBQ1AsOERBQThEO0FBQzlELE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMLGNBQWM7QUFDZCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBLG9FQUFvRSwwQkFBMEI7QUFDOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLCtFQUErRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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L0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUU7QUFDbkIsbUJBQW1CLFFB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WUFBWTtBQUN6STs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7OztVQ3J0Q0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGdDQUFnQyxZQUFZO1dBQzVDO1dBQ0EsRTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHdDQUF3Qyx5Q0FBeUM7V0FDakY7V0FDQTtXQUNBLEU7Ozs7O1dDUEEsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBbEYsT0FBTyxDQUFDQyxHQUFSLHFDQUF5Q3FGLElBQUksQ0FBQ0MsR0FBTCxFQUF6QztBQUNBQyx3REFBQSxHIiwiZmlsZSI6ImNvbnRlbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiZXhwb3J0IGVudW0gTWVzc2FnZXNUb05hdGl2ZUFwcCB7XG4gICAgR2V0SnNvblJ1bGVzID0gJ2dldF9qc29uX3J1bGVzJyxcbiAgICBXcml0ZUluTmF0aXZlTG9nID0gJ3dyaXRlX2luX25hdGl2ZV9sb2cnLFxuICAgIEFkZFRvVXNlcnJ1bGVzID0gJ2FkZF90b191c2VycnVsZXMnLFxuICAgIEdldEJsb2NraW5nRGF0YSA9ICdnZXRfYmxvY2tpbmdfZGF0YScsXG59XG5cbmV4cG9ydCBlbnVtIE1lc3NhZ2VzVG9CYWNrZ3JvdW5kUGFnZSB7XG4gICAgT3BlbkFzc2lzdGFudCA9ICdvcGVuX2Fzc2lzdGFudCcsXG4gICAgR2V0U2NyaXB0c0FuZFNlbGVjdG9ycyA9ICdnZXRfc2NyaXB0c19hbmRfc2VsZWN0b3JzJyxcbiAgICBBZGRSdWxlID0gJ2FkZF9ydWxlJyxcbiAgICBHZXRBZHZhbmNlZEpzb24gPSAnZ2V0X2FkdmFuY2VkX2pzb24nLFxufVxuXG5leHBvcnQgZW51bSBNZXNzYWdlc1RvQ29udGVudFNjcmlwdCB7XG4gICAgSW5pdEFzc2lzdGFudCA9ICdpbml0X2Fzc2lzdGFudCcsXG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5pbXBvcnQgeyBicm93c2VyIH0gZnJvbSAnd2ViZXh0ZW5zaW9uLXBvbHlmaWxsLXRzJztcbmltcG9ydCBFeHRlbmRlZENzcyBmcm9tICdleHRlbmRlZC1jc3MnO1xuaW1wb3J0IHNjcmlwdGxldHMgZnJvbSAnc2NyaXB0bGV0cyc7XG5cbmltcG9ydCB7IE1lc3NhZ2VzVG9CYWNrZ3JvdW5kUGFnZSB9IGZyb20gJy4uL2NvbW1vbi9jb25zdGFudHMnO1xuXG5pbnRlcmZhY2UgU2VsZWN0b3JzQW5kU2NyaXB0cyB7XG4gICAgc2NyaXB0czogc3RyaW5nW10sXG4gICAgY3NzSW5qZWN0OiBzdHJpbmdbXSxcbiAgICBjc3NFeHRlbmRlZDogc3RyaW5nW10sXG4gICAgc2NyaXB0bGV0czogc3RyaW5nW10sXG59XG5cbi8qKlxuICogTG9ncyBhIG1lc3NhZ2UgaWYgdmVyYm9zZSBpcyB0cnVlXG4gKlxuICogQHBhcmFtIHZlcmJvc2VcbiAqIEBwYXJhbSBtZXNzYWdlXG4gKi9cbmNvbnN0IGxvZ01lc3NhZ2UgPSAodmVyYm9zZTogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coYChBRykgJHttZXNzYWdlfWApO1xuICAgIH1cbn07XG5cbmNvbnN0IGdldFNlbGVjdG9yc0FuZFNjcmlwdHMgPSBhc3luYyAoKTogUHJvbWlzZTxTZWxlY3RvcnNBbmRTY3JpcHRzIHwgbnVsbD4gPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYnJvd3Nlci5ydW50aW1lLnNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogTWVzc2FnZXNUb0JhY2tncm91bmRQYWdlLkdldFNjcmlwdHNBbmRTZWxlY3RvcnMsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHVybDogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0FHOiBubyBzY3JpcHRzIGFuZCBzZWxlY3RvcnMgcmVjZWl2ZWQnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UpIGFzIFNlbGVjdG9yc0FuZFNjcmlwdHM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQUc6IGVycm9yIG9jY3VycmVkIG9uIHNlbGVjdG9ycyBhbmQgc2NyaXB0IGpzb24gcGFyc2UnLCBlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIHNjcmlwdHMgaW4gYSBwYWdlIGNvbnRleHQgYW5kIGNsZWFudXAgaXRzZWxmIHdoZW4gZXhlY3V0aW9uIGNvbXBsZXRlc1xuICogQHBhcmFtIHNjcmlwdHMgU2NyaXB0cyBhcnJheSB0byBleGVjdXRlXG4gKi9cbmNvbnN0IGV4ZWN1dGVTY3JpcHRzID0gKHNjcmlwdHM6IHN0cmluZ1tdKSA9PiB7XG4gICAgLy8gV3JhcCB3aXRoIHRyeSBjYXRjaFxuICAgIHNjcmlwdHMudW5zaGlmdCgnKCBmdW5jdGlvbiAoKSB7IHRyeSB7Jyk7XG4gICAgc2NyaXB0cy5wdXNoKFwifSBjYXRjaCAoZXgpIHsgY29uc29sZS5lcnJvcignRXJyb3IgZXhlY3V0aW5nIEFHIGpzOiAnICsgZXgpOyB9IH0pKCk7XCIpO1xuXG4gICAgY29uc3Qgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0VGFnLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcbiAgICBzY3JpcHRUYWcudGV4dENvbnRlbnQgPSBzY3JpcHRzLmpvaW4oJ1xcclxcbicpO1xuXG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG4gICAgaWYgKHNjcmlwdFRhZy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHNjcmlwdFRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdFRhZyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIEpTIGluamVjdGlvbnMuXG4gKiBAcGFyYW0gc2NyaXB0cyBBcnJheSB3aXRoIEpTIHNjcmlwdHNcbiAqIEBwYXJhbSB2ZXJib3NlIGxvZ2dpbmdcbiAqL1xuY29uc3QgYXBwbHlTY3JpcHRzID0gKHNjcmlwdHM6IHN0cmluZ1tdLCB2ZXJib3NlOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFzY3JpcHRzIHx8IHNjcmlwdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dNZXNzYWdlKHZlcmJvc2UsIGBzY3JpcHRzIGxlbmd0aDogJHtzY3JpcHRzLmxlbmd0aH1gKTtcbiAgICBleGVjdXRlU2NyaXB0cyhzY3JpcHRzLnJldmVyc2UoKSk7XG59O1xuXG4vKipcbiAqIFByb3RlY3RzIHNwZWNpZmllZCBzdHlsZSBlbGVtZW50IGZyb20gY2hhbmdlcyB0byB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQWRkIGEgbXV0YXRpb24gb2JzZXJ2ZXIsIHdoaWNoIGlzIGFkZHMgb3VyIHJ1bGVzIGFnYWluIGlmIGl0IHdhcyByZW1vdmVkXG4gKlxuICogQHBhcmFtIHByb3RlY3RTdHlsZUVsIHByb3RlY3RlZCBzdHlsZSBlbGVtZW50XG4gKi9cbmNvbnN0IHByb3RlY3RTdHlsZUVsZW1lbnRDb250ZW50ID0gKHByb3RlY3RTdHlsZUVsOiBOb2RlKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IE11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBvYnNlcnZlciwgd2hpY2ggb2JzZXJ2ZSBwcm90ZWN0U3R5bGVFbCBpbm5lciBjaGFuZ2VzLCB3aXRob3V0IGRlbGV0aW5nIHN0eWxlRWwgKi9cbiAgICBjb25zdCBpbm5lck9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAocHJvdGVjdFN0eWxlRWwuaGFzQXR0cmlidXRlKCdtb2QnKSAmJiBwcm90ZWN0U3R5bGVFbC5nZXRBdHRyaWJ1dGUoJ21vZCcpID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHByb3RlY3RTdHlsZUVsLnJlbW92ZUF0dHJpYnV0ZSgnbW9kJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHByb3RlY3RTdHlsZUVsLnNldEF0dHJpYnV0ZSgnbW9kJywgJ2lubmVyJyk7XG4gICAgICAgICAgICBsZXQgaXNQcm90ZWN0U3R5bGVFbE1vZGlmaWVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZnVydGhlciwgdGhlcmUgYXJlIHR3byBtdXR1YWxseSBleGNsdXNpdmUgc2l0dWF0aW9uczogZWl0aGVyIHRoZXJlIHdlcmUgY2hhbmdlc1xuICAgICAgICAgICAgICogdGhlIHRleHQgb2YgcHJvdGVjdFN0eWxlRWwsIGVpdGhlciB0aGVyZSB3YXMgcmVtb3ZlcyBhIHdob2xlIGNoaWxkIFwidGV4dFwiXG4gICAgICAgICAgICAgKiBlbGVtZW50IG9mIHByb3RlY3RTdHlsZUVsIHdlJ2xsIHByb2Nlc3MgYm90aCBvZiB0aGVtXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChtLnJlbW92ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpc1Byb3RlY3RTdHlsZUVsTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcm90ZWN0U3R5bGVFbC5hcHBlbmRDaGlsZChtLnJlbW92ZWROb2Rlc1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaXNQcm90ZWN0U3R5bGVFbE1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBwcm90ZWN0U3R5bGVFbC50ZXh0Q29udGVudCA9IG0ub2xkVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNQcm90ZWN0U3R5bGVFbE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHByb3RlY3RTdHlsZUVsLnJlbW92ZUF0dHJpYnV0ZSgnbW9kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBpbm5lck9ic2VydmVyLm9ic2VydmUocHJvdGVjdFN0eWxlRWwsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgY3NzIHN0eWxlc2hlZXRcbiAqIEBwYXJhbSBzdHlsZVNlbGVjdG9ycyBBcnJheSBvZiBzdHlsZXNoZWV0cyBvciBzZWxlY3RvcnNcbiAqIEBwYXJhbSB2ZXJib3NlIGxvZ2dpbmdcbiAqL1xuY29uc3QgYXBwbHlDc3MgPSAoc3R5bGVTZWxlY3RvcnM6IHN0cmluZ1tdLCB2ZXJib3NlOiBib29sZWFuKSA9PiB7XG4gICAgY29uc29sZS5sb2coc3R5bGVTZWxlY3RvcnMpO1xuICAgIGlmICghc3R5bGVTZWxlY3RvcnMgfHwgIXN0eWxlU2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coc3R5bGVTZWxlY3RvcnMpO1xuXG4gICAgbG9nTWVzc2FnZSh2ZXJib3NlLCBgY3NzIGxlbmd0aDogJHtzdHlsZVNlbGVjdG9ycy5sZW5ndGh9YCk7XG5cbiAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cbiAgICBjb25zdCBzZWxlY3RvcnMgPSBzdHlsZVNlbGVjdG9ycy5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgICBjb25zb2xlLmxvZyhzZWxlY3RvcnMpO1xuICAgIHNlbGVjdG9ycy5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xuICAgICAgICBzdHlsZUVsZW1lbnQuc2hlZXQhLmluc2VydFJ1bGUoc2VsZWN0b3IpO1xuICAgIH0pO1xuXG4gICAgcHJvdGVjdFN0eWxlRWxlbWVudENvbnRlbnQoc3R5bGVFbGVtZW50KTtcbn07XG5cbi8qKlxuICogQXBwbGllcyBFeHRlbmRlZCBDc3Mgc3R5bGVzaGVldFxuICpcbiAqIEBwYXJhbSBleHRlbmRlZENzcyBBcnJheSB3aXRoIEV4dGVuZGVkQ3NzIHN0eWxlc2hlZXRzXG4gKiBAcGFyYW0gdmVyYm9zZSBsb2dnaW5nXG4gKi9cbmNvbnN0IGFwcGx5RXh0ZW5kZWRDc3MgPSAoZXh0ZW5kZWRDc3M6IHN0cmluZ1tdLCB2ZXJib3NlOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFleHRlbmRlZENzcyB8fCAhZXh0ZW5kZWRDc3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dNZXNzYWdlKHZlcmJvc2UsIGBleHRlbmRlZCBjc3MgbGVuZ3RoOiAke2V4dGVuZGVkQ3NzLmxlbmd0aH1gKTtcbiAgICBjb25zdCBleHRjc3MgPSBuZXcgRXh0ZW5kZWRDc3Moe1xuICAgICAgICBzdHlsZVNoZWV0OiBleHRlbmRlZENzc1xuICAgICAgICAgICAgLmZpbHRlcigocykgPT4gcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpXG4gICAgICAgICAgICAubWFwKChzKSA9PiAoc1tzLmxlbmd0aCAtIDFdICE9PSAnfScgPyBgJHtzfSB7ZGlzcGxheTpub25lIWltcG9ydGFudDt9YCA6IHMpKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxuICAgIH0pO1xuICAgIGV4dGNzcy5hcHBseSgpO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHNjcmlwdGxldHNcbiAqXG4gKiBAcGFyYW0gc2NyaXB0bGV0c0RhdGEgQXJyYXkgd2l0aCBzY3JpcHRsZXRzIGRhdGFcbiAqIEBwYXJhbSB2ZXJib3NlIGxvZ2dpbmdcbiAqL1xuY29uc3QgYXBwbHlTY3JpcHRsZXRzID0gKHNjcmlwdGxldHNEYXRhOiBzdHJpbmdbXSwgdmVyYm9zZTogYm9vbGVhbikgPT4ge1xuICAgIGlmICghc2NyaXB0bGV0c0RhdGEgfHwgIXNjcmlwdGxldHNEYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nTWVzc2FnZSh2ZXJib3NlLCBgc2NyaXB0bGV0cyBsZW5ndGg6ICR7c2NyaXB0bGV0c0RhdGEubGVuZ3RofWApO1xuICAgIGNvbnN0IHNjcmlwdGxldEV4ZWN1dGFibGVTY3JpcHRzID0gc2NyaXB0bGV0c0RhdGFcbiAgICAgICAgLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICAgICAgcGFyYW0uZW5naW5lID0gJ3NhZmFyaS1leHRlbnNpb24nO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS52ZXJib3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHNjcmlwdGxldHMgJiYgc2NyaXB0bGV0cy5pbnZva2UocGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGUgfHwgJyc7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coc2NyaXB0bGV0RXhlY3V0YWJsZVNjcmlwdHMpO1xuICAgIGV4ZWN1dGVTY3JpcHRzKHNjcmlwdGxldEV4ZWN1dGFibGVTY3JpcHRzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc29sZS5sb2cod2luZG93LmFkZyk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgaW5qZWN0ZWQgc2NyaXB0IGFuZCBjc3NcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3JzQW5kU2NyaXB0c1xuICogQHBhcmFtIHZlcmJvc2VcbiAqL1xuY29uc3QgYXBwbHlBZHZhbmNlZEJsb2NraW5nRGF0YSA9IChzZWxlY3RvcnNBbmRTY3JpcHRzOiBTZWxlY3RvcnNBbmRTY3JpcHRzLCB2ZXJib3NlID0gdHJ1ZSkgPT4ge1xuICAgIGxvZ01lc3NhZ2UodmVyYm9zZSwgJ0FwcGx5aW5nIHNjcmlwdHMgYW5kIGNzcy4uJyk7XG4gICAgbG9nTWVzc2FnZSh2ZXJib3NlLCBgRnJhbWUgdXJsOiAke3dpbmRvdy5sb2NhdGlvbi5ocmVmfWApO1xuXG4gICAgYXBwbHlTY3JpcHRzKHNlbGVjdG9yc0FuZFNjcmlwdHMuc2NyaXB0cywgdmVyYm9zZSk7XG4gICAgYXBwbHlDc3Moc2VsZWN0b3JzQW5kU2NyaXB0cy5jc3NJbmplY3QsIHZlcmJvc2UpO1xuICAgIGFwcGx5RXh0ZW5kZWRDc3Moc2VsZWN0b3JzQW5kU2NyaXB0cy5jc3NFeHRlbmRlZCwgdmVyYm9zZSk7XG4gICAgYXBwbHlTY3JpcHRsZXRzKHNlbGVjdG9yc0FuZFNjcmlwdHMuc2NyaXB0bGV0cywgdmVyYm9zZSk7XG5cbiAgICBsb2dNZXNzYWdlKHZlcmJvc2UsICdBcHBseWluZyBzY3JpcHRzIGFuZCBjc3MgLSBkb25lJyk7XG59O1xuXG5jb25zdCBpbml0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudCkge1xuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYgJiYgd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignaHR0cCcpID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEdldHRpbmdTY3JpcHRzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGxldCBzZWxlY3RvcnNBbmRTY3JpcHRzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnNBbmRTY3JpcHRzID0gYXdhaXQgZ2V0U2VsZWN0b3JzQW5kU2NyaXB0cygpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFRpbWUgdG8gZ2V0IHNlbGVjdG9ycyBhbmQgc2NyaXB0cyBmcm9tIG5hdGl2ZSBwYWdlIHRvIGNvbnRlbnQgc2NyaXB0OiAke0RhdGUubm93KCkgLSBzdGFydEdldHRpbmdTY3JpcHRzfSBtc2ApO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yc0FuZFNjcmlwdHMpIHtcbiAgICAgICAgICAgICAgICBhcHBseUFkdmFuY2VkQmxvY2tpbmdEYXRhKHNlbGVjdG9yc0FuZFNjcmlwdHMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjb250ZW50ID0ge1xuICAgIGluaXQsXG59O1xuIiwiLyohIGV4dGVuZGVkLWNzcyAtIHYxLjMuMTIgLSBNb24gTWF5IDMxIDIwMjFcbiogaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0V4dGVuZGVkQ3NzXG4qIENvcHlyaWdodCAoYykgMjAyMSBBZEd1YXJkLiBMaWNlbnNlZCBMR1BMLTMuMFxuKi9cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEFkZ3VhcmQgU29mdHdhcmUgTHRkXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xudmFyIHV0aWxzID0ge307XG51dGlscy5NdXRhdGlvbk9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG4vKipcbiAqIFN0b3JlcyBuYXRpdmUgTm9kZSB0ZXh0Q29udGVudCBnZXR0ZXIgdG8gYmUgdXNlZCBmb3IgY29udGFpbnMgcHNldWRvLWNsYXNzXG4gKiBiZWNhdXNlIGVsZW1lbnRzJyAndGV4dENvbnRlbnQnIGFuZCAnaW5uZXJUZXh0JyBwcm9wZXJ0aWVzIG1pZ2h0IGJlIG1vY2tlZFxuICogaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0V4dGVuZGVkQ3NzL2lzc3Vlcy8xMjdcbiAqL1xuXG51dGlscy5ub2RlVGV4dENvbnRlbnRHZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuYXRpdmVOb2RlID0gd2luZG93Lk5vZGUgfHwgTm9kZTtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmF0aXZlTm9kZS5wcm90b3R5cGUsICd0ZXh0Q29udGVudCcpLmdldDtcbn0oKTtcblxudXRpbHMuaXNTYWZhcmlCcm93c2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaXNDaHJvbWUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTE7XG4gIHZhciBpc1NhZmFyaSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgPiAtMTtcblxuICBpZiAoaXNTYWZhcmkpIHtcbiAgICBpZiAoaXNDaHJvbWUpIHtcbiAgICAgIC8vIENocm9tZSBzZWVtcyB0byBoYXZlIGJvdGggQ2hyb21lIGFuZCBTYWZhcmkgdXNlckFnZW50c1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSgpO1xuLyoqXG4gKiBDb252ZXJ0cyByZWd1bGFyIGV4cHJlc3Npb25zIHBhc3NlZCBhcyBwc2V1ZG8gY2xhc3MgYXJndW1lbnRzIGludG8gUmVnRXhwIGluc3RhbmNlcy5cbiAqIEhhdmUgdG8gdW5lc2NhcGUgZG91YmxlcXVvdGUgXCIgYXMgd2VsbCwgYmVjYXVzZSB3ZSBlc2NhcGUgdGhlbSB3aGlsZSBlbmNsb3Npbmcgc3VjaFxuICogYXJndW1lbnRzIHdpdGggZG91YmxlcXVvdGVzLCBhbmQgc2l6emxlIGRvZXMgbm90IGF1dG9tYXRpY2FsbHkgdW5lc2NhcGVzIHRoZW0uXG4gKi9cblxuXG51dGlscy5wc2V1ZG9BcmdUb1JlZ2V4ID0gZnVuY3Rpb24gKHJlZ2V4U3JjLCBmbGFnKSB7XG4gIGZsYWcgPSBmbGFnIHx8ICdpJztcbiAgcmVnZXhTcmMgPSByZWdleFNyYy50cmltKCkucmVwbGFjZSgvXFxcXChbXCJcXFxcXSkvZywgJyQxJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4U3JjLCBmbGFnKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byB0aGUgcmVnZXhwXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICovXG5cblxudXRpbHMudG9SZWdFeHAgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmIChzdHJbMF0gPT09ICcvJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzdHIuc2xpY2UoMSwgLTEpKTtcbiAgfVxuXG4gIHZhciBlc2NhcGVkID0gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGVzY2FwZWQpO1xufTtcblxudXRpbHMuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzdHIsIHByZWZpeCkge1xuICAvLyBpZiBzdHIgPT09ICcnLCAoc3RyICYmIGZhbHNlKSB3aWxsIHJldHVybiAnJ1xuICAvLyB0aGF0J3Mgd2h5IGl0IGhhcyB0byBiZSAhIXN0clxuICByZXR1cm4gISFzdHIgJiYgc3RyLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbn07XG5cbnV0aWxzLmVuZHNXaXRoID0gZnVuY3Rpb24gKHN0ciwgcG9zdGZpeCkge1xuICBpZiAoIXN0ciB8fCAhcG9zdGZpeCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdHIuZW5kc1dpdGgpIHtcbiAgICByZXR1cm4gc3RyLmVuZHNXaXRoKHBvc3RmaXgpO1xuICB9XG5cbiAgdmFyIHQgPSBTdHJpbmcocG9zdGZpeCk7XG4gIHZhciBpbmRleCA9IHN0ci5sYXN0SW5kZXhPZih0KTtcbiAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPT09IHN0ci5sZW5ndGggLSB0Lmxlbmd0aDtcbn07XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgcmVndWxhciBleHByZXNzaW9uIGZyb20gYSB1cmwgZmlsdGVyIHJ1bGUgc3ludGF4LlxuICovXG5cblxudXRpbHMuY3JlYXRlVVJMUmVnZXggPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENvbnN0YW50c1xuICB2YXIgcmVnZXhDb25maWd1cmF0aW9uID0ge1xuICAgIG1hc2tTdGFydFVybDogJ3x8JyxcbiAgICBtYXNrUGlwZTogJ3wnLFxuICAgIG1hc2tTZXBhcmF0b3I6ICdeJyxcbiAgICBtYXNrQW55U3ltYm9sOiAnKicsXG4gICAgcmVnZXhBbnlTeW1ib2w6ICcuKicsXG4gICAgcmVnZXhTZXBhcmF0b3I6ICcoW14gYS16QS1aMC05LiVfLV18JCknLFxuICAgIHJlZ2V4U3RhcnRVcmw6ICdeKGh0dHB8aHR0cHN8d3N8d3NzKTovLyhbYS16MC05LV8uXStcXFxcLik/JyxcbiAgICByZWdleFN0YXJ0U3RyaW5nOiAnXicsXG4gICAgcmVnZXhFbmRTdHJpbmc6ICckJ1xuICB9OyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9yZWdleHBcbiAgLy8gc2hvdWxkIGJlIGVzY2FwZWQgLiAqICsgPyBeICQgeyB9ICggKSB8IFsgXSAvIFxcXG4gIC8vIGV4Y2VwdCBvZiAqIHwgXlxuXG4gIHZhciBzcGVjaWFscyA9IFsnLicsICcrJywgJz8nLCAnJCcsICd7JywgJ30nLCAnKCcsICcpJywgJ1snLCAnXScsICdcXFxcJywgJy8nXTtcbiAgdmFyIHNwZWNpYWxzUmVnZXggPSBuZXcgUmVnRXhwKFwiW1wiLmNvbmNhdChzcGVjaWFscy5qb2luKCdcXFxcJyksIFwiXVwiKSwgJ2cnKTtcbiAgLyoqXG4gICAqIEVzY2FwZXMgcmVndWxhciBleHByZXNzaW9uIHN0cmluZ1xuICAgKi9cblxuICB2YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShzcGVjaWFsc1JlZ2V4LCAnXFxcXCQmJyk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2VBbGwgPSBmdW5jdGlvbiByZXBsYWNlQWxsKHN0ciwgZmluZCwgcmVwbGFjZSkge1xuICAgIGlmICghc3RyKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBzdHIuc3BsaXQoZmluZCkuam9pbihyZXBsYWNlKTtcbiAgfTtcbiAgLyoqXG4gICAqIE1haW4gZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyBhIHVybCBmaWx0ZXIgcnVsZSBzdHJpbmcgdG8gYSByZWdleC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcmV0dXJuIHtSZWdFeHB9XG4gICAqL1xuXG5cbiAgdmFyIGNyZWF0ZVJlZ2V4VGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZVJlZ2V4VGV4dChzdHIpIHtcbiAgICB2YXIgcmVnZXggPSBlc2NhcGVSZWdFeHAoc3RyKTtcblxuICAgIGlmICh1dGlscy5zdGFydHNXaXRoKHJlZ2V4LCByZWdleENvbmZpZ3VyYXRpb24ubWFza1N0YXJ0VXJsKSkge1xuICAgICAgcmVnZXggPSByZWdleC5zdWJzdHJpbmcoMCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tTdGFydFVybC5sZW5ndGgpICsgcmVwbGFjZUFsbChyZWdleC5zdWJzdHJpbmcocmVnZXhDb25maWd1cmF0aW9uLm1hc2tTdGFydFVybC5sZW5ndGgsIHJlZ2V4Lmxlbmd0aCAtIDEpLCAnXFx8JywgJ1xcXFx8JykgKyByZWdleC5zdWJzdHJpbmcocmVnZXgubGVuZ3RoIC0gMSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5zdGFydHNXaXRoKHJlZ2V4LCByZWdleENvbmZpZ3VyYXRpb24ubWFza1BpcGUpKSB7XG4gICAgICByZWdleCA9IHJlZ2V4LnN1YnN0cmluZygwLCByZWdleENvbmZpZ3VyYXRpb24ubWFza1BpcGUubGVuZ3RoKSArIHJlcGxhY2VBbGwocmVnZXguc3Vic3RyaW5nKHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrUGlwZS5sZW5ndGgsIHJlZ2V4Lmxlbmd0aCAtIDEpLCAnXFx8JywgJ1xcXFx8JykgKyByZWdleC5zdWJzdHJpbmcocmVnZXgubGVuZ3RoIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZ2V4ID0gcmVwbGFjZUFsbChyZWdleC5zdWJzdHJpbmcoMCwgcmVnZXgubGVuZ3RoIC0gMSksICdcXHwnLCAnXFxcXHwnKSArIHJlZ2V4LnN1YnN0cmluZyhyZWdleC5sZW5ndGggLSAxKTtcbiAgICB9IC8vIFJlcGxhY2luZyBzcGVjaWFsIHVybCBtYXNrc1xuXG5cbiAgICByZWdleCA9IHJlcGxhY2VBbGwocmVnZXgsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrQW55U3ltYm9sLCByZWdleENvbmZpZ3VyYXRpb24ucmVnZXhBbnlTeW1ib2wpO1xuICAgIHJlZ2V4ID0gcmVwbGFjZUFsbChyZWdleCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tTZXBhcmF0b3IsIHJlZ2V4Q29uZmlndXJhdGlvbi5yZWdleFNlcGFyYXRvcik7XG5cbiAgICBpZiAodXRpbHMuc3RhcnRzV2l0aChyZWdleCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tTdGFydFVybCkpIHtcbiAgICAgIHJlZ2V4ID0gcmVnZXhDb25maWd1cmF0aW9uLnJlZ2V4U3RhcnRVcmwgKyByZWdleC5zdWJzdHJpbmcocmVnZXhDb25maWd1cmF0aW9uLm1hc2tTdGFydFVybC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuc3RhcnRzV2l0aChyZWdleCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tQaXBlKSkge1xuICAgICAgcmVnZXggPSByZWdleENvbmZpZ3VyYXRpb24ucmVnZXhTdGFydFN0cmluZyArIHJlZ2V4LnN1YnN0cmluZyhyZWdleENvbmZpZ3VyYXRpb24ubWFza1BpcGUubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuZW5kc1dpdGgocmVnZXgsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrUGlwZSkpIHtcbiAgICAgIHJlZ2V4ID0gcmVnZXguc3Vic3RyaW5nKDAsIHJlZ2V4Lmxlbmd0aCAtIDEpICsgcmVnZXhDb25maWd1cmF0aW9uLnJlZ2V4RW5kU3RyaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4LCAnaScpO1xuICB9O1xuXG4gIHJldHVybiBjcmVhdGVSZWdleFRleHQ7XG59KCk7XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGltcGxlbWVudGluZyBMb2NhdGlvbiBpbnRlcmZhY2UgZnJvbSBhIHVybC5cbiAqIEFuIGFsdGVybmF0aXZlIHRvIFVSTC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9GaW5nZXJwcmludGluZ0Jsb2NrZXIvYmxvYi9tYXN0ZXIvc3JjL3NoYXJlZC91cmwudHMjTDY0XG4gKi9cblxuXG51dGlscy5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIChocmVmKSB7XG4gIHZhciBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGFuY2hvci5ocmVmID0gaHJlZjtcblxuICBpZiAoYW5jaG9yLmhvc3QgPT09ICcnKSB7XG4gICAgYW5jaG9yLmhyZWYgPSBhbmNob3IuaHJlZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWFzc2lnblxuICB9XG5cbiAgcmV0dXJuIGFuY2hvcjtcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIEEgaGFzIHRoZSBzYW1lIG9yaWdpbiBhcyBCLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybEEgbG9jYXRpb24uaHJlZiBvZiBBLlxuICogQHBhcmFtIHtMb2NhdGlvbn0gbG9jYXRpb25CIGxvY2F0aW9uIG9mIEIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluQiBkb2N1bWVudC5kb21haW4gb2YgQi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG51dGlscy5pc1NhbWVPcmlnaW4gPSBmdW5jdGlvbiAodXJsQSwgbG9jYXRpb25CLCBkb21haW5CKSB7XG4gIHZhciBsb2NhdGlvbkEgPSB1dGlscy5jcmVhdGVMb2NhdGlvbih1cmxBKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNjcmlwdC11cmxcblxuICBpZiAobG9jYXRpb25BLnByb3RvY29sID09PSAnamF2YXNjcmlwdDonIHx8IGxvY2F0aW9uQS5ocmVmID09PSAnYWJvdXQ6YmxhbmsnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobG9jYXRpb25BLnByb3RvY29sID09PSAnZGF0YTonIHx8IGxvY2F0aW9uQS5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbkEuaG9zdG5hbWUgPT09IGRvbWFpbkIgJiYgbG9jYXRpb25BLnBvcnQgPT09IGxvY2F0aW9uQi5wb3J0ICYmIGxvY2F0aW9uQS5wcm90b2NvbCA9PT0gbG9jYXRpb25CLnByb3RvY29sO1xufTtcbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdG8gdGhyb3R0bGUgZnVuY3Rpb24gY2FsbHMgd2l0aCBzZXRUaW1lb3V0IGFuZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gKi9cblxuXG51dGlscy5Bc3luY1dyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBQaGFudG9tSlMgcGFzc2VzIGEgd3JvbmcgdGltZXN0YW1wIHRvIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbGJhY2sgYW5kIHRoYXQgYnJlYWtzIHRoZSBBc3luY1dyYXBwZXIgbG9naWNcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTQ4MzJcbiAgICovXG4gIHZhciBzdXBwb3J0ZWQgPSB0eXBlb2Ygd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIS9waGFudG9tL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIHJBRiA9IHN1cHBvcnRlZCA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXQ7XG4gIHZhciBjQUYgPSBzdXBwb3J0ZWQgPyBjYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dDtcbiAgdmFyIHBlcmYgPSBzdXBwb3J0ZWQgPyBwZXJmb3JtYW5jZSA6IERhdGU7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge251bWJlcn0gdGhyb3R0bGUgbnVtYmVyLCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgc2hvdWxkIGJlIGV4ZWN1dGVkIHR3aWNlXG4gICAqIGluIHRoaXMgdGltZSBmcmFtZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEFzeW5jV3JhcHBlcihjYWxsYmFjaywgdGhyb3R0bGUpIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIHRoaXMud3JhcHBlZENhbGxiYWNrID0gdGhpcy53cmFwcGVkQ2FsbGJhY2suYmluZCh0aGlzKTtcblxuICAgIGlmICh0aGlzLndyYXBwZWRBc2FwQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMud3JhcHBlZEFzYXBDYWxsYmFjayA9IHRoaXMud3JhcHBlZEFzYXBDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gIEFzeW5jV3JhcHBlci5wcm90b3R5cGUud3JhcHBlZENhbGxiYWNrID0gZnVuY3Rpb24gKHRzKSB7XG4gICAgdGhpcy5sYXN0UnVuID0gaXNOdW1iZXIodHMpID8gdHMgOiBwZXJmLm5vdygpO1xuICAgIGRlbGV0ZSB0aGlzLnJBRmlkO1xuICAgIGRlbGV0ZSB0aGlzLnRpbWVySWQ7XG4gICAgZGVsZXRlIHRoaXMuYXNhcFNjaGVkdWxlZDtcbiAgICB0aGlzLmNhbGxiYWNrKCk7XG4gIH07XG4gIC8qKiBAcHJpdmF0ZSBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBhIHNjaGVkdWxlZCBjYWxsYmFjay4gKi9cblxuXG4gIEFzeW5jV3JhcHBlci5wcm90b3R5cGUuaGFzUGVuZGluZ0NhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc051bWJlcih0aGlzLnJBRmlkKSB8fCBpc051bWJlcih0aGlzLnRpbWVySWQpO1xuICB9O1xuICAvKipcbiAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gY2FsbCBiZWZvcmUgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgKi9cblxuXG4gIEFzeW5jV3JhcHBlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmhhc1BlbmRpbmdDYWxsYmFjaygpKSB7XG4gICAgICAvLyBUaGVyZSBpcyBhIHBlbmRpbmcgZXhlY3V0aW9uIHNjaGVkdWxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMubGFzdFJ1biAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBlbGFwc2VkID0gcGVyZi5ub3coKSAtIHRoaXMubGFzdFJ1bjtcblxuICAgICAgaWYgKGVsYXBzZWQgPCB0aGlzLnRocm90dGxlKSB7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQodGhpcy53cmFwcGVkQ2FsbGJhY2ssIHRoaXMudGhyb3R0bGUgLSBlbGFwc2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuckFGaWQgPSByQUYodGhpcy53cmFwcGVkQ2FsbGJhY2spO1xuICB9O1xuICAvKipcbiAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gY2FsbCBpbiB0aGUgbW9zdCBpbW1lbmVudCBtaWNyb3Rhc2suXG4gICAqIFRoaXMgY2Fubm90IGJlIGNhbmNlbGVkLlxuICAgKi9cblxuXG4gIEFzeW5jV3JhcHBlci5wcm90b3R5cGUucnVuQXNhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hc2FwU2NoZWR1bGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hc2FwU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBjQUYodGhpcy5yQUZpZCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG5cbiAgICBpZiAodXRpbHMuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgLyoqXG4gICAgICAgKiBVc2luZyBNdXRhdGlvbk9ic2VydmVycyB0byBhY2Nlc3MgbWljcm90YXNrIHF1ZXVlIGlzIGEgc3RhbmRhcmQgdGVjaG5pcXVlLFxuICAgICAgICogdXNlZCBpbiBBU0FQIGxpYnJhcnlcbiAgICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL2FzYXAvYmxvYi9tYXN0ZXIvYnJvd3Nlci1yYXcuanMjTDE0MH1cbiAgICAgICAqL1xuICAgICAgaWYgKCF0aGlzLm1vKSB7XG4gICAgICAgIHRoaXMubW8gPSBuZXcgdXRpbHMuTXV0YXRpb25PYnNlcnZlcih0aGlzLndyYXBwZWRDYWxsYmFjayk7XG4gICAgICAgIHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKDEpO1xuICAgICAgICB0aGlzLm1vLm9ic2VydmUodGhpcy5ub2RlLCB7XG4gICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub2RlLm5vZGVWYWx1ZSA9IC10aGlzLm5vZGUubm9kZVZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMud3JhcHBlZENhbGxiYWNrKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSdW5zIHNjaGVkdWxlZCBleGVjdXRpb24gaW1tZWRpYXRlbHksIGlmIHRoZXJlIHdlcmUgYW55LlxuICAgKi9cblxuXG4gIEFzeW5jV3JhcHBlci5wcm90b3R5cGUucnVuSW1tZWRpYXRlbHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaGFzUGVuZGluZ0NhbGxiYWNrKCkpIHtcbiAgICAgIGNBRih0aGlzLnJBRmlkKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgZGVsZXRlIHRoaXMuckFGaWQ7XG4gICAgICBkZWxldGUgdGhpcy50aW1lcklkO1xuICAgICAgdGhpcy53cmFwcGVkQ2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgQXN5bmNXcmFwcGVyLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGVyZi5ub3coKTtcbiAgfTtcblxuICByZXR1cm4gQXN5bmNXcmFwcGVyO1xufSgpO1xuLyoqXG4gKiBTdG9yZXMgbmF0aXZlIE9kUCB0byBiZSB1c2VkIGluIFdlYWtNYXAgYW5kIFNldCBwb2x5ZmlsbHMuXG4gKi9cblxuXG51dGlscy5kZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnV0aWxzLldlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBXZWFrTWFwIDogZnVuY3Rpb24gKCkge1xuICAvKiogT3JpZ2luYWxseSBiYXNlZCBvbiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvV2Vha01hcH0gKi9cbiAgdmFyIGNvdW50ZXIgPSBEYXRlLm5vdygpICUgMWU5O1xuXG4gIHZhciBXZWFrTWFwID0gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICB0aGlzLm5hbWUgPSBcIl9fc3RcIi5jb25jYXQoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkuY29uY2F0KGNvdW50ZXIrKywgXCJfX1wiKTtcbiAgfTtcblxuICBXZWFrTWFwLnByb3RvdHlwZSA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblxuICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIHtcbiAgICAgICAgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLmRlZmluZVByb3BlcnR5KGtleSwgdGhpcy5uYW1lLCB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc1ZhbHVlID0gZW50cnlbMF0gPT09IGtleTtcbiAgICAgIGRlbGV0ZSBlbnRyeVswXTtcbiAgICAgIGRlbGV0ZSBlbnRyeVsxXTtcbiAgICAgIHJldHVybiBoYXNWYWx1ZTtcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBXZWFrTWFwO1xufSgpO1xudXRpbHMuU2V0ID0gdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgPyBTZXQgOiBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcbiAgLyoqXG4gICAqIEEgcG9seWZpbGwgd2hpY2ggY292ZXJzIG9ubHkgdGhlIGJhc2ljIHVzYWdlLlxuICAgKiBPbmx5IHN1cHBvcnRzIG1ldGhvZHMgdGhhdCBhcmUgc3VwcG9ydGVkIGluIElFMTEuXG4gICAqIHtAbGluayBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9zY3JpcHRpbmcvamF2YXNjcmlwdC9yZWZlcmVuY2Uvc2V0LW9iamVjdC1qYXZhc2NyaXB0fVxuICAgKiBBc3N1bWVzIHRoYXQgJ2tleSdzIGFyZSBhbGwgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMgc3VjaCBhcyBhIG51bWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gaXRlbXMgSW5pdGlhbCBpdGVtcyBpbiB0aGlzIHNldFxuICAgKi9cblxuICB2YXIgU2V0ID0gZnVuY3Rpb24gU2V0KGl0ZW1zKSB7XG4gICAgdGhpcy5uYW1lID0gXCJfX3N0XCIuY29uY2F0KE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApLmNvbmNhdChjb3VudGVyKyssIFwiX19cIik7XG4gICAgdGhpcy5rZXlzID0gW107XG5cbiAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKSB7XG4gICAgICB2YXIgaUl0ZW1zID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaUl0ZW1zLS0pIHtcbiAgICAgICAgdGhpcy5hZGQoaXRlbXNbaUl0ZW1zXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNldC5wcm90b3R5cGUgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoa2V5KSB7XG4gICAgICBpZiAoIWlzTnVtYmVyKGtleVt0aGlzLm5hbWVdKSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmtleXMucHVzaChrZXkpIC0gMTtcbiAgICAgICAgdXRpbHMuZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogaW5kZXgsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICBpZiAoaXNOdW1iZXIoa2V5W3RoaXMubmFtZV0pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBkZWxldGUgdGhpcy5rZXlzW2luZGV4XTtcbiAgICAgICAga2V5W3RoaXMubmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBpc051bWJlcihrZXlbdGhpcy5uYW1lXSk7XG4gICAgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGtleVt0aGlzLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2IpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMua2V5cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjYih2YWx1ZSwgdmFsdWUsIHRoYXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB1dGlscy5kZWZpbmVQcm9wZXJ0eShTZXQucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIC8vIFNraXBzIGhvbGVzLlxuICAgICAgcmV0dXJuIHRoaXMua2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYykge1xuICAgICAgICByZXR1cm4gYWNjICsgMTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBTZXQ7XG59KCk7XG4vKipcbiAqIFZlbmRvci1zcGVjaWZpYyBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzXG4gKi9cblxudXRpbHMubWF0Y2hlc1Byb3BlcnR5TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb3BzID0gWydtYXRjaGVzJywgJ21hdGNoZXNTZWxlY3RvcicsICdtb3pNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnb01hdGNoZXNTZWxlY3RvcicsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgIGlmIChFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wc1tpXSkpIHtcbiAgICAgIHJldHVybiBwcm9wc1tpXTtcbiAgICB9XG4gIH1cbn0oKTtcbi8qKlxuICogUHJvdmlkZXMgc3RhdHMgaW5mb3JtYXRpb25cbiAqL1xuXG5cbnV0aWxzLlN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAvKiogQG1lbWJlciB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgdGhpcy5hcnJheSA9IFtdO1xuICAvKiogQG1lbWJlciB7bnVtYmVyfSAqL1xuXG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdmFyIHplcm9EZXNjcmlwdG9yID0ge1xuICAgIHZhbHVlOiAwLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH07XG4gIC8qKiBAbWVtYmVyIHtudW1iZXJ9IEBwcml2YXRlICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdW0nLCB6ZXJvRGVzY3JpcHRvcik7XG4gIC8qKiBAbWVtYmVyIHtudW1iZXJ9IEBwcml2YXRlICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzcXVhcmVkU3VtJywgemVyb0Rlc2NyaXB0b3IpO1xufTtcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGFQb2ludCBkYXRhIHBvaW50XG4gKi9cblxuXG51dGlscy5TdGF0cy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhUG9pbnQpIHtcbiAgdGhpcy5hcnJheS5wdXNoKGRhdGFQb2ludCk7XG4gIHRoaXMubGVuZ3RoKys7XG4gIHRoaXMuc3VtICs9IGRhdGFQb2ludDtcbiAgdGhpcy5zcXVhcmVkU3VtICs9IGRhdGFQb2ludCAqIGRhdGFQb2ludDtcbiAgLyoqIEBtZW1iZXIge251bWJlcn0gKi9cblxuICB0aGlzLm1lYW4gPSB0aGlzLnN1bSAvIHRoaXMubGVuZ3RoO1xuICAvKiogQG1lbWJlciB7bnVtYmVyfSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cbiAgdGhpcy5zdGRkZXYgPSBNYXRoLnNxcnQodGhpcy5zcXVhcmVkU3VtIC8gdGhpcy5sZW5ndGggLSBNYXRoLnBvdyh0aGlzLm1lYW4sIDIpKTtcbn07XG4vKiogU2FmZSBjb25zb2xlLmVycm9yIHZlcnNpb24gKi9cblxuXG51dGlscy5sb2dFcnJvciA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmIGNvbnNvbGUuZXJyb3IuYmluZCA/IGNvbnNvbGUuZXJyb3IuYmluZCh3aW5kb3cuY29uc29sZSkgOiBjb25zb2xlLmVycm9yO1xuLyoqIFNhZmUgY29uc29sZS5pbmZvIHZlcnNpb24gKi9cblxudXRpbHMubG9nSW5mbyA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmluZm8gJiYgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgJiYgY29uc29sZS5pbmZvLmJpbmQgPyBjb25zb2xlLmluZm8uYmluZCh3aW5kb3cuY29uc29sZSkgOiBjb25zb2xlLmluZm87XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ251bWJlcic7XG59XG4vKipcbiAqIFJldHVybnMgcGF0aCB0byBlbGVtZW50IHdlIHdpbGwgdXNlIGFzIGVsZW1lbnQgaWRlbnRpZmllclxuICogQHBhcmFtIHtFbGVtZW50fSBpbnB1dEVsXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHBhdGggdG8gdGhlIGVsZW1lbnRcbiAqL1xuXG5cbnV0aWxzLmdldE5vZGVTZWxlY3RvciA9IGZ1bmN0aW9uIChpbnB1dEVsKSB7XG4gIGlmICghKGlucHV0RWwgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gcmVjZWl2ZWQgYXJndW1lbnQgd2l0aCB3cm9uZyB0eXBlJyk7XG4gIH1cblxuICB2YXIgZWwgPSBpbnB1dEVsO1xuICB2YXIgcGF0aCA9IFtdOyAvLyB3ZSBuZWVkIHRvIGNoZWNrICchIWVsJyBmaXJzdCBiZWNhdXNlIGl0IGlzIHBvc3NpYmxlXG4gIC8vIHRoYXQgc29tZSBhbmNlc3RvciBvZiB0aGUgaW5wdXRFbCB3YXMgcmVtb3ZlZCBiZWZvcmUgaXRcblxuICB3aGlsZSAoISFlbCAmJiBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGVsLmlkICYmIHR5cGVvZiBlbC5pZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlbGVjdG9yICs9IFwiI1wiLmNvbmNhdChlbC5pZCk7XG4gICAgICBwYXRoLnVuc2hpZnQoc2VsZWN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaWJsaW5nID0gZWw7XG4gICAgICB2YXIgbnRoID0gMTtcblxuICAgICAgd2hpbGUgKHNpYmxpbmcucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnByZXZpb3VzU2libGluZztcblxuICAgICAgICBpZiAoc2libGluZy5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgc2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgIG50aCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChudGggIT09IDEpIHtcbiAgICAgICAgc2VsZWN0b3IgKz0gXCI6bnRoLW9mLXR5cGUoXCIuY29uY2F0KG50aCwgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGgudW5zaGlmdChzZWxlY3Rvcik7XG4gICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHBhdGguam9pbignID4gJyk7XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEFkZ3VhcmQgU29mdHdhcmUgTHRkXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3MgY3NzIHV0aWxzXG4gKlxuICogQHR5cGUge3tub3JtYWxpemV9fVxuICovXG52YXIgY3NzVXRpbHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBSZWdleCB0aGF0IG1hdGNoZXMgQWRHdWFyZCdzIGJhY2t3YXJkIGNvbXBhdGlibGUgc3ludGF4ZXMuXG4gICAqL1xuICB2YXIgcmVBdHRyRmFsbGJhY2sgPSAvXFxbLSg/OmV4dHxhYnApLShbYS16LV9dKyk9KFtcIiddKSgoPzooPz0oXFxcXD8pKVxcNC4pKj8pXFwyXFxdL2c7XG4gIC8qKlxuICAgKiBDb21wbGV4IHJlcGxhY2VtZW50IGZ1bmN0aW9uLlxuICAgKiBVbmVzY2FwZXMgcXVvdGUgY2hhcmFjdGVycyBpbnNpZGUgb2YgYW4gZXh0ZW5kZWQgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBtYXRjaCAgICAgV2hvbGUgbWF0Y2hlZCBzdHJpbmdcbiAgICogQHBhcmFtIG5hbWUgICAgICBHcm91cCAxXG4gICAqIEBwYXJhbSBxdW90ZUNoYXIgR3JvdXAgMlxuICAgKiBAcGFyYW0gdmFsdWUgICAgIEdyb3VwIDNcbiAgICovXG5cbiAgdmFyIGV2YWx1YXRlTWF0Y2ggPSBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoKG1hdGNoLCBuYW1lLCBxdW90ZUNoYXIsIHZhbHVlKSB7XG4gICAgLy8gVW5lc2NhcGUgcXVvdGVzXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIihbXlxcXFxcXFxcXXxeKVxcXFxcXFxcXCIuY29uY2F0KHF1b3RlQ2hhciksICdnJyk7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlLCBcIiQxXCIuY29uY2F0KHF1b3RlQ2hhcikpO1xuICAgIHJldHVybiBcIjpcIi5jb25jYXQobmFtZSwgXCIoXCIpLmNvbmNhdCh2YWx1ZSwgXCIpXCIpO1xuICB9OyAvLyBTaXp6bGUncyBwYXJzaW5nIG9mIHBzZXVkbyBjbGFzcyBhcmd1bWVudHMgaXMgYnVnZ3kgb24gY2VydGFpbiBjaXJjdW1zdGFuY2VzXG4gIC8vIFdlIHN1cHBvcnQgZm9sbG93aW5nIGZvcm0gb2YgYXJndW1lbnRzOlxuICAvLyAxLiBmb3IgOm1hdGNoZXMtY3NzLCB0aG9zZSBvZiBhIGZvcm0ge3Byb3BlcnR5TmFtZX06IC8uKi9cbiAgLy8gMi4gZm9yIDpjb250YWlucywgdGhvc2Ugb2YgYSBmb3JtIC8uKi9cbiAgLy8gV2UgdHJhbnNmb3JtIHN1Y2ggY2FzZXMgaW4gYSB3YXkgdGhhdCBTaXp6bGUgaGFzIG5vIGFtYmlndWl0eSBpbiBwYXJzaW5nIGFyZ3VtZW50cy5cblxuXG4gIHZhciByZU1hdGNoZXNDc3MgPSAvXFw6KG1hdGNoZXMtY3NzKD86LWFmdGVyfC1iZWZvcmUpPylcXCgoW2Etei1cXHNdKlxcOlxccypcXC8oPzpcXFxcLnxbXlxcL10pKj9cXC9cXHMqKVxcKS9nO1xuICB2YXIgcmVDb250YWlucyA9IC86KD86LWFicC0pPyhjb250YWluc3xoYXMtdGV4dClcXCgoXFxzKlxcLyg/OlxcXFwufFteXFwvXSkqP1xcL1xccyopXFwpL2c7XG4gIHZhciByZVNjb3BlID0gL1xcKFxcOnNjb3BlID4vZzsgLy8gTm90ZSB0aGF0IHdlIHJlcXVpcmUgYC9gIGNoYXJhY3RlciBpbiByZWd1bGFyIGV4cHJlc3Npb25zIHRvIGJlIGVzY2FwZWQuXG5cbiAgLyoqXG4gICAqIFVzZWQgZm9yIHByZS1wcm9jZXNzaW5nIHBzZXVkby1jbGFzc2VzIHZhbHVlcyB3aXRoIGFib3ZlIHR3byByZWdleGVzLlxuICAgKi9cblxuICB2YXIgYWRkUXVvdGVzID0gZnVuY3Rpb24gYWRkUXVvdGVzKF8sIGMxLCBjMikge1xuICAgIHJldHVybiBcIjpcIi5jb25jYXQoYzEsIFwiKFxcXCJcIikuY29uY2F0KGMyLnJlcGxhY2UoL1tcIlxcXFxdL2csICdcXFxcJCYnKSwgXCJcXFwiKVwiKTtcbiAgfTtcblxuICB2YXIgU0NPUEVfUkVQTEFDRVIgPSAnKD4nO1xuICAvKipcbiAgICogTm9ybWFsaXplcyBzcGVjaWZpZWQgY3NzIHRleHQgaW4gYSBmb3JtIHRoYXQgY2FuIGJlIHBhcnNlZCBieSB0aGVcbiAgICogU2l6emxlIGVuZ2luZS5cbiAgICogTm9ybWFsaXphdGlvbiBtZWFuc1xuICAgKiAgMS4gdHJhbnNmb3JtaW5nIFstZXh0LSo9XCJcIl0gYXR0cmlidXRlcyB0byBwc2V1ZG8gY2xhc3Nlc1xuICAgKiAgMi4gZW5jbG9zaW5nIHBvc3NpYmx5IGFtYmlndW91cyBhcmd1bWVudHMgb2YgYDpjb250YWluc2AsXG4gICAqICAgICBgOm1hdGNoZXMtY3NzYCBwc2V1ZG8gY2xhc3NlcyB3aXRoIHF1b3Rlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuICB2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKGNzc1RleHQpIHtcbiAgICB2YXIgbm9ybWFsaXplZENzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UocmVBdHRyRmFsbGJhY2ssIGV2YWx1YXRlTWF0Y2gpLnJlcGxhY2UocmVNYXRjaGVzQ3NzLCBhZGRRdW90ZXMpLnJlcGxhY2UocmVDb250YWlucywgYWRkUXVvdGVzKS5yZXBsYWNlKHJlU2NvcGUsIFNDT1BFX1JFUExBQ0VSKTtcbiAgICByZXR1cm4gbm9ybWFsaXplZENzc1RleHQ7XG4gIH07XG5cbiAgdmFyIGlzU2ltcGxlU2VsZWN0b3JWYWxpZCA9IGZ1bmN0aW9uIGlzU2ltcGxlU2VsZWN0b3JWYWxpZChzZWxlY3Rvcikge1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZSxcbiAgICBpc1NpbXBsZVNlbGVjdG9yVmFsaWQ6IGlzU2ltcGxlU2VsZWN0b3JWYWxpZFxuICB9O1xufSgpO1xuXG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNC1wcmUtYWRndWFyZFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAyMC0wOC0wNFxuICovXG5cbi8qKlxuICogVmVyc2lvbiBvZiBTaXp6bGUgcGF0Y2hlZCBieSBBZEd1YXJkIGluIG9yZGVyIHRvIGJlIHVzZWQgaW4gdGhlIEV4dGVuZGVkQ3NzIG1vZHVsZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9zaXp6bGUtZXh0Y3NzXG4gKlxuICogTG9vayBmb3IgW0FkR3VhcmQgUGF0Y2hdIGFuZCBBREdVQVJEX0VYVENTUyBtYXJrZXJzIHRvIGZpbmQgb3V0IHdoYXQgZXhhY3RseSB3YXMgY2hhbmdlZCBieSB1cy5cbiAqXG4gKiBHbG9iYWwgY2hhbmdlczpcbiAqIDEuIEFkZGVkIGFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byB0aGUgXCJTaXp6bGUudG9rZW5pemVcIiBtZXRob2Qgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBmb3Igc3R5bGVzaGVldHMgcGFyc2luZyBhbmQgdmFsaWRhdGlvbi5cbiAqIDIuIEFkZGVkIHRva2VucyByZS1zb3J0aW5nIG1lY2hhbmlzbSBmb3JjaW5nIHNsb3cgcHNldWRvcyB0byBiZSBtYXRjaGVkIGxhc3QgIChzZWUgc29ydFRva2VuR3JvdXBzKS5cbiAqIDMuIEZpeCB0aGUgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZSBjYWNoaW5nIC0tIHRoZXJlIHdhcyBubyB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIGEga2V5LlxuICogNC4gQWRkZWQgU2l6emxlLmNvbXBpbGUgY2FsbCB0byB0aGUgYDpoYXNgIHBzZXVkbyBkZWZpbml0aW9uLlxuICpcbiAqIENoYW5nZXMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgQURHVUFSRF9FWFRDU1MgYnVpbGQgb25seTpcbiAqIDEuIERvIG5vdCBleHBvc2UgU2l6emxlIHRvIHRoZSBnbG9iYWwgc2NvcGUuIEluaXRpYWxpemUgaXQgbGF6aWx5IHZpYSBpbml0aWFsaXplU2l6emxlKCkuXG4gKiAyLiBSZW1vdmVkIDpjb250YWlucyBwc2V1ZG8gZGVjbGFyYXRpb24gLS0gaXRzIHN5bnRheCBpcyBjaGFuZ2VkIGFuZCBkZWNsYXJlZCBvdXRzaWRlIG9mIFNpenpsZS5cbiAqIDMuIFJlbW92ZWQgZGVjbGFyYXRpb25zIGZvciB0aGUgZm9sbG93aW5nIG5vbi1zdGFuZGFyZCBwc2V1ZG8gY2xhc3NlczpcbiAqIDpwYXJlbnQsIDpoZWFkZXIsIDppbnB1dCwgOmJ1dHRvbiwgOnRleHQsIDpmaXJzdCwgOmxhc3QsIDplcSxcbiAqIDpldmVuLCA6b2RkLCA6bHQsIDpndCwgOm50aCwgOnJhZGlvLCA6Y2hlY2tib3gsIDpmaWxlLFxuICogOnBhc3N3b3JkLCA6aW1hZ2UsIDpzdWJtaXQsIDpyZXNldFxuICogNC4gQWRkZWQgZXM2IG1vZHVsZSBleHBvcnRcbiAqL1xudmFyIFNpenpsZTtcbi8qKlxuICogSW5pdGlhbGl6ZXMgU2l6emxlIG9iamVjdC5cbiAqIEluIHRoZSBjYXNlIG9mIEFkR3VhcmQgRXh0ZW5kZWRDc3Mgd2Ugd2FudCB0byBhdm9pZCBpbml0aWFsaXppbmcgU2l6emxlIHJpZ2h0IGF3YXlcbiAqIGFuZCBleHBvc2luZyBpdCB0byB0aGUgZ2xvYmFsIHNjb3BlLlxuICovXG5cbnZhciBpbml0aWFsaXplU2l6emxlID0gZnVuY3Rpb24gaW5pdGlhbGl6ZVNpenpsZSgpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIGlmICghU2l6emxlKSB7XG4gICAgLy88PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDxcbiAgICBTaXp6bGUgPSBmdW5jdGlvbiAod2luZG93KSB7XG4gICAgICB2YXIgc3VwcG9ydCxcbiAgICAgICAgICBFeHByLFxuICAgICAgICAgIGdldFRleHQsXG4gICAgICAgICAgaXNYTUwsXG4gICAgICAgICAgdG9rZW5pemUsXG4gICAgICAgICAgY29tcGlsZSxcbiAgICAgICAgICBzZWxlY3QsXG4gICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCxcbiAgICAgICAgICBzb3J0SW5wdXQsXG4gICAgICAgICAgaGFzRHVwbGljYXRlLFxuICAgICAgICAgIC8vIExvY2FsIGRvY3VtZW50IHZhcnNcbiAgICAgIHNldERvY3VtZW50LFxuICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgIGRvY0VsZW0sXG4gICAgICAgICAgZG9jdW1lbnRJc0hUTUwsXG4gICAgICAgICAgcmJ1Z2d5UVNBLFxuICAgICAgICAgIHJidWdneU1hdGNoZXMsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBjb250YWlucyxcbiAgICAgICAgICAvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG4gICAgICBleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgICBkaXJydW5zID0gMCxcbiAgICAgICAgICBkb25lID0gMCxcbiAgICAgICAgICBjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgICB0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgICBjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgICBub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgICBzb3J0T3JkZXIgPSBmdW5jdGlvbiBzb3J0T3JkZXIoYSwgYikge1xuICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICAgICAgLy8gSW5zdGFuY2UgbWV0aG9kc1xuICAgICAgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgICAgICAgYXJyID0gW10sXG4gICAgICAgICAgcG9wID0gYXJyLnBvcCxcbiAgICAgICAgICBwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuICAgICAgICAgIHB1c2ggPSBhcnIucHVzaCxcbiAgICAgICAgICBzbGljZSA9IGFyci5zbGljZSxcbiAgICAgICAgICAvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAgICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcbiAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKGxpc3QsIGVsZW0pIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9LFxuICAgICAgICAgIGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuICAgICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG4gICAgICB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuICAgICAgaWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcbiAgICAgICAgICAvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcbiAgICAgIGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArIC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG4gICAgICBcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgKyAvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuICAgICAgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuICAgICAgICAgIHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgKyAvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuICAgICAgLy8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG4gICAgICBcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICsgLy8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG4gICAgICBcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArIC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcbiAgICAgIFwiLipcIiArIFwiKVxcXFwpfClcIixcbiAgICAgICAgICAvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG4gICAgICByd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAod2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiksXG4gICAgICAgICAgcnRyaW0gPSBuZXcgUmVnRXhwKFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiKSxcbiAgICAgICAgICByY29tbWEgPSBuZXcgUmVnRXhwKFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiksXG4gICAgICAgICAgcmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIpLFxuICAgICAgICAgIHJwc2V1ZG8gPSBuZXcgUmVnRXhwKHBzZXVkb3MpLFxuICAgICAgICAgIHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiksXG4gICAgICAgICAgbWF0Y2hFeHByID0ge1xuICAgICAgICBcIklEXCI6IG5ldyBSZWdFeHAoXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiksXG4gICAgICAgIFwiQ0xBU1NcIjogbmV3IFJlZ0V4cChcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiksXG4gICAgICAgIFwiVEFHXCI6IG5ldyBSZWdFeHAoXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiksXG4gICAgICAgIFwiQVRUUlwiOiBuZXcgUmVnRXhwKFwiXlwiICsgYXR0cmlidXRlcyksXG4gICAgICAgIFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoXCJeXCIgKyBwc2V1ZG9zKSxcbiAgICAgICAgXCJDSElMRFwiOiBuZXcgUmVnRXhwKFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIpLFxuICAgICAgICBcImJvb2xcIjogbmV3IFJlZ0V4cChcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiksXG4gICAgICAgIC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuICAgICAgICAvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG4gICAgICAgIFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIilcbiAgICAgIH0sXG4gICAgICAgICAgcm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG4gICAgICAgICAgLy8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG4gICAgICBycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG4gICAgICAgICAgcnNpYmxpbmcgPSAvWyt+XS8sXG4gICAgICAgICAgLy8gQ1NTIGVzY2FwZXNcbiAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcbiAgICAgIHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIpLFxuICAgICAgICAgIGZ1bmVzY2FwZSA9IGZ1bmN0aW9uIGZ1bmVzY2FwZShfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSkge1xuICAgICAgICB2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwOyAvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG4gICAgICAgIC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXG4gICAgICAgIHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID8gZXNjYXBlZCA6IGhpZ2ggPCAwID8gLy8gQk1QIGNvZGVwb2ludFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpZ2ggKyAweDEwMDAwKSA6IC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCk7XG4gICAgICB9LFxuICAgICAgICAgIC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG4gICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcbiAgICAgIHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcbiAgICAgICAgICBmY3NzZXNjYXBlID0gZnVuY3Rpb24gZmNzc2VzY2FwZShjaCwgYXNDb2RlUG9pbnQpIHtcbiAgICAgICAgaWYgKGFzQ29kZVBvaW50KSB7XG4gICAgICAgICAgLy8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcMFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XG4gICAgICAgICAgfSAvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXG5cbiAgICAgICAgICByZXR1cm4gY2guc2xpY2UoMCwgLTEpICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KGNoLmxlbmd0aCAtIDEpLnRvU3RyaW5nKDE2KSArIFwiIFwiO1xuICAgICAgICB9IC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblxuXG4gICAgICAgIHJldHVybiBcIlxcXFxcIiArIGNoO1xuICAgICAgfSxcbiAgICAgICAgICAvLyBVc2VkIGZvciBpZnJhbWVzXG4gICAgICAvLyBTZWUgc2V0RG9jdW1lbnQoKVxuICAgICAgLy8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG4gICAgICAvLyBlcnJvciBpbiBJRVxuICAgICAgdW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gICAgICAgIHNldERvY3VtZW50KCk7XG4gICAgICB9LFxuICAgICAgICAgIGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZpZWxkc2V0XCI7XG4gICAgICB9LCB7XG4gICAgICAgIGRpcjogXCJwYXJlbnROb2RlXCIsXG4gICAgICAgIG5leHQ6IFwibGVnZW5kXCJcbiAgICAgIH0pOyAvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHB1c2guYXBwbHkoYXJyID0gc2xpY2UuY2FsbChwcmVmZXJyZWREb2MuY2hpbGROb2RlcyksIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKTsgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjBcbiAgICAgICAgLy8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXG4gICAgICAgIGFycltwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBwdXNoID0ge1xuICAgICAgICAgIGFwcGx5OiBhcnIubGVuZ3RoID8gLy8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcbiAgICAgICAgICBmdW5jdGlvbiAodGFyZ2V0LCBlbHMpIHtcbiAgICAgICAgICAgIHB1c2hfbmF0aXZlLmFwcGx5KHRhcmdldCwgc2xpY2UuY2FsbChlbHMpKTtcbiAgICAgICAgICB9IDogLy8gU3VwcG9ydDogSUU8OVxuICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcbiAgICAgICAgICBmdW5jdGlvbiAodGFyZ2V0LCBlbHMpIHtcbiAgICAgICAgICAgIHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpID0gMDsgLy8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSB7fVxuXG4gICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBTaXp6bGUoc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcbiAgICAgICAgdmFyIG0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgIG5pZCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgZ3JvdXBzLFxuICAgICAgICAgICAgbmV3U2VsZWN0b3IsXG4gICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG4gICAgICAgIG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTsgLy8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fCBub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSAvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cblxuICAgICAgICBpZiAoIXNlZWQpIHtcbiAgICAgICAgICBpZiAoKGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYykgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICBzZXREb2N1bWVudChjb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICAgIGlmIChkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2RcbiAgICAgICAgICAgIC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcbiAgICAgICAgICAgIGlmIChub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKSkpIHtcbiAgICAgICAgICAgICAgLy8gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgaWYgKG0gPSBtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IGNvbnRleHRcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChtKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLmlkID09PSBtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgIH0gLy8gRWxlbWVudCBjb250ZXh0XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG4gICAgICAgICAgICAgICAgICBpZiAobmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSkpICYmIGNvbnRhaW5zKGNvbnRleHQsIGVsZW0pICYmIGVsZW0uaWQgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFR5cGUgc2VsZWN0b3JcblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7IC8vIENsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cblxuICAgICAgICAgICAgaWYgKHN1cHBvcnQucXNhICYmICFub25uYXRpdmVTZWxlY3RvckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdICYmICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdChzZWxlY3RvcikpKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7IC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuICAgICAgICAgICAgICAgIC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04XG4gICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSB7XG4gICAgICAgICAgICAgICAgICBuaWQgPSBuaWQucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBuaWQgPSBleHBhbmRvKTtcbiAgICAgICAgICAgICAgICB9IC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXG5cbiAgICAgICAgICAgICAgICBncm91cHMgPSB0b2tlbml6ZShzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgaSA9IGdyb3Vwcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3Rvcihncm91cHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXCIsXCIpOyAvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblxuICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobmV3U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwobmV3U2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHFzYUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAvLyBbQWRHdWFyZCBQYXRoXTogRml4IHRoZSBjYWNoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZShzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGlmIChuaWQgPT09IGV4cGFuZG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQWxsIG90aGVyc1xuXG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdChzZWxlY3Rvci5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gICAgICAgKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAgICAgICAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBjYWNoZShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcbiAgICAgICAgICBpZiAoa2V5cy5wdXNoKGtleSArIFwiIFwiKSA+IEV4cHIuY2FjaGVMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleXMuc2hpZnQoKV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNhY2hlW2tleSArIFwiIFwiXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIG1hcmtGdW5jdGlvbihmbikge1xuICAgICAgICBmbltleHBhbmRvXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIGFzc2VydChmbikge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gISFmbihlbCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH0gLy8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblxuXG4gICAgICAgICAgZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gYWRkSGFuZGxlKGF0dHJzLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG4gICAgICAgICAgICBpID0gYXJyLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgRXhwci5hdHRySGFuZGxlW2FycltpXV0gPSBoYW5kbGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBiXG4gICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIHNpYmxpbmdDaGVjayhhLCBiKSB7XG4gICAgICAgIHZhciBjdXIgPSBiICYmIGEsXG4gICAgICAgICAgICBkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJiBhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDsgLy8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSAvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXG5cbiAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgIHdoaWxlIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChjdXIgPT09IGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhID8gMSA6IC0xO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG4gICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG4gICAgICAgICAgaWYgKFwiZm9ybVwiIGluIGVsZW0pIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcbiAgICAgICAgICAgIC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG4gICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG4gICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuICAgICAgICAgICAgLy8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG4gICAgICAgICAgICAvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG4gICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG4gICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBTdXBwb3J0OiBJRSA2IC0gMTFcbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblxuXG4gICAgICAgICAgICAgIHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8IC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cbiAgICAgICAgICAgICAgLyoganNoaW50IC1XMDE4ICovXG4gICAgICAgICAgICAgIGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmIGluRGlzYWJsZWRGaWVsZHNldChlbGVtKSA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDsgLy8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG4gICAgICAgICAgICAvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgICB9IGVsc2UgaWYgKFwibGFiZWxcIiBpbiBlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgfSAvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gICAgICAgKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIHRlc3RDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbiAgICAgIH0gLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcblxuXG4gICAgICBzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcbiAgICAgIC8qKlxuICAgICAgICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gICAgICAgKi9cblxuICAgICAgaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG4gICAgICAgIC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuICAgICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAqL1xuXG5cbiAgICAgIHNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGhhc0NvbXBhcmUsXG4gICAgICAgICAgICBzdWJXaW5kb3csXG4gICAgICAgICAgICBkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7IC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cbiAgICAgICAgaWYgKGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9IC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cblxuICAgICAgICBkb2N1bWVudCA9IGRvYztcbiAgICAgICAgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoZG9jdW1lbnQpOyAvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG4gICAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblxuICAgICAgICBpZiAocHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJiAoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdykge1xuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG4gICAgICAgICAgaWYgKHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7IC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG4gICAgICAgICAgfSBlbHNlIGlmIChzdWJXaW5kb3cuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIHN1YldpbmRvdy5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBBdHRyaWJ1dGVzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgLy8gU3VwcG9ydDogSUU8OFxuICAgICAgICAvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcbiAgICAgICAgLy8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cblxuICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgZWwuY2xhc3NOYW1lID0gXCJpXCI7XG4gICAgICAgICAgcmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG4gICAgICAgIH0pO1xuICAgICAgICAvKiBnZXRFbGVtZW50KHMpQnkqXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXG4gICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSk7XG4gICAgICAgICAgcmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuICAgICAgICB9KTsgLy8gU3VwcG9ydDogSUU8OVxuXG4gICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKTsgLy8gU3VwcG9ydDogSUU8MTBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG4gICAgICAgIC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuICAgICAgICAvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3RcblxuICAgICAgICBzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuaWQgPSBleHBhbmRvO1xuICAgICAgICAgIHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGV4cGFuZG8pLmxlbmd0aDtcbiAgICAgICAgfSk7IC8vIElEIGZpbHRlciBhbmQgZmluZFxuXG4gICAgICAgIGlmIChzdXBwb3J0LmdldEJ5SWQpIHtcbiAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24gKGlkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPyBbZWxlbV0gOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTsgLy8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblxuXG4gICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICBlbGVtcyxcbiAgICAgICAgICAgICAgICAgIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbV07XG4gICAgICAgICAgICAgICAgfSAvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblxuXG4gICAgICAgICAgICAgICAgZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKGlkKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChlbGVtID0gZWxlbXNbaSsrXSkge1xuICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIFRhZ1xuXG5cbiAgICAgICAgRXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uICh0YWcsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7IC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5xc2EpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAodGFnLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgIHRtcCA9IFtdLFxuICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgLy8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuICAgICAgICAgIHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7IC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblxuICAgICAgICAgIGlmICh0YWcgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICB3aGlsZSAoZWxlbSA9IHJlc3VsdHNbaSsrXSkge1xuICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRtcC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH07IC8vIENsYXNzXG5cbiAgICAgICAgRXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24gKGNsYXNzTmFtZSwgY29udGV4dCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgLy8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuICAgICAgICAvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXG5cbiAgICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IFtdOyAvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuICAgICAgICAvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3JcbiAgICAgICAgLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuICAgICAgICAvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cbiAgICAgICAgcmJ1Z2d5UVNBID0gW107XG5cbiAgICAgICAgaWYgKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpKSB7XG4gICAgICAgICAgLy8gQnVpbGQgUVNBIHJlZ2V4XG4gICAgICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuICAgICAgICAgIGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuICAgICAgICAgICAgLy8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG4gICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGVsKS5pbm5lckhUTUwgPSBBR1BvbGljeS5jcmVhdGVIVE1MKFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgKyBcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICsgXCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiKTsgLy8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuICAgICAgICAgICAgLy8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuICAgICAgICAgICAgLy8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG4gICAgICAgICAgICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblxuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIik7XG4gICAgICAgICAgICB9IC8vIFN1cHBvcnQ6IElFOFxuICAgICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXG5cbiAgICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIpO1xuICAgICAgICAgICAgfSAvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblxuXG4gICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwifj1cIik7XG4gICAgICAgICAgICB9IC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblxuXG4gICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgICAgIH0gLy8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcbiAgICAgICAgICAgIC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblxuXG4gICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gQUdQb2xpY3kuY3JlYXRlSFRNTChcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgKyBcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIik7IC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuICAgICAgICAgICAgLy8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpbnB1dCkuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcIkRcIik7IC8vIFN1cHBvcnQ6IElFOFxuICAgICAgICAgICAgLy8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIik7XG4gICAgICAgICAgICB9IC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG4gICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXG5cbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIik7XG4gICAgICAgICAgICB9IC8vIFN1cHBvcnQ6IElFOS0xMStcbiAgICAgICAgICAgIC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXG5cbiAgICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmRpc2FibGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIik7XG4gICAgICAgICAgICB9IC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cblxuICAgICAgICAgICAgZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fCBkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fCBkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHwgZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikpIHtcbiAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgICAgIC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG4gICAgICAgICAgICBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKGVsLCBcIipcIik7IC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblxuICAgICAgICAgICAgbWF0Y2hlcy5jYWxsKGVsLCBcIltzIT0nJ106eFwiKTtcbiAgICAgICAgICAgIHJidWdneU1hdGNoZXMucHVzaChcIiE9XCIsIHBzZXVkb3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHJidWdneVFTQS5qb2luKFwifFwiKSk7XG4gICAgICAgIHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHJidWdneU1hdGNoZXMuam9pbihcInxcIikpO1xuICAgICAgICAvKiBDb250YWluc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgaGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKTsgLy8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG4gICAgICAgIC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuICAgICAgICAvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXG4gICAgICAgIGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb250YWlucykgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG4gICAgICAgICAgICAgIGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuICAgICAgICAgIHJldHVybiBhID09PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoYWRvd24uY29udGFpbnMgPyBhZG93bi5jb250YWlucyhidXApIDogYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGJ1cCkgJiAxNikpO1xuICAgICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgd2hpbGUgKGIgPSBiLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKGIgPT09IGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogU29ydGluZ1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblxuICAgICAgICBzb3J0T3JkZXIgPSBoYXNDb21wYXJlID8gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSAvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cblxuICAgICAgICAgIHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgICB9IC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblxuXG4gICAgICAgICAgY29tcGFyZSA9IChhLm93bmVyRG9jdW1lbnQgfHwgYSkgPT09IChiLm93bmVyRG9jdW1lbnQgfHwgYikgPyBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpIDogLy8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgMTsgLy8gRGlzY29ubmVjdGVkIG5vZGVzXG5cbiAgICAgICAgICBpZiAoY29tcGFyZSAmIDEgfHwgIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGNvbXBhcmUpIHtcbiAgICAgICAgICAgIC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuICAgICAgICAgICAgaWYgKGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gLy8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblxuXG4gICAgICAgICAgICByZXR1cm4gc29ydElucHV0ID8gaW5kZXhPZihzb3J0SW5wdXQsIGEpIC0gaW5kZXhPZihzb3J0SW5wdXQsIGIpIDogMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcbiAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdXIsXG4gICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICBhdXAgPSBhLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIGJ1cCA9IGIucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgYXAgPSBbYV0sXG4gICAgICAgICAgICAgIGJwID0gW2JdOyAvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXG4gICAgICAgICAgaWYgKCFhdXAgfHwgIWJ1cCkge1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOiBiID09PSBkb2N1bWVudCA/IDEgOiBhdXAgPyAtMSA6IGJ1cCA/IDEgOiBzb3J0SW5wdXQgPyBpbmRleE9mKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mKHNvcnRJbnB1dCwgYikgOiAwOyAvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXVwID09PSBidXApIHtcbiAgICAgICAgICAgIHJldHVybiBzaWJsaW5nQ2hlY2soYSwgYik7XG4gICAgICAgICAgfSAvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXG5cbiAgICAgICAgICBjdXIgPSBhO1xuXG4gICAgICAgICAgd2hpbGUgKGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBhcC51bnNoaWZ0KGN1cik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyID0gYjtcblxuICAgICAgICAgIHdoaWxlIChjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgYnAudW5zaGlmdChjdXIpO1xuICAgICAgICAgIH0gLy8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblxuXG4gICAgICAgICAgd2hpbGUgKGFwW2ldID09PSBicFtpXSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpID8gLy8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG4gICAgICAgICAgc2libGluZ0NoZWNrKGFwW2ldLCBicFtpXSkgOiAvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcbiAgICAgICAgICBhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOiBicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6IDA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgIH07XG5cbiAgICAgIFNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24gKGV4cHIsIGVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMpO1xuICAgICAgfTtcblxuICAgICAgU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtLCBleHByKSB7XG4gICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICBpZiAoKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJiAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVtleHByICsgXCIgXCJdICYmICghcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KGV4cHIpKSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoZXhwcikpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXQgPSBtYXRjaGVzLmNhbGwoZWxlbSwgZXhwcik7IC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblxuICAgICAgICAgICAgaWYgKHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8IC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG4gICAgICAgICAgICAvLyBmcmFnbWVudCBpbiBJRSA5XG4gICAgICAgICAgICBlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gW0FkR3VhcmQgUGF0aF06IEZpeCB0aGUgY2FjaGUgdmFsdWVcbiAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoZXhwciwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBkb2N1bWVudCwgbnVsbCwgW2VsZW1dKS5sZW5ndGggPiAwO1xuICAgICAgfTtcblxuICAgICAgU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZW0pIHtcbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgIGlmICgoY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQpICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbnRleHQsIGVsZW0pO1xuICAgICAgfTtcblxuICAgICAgU2l6emxlLmF0dHIgPSBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xuICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbbmFtZS50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuICAgICAgICB2YWwgPSBmbiAmJiBoYXNPd24uY2FsbChFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSkgPyBmbihlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID8gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSkgOiAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID8gdmFsLnZhbHVlIDogbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIFNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiAoc2VsKSB7XG4gICAgICAgIHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcbiAgICAgIH07XG5cbiAgICAgIFNpenpsZS5lcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICAgICAgICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAgICAgICAqL1xuXG5cbiAgICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICBkdXBsaWNhdGVzID0gW10sXG4gICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgIGkgPSAwOyAvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cbiAgICAgICAgaGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcbiAgICAgICAgc29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKDApO1xuICAgICAgICByZXN1bHRzLnNvcnQoc29ydE9yZGVyKTtcblxuICAgICAgICBpZiAoaGFzRHVwbGljYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKGVsZW0gPSByZXN1bHRzW2krK10pIHtcbiAgICAgICAgICAgIGlmIChlbGVtID09PSByZXN1bHRzW2ldKSB7XG4gICAgICAgICAgICAgIGogPSBkdXBsaWNhdGVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgcmVzdWx0cy5zcGxpY2UoZHVwbGljYXRlc1tqXSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXG5cbiAgICAgICAgc29ydElucHV0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICAgICAgICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gICAgICAgKi9cblxuXG4gICAgICBnZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgIHJldCA9IFwiXCIsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuICAgICAgICBpZiAoIW5vZGVUeXBlKSB7XG4gICAgICAgICAgLy8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcbiAgICAgICAgICB3aGlsZSAobm9kZSA9IGVsZW1baSsrXSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcbiAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgLy8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1MylcbiAgICAgICAgICBpZiAodHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgIGZvciAoZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgcmV0ICs9IGdldFRleHQoZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuICAgICAgICB9IC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuICAgICAgICAvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgY2FjaGVMZW5ndGg6IDUwLFxuICAgICAgICBjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcbiAgICAgICAgbWF0Y2g6IG1hdGNoRXhwcixcbiAgICAgICAgYXR0ckhhbmRsZToge30sXG4gICAgICAgIGZpbmQ6IHt9LFxuICAgICAgICByZWxhdGl2ZToge1xuICAgICAgICAgIFwiPlwiOiB7XG4gICAgICAgICAgICBkaXI6IFwicGFyZW50Tm9kZVwiLFxuICAgICAgICAgICAgZmlyc3Q6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiIFwiOiB7XG4gICAgICAgICAgICBkaXI6IFwicGFyZW50Tm9kZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIitcIjoge1xuICAgICAgICAgICAgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLFxuICAgICAgICAgICAgZmlyc3Q6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiflwiOiB7XG4gICAgICAgICAgICBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZUZpbHRlcjoge1xuICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiBBVFRSKG1hdGNoKSB7XG4gICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpOyAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXG4gICAgICAgICAgICBtYXRjaFszXSA9IChtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiKS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoWzJdID09PSBcIn49XCIpIHtcbiAgICAgICAgICAgICAgbWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSgwLCA0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ0hJTERcIjogZnVuY3Rpb24gQ0hJTEQobWF0Y2gpIHtcbiAgICAgICAgICAgIC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuICAgICAgICAgICAgXHQxIHR5cGUgKG9ubHl8bnRofC4uLilcbiAgICAgICAgICAgIFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuICAgICAgICAgICAgXHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuICAgICAgICAgICAgXHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcbiAgICAgICAgICAgIFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuICAgICAgICAgICAgXHQ2IHggb2YgeG4tY29tcG9uZW50XG4gICAgICAgICAgICBcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuICAgICAgICAgICAgXHQ4IHkgb2YgeS1jb21wb25lbnRcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFsxXS5zbGljZSgwLCAzKSA9PT0gXCJudGhcIikge1xuICAgICAgICAgICAgICAvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuICAgICAgICAgICAgICBpZiAoIW1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgfSAvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcbiAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXG5cbiAgICAgICAgICAgICAgbWF0Y2hbNF0gPSArKG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIikpO1xuICAgICAgICAgICAgICBtYXRjaFs1XSA9ICsobWF0Y2hbN10gKyBtYXRjaFs4XSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIik7IC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IobWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBTRVVET1wiOiBmdW5jdGlvbiBQU0VVRE8obWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBleGNlc3MsXG4gICAgICAgICAgICAgICAgdW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cbiAgICAgICAgICAgIGlmIChtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KG1hdGNoWzBdKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gLy8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblxuXG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiOyAvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QodW5xdW90ZWQpICYmICggLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcbiAgICAgICAgICAgIGV4Y2VzcyA9IHRva2VuaXplKHVucXVvdGVkLCB0cnVlKSkgJiYgKCAvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgIGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcykgLSB1bnF1b3RlZC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG4gICAgICAgICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoMCwgZXhjZXNzKTtcbiAgICAgICAgICAgICAgbWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSgwLCBleGNlc3MpO1xuICAgICAgICAgICAgfSAvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMCwgMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICBcIlRBR1wiOiBmdW5jdGlvbiBUQUcobm9kZU5hbWVTZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ0xBU1NcIjogZnVuY3Rpb24gQ0xBU1MoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbY2xhc3NOYW1lICsgXCIgXCJdO1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4gfHwgKHBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiKSkgJiYgY2xhc3NDYWNoZShjbGFzc05hbWUsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFUVFJcIjogZnVuY3Rpb24gQVRUUihuYW1lLCBvcGVyYXRvciwgY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoZWxlbSwgbmFtZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcIjtcbiAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOiBvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6IG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPT09IDAgOiBvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoY2hlY2spID4gLTEgOiBvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKC1jaGVjay5sZW5ndGgpID09PSBjaGVjayA6IG9wZXJhdG9yID09PSBcIn49XCIgPyAoXCIgXCIgKyByZXN1bHQucmVwbGFjZShyd2hpdGVzcGFjZSwgXCIgXCIpICsgXCIgXCIpLmluZGV4T2YoY2hlY2spID4gLTEgOiBvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoMCwgY2hlY2subGVuZ3RoICsgMSkgPT09IGNoZWNrICsgXCItXCIgOiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uIENISUxEKHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCkge1xuICAgICAgICAgICAgdmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoMCwgMykgIT09IFwibnRoXCIsXG4gICAgICAgICAgICAgICAgZm9yd2FyZCA9IHR5cGUuc2xpY2UoLTQpICE9PSBcImxhc3RcIixcbiAgICAgICAgICAgICAgICBvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID8gLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgdmFyIGNhY2hlLFxuICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUsXG4gICAgICAgICAgICAgICAgICBvdXRlckNhY2hlLFxuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcbiAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgdXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG4gICAgICAgICAgICAgICAgICBkaWZmID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlID0gbm9kZVtkaXJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cblxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gW2ZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGRdOyAvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQgJiYgdXNlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8IChub2RlW2V4cGFuZG9dID0ge30pOyAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblxuICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlW25vZGUudW5pcXVlSURdIHx8IChvdXRlckNhY2hlW25vZGUudW5pcXVlSURdID0ge30pO1xuICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVt0eXBlXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuICAgICAgICAgICAgICAgICAgZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsyXTtcbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbbm9kZUluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fCAoIC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVt0eXBlXSA9IFtkaXJydW5zLCBub2RlSW5kZXgsIGRpZmZdO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgaWYgKHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8IChub2RlW2V4cGFuZG9dID0ge30pOyAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB1bmlxdWVDYWNoZVt0eXBlXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgICB9IC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcbiAgICAgICAgICAgICAgICAgIC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblxuXG4gICAgICAgICAgICAgICAgICBpZiAoZGlmZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fCAoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKChvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxKSAmJiArK2RpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTsgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHwgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlW3R5cGVdID0gW2RpcnJ1bnMsIGRpZmZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cblxuICAgICAgICAgICAgICAgIGRpZmYgLT0gbGFzdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24gUFNFVURPKHBzZXVkbywgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuICAgICAgICAgICAgLy8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3NcbiAgICAgICAgICAgIHZhciBhcmdzLFxuICAgICAgICAgICAgICAgIGZuID0gRXhwci5wc2V1ZG9zW3BzZXVkb10gfHwgRXhwci5zZXRGaWx0ZXJzW3BzZXVkby50b0xvd2VyQ2FzZSgpXSB8fCBTaXp6bGUuZXJyb3IoXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvKTsgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgICAgICAgLy8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblxuICAgICAgICAgICAgaWYgKGZuW2V4cGFuZG9dKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmbihhcmd1bWVudCk7XG4gICAgICAgICAgICB9IC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXG5cbiAgICAgICAgICAgIGlmIChmbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBbcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50XTtcbiAgICAgICAgICAgICAgcmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShwc2V1ZG8udG9Mb3dlckNhc2UoKSkgPyBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4LFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZm4oc2VlZCwgYXJndW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hlZC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mKHNlZWQsIG1hdGNoZWRbaV0pO1xuICAgICAgICAgICAgICAgICAgc2VlZFtpZHhdID0gIShtYXRjaGVzW2lkeF0gPSBtYXRjaGVkW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pIDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZWxlbSwgMCwgYXJncyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBzZXVkb3M6IHtcbiAgICAgICAgICAvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3NcbiAgICAgICAgICBcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcbiAgICAgICAgICAgIC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gW10sXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSBjb21waWxlKHNlbGVjdG9yLnJlcGxhY2UocnRyaW0sIFwiJDFcIikpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJbZXhwYW5kb10gPyBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IG1hdGNoZXIoc2VlZCwgbnVsbCwgeG1sLCBbXSksXG4gICAgICAgICAgICAgICAgICBpID0gc2VlZC5sZW5ndGg7IC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblxuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gPSB1bm1hdGNoZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgIHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pIDogZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICBpbnB1dFswXSA9IGVsZW07XG4gICAgICAgICAgICAgIG1hdGNoZXIoaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyk7IC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cbiAgICAgICAgICAgICAgaW5wdXRbMF0gPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdHMucG9wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgU2l6emxlLmNvbXBpbGUoc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZShzZWxlY3RvciwgZWxlbSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLy8gUmVtb3ZlZCA6Y29udGFpbnMgcHNldWRvLWNsYXNzIGRlY2xhcmF0aW9uXG4gICAgICAgICAgLy8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG4gICAgICAgICAgLy8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcbiAgICAgICAgICAvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuICAgICAgICAgIC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG4gICAgICAgICAgLy8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICAgICAgLy8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cbiAgICAgICAgICBcImxhbmdcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgICAgICAvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG4gICAgICAgICAgICBpZiAoIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYW5nID0gbGFuZy5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtTGFuZztcblxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgPyBlbGVtLmxhbmcgOiBlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YobGFuZyArIFwiLVwiKSA9PT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gd2hpbGUgKChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKTtcblxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcbiAgICAgICAgICBcInRhcmdldFwiOiBmdW5jdGlvbiB0YXJnZXQoZWxlbSkge1xuICAgICAgICAgICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG4gICAgICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKDEpID09PSBlbGVtLmlkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyb290XCI6IGZ1bmN0aW9uIHJvb3QoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZvY3VzXCI6IGZ1bmN0aW9uIGZvY3VzKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBCb29sZWFuIHByb3BlcnRpZXNcbiAgICAgICAgICBcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oZmFsc2UpLFxuICAgICAgICAgIFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8odHJ1ZSksXG4gICAgICAgICAgXCJjaGVja2VkXCI6IGZ1bmN0aW9uIGNoZWNrZWQoZWxlbSkge1xuICAgICAgICAgICAgLy8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQgfHwgbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWxlY3RlZFwiOiBmdW5jdGlvbiBzZWxlY3RlZChlbGVtKSB7XG4gICAgICAgICAgICAvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG4gICAgICAgICAgICAvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG4gICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIENvbnRlbnRzXG4gICAgICAgICAgXCJlbXB0eVwiOiBmdW5jdGlvbiBlbXB0eShlbGVtKSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuICAgICAgICAgICAgLy8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuICAgICAgICAgICAgLy8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcbiAgICAgICAgICAgIC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cbiAgICAgICAgICAgIGZvciAoZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPCA2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gLy8gUmVtb3ZlZCBjdXN0b20gcHNldWRvLWNsYXNzZXNcblxuICAgICAgICB9XG4gICAgICB9OyAvLyBSZW1vdmVkIGN1c3RvbSBwc2V1ZG8tY2xhc3Nlc1xuICAgICAgLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5cbiAgICAgIGZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuXG4gICAgICBzZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbiAgICAgIEV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG4gICAgICAvKipcbiAgICAgICAqIFtBZEd1YXJkIFBhdGNoXTpcbiAgICAgICAqIFNvcnRzIHRoZSB0b2tlbnMgaW4gb3JkZXIgdG8gbWl0aWdhdGUgdGhlIHBlcmZvcm1hbmNlIGlzc3VlcyBjYXVzZWQgYnkgbWF0Y2hpbmcgc2xvdyBwc2V1ZG9zIGZpcnN0OlxuICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0V4dGVuZGVkQ3NzL2lzc3Vlcy81NSNpc3N1ZWNvbW1lbnQtMzY0MDU4NzQ1XG4gICAgICAgKi9cblxuICAgICAgdmFyIHNvcnRUb2tlbkdyb3VwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwbGl0cyBjb21wb3VuZCBzZWxlY3RvciBpbnRvIGEgbGlzdCBvZiBzaW1wbGUgc2VsZWN0b3JzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdG9rZW5zIFRva2VucyB0byBzcGxpdCBpbnRvIGdyb3Vwc1xuICAgICAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBjb25zaXN0aW5nIG9mIHRva2VuIGdyb3VwcyAoYXJyYXlzKSBhbmQgcmVsYXRpb24gdG9rZW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHNwbGl0Q29tcG91bmRTZWxlY3RvciA9IGZ1bmN0aW9uIHNwbGl0Q29tcG91bmRTZWxlY3Rvcih0b2tlbnMpIHtcbiAgICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgICAgdmFyIGN1cnJlbnRUb2tlbnNHcm91cCA9IFtdO1xuICAgICAgICAgIHZhciBtYXhJZHggPSB0b2tlbnMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG1heElkeDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSBTaXp6bGUuc2VsZWN0b3JzLnJlbGF0aXZlW3Rva2VuLnR5cGVdO1xuXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goY3VycmVudFRva2Vuc0dyb3VwKTtcbiAgICAgICAgICAgICAgZ3JvdXBzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICBjdXJyZW50VG9rZW5zR3JvdXAgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRUb2tlbnNHcm91cC5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPT09IG1heElkeCkge1xuICAgICAgICAgICAgICBncm91cHMucHVzaChjdXJyZW50VG9rZW5zR3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIFRPS0VOX1RZUEVTX1ZBTFVFUyA9IHtcbiAgICAgICAgICAvLyBudGgtY2hpbGQsIGV0YywgYWx3YXlzIGdvIGxhc3RcbiAgICAgICAgICBcIkNISUxEXCI6IDEwMCxcbiAgICAgICAgICBcIklEXCI6IDkwLFxuICAgICAgICAgIFwiQ0xBU1NcIjogODAsXG4gICAgICAgICAgXCJUQUdcIjogNzAsXG4gICAgICAgICAgXCJBVFRSXCI6IDcwLFxuICAgICAgICAgIFwiUFNFVURPXCI6IDYwXG4gICAgICAgIH07XG4gICAgICAgIHZhciBQT1NJVElPTkFMX1BTRVVET1MgPSBbXCJudGhcIiwgXCJmaXJzdFwiLCBcImxhc3RcIiwgXCJlcVwiLCBcImV2ZW5cIiwgXCJvZGRcIiwgXCJsdFwiLCBcImd0XCIsIFwibm90XCJdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGRlZmluZXMgdGhlIHNvcnQgb3JkZXIuXG4gICAgICAgICAqIFJldHVybnMgYSB2YWx1ZSBsZXNzZXIgdGhhbiAwIGlmIFwibGVmdFwiIGlzIGxlc3MgdGhhbiBcInJpZ2h0XCIuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBjb21wYXJlRnVuY3Rpb24gPSBmdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICB2YXIgbGVmdFZhbHVlID0gVE9LRU5fVFlQRVNfVkFMVUVTW2xlZnQudHlwZV07XG4gICAgICAgICAgdmFyIHJpZ2h0VmFsdWUgPSBUT0tFTl9UWVBFU19WQUxVRVNbcmlnaHQudHlwZV07XG4gICAgICAgICAgcmV0dXJuIGxlZnRWYWx1ZSAtIHJpZ2h0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCB0b2tlbnMgZ3JvdXAgaXMgc29ydGFibGUuXG4gICAgICAgICAqIFdlIGRvIG5vdCByZS1zb3J0IHRva2VucyBpbiBjYXNlIG9mIGFueSBwb3NpdGlvbmFsIG9yIGNoaWxkIHBzZXVkb3MgaW4gdGhlIGdyb3VwXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdmFyIGlzU29ydGFibGUgPSBmdW5jdGlvbiBpc1NvcnRhYmxlKHRva2Vucykge1xuICAgICAgICAgIHZhciBpVG9rZW5zID0gdG9rZW5zLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpVG9rZW5zLS0pIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpVG9rZW5zXTtcblxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwiUFNFVURPXCIgJiYgUE9TSVRJT05BTF9QU0VVRE9TLmluZGV4T2YodG9rZW4ubWF0Y2hlc1swXSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwiQ0hJTERcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0cyB0aGUgdG9rZW5zIGluIG9yZGVyIHRvIG1pdGlnYXRlIHRoZSBpc3N1ZXMgY2F1c2VkIGJ5IHRoZSBsZWZ0LXRvLXJpZ2h0IG1hdGNoaW5nLlxuICAgICAgICAgKiBUaGUgaWRlYSBpcyBjaGFuZ2UgdGhlIHRva2VucyBvcmRlciBzbyB0aGF0IFNpenpsZSB3YXMgbWF0Y2hpbmcgZmFzdCBzZWxlY3RvcnMgZmlyc3QgKGlkLCBjbGFzcyksXG4gICAgICAgICAqIGFuZCBzbG93IHNlbGVjdG9ycyBhZnRlciB0aGF0IChhbmQgaGVyZSBJIG1lYW4gb3VyIHNsb3cgY3VzdG9tIHBzZXVkbyBjbGFzc2VzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIEFuIGFycmF5IG9mIHRva2VucyB0byBzb3J0XG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgcmUtc29ydGVkIGFycmF5XG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdmFyIHNvcnRUb2tlbnMgPSBmdW5jdGlvbiBzb3J0VG9rZW5zKHRva2Vucykge1xuICAgICAgICAgIGlmICghdG9rZW5zIHx8IHRva2Vucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNvcnRlZFRva2VucyA9IFtdO1xuICAgICAgICAgIHZhciBncm91cHMgPSBzcGxpdENvbXBvdW5kU2VsZWN0b3IodG9rZW5zKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XG5cbiAgICAgICAgICAgIGlmIChncm91cCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgIGlmIChpc1NvcnRhYmxlKGdyb3VwKSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLnNvcnQoY29tcGFyZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNvcnRlZFRva2VucyA9IHNvcnRlZFRva2Vucy5jb25jYXQoZ3JvdXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc29ydGVkVG9rZW5zLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzb3J0ZWRUb2tlbnM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0cyBldmVyeSB0b2tlbnMgYXJyYXkgaW5zaWRlIG9mIHRoZSBzcGVjaWZpZWQgXCJncm91cHNcIiBhcnJheS5cbiAgICAgICAgICogU2VlIFwic29ydFRva2Vuc1wiIG1ldGhvZHMgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRva2VucyBhcmUgc29ydGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBncm91cHMgQW4gYXJyYXkgb2YgdG9rZW5zIGFycmF5cy5cbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSB0aGF0IGNvbnNpc3RzIG9mIHRoZSBzYW1lIHRva2VucyBhcnJheXMgYWZ0ZXIgc29ydGluZ1xuICAgICAgICAgKi9cblxuXG4gICAgICAgIHZhciBzb3J0VG9rZW5Hcm91cHMgPSBmdW5jdGlvbiBzb3J0VG9rZW5Hcm91cHMoZ3JvdXBzKSB7XG4gICAgICAgICAgdmFyIHNvcnRlZEdyb3VwcyA9IFtdO1xuICAgICAgICAgIHZhciBsZW4gPSBncm91cHMubGVuZ3RoO1xuICAgICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHNvcnRlZEdyb3Vwcy5wdXNoKHNvcnRUb2tlbnMoZ3JvdXBzW2ldKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNvcnRlZEdyb3VwcztcbiAgICAgICAgfTsgLy8gRXhwb3NlXG5cblxuICAgICAgICByZXR1cm4gc29ydFRva2VuR3JvdXBzO1xuICAgICAgfSgpO1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGN1c3RvbSBwb2xpY3kgdG8gdXNlIFRydXN0ZWRUeXBlcyBDU1AgcG9saWN5XG4gICAgICAgKiBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXRydXN0ZWQtdHlwZXMvZGlzdC9zcGVjL1xuICAgICAgICovXG5cblxuICAgICAgdmFyIEFHUG9saWN5ID0gZnVuY3Rpb24gY3JlYXRlUG9saWN5KCkge1xuICAgICAgICB2YXIgZGVmYXVsdFBvbGljeSA9IHtcbiAgICAgICAgICBjcmVhdGVIVE1MOiBmdW5jdGlvbiBjcmVhdGVIVE1MKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcmVhdGVTY3JpcHQ6IGZ1bmN0aW9uIGNyZWF0ZVNjcmlwdChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3JlYXRlU2NyaXB0VVJMOiBmdW5jdGlvbiBjcmVhdGVTY3JpcHRVUkwoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHdpbmRvdy50cnVzdGVkVHlwZXMgJiYgd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kpIHtcbiAgICAgICAgICByZXR1cm4gd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koXCJBR1BvbGljeVwiLCBkZWZhdWx0UG9saWN5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0UG9saWN5O1xuICAgICAgfSgpO1xuICAgICAgLyoqXG4gICAgICAgKiBbQWRHdWFyZCBQYXRjaF06XG4gICAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHNwYWNlcyBmcm9tIHRoZSB0b2tlbnMgbGlzdFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdG9rZW5zIEFuIGFycmF5IG9mIFNpenpsZSB0b2tlbnMgdG8gcG9zdC1wcm9jZXNzXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NwYWNlcyh0b2tlbnMpIHtcbiAgICAgICAgdmFyIGlUb2tlbnMgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpVG9rZW5zLS0pIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaVRva2Vuc107XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5sZW5ndGggPSBpVG9rZW5zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogW0FkR3VhcmQgUGF0Y2hdOlxuICAgICAgICogQW4gb2JqZWN0IHdpdGggdGhlIGluZm9ybWF0aW9uIGFib3V0IHNlbGVjdG9ycyBhbmQgdGhlaXIgdG9rZW4gcmVwcmVzZW50YXRpb25cbiAgICAgICAqIEB0eXBlZGVmIHt7c2VsZWN0b3JUZXh0OiBzdHJpbmcsIGdyb3VwczogQXJyYXl9fSBTZWxlY3RvckRhdGFcbiAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzZWxlY3RvclRleHQgQSBDU1Mgc2VsZWN0b3IgdGV4dFxuICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gZ3JvdXBzIEFuIGFycmF5IG9mIHRva2VuIGdyb3VwcyBjb3JyZXNwb25kaW5nIHRvIHRoYXQgc2VsZWN0b3JcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIFtBZEd1YXJkIFBhdGNoXTpcbiAgICAgICAqIFRoaXMgbWV0aG9kIHByb2Nlc3NlcyBwYXJzZWQgdG9rZW4gZ3JvdXBzLCBkaXZpZGVzIHRoZW0gaW50byBhIG51bWJlciBvZiBzZWxlY3RvcnNcbiAgICAgICAqIGFuZCBtYWtlcyBzdXJlIHRoYXQgZWFjaCBzZWxlY3RvcidzIHRva2VucyBhcmUgY2FjaGVkIHByb3Blcmx5IGluIFNpenpsZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IGdyb3VwcyBUb2tlbiBncm91cHMgKHNlZSB7QGxpbmsgU2l6emxlLnRva2VuaXplfSlcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheS48U2VsZWN0b3JEYXRhPn0gQW4gYXJyYXkgb2Ygc2VsZWN0b3JzIGRhdGEgd2UgZ290IGZyb20gdGhlIGdyb3Vwc1xuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gdG9rZW5Hcm91cHNUb1NlbGVjdG9ycyhncm91cHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNwYWNlcyB3aGljaCB3ZSBjYW4gZW5jb3VudGVyIGluIHRvbGVyYW50IG1vZGVcbiAgICAgICAgLy8gV2UncmUgZG9pbmcgaXQgaW4gdG9sZXJhbnQgbW9kZSBvbmx5IGFzIHRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVuXG4gICAgICAgIC8vIGVuY291bnRlcmluZyB0cmFpbGluZyBzcGFjZXMgaXMgZXhwZWN0ZWRcbiAgICAgICAgcmVtb3ZlVHJhaWxpbmdTcGFjZXMoZ3JvdXBzW2dyb3Vwcy5sZW5ndGggLSAxXSk7IC8vIFdlIG5lZWQgc29ydGVkIHRva2VucyB0byBtYWtlIGNhY2hlIHdvcmsgcHJvcGVybHlcblxuICAgICAgICB2YXIgc29ydGVkR3JvdXBzID0gc29ydFRva2VuR3JvdXBzKGdyb3Vwcyk7XG4gICAgICAgIHZhciBzZWxlY3RvcnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0b2tlbkdyb3VwcyA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICB2YXIgc2VsZWN0b3JUZXh0ID0gdG9TZWxlY3Rvcih0b2tlbkdyb3Vwcyk7XG4gICAgICAgICAgc2VsZWN0b3JzLnB1c2goe1xuICAgICAgICAgICAgLy8gU2l6emxlIGV4cGVjdHMgYW4gYXJyYXkgb2YgdG9rZW4gZ3JvdXBzIHdoZW4gY29tcGlsaW5nIGEgc2VsZWN0b3JcbiAgICAgICAgICAgIGdyb3VwczogW3Rva2VuR3JvdXBzXSxcbiAgICAgICAgICAgIHNlbGVjdG9yVGV4dDogc2VsZWN0b3JUZXh0XG4gICAgICAgICAgfSk7IC8vIE5vdyBtYWtlIHN1cmUgdGhhdCBzZWxlY3RvciB0b2tlbnMgYXJlIGNhY2hlZFxuXG4gICAgICAgICAgdmFyIHRva2Vuc0NhY2hlSXRlbSA9IHtcbiAgICAgICAgICAgIGdyb3VwczogdG9rZW5Hcm91cHMsXG4gICAgICAgICAgICBzb3J0ZWRHcm91cHM6IFtzb3J0ZWRHcm91cHNbaV1dXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0b2tlbkNhY2hlKHNlbGVjdG9yVGV4dCwgdG9rZW5zQ2FjaGVJdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxlY3RvcnM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFtBZEd1YXJkIFBhdGNoXTpcbiAgICAgICAqIEFkZCBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50IGZvciBTaXp6bGUudG9rZW5pemUgd2hpY2ggaW5kaWNhdGVzIHRoYXQgaXRcbiAgICAgICAqIHNob3VsZCBub3QgdGhyb3cgb24gaW52YWxpZCB0b2tlbnMsIGFuZCBpbnN0ZWFkIHNob3VsZCByZXR1cm4gdG9rZW5zXG4gICAgICAgKiB0aGF0IGl0IGhhcyBwcm9kdWNlZCBzbyBmYXIuXG4gICAgICAgKlxuICAgICAgICogT25lIG1vcmUgYWRkaXRpb25hbCBhcmd1bWVudCB0aGF0IGFsbG93IHRvIGNob29zZSBpZiB5b3Ugd2FudCB0byByZWNlaXZlIHNvcnRlZCBvciB1bnNvcnRlZCB0b2tlbnNcbiAgICAgICAqIFRoZSBwcm9ibGVtIGlzIHRoYXQgdGhlIHJlLXNvcnRlZCBzZWxlY3RvcnMgYXJlIHZhbGlkIGZvciBTaXp6bGUsIGJ1dCBub3QgZm9yIHRoZSBicm93c2VyLlxuICAgICAgICogb3B0aW9ucy5yZXR1cm5VbnNvcnRlZCAtLSByZXR1cm4gdW5zb3J0ZWQgdG9rZW5zIGlmIHRydWUuXG4gICAgICAgKiBvcHRpb25zLmNhY2hlT25seSAtLSByZXR1cm4gY2FjaGVkIHJlc3VsdCBvbmx5LiBSZXF1aXJlZCBmb3IgdW5pdC10ZXN0cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IG9wdGlvbnMgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCB0d28gYWRkaXRpb25hbCBmbGFnc1xuICAgICAgICogKG9wdGlvbnMudG9sZXJhbnQsIG9wdGlvbnMucmV0dXJuVW5zb3J0ZWQsIG9wdGlvbnMuY2FjaGVPbmx5KSAtLSBzZWUgcGF0Y2hlcyAjNSBhbmQgIzYgbm90ZXNcbiAgICAgICAqL1xuXG5cbiAgICAgIHRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBwYXJzZU9ubHksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQsXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBzb0ZhcixcbiAgICAgICAgICAgIGdyb3VwcyxcbiAgICAgICAgICAgIHByZUZpbHRlcnMsXG4gICAgICAgICAgICBjYWNoZWQgPSB0b2tlbkNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xuICAgICAgICB2YXIgdG9sZXJhbnQgPSBvcHRpb25zICYmIG9wdGlvbnMudG9sZXJhbnQ7XG4gICAgICAgIHZhciByZXR1cm5VbnNvcnRlZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yZXR1cm5VbnNvcnRlZDtcbiAgICAgICAgdmFyIGNhY2hlT25seSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jYWNoZU9ubHk7XG5cbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgIGlmIChwYXJzZU9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHJldHVyblVuc29ydGVkID8gY2FjaGVkLmdyb3VwcyA6IGNhY2hlZC5zb3J0ZWRHcm91cHMpLnNsaWNlKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYWNoZU9ubHkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvRmFyID0gc2VsZWN0b3I7XG4gICAgICAgIGdyb3VwcyA9IFtdO1xuICAgICAgICBwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cbiAgICAgICAgd2hpbGUgKHNvRmFyKSB7XG4gICAgICAgICAgLy8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuICAgICAgICAgIGlmICghbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyhzb0ZhcikpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcbiAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaFswXS5sZW5ndGgpIHx8IHNvRmFyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cHMucHVzaCh0b2tlbnMgPSBbXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF0Y2hlZCA9IGZhbHNlOyAvLyBDb21iaW5hdG9yc1xuXG4gICAgICAgICAgaWYgKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoc29GYXIpKSB7XG4gICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXG4gICAgICAgICAgICAgIC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuICAgICAgICAgICAgICB0eXBlOiBtYXRjaFswXS5yZXBsYWNlKHJ0cmltLCBcIiBcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XG4gICAgICAgICAgfSAvLyBGaWx0ZXJzXG5cblxuICAgICAgICAgIGZvciAodHlwZSBpbiBFeHByLmZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoRXhwclt0eXBlXS5leGVjKHNvRmFyKSkgJiYgKCFwcmVGaWx0ZXJzW3R5cGVdIHx8IChtYXRjaCA9IHByZUZpbHRlcnNbdHlwZV0obWF0Y2gpKSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IG1hdGNoXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3NcbiAgICAgICAgLy8gaWYgd2UncmUganVzdCBwYXJzaW5nXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXG5cbiAgICAgICAgdmFyIGludmFsaWRMZW4gPSBzb0Zhci5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHBhcnNlT25seSkge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkTGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludmFsaWRMZW4gIT09IDAgJiYgIXRvbGVyYW50KSB7XG4gICAgICAgICAgU2l6emxlLmVycm9yKHNlbGVjdG9yKTsgLy8gVGhyb3dzIGFuIGVycm9yLlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvbGVyYW50KSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogW0FkR3VhcmQgUGF0Y2hdOlxuICAgICAgICAgICAqIEluIHRvbGVyYW50IG1vZGUgd2UgcmV0dXJuIGEgc3BlY2lhbCBvYmplY3QgdGhhdCBjb25zdGlzdHMgb2ZcbiAgICAgICAgICAgKiBhbiBhcnJheSBvZiBwYXJzZWQgc2VsZWN0b3JzIChhbmQgdGhlaXIgdG9rZW5zKSBhbmQgYSBcIm5leHRJbmRleFwiIGZpZWxkXG4gICAgICAgICAgICogdGhhdCBwb2ludHMgdG8gYW4gaW5kZXggYWZ0ZXIgd2hpY2ggd2UncmUgbm90IGFibGUgdG8gcGFyc2Ugc2VsZWN0b3JzIGZhcnRoZXIuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIG5leHRJbmRleCA9IHNlbGVjdG9yLmxlbmd0aCAtIGludmFsaWRMZW47XG4gICAgICAgICAgdmFyIHNlbGVjdG9ycyA9IHRva2VuR3JvdXBzVG9TZWxlY3RvcnMoZ3JvdXBzKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgICAgICBuZXh0SW5kZXg6IG5leHRJbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFtBZEd1YXJkIFBhdGNoXTogU29ydGluZyB0b2tlbnMgKi9cblxuXG4gICAgICAgIHZhciBzb3J0ZWRHcm91cHMgPSBzb3J0VG9rZW5Hcm91cHMoZ3JvdXBzKTtcbiAgICAgICAgLyoqIFtBZEd1YXJkIFBhdGNoXTogQ2hhbmdlIHRoZSB3YXkgdG9rZW5zIGFyZSBjYWNoZWQgKi9cblxuICAgICAgICB2YXIgdG9rZW5zQ2FjaGVJdGVtID0ge1xuICAgICAgICAgIGdyb3VwczogZ3JvdXBzLFxuICAgICAgICAgIHNvcnRlZEdyb3Vwczogc29ydGVkR3JvdXBzXG4gICAgICAgIH07XG4gICAgICAgIHRva2Vuc0NhY2hlSXRlbSA9IHRva2VuQ2FjaGUoc2VsZWN0b3IsIHRva2Vuc0NhY2hlSXRlbSk7XG4gICAgICAgIHJldHVybiAocmV0dXJuVW5zb3J0ZWQgPyB0b2tlbnNDYWNoZUl0ZW0uZ3JvdXBzIDogdG9rZW5zQ2FjaGVJdGVtLnNvcnRlZEdyb3Vwcykuc2xpY2UoMCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiB0b1NlbGVjdG9yKHRva2Vucykge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgc2VsZWN0b3IgPSBcIlwiO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZENvbWJpbmF0b3IobWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSkge1xuICAgICAgICB2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG4gICAgICAgICAgICBza2lwID0gY29tYmluYXRvci5uZXh0LFxuICAgICAgICAgICAga2V5ID0gc2tpcCB8fCBkaXIsXG4gICAgICAgICAgICBjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuICAgICAgICAgICAgZG9uZU5hbWUgPSBkb25lKys7XG4gICAgICAgIHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID8gLy8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG4gICAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICB3aGlsZSAoZWxlbSA9IGVsZW1bZGlyXSkge1xuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cykge1xuICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSA6IC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgdmFyIG9sZENhY2hlLFxuICAgICAgICAgICAgICB1bmlxdWVDYWNoZSxcbiAgICAgICAgICAgICAgb3V0ZXJDYWNoZSxcbiAgICAgICAgICAgICAgbmV3Q2FjaGUgPSBbZGlycnVucywgZG9uZU5hbWVdOyAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblxuICAgICAgICAgIGlmICh4bWwpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtID0gZWxlbVtkaXJdKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cykge1xuICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBlbGVtW2V4cGFuZG9dIHx8IChlbGVtW2V4cGFuZG9dID0ge30pOyAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cbiAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbZWxlbS51bmlxdWVJRF0gfHwgKG91dGVyQ2FjaGVbZWxlbS51bmlxdWVJRF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtW2Rpcl0gfHwgZWxlbTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlW2tleV0pICYmIG9sZENhY2hlWzBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWzFdID09PSBkb25lTmFtZSkge1xuICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDYWNoZVsyXSA9IG9sZENhY2hlWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVtrZXldID0gbmV3Q2FjaGU7IC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3Q2FjaGVbMl0gPSBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycykge1xuICAgICAgICByZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/IGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICB2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcnNbaV0oZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gOiBtYXRjaGVyc1swXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyhzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBTaXp6bGUoc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb25kZW5zZSh1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICBuZXdVbm1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcbiAgICAgICAgICAgIG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoZWxlbSA9IHVubWF0Y2hlZFtpXSkge1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgbmV3VW5tYXRjaGVkLnB1c2goZWxlbSk7XG5cbiAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgIG1hcC5wdXNoKGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1VubWF0Y2hlZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0TWF0Y2hlcihwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbZXhwYW5kb10pIHtcbiAgICAgICAgICBwb3N0RmlsdGVyID0gc2V0TWF0Y2hlcihwb3N0RmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3N0RmluZGVyICYmICFwb3N0RmluZGVyW2V4cGFuZG9dKSB7XG4gICAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIocG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgIHZhciB0ZW1wLFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgICBwcmVNYXAgPSBbXSxcbiAgICAgICAgICAgICAgcG9zdE1hcCA9IFtdLFxuICAgICAgICAgICAgICBwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuICAgICAgICAgICAgICAvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuICAgICAgICAgIGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dCwgW10pLFxuICAgICAgICAgICAgICAvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgICBtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKHNlZWQgfHwgIXNlbGVjdG9yKSA/IGNvbmRlbnNlKGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sKSA6IGVsZW1zLFxuICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlciA/IC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG4gICAgICAgICAgcG9zdEZpbmRlciB8fCAoc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIpID8gLy8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgW10gOiAvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcbiAgICAgICAgICByZXN1bHRzIDogbWF0Y2hlckluOyAvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXG4gICAgICAgICAgaWYgKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIG1hdGNoZXIobWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwpO1xuICAgICAgICAgIH0gLy8gQXBwbHkgcG9zdEZpbHRlclxuXG5cbiAgICAgICAgICBpZiAocG9zdEZpbHRlcikge1xuICAgICAgICAgICAgdGVtcCA9IGNvbmRlbnNlKG1hdGNoZXJPdXQsIHBvc3RNYXApO1xuICAgICAgICAgICAgcG9zdEZpbHRlcih0ZW1wLCBbXSwgY29udGV4dCwgeG1sKTsgLy8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXG4gICAgICAgICAgICBpID0gdGVtcC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW0gPSB0ZW1wW2ldKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlck91dFtwb3N0TWFwW2ldXSA9ICEobWF0Y2hlckluW3Bvc3RNYXBbaV1dID0gZWxlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyKSB7XG4gICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtID0gbWF0Y2hlck91dFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2gobWF0Y2hlckluW2ldID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCBtYXRjaGVyT3V0ID0gW10sIHRlbXAsIHhtbCk7XG4gICAgICAgICAgICAgIH0gLy8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblxuXG4gICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiYgKHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZihzZWVkLCBlbGVtKSA6IHByZU1hcFtpXSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgc2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UobWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/IG1hdGNoZXJPdXQuc3BsaWNlKHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCkgOiBtYXRjaGVyT3V0KTtcblxuICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIpIHtcbiAgICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBtYXRjaGVyT3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgdmFyIGNoZWNrQ29udGV4dCxcbiAgICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICAgIGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbdG9rZW5zWzBdLnR5cGVdLFxuICAgICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcbiAgICAgICAgICAgIGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcbiAgICAgICAgICAgIC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG4gICAgICAgIG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuICAgICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlKSxcbiAgICAgICAgICAgIG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXhPZihjaGVja0NvbnRleHQsIGVsZW0pID4gLTE7XG4gICAgICAgIH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUpLFxuICAgICAgICAgICAgbWF0Y2hlcnMgPSBbZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgIHZhciByZXQgPSAhbGVhZGluZ1JlbGF0aXZlICYmICh4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCkgfHwgKChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/IG1hdGNoQ29udGV4dChlbGVtLCBjb250ZXh0LCB4bWwpIDogbWF0Y2hBbnlDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkpOyAvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblxuICAgICAgICAgIGNoZWNrQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfV07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbaV0udHlwZV0pIHtcbiAgICAgICAgICAgIG1hdGNoZXJzID0gW2FkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpLCBtYXRjaGVyKV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoZXIgPSBFeHByLmZpbHRlclt0b2tlbnNbaV0udHlwZV0uYXBwbHkobnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMpOyAvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlcltleHBhbmRvXSkge1xuICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcbiAgICAgICAgICAgICAgaiA9ICsraTtcblxuICAgICAgICAgICAgICBmb3IgKDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEV4cHIucmVsYXRpdmVbdG9rZW5zW2pdLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gc2V0TWF0Y2hlcihpID4gMSAmJiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIGkgPiAxICYmIHRvU2VsZWN0b3IoIC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG4gICAgICAgICAgICAgIHRva2Vucy5zbGljZSgwLCBpIC0gMSkuY29uY2F0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW5zW2kgLSAyXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIlxuICAgICAgICAgICAgICB9KSkucmVwbGFjZShydHJpbSwgXCIkMVwiKSwgbWF0Y2hlciwgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zLnNsaWNlKGksIGopKSwgaiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoaikpLCBqIDwgbGVuICYmIHRvU2VsZWN0b3IodG9rZW5zKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMpIHtcbiAgICAgICAgdmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgc3VwZXJNYXRjaGVyID0gZnVuY3Rpb24gc3VwZXJNYXRjaGVyKHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0KSB7XG4gICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgICAgIG1hdGNoZWRDb3VudCA9IDAsXG4gICAgICAgICAgICAgIGkgPSBcIjBcIixcbiAgICAgICAgICAgICAgdW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcbiAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgICBjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcbiAgICAgICAgICAgICAgLy8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuICAgICAgICAgIGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKFwiKlwiLCBvdXRlcm1vc3QpLFxuICAgICAgICAgICAgICAvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuICAgICAgICAgIGRpcnJ1bnNVbmlxdWUgPSBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSxcbiAgICAgICAgICAgICAgbGVuID0gZWxlbXMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuICAgICAgICAgIH0gLy8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcbiAgICAgICAgICAvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblxuXG4gICAgICAgICAgZm9yICg7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChieUVsZW1lbnQgJiYgZWxlbSkge1xuICAgICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgICBpZiAoIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuICAgICAgICAgICAgICAgIHhtbCA9ICFkb2N1bWVudElzSFRNTDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHdoaWxlIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXG5cbiAgICAgICAgICAgIGlmIChieVNldCkge1xuICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG4gICAgICAgICAgICAgIGlmIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudC0tO1xuICAgICAgICAgICAgICB9IC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcblxuXG4gICAgICAgICAgICAgIGlmIChzZWVkKSB7XG4gICAgICAgICAgICAgICAgdW5tYXRjaGVkLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcbiAgICAgICAgICAvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXG5cbiAgICAgICAgICBtYXRjaGVkQ291bnQgKz0gaTsgLy8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG4gICAgICAgICAgLy8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuICAgICAgICAgIC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuICAgICAgICAgIC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG4gICAgICAgICAgLy8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuICAgICAgICAgIC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuICAgICAgICAgIC8vIG51bWVyaWNhbGx5IHplcm8uXG5cbiAgICAgICAgICBpZiAoYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50KSB7XG4gICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSB7XG4gICAgICAgICAgICAgIG1hdGNoZXIodW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG4gICAgICAgICAgICAgIGlmIChtYXRjaGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbChyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblxuXG4gICAgICAgICAgICAgIHNldE1hdGNoZWQgPSBjb25kZW5zZShzZXRNYXRjaGVkKTtcbiAgICAgICAgICAgIH0gLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXG5cbiAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2V0TWF0Y2hlZCk7IC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJiBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cblxuICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcbiAgICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuICAgICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHVubWF0Y2hlZDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYnlTZXQgPyBtYXJrRnVuY3Rpb24oc3VwZXJNYXRjaGVyKSA6IHN1cGVyTWF0Y2hlcjtcbiAgICAgIH1cblxuICAgICAgY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBtYXRjaFxuICAgICAgLyogSW50ZXJuYWwgVXNlIE9ubHkgKi9cbiAgICAgICkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHNldE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl07XG5cbiAgICAgICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcbiAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICBtYXRjaCA9IHRva2VuaXplKHNlbGVjdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpID0gbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMobWF0Y2hbaV0pO1xuXG4gICAgICAgICAgICBpZiAoY2FjaGVkW2V4cGFuZG9dKSB7XG4gICAgICAgICAgICAgIHNldE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycy5wdXNoKGNhY2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblxuXG4gICAgICAgICAgY2FjaGVkID0gY29tcGlsZXJDYWNoZShzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMpKTsgLy8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cbiAgICAgICAgICBjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gICAgICAgKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICAgICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgICovXG5cblxuICAgICAgc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGZpbmQsXG4gICAgICAgICAgICBjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuICAgICAgICAgICAgbWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZShzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKTtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107IC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG4gICAgICAgIC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcbiAgICAgICAgICB0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDApO1xuXG4gICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVt0b2tlbnNbMV0udHlwZV0pIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSAoRXhwci5maW5kW1wiSURcIl0odG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCkgfHwgW10pWzBdO1xuXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7IC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGlsZWQpIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSh0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH0gLy8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXG5cbiAgICAgICAgICBpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3Qoc2VsZWN0b3IpID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTsgLy8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXG4gICAgICAgICAgICBpZiAoRXhwci5yZWxhdGl2ZVt0eXBlID0gdG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaW5kID0gRXhwci5maW5kW3R5cGVdKSB7XG4gICAgICAgICAgICAgIC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuICAgICAgICAgICAgICBpZiAoc2VlZCA9IGZpbmQodG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgcnNpYmxpbmcudGVzdCh0b2tlbnNbMF0udHlwZSkgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKHRva2Vucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHNlZWQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblxuXG4gICAgICAgIChjb21waWxlZCB8fCBjb21waWxlKHNlbGVjdG9yLCBtYXRjaCkpKHNlZWQsIGNvbnRleHQsICFkb2N1bWVudElzSFRNTCwgcmVzdWx0cywgIWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9OyAvLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuICAgICAgLy8gU29ydCBzdGFiaWxpdHlcblxuXG4gICAgICBzdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoc29ydE9yZGVyKS5qb2luKFwiXCIpID09PSBleHBhbmRvOyAvLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4gICAgICAvLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5cbiAgICAgIHN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlOyAvLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcblxuICAgICAgc2V0RG9jdW1lbnQoKTsgLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbiAgICAgIC8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuXG4gICAgICBzdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgLy8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG4gICAgICAgIHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpICYgMTtcbiAgICAgIH0pOyAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcblxuICAgICAgaWYgKCFhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IEFHUG9saWN5LmNyZWF0ZUhUTUwoXCI8YSBocmVmPScjJz48L2E+XCIpO1xuICAgICAgICByZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIjtcbiAgICAgIH0pKSB7XG4gICAgICAgIGFkZEhhbmRsZShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICAgICAgaWYgKCFpc1hNTCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU3VwcG9ydDogSUU8OVxuICAgICAgLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuXG5cbiAgICAgIGlmICghc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IEFHUG9saWN5LmNyZWF0ZUhUTUwoXCI8aW5wdXQvPlwiKTtcbiAgICAgICAgZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IFwiXCI7XG4gICAgICB9KSkge1xuICAgICAgICBhZGRIYW5kbGUoXCJ2YWx1ZVwiLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgICBpZiAoIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gU3VwcG9ydDogSUU8OVxuICAgICAgLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuXG5cbiAgICAgIGlmICghYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbiAgICAgIH0pKSB7XG4gICAgICAgIGFkZEhhbmRsZShib29sZWFucywgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICAgIGlmICghaXNYTUwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtW25hbWVdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDogKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/IHZhbC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRVhQT1NFXG4gICAgICAvLyBEbyBub3QgZXhwb3NlIFNpenpsZSB0byB0aGUgZ2xvYmFsIHNjb3BlIGluIHRoZSBjYXNlIG9mIEFkR3VhcmQgRXh0ZW5kZWRDc3MgYnVpbGRcblxuXG4gICAgICByZXR1cm4gU2l6emxlOyAvLyBFWFBPU0VcbiAgICB9KHdpbmRvdyk7IC8vPj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+XG5cbiAgfVxuXG4gIHJldHVybiBTaXp6bGU7XG59O1xuXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEFkZ3VhcmQgU29mdHdhcmUgTHRkXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIFNpenpsZSBhbmQgYWRkcyBzdXBwb3J0IGZvciBcIm1hdGNoZXMtY3NzXCIgcHNldWRvIGVsZW1lbnQuXG4gKi9cblxudmFyIFN0eWxlUHJvcGVydHlNYXRjaGVyID0gZnVuY3Rpb24gKHdpbmRvdykge1xuICB2YXIgaXNQaGFudG9tID0gISF3aW5kb3cuX3BoYW50b207XG4gIHZhciB1c2VGYWxsYmFjayA9IGlzUGhhbnRvbSAmJiAhIXdpbmRvdy5nZXRNYXRjaGVkQ1NTUnVsZXM7XG4gIC8qKlxuICAgKiBVbnF1b3RlcyBzcGVjaWZpZWQgdmFsdWVcbiAgICogV2Via2l0LWJhc2VkIGJyb3dzZXJzIHNpbmdsZXF1b3RlcyA8c3RyaW5nPiBjb250ZW50IHByb3BlcnR5IHZhbHVlc1xuICAgKiBPdGhlciBicm93c2VycyBkb3VibGVxdW90ZXMgY29udGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuXG4gIHZhciByZW1vdmVDb250ZW50UXVvdGVzID0gZnVuY3Rpb24gcmVtb3ZlQ29udGVudFF1b3Rlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXihbXCInXSkoW1xcc1xcU10qKVxcMSQvLCAnJDInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGdldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZS5iaW5kKHdpbmRvdyk7XG4gIHZhciBnZXRNYXRjaGVkQ1NTUnVsZXMgPSB1c2VGYWxsYmFjayA/IHdpbmRvdy5nZXRNYXRjaGVkQ1NTUnVsZXMuYmluZCh3aW5kb3cpIDogbnVsbDtcbiAgLyoqXG4gICAqIFRoZXJlIGlzIGFuIGlzc3VlIGluIGJyb3dzZXJzIGJhc2VkIG9uIG9sZCB3ZWJraXQ6XG4gICAqIGdldENvbXB1dGVkU3R5bGUoZWwsIFwiOmJlZm9yZVwiKSBpcyBlbXB0eSBpZiBlbGVtZW50IGlzIG5vdCB2aXNpYmxlLlxuICAgKlxuICAgKiBUbyBjaXJjdW12ZW50IHRoaXMgaXNzdWUgd2UgdXNlIGdldE1hdGNoZWRDU1NSdWxlcyBpbnN0ZWFkLlxuICAgKlxuICAgKiBJdCBhcHBlYXJzIHRoYXQgZ2V0TWF0Y2hlZENTU1J1bGVzIHNvcnRzIHRoZSBDU1MgcnVsZXNcbiAgICogaW4gaW5jcmVhc2luZyBvcmRlciBvZiBzcGVjaWZpdGllcyBvZiBjb3JyZXNwb25kaW5nIHNlbGVjdG9ycy5cbiAgICogV2UgcGljayB0aGUgY3NzIHJ1bGUgdGhhdCBpcyBiZWluZyBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgYmFzZWQgb24gdGhpcyBhc3N1bXB0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCAgICAgICBET00gbm9kZVxuICAgKiBAcGFyYW0gcHNldWRvRWxlbWVudCBPcHRpb25hbCBwc2V1ZG9FbGVtZW50IG5hbWVcbiAgICogQHBhcmFtIHByb3BlcnR5TmFtZSAgQ1NTIHByb3BlcnR5IG5hbWVcbiAgICovXG5cbiAgdmFyIGdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHNldWRvRWxlbWVudCwgcHJvcGVydHlOYW1lKSB7XG4gICAgdmFyIHZhbHVlID0gJyc7XG5cbiAgICBpZiAodXNlRmFsbGJhY2sgJiYgcHNldWRvRWxlbWVudCkge1xuICAgICAgdmFyIGNzc1J1bGVzID0gZ2V0TWF0Y2hlZENTU1J1bGVzKGVsZW1lbnQsIHBzZXVkb0VsZW1lbnQpIHx8IFtdO1xuICAgICAgdmFyIGkgPSBjc3NSdWxlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwICYmICF2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IGNzc1J1bGVzW2ldLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBwc2V1ZG9FbGVtZW50KTtcblxuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIHZhbHVlID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpOyAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTM0NDVcblxuICAgICAgICBpZiAocHJvcGVydHlOYW1lID09PSAnb3BhY2l0eScgJiYgdXRpbHMuaXNTYWZhcmlCcm93c2VyKSB7XG4gICAgICAgICAgdmFsdWUgPSAoTWF0aC5yb3VuZChwYXJzZUZsb2F0KHZhbHVlKSAqIDEwMCkgLyAxMDApLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlOYW1lID09PSAnY29udGVudCcpIHtcbiAgICAgIHZhbHVlID0gcmVtb3ZlQ29udGVudFF1b3Rlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICAvKipcbiAgICogQWRkcyB1cmwgcGFyYW1ldGVyIHF1b3RlcyBmb3Igbm9uLXJlZ2V4IHBhdHRlcm5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAgICovXG5cblxuICB2YXIgYWRkVXJsUXVvdGVzID0gZnVuY3Rpb24gYWRkVXJsUXVvdGVzKHBhdHRlcm4pIHtcbiAgICAvLyBmb3IgcmVnZXggcGF0dGVybnNcbiAgICBpZiAocGF0dGVyblswXSA9PT0gJy8nICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJy8nICYmIHBhdHRlcm4uaW5kZXhPZignXFxcXFwiJykgPCAxMCkge1xuICAgICAgLy8gZS5nLiAvXnVybFxcXFwoW2Etel17NH06W2Etel17NX0vXG4gICAgICAvLyBvciAvXnVybFxcXFwoZGF0YVxcXFw6XFxcXGltYWdlXFxcXC9naWY7YmFzZTY0LisvXG4gICAgICB2YXIgcmUgPSAvKFxcXik/dXJsKFxcXFwpP1xcXFxcXCgoXFx3fFxcW1xcdykvZztcbiAgICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UocmUsICckMXVybCQyXFxcXFxcKFxcXFxcIj8kMycpO1xuICAgIH0gLy8gZm9yIG5vbi1yZWdleCBwYXR0ZXJuc1xuXG5cbiAgICBpZiAocGF0dGVybi5pbmRleE9mKCd1cmwoXCInKSA9PT0gLTEpIHtcbiAgICAgIHZhciBfcmUgPSAvdXJsXFwoKC4qPylcXCkvZztcbiAgICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoX3JlLCAndXJsKFwiJDFcIiknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfTtcbiAgLyoqXG4gICAqIENsYXNzIHRoYXQgbWF0Y2hlcyBlbGVtZW50IHN0eWxlIGFnYWluc3QgdGhlIHNwZWNpZmllZCBleHByZXNzaW9uXG4gICAqIEBtZW1iZXIge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBtZW1iZXIge3N0cmluZ30gcHNldWRvRWxlbWVudFxuICAgKiBAbWVtYmVyIHtSZWdFeHB9IHJlZ2V4XG4gICAqL1xuXG5cbiAgdmFyIE1hdGNoZXIgPSBmdW5jdGlvbiBNYXRjaGVyKHByb3BlcnR5RmlsdGVyLCBwc2V1ZG9FbGVtZW50KSB7XG4gICAgdGhpcy5wc2V1ZG9FbGVtZW50ID0gcHNldWRvRWxlbWVudDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgaW5kZXggPSBwcm9wZXJ0eUZpbHRlci5pbmRleE9mKCc6Jyk7XG4gICAgICB0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5RmlsdGVyLnN1YnN0cmluZygwLCBpbmRleCkudHJpbSgpO1xuICAgICAgdmFyIHBhdHRlcm4gPSBwcm9wZXJ0eUZpbHRlci5zdWJzdHJpbmcoaW5kZXggKyAxKS50cmltKCk7XG4gICAgICBwYXR0ZXJuID0gYWRkVXJsUXVvdGVzKHBhdHRlcm4pOyAvLyBVbmVzY2FwaW5nIHBhdHRlcm5cbiAgICAgIC8vIEZvciBub24tcmVnZXggcGF0dGVybnMsICgsKSxbLF0gc2hvdWxkIGJlIHVuZXNjYXBlZCwgYmVjYXVzZSB3ZSByZXF1aXJlIGVzY2FwaW5nIHRoZW0gaW4gZmlsdGVyIHJ1bGVzLlxuICAgICAgLy8gRm9yIHJlZ2V4IHBhdHRlcm5zLCBcIixcXCBzaG91bGQgYmUgZXNjYXBlZCwgYmVjYXVzZSB3ZSBtYW51YWxseSBlc2NhcGUgdGhvc2UgaW4gZXh0ZW5kZWQtY3NzLXNlbGVjdG9yLmpzLlxuXG4gICAgICBpZiAoL15cXC8uKlxcLyQvLnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICAgICAgICB0aGlzLnJlZ2V4ID0gdXRpbHMucHNldWRvQXJnVG9SZWdleChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcXFwoW1xcXFwoKVtcXF1cIl0pL2csICckMScpO1xuICAgICAgICB0aGlzLnJlZ2V4ID0gdXRpbHMuY3JlYXRlVVJMUmVnZXgocGF0dGVybik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHV0aWxzLmxvZ0Vycm9yKFwiU3R5bGVQcm9wZXJ0eU1hdGNoZXI6IGludmFsaWQgbWF0Y2ggc3RyaW5nIFwiLmNvbmNhdChwcm9wZXJ0eUZpbHRlcikpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIGVsZW1lbnQgQ1NTIHByb3BlcnR5IG1hdGNoZXMgZmlsdGVyIHBhdHRlcm5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrXG4gICAqL1xuXG5cbiAgTWF0Y2hlci5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKCF0aGlzLnJlZ2V4IHx8ICF0aGlzLnByb3BlcnR5TmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHRoaXMucHNldWRvRWxlbWVudCwgdGhpcy5wcm9wZXJ0eU5hbWUpO1xuICAgIHJldHVybiB2YWx1ZSAmJiB0aGlzLnJlZ2V4LnRlc3QodmFsdWUpO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwc2V1ZG8tY2xhc3MgYW5kIHJlZ2lzdGVycyBpdCBpbiBTaXp6bGVcbiAgICovXG5cblxuICB2YXIgZXh0ZW5kU2l6emxlID0gZnVuY3Rpb24gZXh0ZW5kU2l6emxlKHNpenpsZSkge1xuICAgIC8vIEZpcnN0IG9mIGFsbCB3ZSBzaG91bGQgcHJlcGFyZSBTaXp6bGUgZW5naW5lXG4gICAgc2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydtYXRjaGVzLWNzcyddID0gc2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHByb3BlcnR5RmlsdGVyKSB7XG4gICAgICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKHByb3BlcnR5RmlsdGVyKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5tYXRjaGVzKGVsZW1lbnQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBzaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ21hdGNoZXMtY3NzLWJlZm9yZSddID0gc2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHByb3BlcnR5RmlsdGVyKSB7XG4gICAgICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKHByb3BlcnR5RmlsdGVyLCAnOmJlZm9yZScpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLm1hdGNoZXMoZWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snbWF0Y2hlcy1jc3MtYWZ0ZXInXSA9IHNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChwcm9wZXJ0eUZpbHRlcikge1xuICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgTWF0Y2hlcihwcm9wZXJ0eUZpbHRlciwgJzphZnRlcicpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLm1hdGNoZXMoZWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9OyAvLyBFWFBPU0VcblxuXG4gIHJldHVybiB7XG4gICAgZXh0ZW5kU2l6emxlOiBleHRlbmRTaXp6bGVcbiAgfTtcbn0od2luZG93KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBBZGd1YXJkIFNvZnR3YXJlIEx0ZFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgbWF0Y2hlclV0aWxzID0ge307XG5tYXRjaGVyVXRpbHMuTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuLyoqXG4gKiBQYXJzZXMgYXJndW1lbnQgb2YgbWF0Y2hlciBwc2V1ZG8gKGZvciBtYXRjaGVzLWF0dHIgYW5kIG1hdGNoZXMtcHJvcGVydHkpXG4gKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hlckZpbHRlciBhcmd1bWVudCBvZiBwc2V1ZG8gY2xhc3NcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuXG5tYXRjaGVyVXRpbHMucGFyc2VNYXRjaGVyRmlsdGVyID0gZnVuY3Rpb24gKG1hdGNoZXJGaWx0ZXIpIHtcbiAgdmFyIEZVTExfTUFUQ0hfTUFSS0VSID0gJ1wiPVwiJztcbiAgdmFyIHJhd0FyZ3MgPSBbXTtcblxuICBpZiAobWF0Y2hlckZpbHRlci5pbmRleE9mKEZVTExfTUFUQ0hfTUFSS0VSKSA9PT0gLTEpIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBwc2V1ZG8gYXJnXG4gICAgLy8gZS5nLiA6bWF0Y2hlcy1hdHRyKFwiZGF0YS1uYW1lXCIpIG9yIDptYXRjaGVzLXByb3BlcnR5KFwiaW5uZXIucHJvcFwiKVxuICAgIC8vIFNpenpsZSB3aWxsIHBhcnNlIGl0IGFuZCBnZXQgcmlkIG9mIHF1b3Rlc1xuICAgIC8vIHNvIGl0IG1pZ2h0IGJlIHZhbGlkIGFyZyBhbHJlYWR5IHdpdGhvdXQgdGhlbVxuICAgIHJhd0FyZ3MucHVzaChtYXRjaGVyRmlsdGVyKTtcbiAgfSBlbHNlIHtcbiAgICBtYXRjaGVyRmlsdGVyLnNwbGl0KCc9JykuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICBpZiAoYXJnWzBdID09PSAnXCInICYmIGFyZ1thcmcubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgcmF3QXJncy5wdXNoKGFyZy5zbGljZSgxLCAtMSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJhd0FyZ3M7XG59O1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBcmdEYXRhXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXJnXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzUmVnZXhwXG4gKi9cblxuLyoqXG4gKiBQYXJzZXMgcmF3IG1hdGNoZXIgYXJnXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3QXJnXG4gKiBAcmV0dXJucyB7QXJnRGF0YX1cbiAqL1xuXG5cbm1hdGNoZXJVdGlscy5wYXJzZVJhd01hdGNoZXJBcmcgPSBmdW5jdGlvbiAocmF3QXJnKSB7XG4gIHZhciBhcmcgPSByYXdBcmc7XG4gIHZhciBpc1JlZ2V4cCA9ICEhcmF3QXJnICYmIHJhd0FyZ1swXSA9PT0gJy8nICYmIHJhd0FyZ1tyYXdBcmcubGVuZ3RoIC0gMV0gPT09ICcvJztcblxuICBpZiAoaXNSZWdleHApIHtcbiAgICAvLyB0byBhdm9pZCBhdCBsZWFzdCBzdWNoIGNhc2Ug4oCUIDptYXRjaGVzLXByb3BlcnR5KFwiLy9cIilcbiAgICBpZiAocmF3QXJnLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFyZyA9IHV0aWxzLnRvUmVnRXhwKHJhd0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVnZXhwOiBcIi5jb25jYXQocmF3QXJnKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhcmc6IGFyZyxcbiAgICBpc1JlZ2V4cDogaXNSZWdleHBcbiAgfTtcbn07XG4vKipcbiAqIEB0eXBlZGVmIENoYWluXG4gKiBAcHJvcGVydHkge09iamVjdH0gYmFzZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3BcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZVxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMgaW4gdGhlIGJhc2Ugb2JqZWN0IChyZWN1cnNpdmVseSkuXG4gKiBAcGFyYW0ge09iamVjdH0gYmFzZVxuICogQHBhcmFtIHtBcmdEYXRhW119IGNoYWluIGFycmF5IG9mIG9iamVjdHMgLSBwYXJzZWQgc3RyaW5nIHByb3BlcnR5IGNoYWluXG4gKiBAcGFyYW0ge0FycmF5fSBbb3V0cHV0PVtdXSByZXN1bHQgYWNjXG4gKiBAcmV0dXJucyB7Q2hhaW5bXX0gYXJyYXkgb2Ygb2JqZWN0c1xuICovXG5cblxubWF0Y2hlclV0aWxzLmZpbHRlclJvb3RzQnlSZWdleHBDaGFpbiA9IGZ1bmN0aW9uIChiYXNlLCBjaGFpbikge1xuICB2YXIgb3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcbiAgdmFyIHRlbXBQcm9wID0gY2hhaW5bMF07XG5cbiAgaWYgKGNoYWluLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIGZvciAodmFyIGtleSBpbiBiYXNlKSB7XG4gICAgICBpZiAodGVtcFByb3AuaXNSZWdleHApIHtcbiAgICAgICAgaWYgKHRlbXBQcm9wLmFyZy50ZXN0KGtleSkpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgcHJvcDoga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGJhc2Vba2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBQcm9wLmFyZyA9PT0ga2V5KSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHtcbiAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgIHByb3A6IHRlbXBQcm9wLmFyZyxcbiAgICAgICAgICB2YWx1ZTogYmFzZVtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0gLy8gaWYgdGhlcmUgaXMgYSByZWdleHAgcHJvcCBpbiBpbnB1dCBjaGFpblxuICAvLyBlLmcuICd1bml0Li9eYWQuKy8uc3JjJyBmb3IgJ3VuaXQuYWQtMWdmMi5zcmMgdW5pdC5hZC1mZ2QzNC5zcmMnKSxcbiAgLy8gZXZlcnkgYmFzZSBrZXlzIHNob3VsZCBiZSB0ZXN0ZWQgYnkgcmVnZXhwIGFuZCBpdCBjYW4gYmUgbW9yZSB0aGF0IG9uZSByZXN1bHRzXG5cblxuICBpZiAodGVtcFByb3AuaXNSZWdleHApIHtcbiAgICB2YXIgbmV4dFByb3AgPSBjaGFpbi5zbGljZSgxKTtcbiAgICB2YXIgYmFzZUtleXMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5cbiAgICBmb3IgKHZhciBfa2V5IGluIGJhc2UpIHtcbiAgICAgIGlmICh0ZW1wUHJvcC5hcmcudGVzdChfa2V5KSkge1xuICAgICAgICBiYXNlS2V5cy5wdXNoKF9rZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhc2VLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGl0ZW0gPSBiYXNlW2tleV07XG4gICAgICBtYXRjaGVyVXRpbHMuZmlsdGVyUm9vdHNCeVJlZ2V4cENoYWluKGl0ZW0sIG5leHRQcm9wLCBvdXRwdXQpO1xuICAgIH0pO1xuICB9IC8vIGF2b2lkIFR5cGVFcnJvciB3aGlsZSBhY2Nlc3NpbmcgdG8gbnVsbC1wcm9wJ3MgY2hpbGRcblxuXG4gIGlmIChiYXNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5leHRCYXNlID0gYmFzZVt0ZW1wUHJvcC5hcmddO1xuICBjaGFpbiA9IGNoYWluLnNsaWNlKDEpO1xuXG4gIGlmIChuZXh0QmFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbWF0Y2hlclV0aWxzLmZpbHRlclJvb3RzQnlSZWdleHBDaGFpbihuZXh0QmFzZSwgY2hhaW4sIG91dHB1dCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcbi8qKlxuICogVmFsaWRhdGVzIHBhcnNlZCBhcmdzIG9mIG1hdGNoZXMtcHJvcGVydHkgcHNldWRvXG4gKiBAcGFyYW0gey4uLkFyZ0RhdGF9IGFyZ3NcbiAqL1xuXG5cbm1hdGNoZXJVdGlscy52YWxpZGF0ZVByb3BNYXRjaGVyQXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGFyZ3NbaV0uaXNSZWdleHApIHtcbiAgICAgIGlmICghdXRpbHMuc3RhcnRzV2l0aChhcmdzW2ldLmFyZy50b1N0cmluZygpLCAnLycpIHx8ICF1dGlscy5lbmRzV2l0aChhcmdzW2ldLmFyZy50b1N0cmluZygpLCAnLycpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gc2ltcGxlIGFyZyBjaGVjayBpZiBpdCBpcyBub3QgYSByZWdleHBcblxuICAgIH0gZWxzZSBpZiAoIS9eW1xcdy1dKyQvLnRlc3QoYXJnc1tpXS5hcmcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyBTaXp6bGUgYW5kIGFkZHMgc3VwcG9ydCBmb3IgXCJtYXRjaGVzLWF0dHJcIiBwc2V1ZG8gZWxlbWVudC5cbiAqL1xuXG52YXIgQXR0cmlidXRlc01hdGNoZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDbGFzcyB0aGF0IG1hdGNoZXMgZWxlbWVudCBhdHRyaWJ1dGVzIGFnYWluc3QgdGhlIHNwZWNpZmllZCBleHByZXNzaW9uc1xuICAgKiBAcGFyYW0ge0FyZ0RhdGF9IG5hbWVBcmcgLSBwYXJzZWQgbmFtZSBhcmd1bWVudFxuICAgKiBAcGFyYW0ge0FyZ0RhdGF9IHZhbHVlQXJnIC0gcGFyc2VkIHZhbHVlIGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwc2V1ZG9FbGVtZW50XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAbWVtYmVyIHtzdHJpbmd8UmVnRXhwfSBhdHRyTmFtZVxuICAgKiBAbWVtYmVyIHtib29sZWFufSBpc1JlZ2V4cE5hbWVcbiAgICogQG1lbWJlciB7c3RyaW5nfFJlZ0V4cH0gYXR0clZhbHVlXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59IGlzUmVnZXhwVmFsdWVcbiAgICovXG4gIHZhciBBdHRyTWF0Y2hlciA9IGZ1bmN0aW9uIEF0dHJNYXRjaGVyKG5hbWVBcmcsIHZhbHVlQXJnLCBwc2V1ZG9FbGVtZW50KSB7XG4gICAgdGhpcy5wc2V1ZG9FbGVtZW50ID0gcHNldWRvRWxlbWVudDtcbiAgICB0aGlzLmF0dHJOYW1lID0gbmFtZUFyZy5hcmc7XG4gICAgdGhpcy5pc1JlZ2V4cE5hbWUgPSBuYW1lQXJnLmlzUmVnZXhwO1xuICAgIHRoaXMuYXR0clZhbHVlID0gdmFsdWVBcmcuYXJnO1xuICAgIHRoaXMuaXNSZWdleHBWYWx1ZSA9IHZhbHVlQXJnLmlzUmVnZXhwO1xuICB9O1xuICAvKipcbiAgICogRnVuY3Rpb24gdG8gY2hlY2sgaWYgZWxlbWVudCBhdHRyaWJ1dGVzIG1hdGNoZXMgZmlsdGVyIHBhdHRlcm5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrXG4gICAqL1xuXG5cbiAgQXR0ck1hdGNoZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBlbEF0dHJzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuXG4gICAgaWYgKGVsQXR0cnMubGVuZ3RoID09PSAwIHx8ICF0aGlzLmF0dHJOYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBlbEF0dHJzLmxlbmd0aCkge1xuICAgICAgdmFyIGF0dHIgPSBlbEF0dHJzW2ldO1xuICAgICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgIHZhciBhdHRyTmFtZU1hdGNoZWQgPSB0aGlzLmlzUmVnZXhwTmFtZSA/IHRoaXMuYXR0ck5hbWUudGVzdChhdHRyLm5hbWUpIDogdGhpcy5hdHRyTmFtZSA9PT0gYXR0ci5uYW1lO1xuXG4gICAgICBpZiAoIXRoaXMuYXR0clZhbHVlKSB7XG4gICAgICAgIC8vIGZvciA6bWF0Y2hlcy1hdHRyKFwiL3JlZ2V4L1wiKSBvciA6bWF0Y2hlcy1hdHRyKFwiYXR0ci1uYW1lXCIpXG4gICAgICAgIG1hdGNoZWQgPSBhdHRyTmFtZU1hdGNoZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0clZhbHVlTWF0Y2hlZCA9IHRoaXMuaXNSZWdleHBWYWx1ZSA/IHRoaXMuYXR0clZhbHVlLnRlc3QoYXR0ci52YWx1ZSkgOiB0aGlzLmF0dHJWYWx1ZSA9PT0gYXR0ci52YWx1ZTtcbiAgICAgICAgbWF0Y2hlZCA9IGF0dHJOYW1lTWF0Y2hlZCAmJiBhdHRyVmFsdWVNYXRjaGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcHNldWRvLWNsYXNzIGFuZCByZWdpc3RlcnMgaXQgaW4gU2l6emxlXG4gICAqL1xuXG5cbiAgdmFyIGV4dGVuZFNpenpsZSA9IGZ1bmN0aW9uIGV4dGVuZFNpenpsZShzaXp6bGUpIHtcbiAgICAvLyBGaXJzdCBvZiBhbGwgd2Ugc2hvdWxkIHByZXBhcmUgU2l6emxlIGVuZ2luZVxuICAgIHNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snbWF0Y2hlcy1hdHRyJ10gPSBzaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoYXR0ckZpbHRlcikge1xuICAgICAgdmFyIF9tYXRjaGVyVXRpbHMkcGFyc2VNYSA9IG1hdGNoZXJVdGlscy5wYXJzZU1hdGNoZXJGaWx0ZXIoYXR0ckZpbHRlciksXG4gICAgICAgICAgX21hdGNoZXJVdGlscyRwYXJzZU1hMiA9IF9zbGljZWRUb0FycmF5KF9tYXRjaGVyVXRpbHMkcGFyc2VNYSwgMiksXG4gICAgICAgICAgcmF3TmFtZSA9IF9tYXRjaGVyVXRpbHMkcGFyc2VNYTJbMF0sXG4gICAgICAgICAgcmF3VmFsdWUgPSBfbWF0Y2hlclV0aWxzJHBhcnNlTWEyWzFdO1xuXG4gICAgICB2YXIgbmFtZUFyZyA9IG1hdGNoZXJVdGlscy5wYXJzZVJhd01hdGNoZXJBcmcocmF3TmFtZSk7XG4gICAgICB2YXIgdmFsdWVBcmcgPSBtYXRjaGVyVXRpbHMucGFyc2VSYXdNYXRjaGVyQXJnKHJhd1ZhbHVlKTtcblxuICAgICAgaWYgKCFhdHRyRmlsdGVyIHx8ICFtYXRjaGVyVXRpbHMudmFsaWRhdGVQcm9wTWF0Y2hlckFyZ3MobmFtZUFyZywgdmFsdWVBcmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOm1hdGNoZXMtYXR0ciBwc2V1ZG8gY2xhc3M6IFwiLmNvbmNhdChhdHRyRmlsdGVyKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVyID0gbmV3IEF0dHJNYXRjaGVyKG5hbWVBcmcsIHZhbHVlQXJnKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5tYXRjaGVzKGVsZW1lbnQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTsgLy8gRVhQT1NFXG5cblxuICByZXR1cm4ge1xuICAgIGV4dGVuZFNpenpsZTogZXh0ZW5kU2l6emxlXG4gIH07XG59KCk7XG5cbi8qKlxuICogUGFyc2VzIHJhdyBwcm9wZXJ0eSBhcmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHJldHVybnMge0FyZ0RhdGFbXX0gYXJyYXkgb2Ygb2JqZWN0c1xuICovXG5cbnZhciBwYXJzZVJhd1Byb3BDaGFpbiA9IGZ1bmN0aW9uIHBhcnNlUmF3UHJvcENoYWluKGlucHV0KSB7XG4gIHZhciBQUk9QU19ESVZJREVSID0gJy4nO1xuICB2YXIgUkVHRVhQX01BUktFUiA9ICcvJztcbiAgdmFyIHByb3BzQXJyID0gW107XG4gIHZhciBzdHIgPSBpbnB1dDtcblxuICB3aGlsZSAoc3RyLmxlbmd0aCA+IDApIHtcbiAgICBpZiAodXRpbHMuc3RhcnRzV2l0aChzdHIsIFBST1BTX0RJVklERVIpKSB7XG4gICAgICAvLyBmb3IgY2FzZXMgbGlrZSAnLnByb3AuaWQnIGFuZCAnbmVzdGVkLi50ZXN0J1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFpbiBwcm9wZXJ0eTogXCIuY29uY2F0KGlucHV0KSk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlscy5zdGFydHNXaXRoKHN0ciwgUkVHRVhQX01BUktFUikpIHtcbiAgICAgIHZhciBpc1JlZ2V4cCA9IGZhbHNlO1xuICAgICAgdmFyIGRpdmlkZXJJbmRleCA9IHN0ci5pbmRleE9mKFBST1BTX0RJVklERVIpO1xuXG4gICAgICBpZiAoc3RyLmluZGV4T2YoUFJPUFNfRElWSURFUikgPT09IC0xKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vICcuJyBsZWZ0IGluIHN0clxuICAgICAgICAvLyB0YWtlIHRoZSByZXN0IG9mIHN0ciBhcyBwcm9wXG4gICAgICAgIHByb3BzQXJyLnB1c2goe1xuICAgICAgICAgIGFyZzogc3RyLFxuICAgICAgICAgIGlzUmVnZXhwOiBpc1JlZ2V4cFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb3BzQXJyO1xuICAgICAgfSAvLyBlbHNlIHRha2UgcHJvcCBmcm9tIHN0clxuXG5cbiAgICAgIHZhciBwcm9wID0gc3RyLnNsaWNlKDAsIGRpdmlkZXJJbmRleCk7IC8vIGZvciBjYXNlcyBsaWtlICdhc2FkZi4/Ky8udGVzdCdcblxuICAgICAgaWYgKHByb3AuaW5kZXhPZihSRUdFWFBfTUFSS0VSKSA+IC0xKSB7XG4gICAgICAgIC8vIHByb3AgaXMgJz8rLydcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFpbiBwcm9wZXJ0eTogXCIuY29uY2F0KHByb3ApKTtcbiAgICAgIH1cblxuICAgICAgcHJvcHNBcnIucHVzaCh7XG4gICAgICAgIGFyZzogcHJvcCxcbiAgICAgICAgaXNSZWdleHA6IGlzUmVnZXhwXG4gICAgICB9KTsgLy8gZGVsZXRlIHByb3AgZnJvbSBzdHJcblxuICAgICAgc3RyID0gc3RyLnNsaWNlKGRpdmlkZXJJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlYWwgd2l0aCByZWdleHBcbiAgICAgIHZhciBwcm9wQ2h1bmtzID0gW107XG4gICAgICBwcm9wQ2h1bmtzLnB1c2goc3RyLnNsaWNlKDAsIDEpKTsgLy8gaWYgc3RyIHN0YXJ0cyB3aXRoICcvJywgZGVsZXRlIGl0IGZyb20gc3RyIGFuZCBmaW5kIGNsb3NpbmcgcmVnZXhwIHNsYXNoLlxuICAgICAgLy8gbm90ZSB0aGF0IGNoYWluZWQgcHJvcGVydHkgbmFtZSBjYW4gbm90IGluY2x1ZGUgJy8nIG9yICcuJ1xuICAgICAgLy8gc28gdGhlcmUgaXMgbm8gY2hlY2tpbmcgZm9yIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICB2YXIgcmVnZXhFbmRJbmRleCA9IHN0ci5pbmRleE9mKFJFR0VYUF9NQVJLRVIpO1xuXG4gICAgICBpZiAocmVnZXhFbmRJbmRleCA8IDEpIHtcbiAgICAgICAgLy8gcmVnZXhwIHNob3VsZCBiZSBhdCBsZWFzdCA9PT0gJy8uLydcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGF2b2lkIGFyZ3MgbGlrZSAnL2lkJyBhbmQgJ3Rlc3QuLy8uaWQnXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVnZXhwOiBcIi5jb25jYXQoUkVHRVhQX01BUktFUikuY29uY2F0KHN0cikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2lzUmVnZXhwID0gdHJ1ZTsgLy8gdGFrZSB0aGUgcmVzdCByZWdleHAgcGFydFxuXG4gICAgICBwcm9wQ2h1bmtzLnB1c2goc3RyLnNsaWNlKDAsIHJlZ2V4RW5kSW5kZXggKyAxKSk7XG5cbiAgICAgIHZhciBfcHJvcCA9IHV0aWxzLnRvUmVnRXhwKHByb3BDaHVua3Muam9pbignJykpO1xuXG4gICAgICBwcm9wc0Fyci5wdXNoKHtcbiAgICAgICAgYXJnOiBfcHJvcCxcbiAgICAgICAgaXNSZWdleHA6IF9pc1JlZ2V4cFxuICAgICAgfSk7IC8vIGRlbGV0ZSBwcm9wIGZyb20gc3RyXG5cbiAgICAgIHN0ciA9IHN0ci5zbGljZShyZWdleEVuZEluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgaWYgKCFzdHIpIHtcbiAgICAgIHJldHVybiBwcm9wc0FycjtcbiAgICB9IC8vIHN0ciBzaG91bGQgYmUgbGlrZSAnLm5leHRQcm9wJyBub3dcbiAgICAvLyBzbyAnengucHJvcCcgb3IgJy4nIGlzIGludmFsaWRcblxuXG4gICAgaWYgKCF1dGlscy5zdGFydHNXaXRoKHN0ciwgUFJPUFNfRElWSURFUikgfHwgdXRpbHMuc3RhcnRzV2l0aChzdHIsIFBST1BTX0RJVklERVIpICYmIHN0ci5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hhaW4gcHJvcGVydHk6IFwiLmNvbmNhdChpbnB1dCkpO1xuICAgIH1cblxuICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgfVxufTtcblxudmFyIGNvbnZlcnRUeXBlRnJvbVN0ciA9IGZ1bmN0aW9uIGNvbnZlcnRUeXBlRnJvbVN0cih2YWx1ZSkge1xuICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICB2YXIgb3V0cHV0O1xuXG4gIGlmICghTnVtYmVyLmlzTmFOKG51bVZhbHVlKSkge1xuICAgIG91dHB1dCA9IG51bVZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIG91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICBvdXRwdXQgPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgIG91dHB1dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdmYWxzZSc6XG4gICAgICAgIG91dHB1dCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0cHV0ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnZhciBjb252ZXJ0VHlwZUludG9TdHIgPSBmdW5jdGlvbiBjb252ZXJ0VHlwZUludG9TdHIodmFsdWUpIHtcbiAgdmFyIG91dHB1dDtcblxuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBvdXRwdXQgPSAndW5kZWZpbmVkJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBudWxsOlxuICAgICAgb3V0cHV0ID0gJ251bGwnO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb3V0cHV0ID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgU2l6emxlIGFuZCBhZGRzIHN1cHBvcnQgZm9yIFwibWF0Y2hlcy1wcm9wZXJ0eVwiIHBzZXVkbyBlbGVtZW50LlxuICovXG5cblxudmFyIEVsZW1lbnRQcm9wZXJ0eU1hdGNoZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDbGFzcyB0aGF0IG1hdGNoZXMgZWxlbWVudCBwcm9wZXJ0aWVzIGFnYWluc3QgdGhlIHNwZWNpZmllZCBleHByZXNzaW9uc1xuICAgKiBAcGFyYW0ge0FyZ0RhdGFbXX0gcHJvcHNDaGFpbkFyZyAtIGFycmF5IG9mIHBhcnNlZCBwcm9wcyBjaGFpbiBvYmplY3RzXG4gICAqIEBwYXJhbSB7QXJnRGF0YX0gdmFsdWVBcmcgLSBwYXJzZWQgdmFsdWUgYXJndW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBzZXVkb0VsZW1lbnRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBtZW1iZXIge0FycmF5fSBjaGFpbmVkUHJvcHNcbiAgICogQG1lbWJlciB7Ym9vbGVhbn0gaXNSZWdleHBOYW1lXG4gICAqIEBtZW1iZXIge3N0cmluZ3xSZWdFeHB9IHByb3BWYWx1ZVxuICAgKiBAbWVtYmVyIHtib29sZWFufSBpc1JlZ2V4cFZhbHVlXG4gICAqL1xuICB2YXIgUHJvcE1hdGNoZXIgPSBmdW5jdGlvbiBQcm9wTWF0Y2hlcihwcm9wc0NoYWluQXJnLCB2YWx1ZUFyZywgcHNldWRvRWxlbWVudCkge1xuICAgIHRoaXMucHNldWRvRWxlbWVudCA9IHBzZXVkb0VsZW1lbnQ7XG4gICAgdGhpcy5jaGFpbmVkUHJvcHMgPSBwcm9wc0NoYWluQXJnO1xuICAgIHRoaXMucHJvcFZhbHVlID0gdmFsdWVBcmcuYXJnO1xuICAgIHRoaXMuaXNSZWdleHBWYWx1ZSA9IHZhbHVlQXJnLmlzUmVnZXhwO1xuICB9O1xuICAvKipcbiAgICogRnVuY3Rpb24gdG8gY2hlY2sgaWYgZWxlbWVudCBwcm9wZXJ0aWVzIG1hdGNoZXMgZmlsdGVyIHBhdHRlcm5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrXG4gICAqL1xuXG5cbiAgUHJvcE1hdGNoZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBvd25lck9iakFyciA9IG1hdGNoZXJVdGlscy5maWx0ZXJSb290c0J5UmVnZXhwQ2hhaW4oZWxlbWVudCwgdGhpcy5jaGFpbmVkUHJvcHMpO1xuXG4gICAgaWYgKG93bmVyT2JqQXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnByb3BWYWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvd25lck9iakFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmVhbFZhbHVlID0gb3duZXJPYmpBcnJbaV0udmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNSZWdleHBWYWx1ZSkge1xuICAgICAgICAgIG1hdGNoZWQgPSB0aGlzLnByb3BWYWx1ZS50ZXN0KGNvbnZlcnRUeXBlSW50b1N0cihyZWFsVmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBoYW5kbGUgJ251bGwnIGFuZCAndW5kZWZpbmVkJyBwcm9wZXJ0eSB2YWx1ZXMgc2V0IGFzIHN0cmluZ1xuICAgICAgICAgIGlmIChyZWFsVmFsdWUgPT09ICdudWxsJyB8fCByZWFsVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYXRjaGVkID0gdGhpcy5wcm9wVmFsdWUgPT09IHJlYWxWYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hdGNoZWQgPSBjb252ZXJ0VHlwZUZyb21TdHIodGhpcy5wcm9wVmFsdWUpID09PSByZWFsVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZWQ7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBzZXVkby1jbGFzcyBhbmQgcmVnaXN0ZXJzIGl0IGluIFNpenpsZVxuICAgKi9cblxuXG4gIHZhciBleHRlbmRTaXp6bGUgPSBmdW5jdGlvbiBleHRlbmRTaXp6bGUoc2l6emxlKSB7XG4gICAgLy8gRmlyc3Qgb2YgYWxsIHdlIHNob3VsZCBwcmVwYXJlIFNpenpsZSBlbmdpbmVcbiAgICBzaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ21hdGNoZXMtcHJvcGVydHknXSA9IHNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChwcm9wZXJ0eUZpbHRlcikge1xuICAgICAgaWYgKCFwcm9wZXJ0eUZpbHRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFyZ3VtZW50IGlzIGdpdmVuIGZvciA6bWF0Y2hlcy1wcm9wZXJ0eSBwc2V1ZG8gY2xhc3MnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9tYXRjaGVyVXRpbHMkcGFyc2VNYSA9IG1hdGNoZXJVdGlscy5wYXJzZU1hdGNoZXJGaWx0ZXIocHJvcGVydHlGaWx0ZXIpLFxuICAgICAgICAgIF9tYXRjaGVyVXRpbHMkcGFyc2VNYTIgPSBfc2xpY2VkVG9BcnJheShfbWF0Y2hlclV0aWxzJHBhcnNlTWEsIDIpLFxuICAgICAgICAgIHJhd1Byb3AgPSBfbWF0Y2hlclV0aWxzJHBhcnNlTWEyWzBdLFxuICAgICAgICAgIHJhd1ZhbHVlID0gX21hdGNoZXJVdGlscyRwYXJzZU1hMlsxXTsgLy8gY2hhaW5lZCBwcm9wZXJ0eSBuYW1lIGNhbiBub3QgaW5jbHVkZSAnLycgb3IgJy4nXG4gICAgICAvLyBzbyByZWdleCBwcm9wIG5hbWVzIHdpdGggc3VjaCBlc2NhcGVkIGNoYXJhY3RlcnMgYXJlIGludmFsaWRcblxuXG4gICAgICBpZiAocmF3UHJvcC5pbmRleE9mKCdcXFxcLycpID4gLTEgfHwgcmF3UHJvcC5pbmRleE9mKCdcXFxcLicpID4gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lOiBcIi5jb25jYXQocmF3UHJvcCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcHNDaGFpbkFyZyA9IHBhcnNlUmF3UHJvcENoYWluKHJhd1Byb3ApO1xuICAgICAgdmFyIHZhbHVlQXJnID0gbWF0Y2hlclV0aWxzLnBhcnNlUmF3TWF0Y2hlckFyZyhyYXdWYWx1ZSk7XG4gICAgICB2YXIgcHJvcHNUb1ZhbGlkYXRlID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwcm9wc0NoYWluQXJnKSwgW3ZhbHVlQXJnXSk7XG5cbiAgICAgIGlmICghbWF0Y2hlclV0aWxzLnZhbGlkYXRlUHJvcE1hdGNoZXJBcmdzKHByb3BzVG9WYWxpZGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6bWF0Y2hlcy1wcm9wZXJ0eSBwc2V1ZG8gY2xhc3M6IFwiLmNvbmNhdChwcm9wZXJ0eUZpbHRlcikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlciA9IG5ldyBQcm9wTWF0Y2hlcihwcm9wc0NoYWluQXJnLCB2YWx1ZUFyZyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2hlcyhlbGVtZW50KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07IC8vIEVYUE9TRVxuXG5cbiAgcmV0dXJuIHtcbiAgICBleHRlbmRTaXp6bGU6IGV4dGVuZFNpenpsZVxuICB9O1xufSgpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDIwIEFkZ3VhcmQgU29mdHdhcmUgTHRkXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIFNpenpsZSBhbmQgYWRkcyBzdXBwb3J0IGZvciA6aXMoKSBwc2V1ZG8gZWxlbWVudC5cbiAqL1xuXG52YXIgSXNBbnlNYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ2xhc3MgdGhhdCBtYXRjaGVzIGVsZW1lbnQgYnkgb25lIG9mIHRoZSBzZWxlY3RvcnNcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTLzppc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RvcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBzZXVkb0VsZW1lbnRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgSXNNYXRjaGVyID0gZnVuY3Rpb24gSXNNYXRjaGVyKHNlbGVjdG9ycywgcHNldWRvRWxlbWVudCkge1xuICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgIHRoaXMucHNldWRvRWxlbWVudCA9IHBzZXVkb0VsZW1lbnQ7XG4gIH07XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBjaGVjayBpZiBlbGVtZW50IGNhbiBiZSBtYXRjaGVkIGJ5IGFueSBwYXNzZWQgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrXG4gICAqL1xuXG5cbiAgSXNNYXRjaGVyLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgaXNNYXRjaGVkID0gISF0aGlzLnNlbGVjdG9ycy5maW5kKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlcykuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBpc01hdGNoZWQ7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBzZXVkby1jbGFzcyBhbmQgcmVnaXN0ZXJzIGl0IGluIFNpenpsZVxuICAgKi9cblxuXG4gIHZhciBleHRlbmRTaXp6bGUgPSBmdW5jdGlvbiBleHRlbmRTaXp6bGUoc2l6emxlKSB7XG4gICAgLy8gRmlyc3Qgb2YgYWxsIHdlIHNob3VsZCBwcmVwYXJlIFNpenpsZSBlbmdpbmVcbiAgICBzaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ2lzJ10gPSBzaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6aXMgcHNldWRvLWNsYXNzOiBcIi5jb25jYXQoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGVjdG9ycyA9IGlucHV0LnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLnRyaW0oKTtcbiAgICAgIH0pOyAvLyBjb2xsZWN0IHZhbGlkIHNlbGVjdG9ycyBhbmQgbG9nIGFib3V0IGludmFsaWQgb25lc1xuXG4gICAgICB2YXIgdmFsaWRTZWxlY3RvcnMgPSBzZWxlY3RvcnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChjc3NVdGlscy5pc1NpbXBsZVNlbGVjdG9yVmFsaWQoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgYWNjLnB1c2goc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWxzLmxvZ0luZm8oXCJJbnZhbGlkIHNlbGVjdG9yIHBhc3NlZCB0byA6aXMoKSBwc2V1ZG8tY2xhc3M6ICdcIi5jb25jYXQoc2VsZWN0b3IsIFwiJ1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgW10pO1xuICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgSXNNYXRjaGVyKHZhbGlkU2VsZWN0b3JzKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5tYXRjaGVzKGVsZW1lbnQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGV4dGVuZFNpenpsZTogZXh0ZW5kU2l6emxlXG4gIH07XG59KCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgQWRndWFyZCBTb2Z0d2FyZSBMdGRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBFeHRlbmRlZCBzZWxlY3RvciBmYWN0b3J5IG1vZHVsZSwgZm9yIGNyZWF0aW5nIGV4dGVuZGVkIHNlbGVjdG9yIGNsYXNzZXMuXG4gKlxuICogRXh0ZW5kZWQgc2VsZWN0aW9uIGNhcGFiaWxpdGllcyBkZXNjcmlwdGlvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9FeHRlbmRlZENzcy9ibG9iL21hc3Rlci9SRUFETUUubWRcbiAqL1xuXG52YXIgRXh0ZW5kZWRTZWxlY3RvckZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHdoaWxlIGFkZGluZyBuZXcgbWFya2VycywgY29uc3RhbnRzIGluIG90aGVyIEFkR3VhcmQgcmVwb3Mgc2hvdWxkIGJlIGNvcnJlY3RlZFxuICAvLyBBZEd1YXJkIGJyb3dzZXIgZXh0ZW5zaW9uIDogQ3NzRmlsdGVyUnVsZS5TVVBQT1JURURfUFNFVURPX0NMQVNTRVMgYW5kIENzc0ZpbHRlclJ1bGUuRVhURU5ERURfQ1NTX01BUktFUlNcbiAgLy8gdHN1cmxmaWx0ZXIsIFNhZmFyaUNvbnZlcnRlckxpYiA6IEVYVF9DU1NfUFNFVURPX0lORElDQVRPUlNcbiAgdmFyIFBTRVVET19FWFRFTlNJT05TX01BUktFUlMgPSBbJzpoYXMnLCAnOmNvbnRhaW5zJywgJzpoYXMtdGV4dCcsICc6bWF0Y2hlcy1jc3MnLCAnOi1hYnAtaGFzJywgJzotYWJwLWhhcy10ZXh0JywgJzppZicsICc6aWYtbm90JywgJzp4cGF0aCcsICc6bnRoLWFuY2VzdG9yJywgJzp1cHdhcmQnLCAnOnJlbW92ZScsICc6bWF0Y2hlcy1hdHRyJywgJzptYXRjaGVzLXByb3BlcnR5JywgJzotYWJwLWNvbnRhaW5zJywgJzppcyddO1xuICB2YXIgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgdmFyIFNpenpsZTtcbiAgLyoqXG4gICAqIExhenkgaW5pdGlhbGl6YXRpb24gb2YgdGhlIEV4dGVuZGVkU2VsZWN0b3JGYWN0b3J5IGFuZCBvYmplY3RzIHRoYXQgbWlnaHQgYmUgbmVjZXNzYXJ5IGZvciBjcmVhdGluZyBhbmQgYXBwbHlpbmcgc3R5bGVzLlxuICAgKiBUaGlzIG1ldGhvZCBleHRlbmRzIFNpenpsZSBlbmdpbmUgdGhhdCB3ZSB1c2UgdW5kZXIgdGhlIGhvb2Qgd2l0aCBvdXIgY3VzdG9tIHBzZXVkby1jbGFzc2VzLlxuICAgKi9cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmIChpbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVkID0gdHJ1ZTsgLy8gT3VyIHZlcnNpb24gb2YgU2l6emxlIGlzIGluaXRpYWxpemVkIGxhemlseSBhcyB3ZWxsXG5cbiAgICBTaXp6bGUgPSBpbml0aWFsaXplU2l6emxlKCk7IC8vIEFkZCA6bWF0Y2hlcy1jc3MtKigpIHN1cHBvcnRcblxuICAgIFN0eWxlUHJvcGVydHlNYXRjaGVyLmV4dGVuZFNpenpsZShTaXp6bGUpOyAvLyBBZGQgOm1hdGNoZXMtYXR0cigpIHN1cHBvcnRcblxuICAgIEF0dHJpYnV0ZXNNYXRjaGVyLmV4dGVuZFNpenpsZShTaXp6bGUpOyAvLyBBZGQgOm1hdGNoZXMtcHJvcGVydHkoKSBzdXBwb3J0XG5cbiAgICBFbGVtZW50UHJvcGVydHlNYXRjaGVyLmV4dGVuZFNpenpsZShTaXp6bGUpOyAvLyBBZGQgOmlzKCkgc3VwcG9ydFxuXG4gICAgSXNBbnlNYXRjaGVyLmV4dGVuZFNpenpsZShTaXp6bGUpOyAvLyBBZGQgOmNvbnRhaW5zLCA6aGFzLXRleHQsIDotYWJwLWNvbnRhaW5zIHN1cHBvcnRcblxuICAgIHZhciBjb250YWluc1BzZXVkbyA9IFNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICBpZiAoL15cXHMqXFwvLipcXC9bZ21pc3V5XSpcXHMqJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gICAgICAgIHZhciBmbGFnc0luZGV4ID0gdGV4dC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICB2YXIgZmxhZ3MgPSB0ZXh0LnN1YnN0cmluZyhmbGFnc0luZGV4ICsgMSk7XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigwLCBmbGFnc0luZGV4ICsgMSkuc2xpY2UoMSwgLTEpLnJlcGxhY2UoL1xcXFwoW1xcXFxcIl0pL2csICckMScpO1xuICAgICAgICB2YXIgcmVnZXg7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAodGV4dCwgZmxhZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6Y29udGFpbnMgcHNldWRvIGNsYXNzOiBcIi5jb25jYXQodGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgdmFyIGVsZW1UZXh0Q29udGVudCA9IHV0aWxzLm5vZGVUZXh0Q29udGVudEdldHRlci5hcHBseShlbGVtKTtcbiAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdChlbGVtVGV4dENvbnRlbnQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXFxcKFtcXFxcKClbXFxdXCJdKS9nLCAnJDEnKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICB2YXIgZWxlbVRleHRDb250ZW50ID0gdXRpbHMubm9kZVRleHRDb250ZW50R2V0dGVyLmFwcGx5KGVsZW0pO1xuICAgICAgICByZXR1cm4gZWxlbVRleHRDb250ZW50LmluZGV4T2YodGV4dCkgPiAtMTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydjb250YWlucyddID0gY29udGFpbnNQc2V1ZG87XG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydoYXMtdGV4dCddID0gY29udGFpbnNQc2V1ZG87XG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWyctYWJwLWNvbnRhaW5zJ10gPSBjb250YWluc1BzZXVkbzsgLy8gQWRkIDppZiwgOi1hYnAtaGFzIHN1cHBvcnRcblxuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snaWYnXSA9IFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snaGFzJ107XG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWyctYWJwLWhhcyddID0gU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydoYXMnXTsgLy8gQWRkIDppZi1ub3Qgc3VwcG9ydFxuXG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydpZi1ub3QnXSA9IFNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgU2l6emxlLmNvbXBpbGUoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIFNpenpsZShzZWxlY3RvciwgZWxlbSkubGVuZ3RoID09PSAwO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZWdpc3RlclBhcnNlck9ubHlUb2tlbnMoKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0cmF0ZSBjdXN0b20gdG9rZW5zIGZvciBwYXJzZXIuXG4gICAqIE5lZWRlZCBmb3IgcHJvcGVyIHdvcmsgb2YgcHNldWRvczpcbiAgICogZm9yIGNoZWNraW5nIGlmIHRoZSB0b2tlbiBpcyBsYXN0IGFuZCBwc2V1ZG8tY2xhc3MgYXJndW1lbnRzIHZhbGlkYXRpb25cbiAgICovXG5cblxuICBmdW5jdGlvbiByZWdpc3RlclBhcnNlck9ubHlUb2tlbnMoKSB7XG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWyd4cGF0aCddID0gU2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5jcmVhdGVFeHByZXNzaW9uKHNlbGVjdG9yLCBudWxsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6eHBhdGggcHNldWRvIGNsYXNzOiBcIi5jb25jYXQoc2VsZWN0b3IpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snbnRoLWFuY2VzdG9yJ10gPSBTaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBkZWVwID0gTnVtYmVyKHNlbGVjdG9yKTtcblxuICAgICAgaWYgKE51bWJlci5pc05hTihkZWVwKSB8fCBkZWVwIDwgMSB8fCBkZWVwID49IDI1Nikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDpudGgtYW5jZXN0b3IgcHNldWRvIGNsYXNzOiBcIi5jb25jYXQoc2VsZWN0b3IpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1sndXB3YXJkJ10gPSBTaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6dXB3YXJkIHBzZXVkbyBjbGFzczogXCIuY29uY2F0KGlucHV0KSk7XG4gICAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoK2lucHV0KSAmJiAoK2lucHV0IDwgMSB8fCAraW5wdXQgPj0gMjU2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDp1cHdhcmQgcHNldWRvIGNsYXNzOiBcIi5jb25jYXQoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1sncmVtb3ZlJ10gPSBTaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCAhPT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6cmVtb3ZlIHBzZXVkbyBjbGFzczogXCIuY29uY2F0KGlucHV0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHNwZWNpZmllZCB0b2tlbiBjYW4gYmUgdXNlZCBieSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzU2ltcGxlVG9rZW4odG9rZW4pIHtcbiAgICB2YXIgdHlwZSA9IHRva2VuLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ0lEJyB8fCB0eXBlID09PSAnQ0xBU1MnIHx8IHR5cGUgPT09ICdBVFRSJyB8fCB0eXBlID09PSAnVEFHJyB8fCB0eXBlID09PSAnQ0hJTEQnKSB7XG4gICAgICAvLyBrbm93biBzaW1wbGUgdG9rZW5zXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ1BTRVVETycpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHZhbHVlIGNvbnRhaW5zIGFueSBvZiBleHRlbmRlZCBwc2V1ZG8gY2xhc3Nlc1xuICAgICAgdmFyIGkgPSBQU0VVRE9fRVhURU5TSU9OU19NQVJLRVJTLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAodG9rZW4udmFsdWUuaW5kZXhPZihQU0VVRE9fRVhURU5TSU9OU19NQVJLRVJTW2ldKSA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gYWxsIG90aGVycyBhcmVuJ3Qgc2ltcGxlXG5cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHNwZWNpZmllZCB0b2tlbiBpcyBhIGNvbWJpbmF0b3JcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1JlbGF0aW9uVG9rZW4odG9rZW4pIHtcbiAgICB2YXIgdHlwZSA9IHRva2VuLnR5cGU7XG4gICAgcmV0dXJuIHR5cGUgPT09ICcgJyB8fCB0eXBlID09PSAnPicgfHwgdHlwZSA9PT0gJysnIHx8IHR5cGUgPT09ICd+JztcbiAgfVxuICAvKipcbiAgICogRXh0ZW5kZWRTZWxlY3RvclBhcnNlciBpcyBhIGhlbHBlciBjbGFzcyBmb3IgY3JlYXRpbmcgdmFyaW91cyBzZWxlY3RvciBpbnN0YW5jZXMgd2hpY2hcbiAgICogYWxsIHNoYXJlcyBhIG1ldGhvZCBgcXVlcnlTZWxlY3RvckFsbCgpYCBhbmQgYG1hdGNoZXMoKWAgaW1wbGVtZW50aW5nIGRpZmZlcmVudCBzZWFyY2ggc3RyYXRlZ2llc1xuICAgKiBkZXBlbmRpbmcgb24gYSB0eXBlIG9mIHNlbGVjdG9yLlxuICAgKlxuICAgKiBDdXJyZW50bHksIHRoZXJlIGFyZSAzIHR5cGVzOlxuICAgKiAgQSB0cmFpdC1sZXNzIGV4dGVuZGVkIHNlbGVjdG9yXG4gICAqICAgIC0gd2UgZGlyZWN0bHkgZmVlZCBzZWxlY3RvciBzdHJpbmdzIHRvIFNpenpsZS5cbiAgICogIEEgc3BsaXR0ZWQgZXh0ZW5kZWQgc2VsZWN0b3JcbiAgICogICAgLSBzdWNoIGFzICNjb250YWluZXIgI2ZlZWRJdGVtOmhhcyguYWRzKSwgd2hlcmUgaXQgaXMgc3BsaXR0ZWQgdG8gYCNjb250YWluZXJgIGFuZCBgI2ZlZWRJdGVtOmhhcyguYWRzKWAuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gRXh0ZW5kZWRTZWxlY3RvclBhcnNlcihzZWxlY3RvclRleHQsIHRva2VucywgZGVidWcpIHtcbiAgICBpbml0aWFsaXplKCk7XG5cbiAgICBpZiAodHlwZW9mIHRva2VucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gY3NzVXRpbHMubm9ybWFsaXplKHNlbGVjdG9yVGV4dCk7IC8vIFBhc3NpbmcgYHJldHVyblVuc29ydGVkYCBpbiBvcmRlciB0byByZWNlaXZlIHRva2VucyBpbiB0aGUgb3JkZXIgdGhhdCdzIHZhbGlkIGZvciB0aGUgYnJvd3NlclxuICAgICAgLy8gSW4gU2l6emxlIGludGVybmFsbHksIHRoZSB0b2tlbnMgYXJlIHJlLXNvcnRlZDogaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0V4dGVuZGVkQ3NzL2lzc3Vlcy81NVxuXG4gICAgICB0aGlzLnRva2VucyA9IFNpenpsZS50b2tlbml6ZSh0aGlzLnNlbGVjdG9yVGV4dCwgZmFsc2UsIHtcbiAgICAgICAgcmV0dXJuVW5zb3J0ZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDtcbiAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgIH1cblxuICAgIGlmIChkZWJ1ZyA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5kZWJ1ZyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgRXh0ZW5kZWRTZWxlY3RvclBhcnNlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gbWV0aG9kLCBjcmVhdGVzIGEgc2VsZWN0b3IgaW5zdGFuY2UgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGEgc2VsZWN0b3IuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNyZWF0ZVNlbGVjdG9yOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvcigpIHtcbiAgICAgIHZhciBkZWJ1ZyA9IHRoaXMuZGVidWc7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnM7XG4gICAgICB2YXIgc2VsZWN0b3JUZXh0ID0gdGhpcy5zZWxlY3RvclRleHQ7XG5cbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIC8vIENvbW1hLXNlcGFyYXRlIHNlbGVjdG9yIC0gY2FuJ3Qgb3B0aW1pemUgZnVydGhlclxuICAgICAgICByZXR1cm4gbmV3IFRyYWl0TGVzc1NlbGVjdG9yKHNlbGVjdG9yVGV4dCwgZGVidWcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeHBhdGhQYXJ0ID0gdGhpcy5nZXRYcGF0aFBhcnQoKTtcblxuICAgICAgaWYgKHR5cGVvZiB4cGF0aFBhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgWHBhdGhTZWxlY3RvcihzZWxlY3RvclRleHQsIHhwYXRoUGFydCwgZGVidWcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXB3YXJkUGFydCA9IHRoaXMuZ2V0VXB3YXJkUGFydCgpO1xuXG4gICAgICBpZiAodHlwZW9mIHVwd2FyZFBhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgIHZhciB1cHdhcmREZWVwID0gcGFyc2VJbnQodXB3YXJkUGFydCwgMTApOyAvLyBpZiB1cHdhcmQgcGFyYW1ldGVyIGlzIG5vdCBhIG51bWJlciwgd2UgY29uc2lkZXIgaXQgYXMgYSBzZWxlY3RvclxuXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4odXB3YXJkRGVlcCkpIHtcbiAgICAgICAgICBvdXRwdXQgPSBuZXcgVXB3YXJkU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCB1cHdhcmRQYXJ0LCBkZWJ1Zyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXB3YXJkIHdvcmtzIGxpa2UgbnRoLWFuY2VzdG9yXG4gICAgICAgICAgdmFyIHhwYXRoID0gdGhpcy5jb252ZXJ0TnRoQW5jZXN0b3JUb2tlbih1cHdhcmREZWVwKTtcbiAgICAgICAgICBvdXRwdXQgPSBuZXcgWHBhdGhTZWxlY3RvcihzZWxlY3RvclRleHQsIHhwYXRoLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfSAvLyBhcmd1bWVudCBvZiBwc2V1ZG8tY2xhc3MgcmVtb3ZlO1xuICAgICAgLy8gaXQncyBkZWZpbmVkIG9ubHkgaWYgcmVtb3ZlIGlzIHBhcnNlZCBhcyBsYXN0IHRva2VuXG4gICAgICAvLyBhbmQgaXQncyB2YWxpZCBvbmx5IGlmIHJlbW92ZSBhcmcgaXMgZW1wdHkgc3RyaW5nXG5cblxuICAgICAgdmFyIHJlbW92ZVBhcnQgPSB0aGlzLmdldFJlbW92ZVBhcnQoKTtcblxuICAgICAgaWYgKHR5cGVvZiByZW1vdmVQYXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaGFzVmFsaWRSZW1vdmVQYXJ0ID0gcmVtb3ZlUGFydCA9PT0gJyc7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBoYXNWYWxpZFJlbW92ZVBhcnQsIGRlYnVnKTtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zID0gdG9rZW5zWzBdO1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgdmFyIGxhc3RSZWxUb2tlbkluZCA9IHRoaXMuZ2V0U3BsaXRQb2ludCgpO1xuXG4gICAgICBpZiAodHlwZW9mIGxhc3RSZWxUb2tlbkluZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRyYWl0TGVzc1NlbGVjdG9yKHNlbGVjdG9yVGV4dCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOb3RBbkV4dGVuZGVkU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBkZWJ1Zyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaW1wbGUgPSAnJztcbiAgICAgIHZhciByZWxhdGlvbiA9IG51bGw7XG4gICAgICB2YXIgY29tcGxleCA9ICcnO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGxhc3RSZWxUb2tlbkluZDsgaSsrKSB7XG4gICAgICAgIC8vIGJ1aWxkIHNpbXBsZSBwYXJ0XG4gICAgICAgIHNpbXBsZSArPSB0b2tlbnNbaV0udmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAvLyBidWlsZCByZWxhdGlvbiBwYXJ0XG4gICAgICAgIHJlbGF0aW9uID0gdG9rZW5zW2krK10udHlwZTtcbiAgICAgIH0gLy8gaSBpcyBwb2ludGluZyB0byB0aGUgc3RhcnQgb2YgYSBjb21wbGV4IHBhcnQuXG5cblxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29tcGxleCArPSB0b2tlbnNbaV0udmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXN0UmVsVG9rZW5JbmQgPT09IC0xID8gbmV3IFRyYWl0TGVzc1NlbGVjdG9yKHNlbGVjdG9yVGV4dCwgZGVidWcpIDogbmV3IFNwbGl0dGVkU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBzaW1wbGUsIHJlbGF0aW9uLCBjb21wbGV4LCBkZWJ1Zyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gQW4gaW5kZXggb2YgYSB0b2tlbiB0aGF0IGlzIHNwbGl0IHBvaW50LlxuICAgICAqIHJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBzZWxlY3RvciBkb2VzIG5vdCBjb250YWluIGFueSBjb21wbGV4IHRva2Vuc1xuICAgICAqIG9yIGl0IGlzIG5vdCBlbGlnaWJsZSBmb3Igc3BsaXR0aW5nLlxuICAgICAqIE90aGVyd2lzZSByZXR1cm5zIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgcmVsYXRpb24gdG9rZW4uXG4gICAgICovXG4gICAgZ2V0U3BsaXRQb2ludDogZnVuY3Rpb24gZ2V0U3BsaXRQb2ludCgpIHtcbiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2Vuc1swXTsgLy8gV2Ugc3BsaXQgc2VsZWN0b3Igb25seSB3aGVuIHRoZSBsYXN0IGNvbXBvdW5kIHNlbGVjdG9yXG4gICAgICAvLyBpcyB0aGUgb25seSBleHRlbmRlZCBzZWxlY3Rvci5cblxuICAgICAgdmFyIGxhdGVzdFJlbGF0aW9uVG9rZW5JbmRleCA9IC0xO1xuICAgICAgdmFyIGhhdmVNZXRDb21wbGV4VG9rZW4gPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAoaXNSZWxhdGlvblRva2VuKHRva2VuKSkge1xuICAgICAgICAgIGlmIChoYXZlTWV0Q29tcGxleFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGF0ZXN0UmVsYXRpb25Ub2tlbkluZGV4ID0gaTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNTaW1wbGVUb2tlbih0b2tlbikpIHtcbiAgICAgICAgICBoYXZlTWV0Q29tcGxleFRva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhdmVNZXRDb21wbGV4VG9rZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGF0ZXN0UmVsYXRpb25Ub2tlbkluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IHhwYXRoIHNlbGVjdG9yIHBhcnQgaWYgZXhpc3RzXG4gICAgICogcmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIHNlbGVjdG9yIGRvZXMgbm90IGNvbnRhaW4geHBhdGggdG9rZW5zXG4gICAgICovXG4gICAgZ2V0WHBhdGhQYXJ0OiBmdW5jdGlvbiBnZXRYcGF0aFBhcnQoKSB7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnNbMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoOyBpIDwgdG9rZW5zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnUFNFVURPJykge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gdG9rZW4ubWF0Y2hlcztcblxuICAgICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNbMF0gPT09ICd4cGF0aCcpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMYXN0VG9rZW4odG9rZW5zLCBpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwc2V1ZG86IFxcJzp4cGF0aFxcJyBzaG91bGQgYmUgYXQgdGhlIGVuZCBvZiB0aGUgc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlc1swXSA9PT0gJ250aC1hbmNlc3RvcicpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMYXN0VG9rZW4odG9rZW5zLCBpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwc2V1ZG86IFxcJzpudGgtYW5jZXN0b3JcXCcgc2hvdWxkIGJlIGF0IHRoZSBlbmQgb2YgdGhlIHNlbGVjdG9yJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZGVlcCA9IG1hdGNoZXNbMV07XG5cbiAgICAgICAgICAgICAgaWYgKGRlZXAgPiAwICYmIGRlZXAgPCAyNTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0TnRoQW5jZXN0b3JUb2tlbihkZWVwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBudGgtYW5jZXN0b3IvdXB3YXJkIGRlZXAgdmFsdWUgdG8geHBhdGggZXF1aXZhbGVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWVwXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvbnZlcnROdGhBbmNlc3RvclRva2VuOiBmdW5jdGlvbiBjb252ZXJ0TnRoQW5jZXN0b3JUb2tlbihkZWVwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJy4uJztcblxuICAgICAgd2hpbGUgKGRlZXAgPiAxKSB7XG4gICAgICAgIHJlc3VsdCArPSAnLy4uJztcbiAgICAgICAgZGVlcC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHRva2VuIGlzIGxhc3QsXG4gICAgICogZXhjZXB0IG9mIHJlbW92ZSBwc2V1ZG8tY2xhc3NcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSBpbmRleCBvZiB0b2tlblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTGFzdFRva2VuOiBmdW5jdGlvbiBpc0xhc3RUb2tlbih0b2tlbnMsIGkpIHtcbiAgICAgIC8vIGNoZWNrIGlkIHRoZSBuZXh0IHBhcnNlZCB0b2tlbiBpcyByZW1vdmUgcHNldWRvXG4gICAgICB2YXIgaXNOZXh0UmVtb3ZlVG9rZW4gPSB0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ1BTRVVETycgJiYgdG9rZW5zW2kgKyAxXS5tYXRjaGVzICYmIHRva2Vuc1tpICsgMV0ubWF0Y2hlc1swXSA9PT0gJ3JlbW92ZSc7IC8vIGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBsYXN0XG4gICAgICAvLyBhbmQgaWYgaXQgaXMgbm90IGNoZWNrIGlmIGl0IGlzIHJlbW92ZSBvbmVcbiAgICAgIC8vIHdoaWNoIHNob3VsZCBiZSBza2lwcGVkXG5cbiAgICAgIHJldHVybiBpICsgMSAhPT0gdG9rZW5zLmxlbmd0aCAmJiAhaXNOZXh0UmVtb3ZlVG9rZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gdXB3YXJkIHBhcmFtZXRlclxuICAgICAqIG9yIHVuZGVmaW5lZCBpZiB0aGUgaW5wdXQgZG9lcyBub3QgY29udGFpbiB1cHdhcmQgdG9rZW5zXG4gICAgICovXG4gICAgZ2V0VXB3YXJkUGFydDogZnVuY3Rpb24gZ2V0VXB3YXJkUGFydCgpIHtcbiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2Vuc1swXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHRva2Vuc0xlbmd0aCA9IHRva2Vucy5sZW5ndGg7IGkgPCB0b2tlbnNMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdQU0VVRE8nKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSB0b2tlbi5tYXRjaGVzO1xuXG4gICAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlc1swXSA9PT0gJ3Vwd2FyZCcpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMYXN0VG9rZW4odG9rZW5zLCBpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwc2V1ZG86IFxcJzp1cHdhcmRcXCcgc2hvdWxkIGJlIGF0IHRoZSBlbmQgb2YgdGhlIHNlbGVjdG9yJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogb3IgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCBkb2VzIG5vdCBjb250YWluIHJlbW92ZSB0b2tlbnNcbiAgICAgKi9cbiAgICBnZXRSZW1vdmVQYXJ0OiBmdW5jdGlvbiBnZXRSZW1vdmVQYXJ0KCkge1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgdG9rZW5zTGVuZ3RoID0gdG9rZW5zLmxlbmd0aDsgaSA8IHRva2Vuc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ1BTRVVETycpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRva2VuLm1hdGNoZXM7XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzWzBdID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgICBpZiAoaSArIDEgIT09IHRva2Vuc0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwc2V1ZG86IFxcJzpyZW1vdmVcXCcgc2hvdWxkIGJlIGF0IHRoZSBlbmQgb2YgdGhlIHNlbGVjdG9yJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBnbG9iYWxEZWJ1Z2dpbmdGbGFnID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gaXNEZWJ1Z2dpbmcoKSB7XG4gICAgcmV0dXJuIGdsb2JhbERlYnVnZ2luZ0ZsYWcgfHwgdGhpcy5kZWJ1ZztcbiAgfVxuICAvKipcbiAgICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2VsZWN0b3Igd2hpY2ggaXMgbm90IGFuIGV4dGVuZGVkIHNlbGVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JUZXh0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlYnVnXG4gICAqIEBmaW5hbFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIE5vdEFuRXh0ZW5kZWRTZWxlY3RvcihzZWxlY3RvclRleHQsIGRlYnVnKSB7XG4gICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICB9XG5cbiAgTm90QW5FeHRlbmRlZFNlbGVjdG9yLnByb3RvdHlwZSA9IHtcbiAgICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3RvclRleHQpO1xuICAgIH0sXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudFt1dGlscy5tYXRjaGVzUHJvcGVydHlOYW1lXSh0aGlzLnNlbGVjdG9yVGV4dCk7XG4gICAgfSxcbiAgICBpc0RlYnVnZ2luZzogaXNEZWJ1Z2dpbmdcbiAgfTtcbiAgLyoqXG4gICAqIEEgdHJhaXQtbGVzcyBleHRlbmRlZCBzZWxlY3RvciBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yVGV4dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWJ1Z1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gVHJhaXRMZXNzU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBkZWJ1Zykge1xuICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0O1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcbiAgICBTaXp6bGUuY29tcGlsZShzZWxlY3RvclRleHQpO1xuICB9XG5cbiAgVHJhaXRMZXNzU2VsZWN0b3IucHJvdG90eXBlID0ge1xuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwoKSB7XG4gICAgICByZXR1cm4gU2l6emxlKHRoaXMuc2VsZWN0b3JUZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqIEBmaW5hbCAqL1xuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IoZWxlbWVudCwgdGhpcy5zZWxlY3RvclRleHQpO1xuICAgIH0sXG5cbiAgICAvKiogQGZpbmFsICovXG4gICAgaXNEZWJ1Z2dpbmc6IGlzRGVidWdnaW5nXG4gIH07XG4gIC8qKlxuICAgKiBQYXJlbnRhbCBjbGFzcyBmb3Igc3VjaCBwc2V1ZG8tY2xhc3NlcyBhcyB4cGF0aCwgdXB3YXJkLCByZW1vdmVcbiAgICogd2hpY2ggYXJlIGxpbWl0ZWQgdG8gYmUgdGhlIGxhc3Qgb25lIHRva2VuIGluIHNlbGVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBzZXVkb0NsYXNzQXJnIHBzZXVkby1jbGFzcyBhcmdcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZGVidWdcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEJhc2VMYXN0QXJndW1lbnRTZWxlY3RvcihzZWxlY3RvclRleHQsIHBzZXVkb0NsYXNzQXJnLCBkZWJ1Zykge1xuICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0O1xuICAgIHRoaXMucHNldWRvQ2xhc3NBcmcgPSBwc2V1ZG9DbGFzc0FyZztcbiAgICB0aGlzLmRlYnVnID0gZGVidWc7XG4gICAgU2l6emxlLmNvbXBpbGUodGhpcy5zZWxlY3RvclRleHQpO1xuICB9XG5cbiAgQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yLnByb3RvdHlwZSA9IHtcbiAgICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJlc3VsdE5vZGVzID0gW107XG4gICAgICB2YXIgc2ltcGxlTm9kZXM7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdG9yVGV4dCkge1xuICAgICAgICBzaW1wbGVOb2RlcyA9IFNpenpsZSh0aGlzLnNlbGVjdG9yVGV4dCk7XG5cbiAgICAgICAgaWYgKCFzaW1wbGVOb2RlcyB8fCAhc2ltcGxlTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdE5vZGVzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW1wbGVOb2RlcyA9IFtkb2N1bWVudF07XG4gICAgICB9XG5cbiAgICAgIHNpbXBsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoUmVzdWx0Tm9kZXMobm9kZSwgX3RoaXMucHNldWRvQ2xhc3NBcmcsIHJlc3VsdE5vZGVzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdE5vZGVzKTtcbiAgICB9LFxuXG4gICAgLyoqIEBmaW5hbCAqL1xuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCkge1xuICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoKTtcbiAgICAgIHJldHVybiByZXN1bHRzLmluZGV4T2YoZWxlbWVudCkgPiAtMTtcbiAgICB9LFxuXG4gICAgLyoqIEBmaW5hbCAqL1xuICAgIGlzRGVidWdnaW5nOiBpc0RlYnVnZ2luZyxcblxuICAgIC8qKlxuICAgICAqIFByaW1pdGl2ZSBtZXRob2QgdGhhdCByZXR1cm5zIGFsbCBub2RlcyBpZiBwc2V1ZG8tY2xhc3MgYXJnIGlzIGRlZmluZWQuXG4gICAgICogVGhhdCBsb2dpYyB3b3JrcyBmb3IgcmVtb3ZlIHBzZXVkby1jbGFzcyxcbiAgICAgKiBidXQgZm9yIG90aGVycyBpdCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBjb250ZXh0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHNldWRvQ2xhc3NBcmcgcHNldWRvLWNsYXNzIGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gcmVzdWx0XG4gICAgICovXG4gICAgc2VhcmNoUmVzdWx0Tm9kZXM6IGZ1bmN0aW9uIHNlYXJjaFJlc3VsdE5vZGVzKG5vZGUsIHBzZXVkb0NsYXNzQXJnLCByZXN1bHQpIHtcbiAgICAgIGlmIChwc2V1ZG9DbGFzc0FyZykge1xuICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBYcGF0aCBzZWxlY3RvciBjbGFzc1xuICAgKiBMaW1pdGVkIHRvIHN1cHBvcnQgJ3hwYXRoJyB0byBiZSBvbmx5IHRoZSBsYXN0IG9uZSB0b2tlbiBpbiBzZWxlY3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB4cGF0aCB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWJ1Z1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGF1Z21lbnRzIEJhc2VMYXN0QXJndW1lbnRTZWxlY3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBYcGF0aFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgeHBhdGgsIGRlYnVnKSB7XG4gICAgdmFyIE5PX1NFTEVDVE9SX01BUktFUiA9ICc6eHBhdGgoLy8nO1xuICAgIHZhciBCT0RZX1NFTEVDVE9SX1JFUExBQ0VSID0gJ2JvZHk6eHBhdGgoLy8nO1xuICAgIHZhciBtb2RpZmllZFNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDsgLy8gTm9ybWFsbHksIGEgcHNldWRvLWNsYXNzIGlzIGFwcGxpZWQgdG8gbm9kZXMgc2VsZWN0ZWQgYnkgYSBzZWxlY3RvciAtLSBzZWxlY3Rvcjp4cGF0aCguLi4pLlxuICAgIC8vIEhvd2V2ZXIsIDp4cGF0aCBpcyBzcGVjaWFsIGFzIHRoZSBzZWxlY3RvciBjYW4gYmUgb21taXRlZC5cbiAgICAvLyBGb3IgYW55IG90aGVyIHBzZXVkby1jbGFzcyB0aGF0IHdvdWxkIG1lYW4gXCJhcHBseSB0byBBTEwgRE9NIG5vZGVzXCIsXG4gICAgLy8gYnV0IGluIGNhc2Ugb2YgOnhwYXRoIGl0IGp1c3QgbWVhbnMgXCJhcHBseSBtZSB0byB0aGUgZG9jdW1lbnRcIi5cblxuICAgIGlmICh1dGlscy5zdGFydHNXaXRoKHNlbGVjdG9yVGV4dCwgTk9fU0VMRUNUT1JfTUFSS0VSKSkge1xuICAgICAgbW9kaWZpZWRTZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQucmVwbGFjZShOT19TRUxFQ1RPUl9NQVJLRVIsIEJPRFlfU0VMRUNUT1JfUkVQTEFDRVIpO1xuICAgIH1cblxuICAgIEJhc2VMYXN0QXJndW1lbnRTZWxlY3Rvci5jYWxsKHRoaXMsIG1vZGlmaWVkU2VsZWN0b3JUZXh0LCB4cGF0aCwgZGVidWcpO1xuICB9XG5cbiAgWHBhdGhTZWxlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VMYXN0QXJndW1lbnRTZWxlY3Rvci5wcm90b3R5cGUpO1xuICBYcGF0aFNlbGVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFhwYXRoU2VsZWN0b3I7XG4gIC8qKlxuICAgKiBBcHBsaWVzIHhwYXRoIHBzZXVkby1jbGFzcyB0byBwcm92aWRlZCBjb250ZXh0IG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgY29udGV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwc2V1ZG9DbGFzc0FyZyB4cGF0aFxuICAgKiBAcGFyYW0ge0FycmF5fSByZXN1bHRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG4gIFhwYXRoU2VsZWN0b3IucHJvdG90eXBlLnNlYXJjaFJlc3VsdE5vZGVzID0gZnVuY3Rpb24gKG5vZGUsIHBzZXVkb0NsYXNzQXJnLCByZXN1bHQpIHtcbiAgICB2YXIgeHBhdGhSZXN1bHQgPSBkb2N1bWVudC5ldmFsdWF0ZShwc2V1ZG9DbGFzc0FyZywgbm9kZSwgbnVsbCwgWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRSwgbnVsbCk7XG4gICAgdmFyIGlOb2RlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cblxuICAgIHdoaWxlIChpTm9kZSA9IHhwYXRoUmVzdWx0Lml0ZXJhdGVOZXh0KCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGlOb2RlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBVcHdhcmQgc2VsZWN0b3IgY2xhc3NcbiAgICogTGltaXRlZCB0byBzdXBwb3J0ICd1cHdhcmQnIHRvIGJlIG9ubHkgdGhlIGxhc3Qgb25lIHRva2VuIGluIHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVwd2FyZFNlbGVjdG9yIHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlYnVnXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAYXVnbWVudHMgQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gVXB3YXJkU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCB1cHdhcmRTZWxlY3RvciwgZGVidWcpIHtcbiAgICBCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3IuY2FsbCh0aGlzLCBzZWxlY3RvclRleHQsIHVwd2FyZFNlbGVjdG9yLCBkZWJ1Zyk7XG4gIH1cblxuICBVcHdhcmRTZWxlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VMYXN0QXJndW1lbnRTZWxlY3Rvci5wcm90b3R5cGUpO1xuICBVcHdhcmRTZWxlY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVcHdhcmRTZWxlY3RvcjtcbiAgLyoqXG4gICAqIEFwcGxpZXMgdXB3YXJkIHBzZXVkby1jbGFzcyB0byBwcm92aWRlZCBjb250ZXh0IG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgY29udGV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cHdhcmRTZWxlY3RvciB1cHdhcmQgc2VsZWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzdWx0XG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuICBVcHdhcmRTZWxlY3Rvci5wcm90b3R5cGUuc2VhcmNoUmVzdWx0Tm9kZXMgPSBmdW5jdGlvbiAobm9kZSwgdXB3YXJkU2VsZWN0b3IsIHJlc3VsdCkge1xuICAgIGlmICh1cHdhcmRTZWxlY3RvciAhPT0gJycpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gcGFyZW50LmNsb3Nlc3QodXB3YXJkU2VsZWN0b3IpO1xuXG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZWN0b3IgY2xhc3NcbiAgICogTGltaXRlZCB0byBzdXBwb3J0ICdyZW1vdmUnIHRvIGJlIG9ubHkgdGhlIGxhc3Qgb25lIHRva2VuIGluIHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclRleHRcbiAgICogQHBhcmFtIHtib29sZWFufSBoYXNWYWxpZFJlbW92ZVBhcnRcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZGVidWdcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhdWdtZW50cyBCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3JcbiAgICovXG5cblxuICBmdW5jdGlvbiBSZW1vdmVTZWxlY3RvcihzZWxlY3RvclRleHQsIGhhc1ZhbGlkUmVtb3ZlUGFydCwgZGVidWcpIHtcbiAgICB2YXIgUkVNT1ZFX1BTRVVET19NQVJLRVIgPSAnOnJlbW92ZSgpJztcbiAgICB2YXIgcmVtb3ZlTWFya2VySW5kZXggPSBzZWxlY3RvclRleHQuaW5kZXhPZihSRU1PVkVfUFNFVURPX01BUktFUik7IC8vIGRlbGV0aW5nIHJlbW92ZSBwYXJ0IG9mIHJ1bGUgaW5zdGVhZCBvZiB3aGljaFxuICAgIC8vIHBzZXVkby1wcm9wZXJ0eSBwcm9wZXJ0eSAncmVtb3ZlJyB3aWxsIGJlIGFkZGVkIGJ5IEV4dGVuZGVkQ3NzUGFyc2VyXG5cbiAgICB2YXIgbW9kaWZpZWRTZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQuc2xpY2UoMCwgcmVtb3ZlTWFya2VySW5kZXgpO1xuICAgIEJhc2VMYXN0QXJndW1lbnRTZWxlY3Rvci5jYWxsKHRoaXMsIG1vZGlmaWVkU2VsZWN0b3JUZXh0LCBoYXNWYWxpZFJlbW92ZVBhcnQsIGRlYnVnKTsgLy8gbWFyayBleHRlbmRlZFNlbGVjdG9yIGFzIFJlbW92ZSBvbmUgZm9yIEV4dGVuZGVkQ3NzUGFyc2VyXG5cbiAgICB0aGlzLmlzUmVtb3ZlU2VsZWN0b3IgPSB0cnVlO1xuICB9XG5cbiAgUmVtb3ZlU2VsZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3IucHJvdG90eXBlKTtcbiAgUmVtb3ZlU2VsZWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVtb3ZlU2VsZWN0b3I7XG4gIC8qKlxuICAgKiBBIHNwbGl0dGVkIGV4dGVuZGVkIHNlbGVjdG9yIGNsYXNzLlxuICAgKlxuICAgKiAjY29udGFpbmVyICNmZWVkSXRlbTpoYXMoLmFkcylcbiAgICogKy0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgIHNpbXBsZVxuICAgKiAgICAgICAgICAgKyAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25cbiAgICogICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0rIGNvbXBsZXhcbiAgICogV2Ugc3BsaXQgc2VsZWN0b3Igb25seSB3aGVuIHRoZSBsYXN0IHNlbGVjdG9yIGlzIGNvbXBsZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yVGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2ltcGxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcGxleFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWJ1Z1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMgVHJhaXRMZXNzU2VsZWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gU3BsaXR0ZWRTZWxlY3RvcihzZWxlY3RvclRleHQsIHNpbXBsZSwgcmVsYXRpb24sIGNvbXBsZXgsIGRlYnVnKSB7XG4gICAgVHJhaXRMZXNzU2VsZWN0b3IuY2FsbCh0aGlzLCBzZWxlY3RvclRleHQsIGRlYnVnKTtcbiAgICB0aGlzLnNpbXBsZSA9IHNpbXBsZTtcbiAgICB0aGlzLnJlbGF0aW9uID0gcmVsYXRpb247XG4gICAgdGhpcy5jb21wbGV4ID0gY29tcGxleDtcbiAgICBTaXp6bGUuY29tcGlsZShjb21wbGV4KTtcbiAgfVxuXG4gIFNwbGl0dGVkU2VsZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFpdExlc3NTZWxlY3Rvci5wcm90b3R5cGUpO1xuICBTcGxpdHRlZFNlbGVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwbGl0dGVkU2VsZWN0b3I7XG4gIC8qKiBAb3ZlcnJpZGUgKi9cblxuICBTcGxpdHRlZFNlbGVjdG9yLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHJlc3VsdE5vZGVzID0gW107XG4gICAgdmFyIHNpbXBsZU5vZGVzO1xuICAgIHZhciBzaW1wbGUgPSB0aGlzLnNpbXBsZTtcbiAgICB2YXIgcmVsYXRpb247XG5cbiAgICBpZiAoc2ltcGxlKSB7XG4gICAgICAvLyBGaXJzdCB3ZSB1c2Ugc2ltcGxlIHNlbGVjdG9yIHRvIG5hcnJvdyBvdXIgc2VhcmNoXG4gICAgICBzaW1wbGVOb2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2ltcGxlKTtcblxuICAgICAgaWYgKCFzaW1wbGVOb2RlcyB8fCAhc2ltcGxlTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHROb2RlcztcbiAgICAgIH1cblxuICAgICAgcmVsYXRpb24gPSB0aGlzLnJlbGF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaW1wbGVOb2RlcyA9IFtkb2N1bWVudF07XG4gICAgICByZWxhdGlvbiA9ICcgJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHJlbGF0aW9uKSB7XG4gICAgICBjYXNlICcgJzpcbiAgICAgICAgc2ltcGxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIF90aGlzMi5yZWxhdGl2ZVNlYXJjaChub2RlLCByZXN1bHROb2Rlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPic6XG4gICAgICAgIHtcbiAgICAgICAgICBzaW1wbGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKG5vZGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLm1hdGNoZXMoY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdE5vZGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnKyc6XG4gICAgICAgIHtcbiAgICAgICAgICBzaW1wbGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMocGFyZW50Tm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIubWF0Y2hlcyhjaGlsZE5vZGUpICYmIGNoaWxkTm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Tm9kZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICd+JzpcbiAgICAgICAge1xuICAgICAgICAgIHNpbXBsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhwYXJlbnROb2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzMi5tYXRjaGVzKGNoaWxkTm9kZSkgJiYgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihjaGlsZE5vZGUpID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Tm9kZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBTaXp6bGUudW5pcXVlU29ydChyZXN1bHROb2Rlcyk7XG4gIH07XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIHNlYXJjaCBvZiBcImNvbXBsZXhcIiBwYXJ0IHJlbGF0aXZlIHRvIHJlc3VsdHMgZm9yIHRoZSBcInNpbXBsZVwiIHBhcnQuXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBhIG5vZGUgbWF0Y2hpbmcgdGhlIFwic2ltcGxlXCIgcGFydC5cbiAgICogQHBhcmFtIHtOb2RlW119IHJlc3VsdCBhbiBhcnJheSB0byBhcHBlbmQgc2VhcmNoIHJlc3VsdC5cbiAgICovXG5cblxuICBTcGxpdHRlZFNlbGVjdG9yLnByb3RvdHlwZS5yZWxhdGl2ZVNlYXJjaCA9IGZ1bmN0aW9uIChub2RlLCByZXN1bHRzKSB7XG4gICAgU2l6emxlKHRoaXMuY29tcGxleCwgbm9kZSwgcmVzdWx0cyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBXcmFwcyB0aGUgaW5uZXIgY2xhc3Mgc28gdGhhdCB0aGUgaW5zdGFuY2UgaXMgbm90IGV4cG9zZWQuXG4gICAgICovXG4gICAgY3JlYXRlU2VsZWN0b3I6IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yKHNlbGVjdG9yLCB0b2tlbnMsIGRlYnVnKSB7XG4gICAgICByZXR1cm4gbmV3IEV4dGVuZGVkU2VsZWN0b3JQYXJzZXIoc2VsZWN0b3IsIHRva2VucywgZGVidWcpLmNyZWF0ZVNlbGVjdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hcmsgZXZlcnkgc2VsZWN0b3IgYXMgYSBzZWxlY3RvciBiZWluZyBkZWJ1Z2dlZCwgc28gdGhhdCB0aW1pbmcgaW5mb3JtYXRpb25cbiAgICAgKiBmb3IgdGhlIHNlbGVjdG9yIGlzIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUuXG4gICAgICovXG4gICAgZW5hYmxlR2xvYmFsRGVidWdnaW5nOiBmdW5jdGlvbiBlbmFibGVHbG9iYWxEZWJ1Z2dpbmcoKSB7XG4gICAgICBnbG9iYWxEZWJ1Z2dpbmdGbGFnID0gdHJ1ZTtcbiAgICB9XG4gIH07XG59KCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgQWRndWFyZCBTb2Z0d2FyZSBMdGRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0aGF0IHBhcnNlcyBzdHlsZXNoZWV0cyBjb250YWluaW5nIGV4dGVuZGVkIHNlbGVjdG9yc1xuICogaW50byBFeHRlbmRlZFNlbGVjdG9yIGluc3RhbmNlcyBhbmQga2V5LXZhbHVlIG1hcHMgb2Ygc3R5bGUgZGVjbGFyYXRpb25zLlxuICogUGxlYXNlIG5vdGUsIHRoYXQgaXQgZG9lcyBub3Qgc3VwcG9ydCBhbnkgY29tcGxleCB0aGluZ3MgbGlrZSBtZWRpYSBxdWVyaWVzIGFuZCBzdWNoLlxuICovXG5cbnZhciBFeHRlbmRlZENzc1BhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlRGVjbEVuZCA9IC9bO31dL2c7XG4gIHZhciByZURlY2xEaXZpZGVyID0gL1s7On1dL2c7XG4gIHZhciByZU5vbldoaXRlc3BhY2UgPSAvXFxTL2c7XG4gIHZhciBTaXp6bGU7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gUGFyc2VyKGNzc1RleHQpIHtcbiAgICB0aGlzLmNzc1RleHQgPSBjc3NUZXh0O1xuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IocG9zaXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNzc1BhcnNlcjogcGFyc2UgZXJyb3IgYXQgcG9zaXRpb24gXCIuY29uY2F0KHRoaXMucG9zT2Zmc2V0ICsgcG9zaXRpb24pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHRva2VucyBjb3JyZXNwb25kIHRvIGEgdmFsaWQgc2VsZWN0b3IuXG4gICAgICogU2l6emxlIGlzIGRpZmZlcmVudCBmcm9tIGJyb3dzZXJzIGFuZCBzb21lIHNlbGVjdG9ycyB0aGF0IGl0IHRvbGVyYXRlcyBhcmVuJ3QgYWN0dWFsbHkgdmFsaWQuXG4gICAgICogRm9yIGluc3RhbmNlLCBcImRpdiA+XCIgd29uJ3Qgd29yayBpbiBhIGJyb3dzZXIsIGJ1dCBpdCB3aWxsIGluIFNpenpsZSAoaXQnZCBiZSB0aGUgc2FtZSBhcyBcImRpdiA+ICpcIikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHNlbGVjdG9ycyBBbiBhcnJheSBvZiBTZWxlY3RvckRhdGEgKHNlbGVjdG9yLCBncm91cHMpXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgZ3JvdXBzIGFyZSBpbnZhbGlkXG4gICAgICovXG4gICAgdmFsaWRhdGVTZWxlY3RvcnM6IGZ1bmN0aW9uIHZhbGlkYXRlU2VsZWN0b3JzKHNlbGVjdG9ycykge1xuICAgICAgdmFyIGlTZWxlY3RvcnMgPSBzZWxlY3RvcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaVNlbGVjdG9ycy0tKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBzZWxlY3RvcnNbaVNlbGVjdG9yc10uZ3JvdXBzO1xuICAgICAgICB2YXIgaUdyb3VwcyA9IGdyb3Vwcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGlHcm91cHMtLSkge1xuICAgICAgICAgIHZhciB0b2tlbnMgPSBncm91cHNbaUdyb3Vwc107XG4gICAgICAgICAgdmFyIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAoU2l6emxlLnNlbGVjdG9ycy5yZWxhdGl2ZVtsYXN0VG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHN0eWxlc2hlZXQgYW5kIHJldHVybnMgYSBsaXN0IG9mIHBhaXJzIG9mIGFuIEV4dGVuZGVkU2VsZWN0b3IgYW5kIGEgc3R5bGVzIG1hcC5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHRocm93IGFuIGVycm9yIGluIGNhc2Ugb2YgYW4gb2J2aW91c2x5IGludmFsaWQgaW5wdXQuXG4gICAgICogSWYgYW55IG9mIHRoZSBzZWxlY3RvcnMgdXNlZCBpbiB0aGUgc3R5bGVzaGVldCBjYW5ub3QgYmUgY29tcGlsZWQgaW50byBhbiBFeHRlbmRlZFNlbGVjdG9yLFxuICAgICAqIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IEV4dGVuZGVkU3R5bGVcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc2VsZWN0b3IgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFeHRlbmRlZFNlbGVjdG9yfSBjbGFzc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzdHlsZU1hcCBBIG1hcCBvZiBzdHlsZXMgcGFyc2VkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEV4dGVuZGVkU3R5bGU+fSBBbiBhcnJheSBvZiB0aGUgc3R5bGVzIHBhcnNlZFxuICAgICAqL1xuICAgIHBhcnNlQ3NzOiBmdW5jdGlvbiBwYXJzZUNzcygpIHtcbiAgICAgIHRoaXMucG9zT2Zmc2V0ID0gMDtcblxuICAgICAgaWYgKCF0aGlzLmNzc1RleHQpIHtcbiAgICAgICAgdGhpcy5lcnJvcigwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgd2hpbGUgKHRoaXMuY3NzVGV4dCkge1xuICAgICAgICAvLyBBcHBseSB0b2xlcmFudCB0b2tlbml6YXRpb24uXG4gICAgICAgIHZhciBwYXJzZVJlc3VsdCA9IFNpenpsZS50b2tlbml6ZSh0aGlzLmNzc1RleHQsIGZhbHNlLCB7XG4gICAgICAgICAgdG9sZXJhbnQ6IHRydWUsXG4gICAgICAgICAgcmV0dXJuVW5zb3J0ZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZWxlY3RvckRhdGEgPSBwYXJzZVJlc3VsdC5zZWxlY3RvcnM7XG4gICAgICAgIHRoaXMubmV4dEluZGV4ID0gcGFyc2VSZXN1bHQubmV4dEluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLmNzc1RleHQuY2hhckNvZGVBdCh0aGlzLm5leHRJbmRleCkgIT09IDEyMyB8fFxuICAgICAgICAvKiBjaGFyQ29kZSBvZiAneycgKi9cbiAgICAgICAgIXRoaXMudmFsaWRhdGVTZWxlY3RvcnMoc2VsZWN0b3JEYXRhKSkge1xuICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5uZXh0SW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZXh0SW5kZXgrKzsgLy8gTW92ZSB0aGUgcG9pbnRlciB0byB0aGUgc3RhcnQgb2Ygc3R5bGUgZGVjbGFyYXRpb24uXG5cbiAgICAgICAgdmFyIHN0eWxlTWFwID0gdGhpcy5wYXJzZU5leHRTdHlsZSgpO1xuICAgICAgICB2YXIgZGVidWcgPSBmYWxzZTsgLy8gSWYgdGhlcmUgaXMgYSBzdHlsZSBwcm9wZXJ0eSAnZGVidWcnLCBtYXJrIHRoZSBzZWxlY3RvclxuICAgICAgICAvLyBhcyBhIGRlYnVnZ2FibGUgc2VsZWN0b3IsIGFuZCBkZWxldGUgdGhlIHN0eWxlIGRlY2xhcmF0aW9uLlxuXG4gICAgICAgIHZhciBkZWJ1Z1Byb3BlcnR5VmFsdWUgPSBzdHlsZU1hcFsnZGVidWcnXTtcblxuICAgICAgICBpZiAodHlwZW9mIGRlYnVnUHJvcGVydHlWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoZGVidWdQcm9wZXJ0eVZhbHVlID09PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgRXh0ZW5kZWRTZWxlY3RvckZhY3RvcnkuZW5hYmxlR2xvYmFsRGVidWdnaW5nKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVidWcgPSB0cnVlO1xuICAgICAgICAgIGRlbGV0ZSBzdHlsZU1hcFsnZGVidWcnXTtcbiAgICAgICAgfSAvLyBDcmVhdGluZyBhbiBFeHRlbmRlZFNlbGVjdG9yIGluc3RhbmNlIGZvciBldmVyeSBzZWxlY3RvciB3ZSBnb3QgZnJvbSBTaXp6bGUudG9rZW5pemUuXG4gICAgICAgIC8vIFRoaXMgaXMgcXVpdGUgaW1wb3J0YW50IGFzIFNpenpsZSBkb2VzIGEgcG9vciBqb2IgYXQgZXhlY3V0aW5nIHNlbGVjdG9ycyBsaWtlIFwic2VsZWN0b3IxLCBzZWxlY3RvcjJcIi5cblxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZWN0b3JEYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBkYXRhID0gc2VsZWN0b3JEYXRhW2ldO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBleHRlbmRlZFNlbGVjdG9yID0gRXh0ZW5kZWRTZWxlY3RvckZhY3RvcnkuY3JlYXRlU2VsZWN0b3IoZGF0YS5zZWxlY3RvclRleHQsIGRhdGEuZ3JvdXBzLCBkZWJ1Zyk7XG5cbiAgICAgICAgICAgIGlmIChleHRlbmRlZFNlbGVjdG9yLnBzZXVkb0NsYXNzQXJnICYmIGV4dGVuZGVkU2VsZWN0b3IuaXNSZW1vdmVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyByZW1vdmUgcHNldWRvLWNsYXNzIGluIHJ1bGUsXG4gICAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50IHdpbGwgYmUgcmVtb3ZlZCBhbmQgbm8gb3RoZXIgc3R5bGVzIHdpbGwgYmUgYXBwbGllZFxuICAgICAgICAgICAgICBzdHlsZU1hcFsncmVtb3ZlJ10gPSAndHJ1ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgIHNlbGVjdG9yOiBleHRlbmRlZFNlbGVjdG9yLFxuICAgICAgICAgICAgICBzdHlsZTogc3R5bGVNYXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB1dGlscy5sb2dFcnJvcihcIkV4dGVuZGVkQ3NzUGFyc2VyOiBpZ25vcmluZyBpbnZhbGlkIHNlbGVjdG9yIFwiLmNvbmNhdChkYXRhLnNlbGVjdG9yVGV4dCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuICAgIHBhcnNlTmV4dFN0eWxlOiBmdW5jdGlvbiBwYXJzZU5leHRTdHlsZSgpIHtcbiAgICAgIHZhciBzdHlsZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgYnJhY2tldFBvcyA9IHRoaXMucGFyc2VVbnRpbENsb3NpbmdCcmFja2V0KHN0eWxlTWFwKTsgLy8gQ3V0IG91dCBtYXRjaGVkIHBvcnRpb24gZnJvbSBjc3NUZXh0LlxuXG4gICAgICByZU5vbldoaXRlc3BhY2UubGFzdEluZGV4ID0gYnJhY2tldFBvcyArIDE7XG4gICAgICB2YXIgbWF0Y2ggPSByZU5vbldoaXRlc3BhY2UuZXhlYyh0aGlzLmNzc1RleHQpO1xuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jc3NUZXh0ID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZU1hcDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoUG9zID0gbWF0Y2guaW5kZXg7XG4gICAgICB0aGlzLmNzc1RleHQgPSB0aGlzLmNzc1RleHQuc2xpY2UobWF0Y2hQb3MpO1xuICAgICAgdGhpcy5wb3NPZmZzZXQgKz0gbWF0Y2hQb3M7XG4gICAgICByZXR1cm4gc3R5bGVNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYW4gaW5kZXggb2YgdGhlIG5leHQgJ30nIGluIGB0aGlzLmNzc1RleHRgLlxuICAgICAqL1xuICAgIHBhcnNlVW50aWxDbG9zaW5nQnJhY2tldDogZnVuY3Rpb24gcGFyc2VVbnRpbENsb3NpbmdCcmFja2V0KHN0eWxlTWFwKSB7XG4gICAgICAvLyBFeHBlY3RzIFwiOlwiLCBcIjtcIiwgYW5kIFwifVwiLlxuICAgICAgcmVEZWNsRGl2aWRlci5sYXN0SW5kZXggPSB0aGlzLm5leHRJbmRleDtcbiAgICAgIHZhciBtYXRjaCA9IHJlRGVjbERpdmlkZXIuZXhlYyh0aGlzLmNzc1RleHQpO1xuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lcnJvcih0aGlzLm5leHRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaFBvcyA9IG1hdGNoLmluZGV4O1xuICAgICAgdmFyIG1hdGNoZWQgPSBtYXRjaFswXTtcblxuICAgICAgaWYgKG1hdGNoZWQgPT09ICd9Jykge1xuICAgICAgICByZXR1cm4gbWF0Y2hQb3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaGVkID09PSAnOicpIHtcbiAgICAgICAgdmFyIGNvbG9uSW5kZXggPSBtYXRjaFBvczsgLy8gRXhwZWN0cyBcIjtcIiBhbmQgXCJ9XCIuXG5cbiAgICAgICAgcmVEZWNsRW5kLmxhc3RJbmRleCA9IGNvbG9uSW5kZXg7XG4gICAgICAgIG1hdGNoID0gcmVEZWNsRW5kLmV4ZWModGhpcy5jc3NUZXh0KTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKGNvbG9uSW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2hQb3MgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgbWF0Y2hlZCA9IG1hdGNoWzBdOyAvLyBQb3B1bGF0ZXMgdGhlIGBzdHlsZU1hcGAga2V5LXZhbHVlIG1hcC5cblxuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmNzc1RleHQuc2xpY2UodGhpcy5uZXh0SW5kZXgsIGNvbG9uSW5kZXgpLnRyaW0oKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5jc3NUZXh0LnNsaWNlKGNvbG9uSW5kZXggKyAxLCBtYXRjaFBvcykudHJpbSgpO1xuICAgICAgICBzdHlsZU1hcFtwcm9wZXJ0eV0gPSB2YWx1ZTsgLy8gSWYgZm91bmQgXCJ9XCIsIHJlLXJ1biB0aGUgb3V0ZXIgbG9vcC5cblxuICAgICAgICBpZiAobWF0Y2hlZCA9PT0gJ30nKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoUG9zO1xuICAgICAgICB9XG4gICAgICB9IC8vIG1hdGNoUG9zIGlzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCAnOycuXG4gICAgICAvLyBJbmNyZWFzZSAnbmV4dEluZGV4JyBhbmQgcmUtcnVuIHRoZSBsb29wLlxuXG5cbiAgICAgIHRoaXMubmV4dEluZGV4ID0gbWF0Y2hQb3MgKyAxO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbnRpbENsb3NpbmdCcmFja2V0KHN0eWxlTWFwKTsgLy8gU2hvdWxkIGJlIGEgc3ViamVjdCBvZiB0YWlsLWNhbGwgb3B0aW1pemF0aW9uLlxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZUNzczogZnVuY3Rpb24gcGFyc2VDc3MoY3NzVGV4dCkge1xuICAgICAgU2l6emxlID0gaW5pdGlhbGl6ZVNpenpsZSgpO1xuICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoY3NzVXRpbHMubm9ybWFsaXplKGNzc1RleHQpKS5wYXJzZUNzcygpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIGNhbGxiYWNrIGlzIHVzZWQgdG8gZ2V0IGFmZmVjdGVkIG5vZGUgZWxlbWVudHMgYW5kIGhhbmRsZSBzdHlsZSBwcm9wZXJ0aWVzXG4gKiBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGVtIGlmIGl0IGlzIG5lY2Vzc2FyeVxuICogQGNhbGxiYWNrIGJlZm9yZVN0eWxlQXBwbGllZFxuICogQHBhcmFtIHtvYmplY3R9IGFmZmVjdGVkRWxlbWVudCAtIE9iamVjdCBjb250YWluaW5nIERPTSBub2RlIGFuZCBydWxlIHRvIGJlIGFwcGxpZWRcbiAqIEByZXR1cm4ge29iamVjdH0gYWZmZWN0ZWRFbGVtZW50IC0gU2FtZSBvciBtb2RpZmllZCBvYmplY3QgY29udGFpbmluZyBET00gbm9kZSBhbmQgcnVsZSB0byBiZSBhcHBsaWVkXG4gKi9cblxuLyoqXG4gKiBFeHRlbmRlZCBjc3MgY2xhc3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZ3VyYXRpb24uc3R5bGVTaGVldCAtIHRoZSBDU1Mgc3R5bGVzaGVldCB0ZXh0XG4gKiBAcGFyYW0ge2JlZm9yZVN0eWxlQXBwbGllZH0gW2NvbmZpZ3VyYXRpb24uYmVmb3JlU3R5bGVBcHBsaWVkXSAtIHRoZSBjYWxsYmFjayB0aGF0IGhhbmRsZXMgYWZmZWN0ZWQgZWxlbWVudHNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIEV4dGVuZGVkQ3NzKGNvbmZpZ3VyYXRpb24pIHtcbiAgaWYgKCFjb25maWd1cmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25maWd1cmF0aW9uIGlzIG5vdCBwcm92aWRlZC4nKTtcbiAgfVxuXG4gIHZhciBzdHlsZVNoZWV0ID0gY29uZmlndXJhdGlvbi5zdHlsZVNoZWV0O1xuICB2YXIgYmVmb3JlU3R5bGVBcHBsaWVkID0gY29uZmlndXJhdGlvbi5iZWZvcmVTdHlsZUFwcGxpZWQ7XG5cbiAgaWYgKGJlZm9yZVN0eWxlQXBwbGllZCAmJiB0eXBlb2YgYmVmb3JlU3R5bGVBcHBsaWVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBjb25maWd1cmF0aW9uLiBUeXBlIG9mICdiZWZvcmVTdHlsZUFwcGxpZWQnIGZpZWxkIHNob3VsZCBiZSBhIGZ1bmN0aW9uLCByZWNlaXZlZDogXCIuY29uY2F0KF90eXBlb2YoYmVmb3JlU3R5bGVBcHBsaWVkKSkpO1xuICB9IC8vIFdlIHVzZSBFdmVudFRyYWNrZXIgdG8gdHJhY2sgdGhlIGV2ZW50IHRoYXQgaXMgbGlrZWx5IHRvIGNhdXNlIHRoZSBtdXRhdGlvbi5cbiAgLy8gVGhlIHByb2JsZW0gaXMgdGhhdCB3ZSBjYW5ub3QgdXNlIGB3aW5kb3cuZXZlbnRgIGRpcmVjdGx5IGZyb20gdGhlIG11dGF0aW9uIG9ic2VydmVyIGNhbGxcbiAgLy8gYXMgd2UncmUgbm90IGluIHRoZSBldmVudCBoYW5kbGVyIGNvbnRleHQgYW55bW9yZS5cblxuXG4gIHZhciBFdmVudFRyYWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlnbm9yZWRFdmVudFR5cGVzID0gWydtb3VzZW92ZXInLCAnbW91c2VsZWF2ZScsICdtb3VzZWVudGVyJywgJ21vdXNlb3V0J107XG4gICAgdmFyIExBU1RfRVZFTlRfVElNRU9VVF9NUyA9IDEwO1xuICAgIHZhciBFVkVOVFMgPSBbLy8ga2V5Ym9hcmQgZXZlbnRzXG4gICAgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAvLyBtb3VzZSBldmVudHNcbiAgICAnYXV4Y2xpY2snLCAnY2xpY2snLCAnY29udGV4dG1lbnUnLCAnZGJsY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZScsICdtb3VzZW1vdmUnLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAncG9pbnRlcmxvY2tjaGFuZ2UnLCAncG9pbnRlcmxvY2tlcnJvcicsICdzZWxlY3QnLCAnd2hlZWwnXTsgLy8gJ3doZWVsJyBldmVudCBtYWtlcyBzY3JvbGxpbmcgaW4gU2FmYXJpIHR3aXRjaHlcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vRXh0ZW5kZWRDc3MvaXNzdWVzLzEyMFxuXG4gICAgdmFyIHNhZmFyaVByb2JsZW1hdGljRXZlbnRzID0gWyd3aGVlbCddO1xuICAgIHZhciB0cmFja2VkRXZlbnRzID0gdXRpbHMuaXNTYWZhcmlCcm93c2VyID8gRVZFTlRTLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiAhKHNhZmFyaVByb2JsZW1hdGljRXZlbnRzLmluZGV4T2YoZWwpID4gLTEpO1xuICAgIH0pIDogRVZFTlRTO1xuICAgIHZhciBsYXN0RXZlbnRUeXBlO1xuICAgIHZhciBsYXN0RXZlbnRUaW1lO1xuXG4gICAgdmFyIHRyYWNrRXZlbnQgPSBmdW5jdGlvbiB0cmFja0V2ZW50KGUpIHtcbiAgICAgIGxhc3RFdmVudFR5cGUgPSBlLnR5cGU7XG4gICAgICBsYXN0RXZlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgdHJhY2tlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldk5hbWUpIHtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2TmFtZSwgdHJhY2tFdmVudCwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0TGFzdEV2ZW50VHlwZSA9IGZ1bmN0aW9uIGdldExhc3RFdmVudFR5cGUoKSB7XG4gICAgICByZXR1cm4gbGFzdEV2ZW50VHlwZTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFRpbWVTaW5jZUxhc3RFdmVudCA9IGZ1bmN0aW9uIGdldFRpbWVTaW5jZUxhc3RFdmVudCgpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbGFzdEV2ZW50VGltZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzSWdub3JlZEV2ZW50VHlwZTogZnVuY3Rpb24gaXNJZ25vcmVkRXZlbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gaWdub3JlZEV2ZW50VHlwZXMuaW5kZXhPZihnZXRMYXN0RXZlbnRUeXBlKCkpID4gLTEgJiYgZ2V0VGltZVNpbmNlTGFzdEV2ZW50KCkgPCBMQVNUX0VWRU5UX1RJTUVPVVRfTVM7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBydWxlcyA9IFtdO1xuICB2YXIgYWZmZWN0ZWRFbGVtZW50cyA9IFtdO1xuICB2YXIgcmVtb3ZhbHNTdGF0aXN0aWMgPSB7fTtcbiAgdmFyIGRvbU9ic2VydmVkO1xuICB2YXIgZXZlbnRMaXN0ZW5lclN1cHBvcnRlZCA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xuICB2YXIgZG9tTXV0YXRpb25PYnNlcnZlcjtcblxuICBmdW5jdGlvbiBvYnNlcnZlRG9jdW1lbnQoY2FsbGJhY2spIHtcbiAgICAvLyBXZSBhcmUgdHJ5aW5nIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgY2FsbGJhY2sgY2FsbHMgYnkgbm90IGNhbGxpbmcgaXQgb24gYWxsIGtpbmQgb2YgXCJob3ZlclwiIGV2ZW50cy5cbiAgICAvLyBUaGUgcmF0aW9uYWxlIGJlaGluZCB0aGlzIGlzIHRoYXQgXCJob3ZlclwiIGV2ZW50cyBvZnRlbiBjYXVzZSBhdHRyaWJ1dGVzIG1vZGlmaWNhdGlvbixcbiAgICAvLyBidXQgcmUtYXBwbHlpbmcgZXh0Q1NTIHJ1bGVzIHdpbGwgYmUgdXNlbGVzcyBhcyB0aGVzZSBhdHRyaWJ1dGUgY2hhbmdlcyBhcmUgdXN1YWxseSB0cmFuc2llbnQuXG4gICAgdmFyIGlzSWdub3JlZE11dGF0aW9uID0gZnVuY3Rpb24gaXNJZ25vcmVkTXV0YXRpb24obXV0YXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAobXV0YXRpb25zLnR5cGUgIT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgaWYgKHV0aWxzLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGRvbU11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgdXRpbHMuTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICAgIGlmICghbXV0YXRpb25zIHx8IG11dGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoRXZlbnRUcmFja2VyLmlzSWdub3JlZEV2ZW50VHlwZSgpICYmIGlzSWdub3JlZE11dGF0aW9uKG11dGF0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICBkb21NdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnaWQnLCAnY2xhc3MnXVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChldmVudExpc3RlbmVyU3VwcG9ydGVkKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWQnLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQXR0ck1vZGlmaWVkJywgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNjb25uZWN0RG9jdW1lbnQoY2FsbGJhY2spIHtcbiAgICBpZiAoZG9tTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgZG9tTXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSBlbHNlIGlmIChldmVudExpc3RlbmVyU3VwcG9ydGVkKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Ob2RlSW5zZXJ0ZWQnLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWQnLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQXR0ck1vZGlmaWVkJywgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTUFYX1NUWUxFX1BST1RFQ1RJT05fQ09VTlQgPSA1MDtcbiAgdmFyIHByb3RlY3Rpb25PYnNlcnZlck9wdGlvbiA9IHtcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZUZpbHRlcjogWydzdHlsZSddXG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIE11dGF0aW9uT2JzZXJ2ZXIgcHJvdGVjdGlvbiBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0gc3R5bGVzXG4gICAqIEByZXR1cm4ge3Byb3RlY3Rpb25GdW5jdGlvbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJvdGVjdGlvbkZ1bmN0aW9uKHN0eWxlcykge1xuICAgIGZ1bmN0aW9uIHByb3RlY3Rpb25GdW5jdGlvbihtdXRhdGlvbnMsIG9ic2VydmVyKSB7XG4gICAgICBpZiAoIW11dGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXV0YXRpb24gPSBtdXRhdGlvbnNbMF07XG4gICAgICB2YXIgdGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHNldFN0eWxlVG9FbGVtZW50KHRhcmdldCwgc3R5bGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICgrK29ic2VydmVyLnN0eWxlUHJvdGVjdGlvbkNvdW50IDwgTUFYX1NUWUxFX1BST1RFQ1RJT05fQ09VTlQpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHByb3RlY3Rpb25PYnNlcnZlck9wdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlscy5sb2dFcnJvcignRXh0ZW5kZWRDc3M6IGluZmluaXRlIGxvb3AgcHJvdGVjdGlvbiBmb3Igc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvdGVjdGlvbkZ1bmN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgTXV0YXRpb25PYnNlcnZlciB3aGljaCBwcm90ZWN0cyBzdHlsZSBhdHRyaWJ1dGVzIGZyb20gY2hhbmdlc1xuICAgKiBAcGFyYW0gbm9kZSBET00gbm9kZVxuICAgKiBAcGFyYW0gcnVsZXMgcnVsZXNcbiAgICogQHJldHVybnMgTXV0YXRpb24gb2JzZXJ2ZXIgdXNlZCB0byBwcm90ZWN0IGF0dHJpYnV0ZSBvciBudWxsIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBwcm90ZWN0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcHJvdGVjdFN0eWxlQXR0cmlidXRlKG5vZGUsIHJ1bGVzKSB7XG4gICAgaWYgKCF1dGlscy5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gcnVsZXMubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gci5zdHlsZTtcbiAgICB9KTtcbiAgICB2YXIgcHJvdGVjdGlvbk9ic2VydmVyID0gbmV3IHV0aWxzLk11dGF0aW9uT2JzZXJ2ZXIoY3JlYXRlUHJvdGVjdGlvbkZ1bmN0aW9uKHN0eWxlcykpO1xuICAgIHByb3RlY3Rpb25PYnNlcnZlci5vYnNlcnZlKG5vZGUsIHByb3RlY3Rpb25PYnNlcnZlck9wdGlvbik7IC8vIEFkZHMgYW4gZXhwYW5kbyB0byB0aGUgb2JzZXJ2ZXIgdG8ga2VlcCAnc3R5bGUgZml4IGNvdW50cycuXG5cbiAgICBwcm90ZWN0aW9uT2JzZXJ2ZXIuc3R5bGVQcm90ZWN0aW9uQ291bnQgPSAwO1xuICAgIHJldHVybiBwcm90ZWN0aW9uT2JzZXJ2ZXI7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVTdWZmaXgoc3RyLCBzdWZmaXgpIHtcbiAgICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICAvKipcbiAgICogRmluZHMgYWZmZWN0ZWRFbGVtZW50IG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBET00gbm9kZVxuICAgKiBAcGFyYW0gbm9kZSAgRE9NIG5vZGVcbiAgICogQHJldHVybnMgICAgIGFmZmVjdGVkRWxlbWVudCBmb3VuZCBvciBudWxsXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZmluZEFmZmVjdGVkRWxlbWVudChub2RlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZmZlY3RlZEVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoYWZmZWN0ZWRFbGVtZW50c1tpXS5ub2RlID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiBhZmZlY3RlZEVsZW1lbnRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChhZmZlY3RlZEVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZSA9IGFmZmVjdGVkRWxlbWVudC5ub2RlO1xuICAgIGFmZmVjdGVkRWxlbWVudC5yZW1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgZWxlbWVudFNlbGVjdG9yID0gdXRpbHMuZ2V0Tm9kZVNlbGVjdG9yKG5vZGUpOyAvLyBjaGVjayBpZiB0aGUgZWxlbWVudCBoYXMgYmVlbiBhbHJlYWR5IHJlbW92ZWQgZWFybGllclxuXG4gICAgdmFyIGVsZW1lbnRSZW1vdmFsc0NvdW50ZXIgPSByZW1vdmFsc1N0YXRpc3RpY1tlbGVtZW50U2VsZWN0b3JdIHx8IDA7IC8vIGlmIHJlbW92YWxzIGF0dGVtcHRzIGhhcHBlbmVkIG1vcmUgdGhhbiBzcGVjaWZpZWQgd2UgZG8gbm90IHRyeSB0byByZW1vdmUgbm9kZSBhZ2FpblxuXG4gICAgaWYgKGVsZW1lbnRSZW1vdmFsc0NvdW50ZXIgPiBNQVhfU1RZTEVfUFJPVEVDVElPTl9DT1VOVCkge1xuICAgICAgdXRpbHMubG9nRXJyb3IoJ0V4dGVuZGVkQ3NzOiBpbmZpbml0ZSBsb29wIHByb3RlY3Rpb24gZm9yIFNFTEVDVE9SJywgZWxlbWVudFNlbGVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICByZW1vdmFsc1N0YXRpc3RpY1tlbGVtZW50U2VsZWN0b3JdID0gZWxlbWVudFJlbW92YWxzQ291bnRlciArIDE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHN0eWxlIHRvIHRoZSBzcGVjaWZpZWQgRE9NIG5vZGVcbiAgICogQHBhcmFtIGFmZmVjdGVkRWxlbWVudCBPYmplY3QgY29udGFpbmluZyBET00gbm9kZSBhbmQgcnVsZSB0byBiZSBhcHBsaWVkXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXBwbHlTdHlsZShhZmZlY3RlZEVsZW1lbnQpIHtcbiAgICBpZiAoYWZmZWN0ZWRFbGVtZW50LnByb3RlY3Rpb25PYnNlcnZlcikge1xuICAgICAgLy8gU3R5bGUgaXMgYWxyZWFkeSBhcHBsaWVkIGFuZCBwcm90ZWN0ZWQgYnkgdGhlIG9ic2VydmVyXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZVN0eWxlQXBwbGllZCkge1xuICAgICAgYWZmZWN0ZWRFbGVtZW50ID0gYmVmb3JlU3R5bGVBcHBsaWVkKGFmZmVjdGVkRWxlbWVudCk7XG5cbiAgICAgIGlmICghYWZmZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2FmZmVjdGVkRWxlbWVudCA9IGFmZmVjdGVkRWxlbWVudCxcbiAgICAgICAgbm9kZSA9IF9hZmZlY3RlZEVsZW1lbnQubm9kZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWZmZWN0ZWRFbGVtZW50LnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3R5bGUgPSBhZmZlY3RlZEVsZW1lbnQucnVsZXNbaV0uc3R5bGU7XG5cbiAgICAgIGlmIChzdHlsZVsncmVtb3ZlJ10gPT09ICd0cnVlJykge1xuICAgICAgICByZW1vdmVFbGVtZW50KGFmZmVjdGVkRWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0U3R5bGVUb0VsZW1lbnQobm9kZSwgc3R5bGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0cyBzdHlsZSB0byB0aGUgc3BlY2lmaWVkIERPTSBub2RlXG4gICAqIEBwYXJhbSBub2RlIGVsZW1lbnRcbiAgICogQHBhcmFtIHN0eWxlIHN0eWxlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2V0U3R5bGVUb0VsZW1lbnQobm9kZSwgc3R5bGUpIHtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgLy8gQXBwbHkgdGhpcyBzdHlsZSBvbmx5IHRvIGV4aXN0aW5nIHByb3BlcnRpZXNcbiAgICAgIC8vIFdlIGNhbid0IHVzZSBoYXNPd25Qcm9wZXJ0eSBoZXJlIChkb2VzIG5vdCB3b3JrIGluIEZGKVxuICAgICAgaWYgKHR5cGVvZiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlW3Byb3BdOyAvLyBGaXJzdCB3ZSBzaG91bGQgcmVtb3ZlICFpbXBvcnRhbnQgYXR0cmlidXRlIChvciBpdCB3b24ndCBiZSBhcHBsaWVkJylcblxuICAgICAgICB2YWx1ZSA9IHJlbW92ZVN1ZmZpeCh2YWx1ZS50cmltKCksICchaW1wb3J0YW50JykudHJpbSgpO1xuICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlLCAnaW1wb3J0YW50Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldmVydHMgc3R5bGUgZm9yIHRoZSBhZmZlY3RlZCBvYmplY3RcbiAgICovXG5cblxuICBmdW5jdGlvbiByZXZlcnRTdHlsZShhZmZlY3RlZEVsZW1lbnQpIHtcbiAgICBpZiAoYWZmZWN0ZWRFbGVtZW50LnByb3RlY3Rpb25PYnNlcnZlcikge1xuICAgICAgYWZmZWN0ZWRFbGVtZW50LnByb3RlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgYWZmZWN0ZWRFbGVtZW50Lm5vZGUuc3R5bGUuY3NzVGV4dCA9IGFmZmVjdGVkRWxlbWVudC5vcmlnaW5hbFN0eWxlO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHNwZWNpZmllZCBydWxlIGFuZCByZXR1cm5zIGxpc3Qgb2YgZWxlbWVudHMgYWZmZWN0ZWRcbiAgICogQHBhcmFtIHJ1bGUgUnVsZSB0byBhcHBseVxuICAgKiBAcmV0dXJucyBMaXN0IG9mIGVsZW1lbnRzIGFmZmVjdGVkIGJ5IHRoaXMgcnVsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFwcGx5UnVsZShydWxlKSB7XG4gICAgdmFyIGRlYnVnID0gcnVsZS5zZWxlY3Rvci5pc0RlYnVnZ2luZygpO1xuICAgIHZhciBzdGFydDtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgc3RhcnQgPSB1dGlscy5Bc3luY1dyYXBwZXIubm93KCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICB2YXIgbm9kZXMgPSBzZWxlY3Rvci5xdWVyeVNlbGVjdG9yQWxsKCk7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGFmZmVjdGVkRWxlbWVudCA9IGZpbmRBZmZlY3RlZEVsZW1lbnQobm9kZSk7XG5cbiAgICAgIGlmIChhZmZlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgYWZmZWN0ZWRFbGVtZW50LnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIGFwcGx5U3R5bGUoYWZmZWN0ZWRFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFwcGx5aW5nIHN0eWxlIGZpcnN0IHRpbWVcbiAgICAgICAgdmFyIG9yaWdpbmFsU3R5bGUgPSBub2RlLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIGFmZmVjdGVkRWxlbWVudCA9IHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIC8vIGFmZmVjdGVkIERPTSBub2RlXG4gICAgICAgICAgcnVsZXM6IFtydWxlXSxcbiAgICAgICAgICAvLyBydWxlcyB0byBiZSBhcHBsaWVkXG4gICAgICAgICAgb3JpZ2luYWxTdHlsZTogb3JpZ2luYWxTdHlsZSxcbiAgICAgICAgICAvLyBvcmlnaW5hbCBub2RlIHN0eWxlXG4gICAgICAgICAgcHJvdGVjdGlvbk9ic2VydmVyOiBudWxsIC8vIHN0eWxlIGF0dHJpYnV0ZSBvYnNlcnZlclxuXG4gICAgICAgIH07XG4gICAgICAgIGFwcGx5U3R5bGUoYWZmZWN0ZWRFbGVtZW50KTtcbiAgICAgICAgYWZmZWN0ZWRFbGVtZW50cy5wdXNoKGFmZmVjdGVkRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIHZhciBlbGFwc2VkID0gdXRpbHMuQXN5bmNXcmFwcGVyLm5vdygpIC0gc3RhcnQ7XG5cbiAgICAgIGlmICghKCd0aW1pbmdTdGF0cycgaW4gcnVsZSkpIHtcbiAgICAgICAgcnVsZS50aW1pbmdTdGF0cyA9IG5ldyB1dGlscy5TdGF0cygpO1xuICAgICAgfVxuXG4gICAgICBydWxlLnRpbWluZ1N0YXRzLnB1c2goZWxhcHNlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIGZpbHRlcmluZyBydWxlc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFwcGx5UnVsZXMoKSB7XG4gICAgdmFyIGVsZW1lbnRzSW5kZXggPSBbXTsgLy8gc29tZSBydWxlcyBjb3VsZCBtYWtlIGNhbGwgLSBzZWxlY3Rvci5xdWVyeVNlbGVjdG9yQWxsKCkgdGVtcG9yYXJpbHkgdG8gY2hhbmdlIG5vZGUgaWQgYXR0cmlidXRlXG4gICAgLy8gdGhpcyBjYXVzZWQgTXV0YXRpb25PYnNlcnZlciB0byBjYWxsIHJlY3Vyc2l2ZWx5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0V4dGVuZGVkQ3NzL2lzc3Vlcy84MVxuXG4gICAgc3RvcE9ic2VydmUoKTtcbiAgICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICB2YXIgbm9kZXMgPSBhcHBseVJ1bGUocnVsZSk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbGVtZW50c0luZGV4LCBub2Rlcyk7XG4gICAgfSk7IC8vIE5vdyByZXZlcnQgc3R5bGVzIGZvciBlbGVtZW50cyB3aGljaCBhcmUgbm8gbW9yZSBhZmZlY3RlZFxuXG4gICAgdmFyIGwgPSBhZmZlY3RlZEVsZW1lbnRzLmxlbmd0aDsgLy8gZG8gbm90aGluZyBpZiB0aGVyZSBpcyBubyBlbGVtZW50cyB0byBwcm9jZXNzXG5cbiAgICBpZiAoZWxlbWVudHNJbmRleC5sZW5ndGggPiAwKSB7XG4gICAgICB3aGlsZSAobC0tKSB7XG4gICAgICAgIHZhciBvYmogPSBhZmZlY3RlZEVsZW1lbnRzW2xdO1xuXG4gICAgICAgIGlmIChlbGVtZW50c0luZGV4LmluZGV4T2Yob2JqLm5vZGUpID09PSAtMSkge1xuICAgICAgICAgIC8vIFRpbWUgdG8gcmV2ZXJ0IHN0eWxlXG4gICAgICAgICAgcmV2ZXJ0U3R5bGUob2JqKTtcbiAgICAgICAgICBhZmZlY3RlZEVsZW1lbnRzLnNwbGljZShsLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmICghb2JqLnJlbW92ZWQpIHtcbiAgICAgICAgICAvLyBBZGQgc3R5bGUgcHJvdGVjdGlvbiBvYnNlcnZlclxuICAgICAgICAgIC8vIFByb3RlY3QgXCJzdHlsZVwiIGF0dHJpYnV0ZSBmcm9tIGNoYW5nZXNcbiAgICAgICAgICBpZiAoIW9iai5wcm90ZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIG9iai5wcm90ZWN0aW9uT2JzZXJ2ZXIgPSBwcm90ZWN0U3R5bGVBdHRyaWJ1dGUob2JqLm5vZGUsIG9iai5ydWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBBZnRlciBzdHlsZXMgYXJlIGFwcGxpZWQgd2UgY2FuIHN0YXJ0IG9ic2VydmUgYWdhaW5cblxuXG4gICAgb2JzZXJ2ZSgpO1xuICAgIHByaW50VGltaW5nSW5mbygpO1xuICB9XG5cbiAgdmFyIEFQUExZX1JVTEVTX0RFTEFZID0gMTUwO1xuICB2YXIgYXBwbHlSdWxlc1NjaGVkdWxlciA9IG5ldyB1dGlscy5Bc3luY1dyYXBwZXIoYXBwbHlSdWxlcywgQVBQTFlfUlVMRVNfREVMQVkpO1xuICB2YXIgbWFpbkNhbGxiYWNrID0gYXBwbHlSdWxlc1NjaGVkdWxlci5ydW4uYmluZChhcHBseVJ1bGVzU2NoZWR1bGVyKTtcblxuICBmdW5jdGlvbiBvYnNlcnZlKCkge1xuICAgIGlmIChkb21PYnNlcnZlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSGFuZGxlIGR5bmFtaWNhbGx5IGFkZGVkIGVsZW1lbnRzXG5cblxuICAgIGRvbU9ic2VydmVkID0gdHJ1ZTtcbiAgICBvYnNlcnZlRG9jdW1lbnQobWFpbkNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3BPYnNlcnZlKCkge1xuICAgIGlmICghZG9tT2JzZXJ2ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkb21PYnNlcnZlZCA9IGZhbHNlO1xuICAgIGRpc2Nvbm5lY3REb2N1bWVudChtYWluQ2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgYXBwbHlSdWxlcygpO1xuXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBhcHBseVJ1bGVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERpc3Bvc2VzIEV4dGVuZGVkQ3NzIGFuZCByZW1vdmVzIG91ciBzdHlsZXMgZnJvbSBtYXRjaGVkIGVsZW1lbnRzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBzdG9wT2JzZXJ2ZSgpO1xuICAgIGFmZmVjdGVkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXZlcnRTdHlsZShvYmopO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHRpbWluZ3NQcmludGVkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBQcmludHMgdGltaW5nIGluZm9ybWF0aW9uIGZvciBhbGwgc2VsZWN0b3JzIG1hcmtlZCBhcyBcImRlYnVnXCJcbiAgICovXG5cbiAgZnVuY3Rpb24gcHJpbnRUaW1pbmdJbmZvKCkge1xuICAgIGlmICh0aW1pbmdzUHJpbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWluZ3NQcmludGVkID0gdHJ1ZTtcbiAgICB2YXIgdGltaW5ncyA9IHJ1bGVzLmZpbHRlcihmdW5jdGlvbiAocnVsZSkge1xuICAgICAgcmV0dXJuIHJ1bGUuc2VsZWN0b3IuaXNEZWJ1Z2dpbmcoKTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdG9yVGV4dDogcnVsZS5zZWxlY3Rvci5zZWxlY3RvclRleHQsXG4gICAgICAgIHRpbWluZ1N0YXRzOiBydWxlLnRpbWluZ1N0YXRzXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgaWYgKHRpbWluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBBZGQgbG9jYXRpb24uaHJlZiB0byB0aGUgbWVzc2FnZSB0byBkaXN0aW5ndWlzaCBmcmFtZXNcblxuXG4gICAgdXRpbHMubG9nSW5mbygnW0V4dGVuZGVkQ3NzXSBUaW1pbmdzIGZvciAlbzpcXG4lbyAoaW4gbWlsbGlzZWNvbmRzKScsIHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB0aW1pbmdzKTtcbiAgfSAvLyBGaXJzdCBvZiBhbGwgcGFyc2UgdGhlIHN0eWxlc2hlZXRcblxuXG4gIHJ1bGVzID0gRXh0ZW5kZWRDc3NQYXJzZXIucGFyc2VDc3Moc3R5bGVTaGVldCk7IC8vIEVYUE9TRVxuXG4gIHRoaXMuZGlzcG9zZSA9IGRpc3Bvc2U7XG4gIHRoaXMuYXBwbHkgPSBhcHBseTtcbiAgLyoqIEV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSAqL1xuXG4gIHRoaXMuX2dldEFmZmVjdGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFmZmVjdGVkRWxlbWVudHM7XG4gIH07XG59XG4vKipcbiAqIEV4cG9zZSBxdWVyeVNlbGVjdG9yQWxsIGZvciBkZWJ1Z2dpbmcgYW5kIHZhbGlkYXRpbmcgc2VsZWN0b3JzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yVGV4dCBzZWxlY3RvciB0ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG5vVGltaW5nIGlmIHRydWUgLS0gZG8gbm90IHByaW50IHRoZSB0aW1pbmcgdG8gdGhlIGNvbnNvbGVcbiAqIEByZXR1cm5zIHtBcnJheTxOb2RlPnxOb2RlTGlzdH0gYSBsaXN0IG9mIGVsZW1lbnRzIGZvdW5kXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGFyZ3VtZW50IGlzIG5vdCBhIHZhbGlkIHNlbGVjdG9yXG4gKi9cblxuXG5FeHRlbmRlZENzcy5xdWVyeSA9IGZ1bmN0aW9uIChzZWxlY3RvclRleHQsIG5vVGltaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3JUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0b3IgdGV4dCBpcyBlbXB0eScpO1xuICB9XG5cbiAgdmFyIG5vdyA9IHV0aWxzLkFzeW5jV3JhcHBlci5ub3c7XG4gIHZhciBzdGFydCA9IG5vdygpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEV4dGVuZGVkU2VsZWN0b3JGYWN0b3J5LmNyZWF0ZVNlbGVjdG9yKHNlbGVjdG9yVGV4dCkucXVlcnlTZWxlY3RvckFsbCgpO1xuICB9IGZpbmFsbHkge1xuICAgIHZhciBlbmQgPSBub3coKTtcblxuICAgIGlmICghbm9UaW1pbmcpIHtcbiAgICAgIHV0aWxzLmxvZ0luZm8oXCJbRXh0ZW5kZWRDc3NdIEVsYXBzZWQ6IFwiLmNvbmNhdChNYXRoLnJvdW5kKChlbmQgLSBzdGFydCkgKiAxMDAwKSwgXCIgXFx1MDNCQ3MuXCIpKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEV4dGVuZGVkQ3NzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJcbi8qKlxuICogQWRHdWFyZCBTY3JpcHRsZXRzXG4gKiBWZXJzaW9uIDEuMy4yMFxuICovXG5cbi8qKlxuICogUmV0dXJucyB3aWxkY2FyZCBzeW1ib2xcbiAqIEByZXR1cm5zIHtzdHJpbmd9ICcqJ1xuICovXG52YXIgZ2V0V2lsZGNhcmRTeW1ib2wgPSBmdW5jdGlvbiBnZXRXaWxkY2FyZFN5bWJvbCgpIHtcbiAgcmV0dXJuICcqJztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgcmFuZG9tIHNpeCBzeW1ib2xzIGlkXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUlkKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpO1xufVxuXG4vKipcbiAqIFNldCBnZXR0ZXIgYW5kIHNldHRlciB0byBwcm9wZXJ0eSBpZiBpdCdzIGNvbmZpZ3VyYWJsZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0YXJnZXQgb2JqZWN0IHdpdGggcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciBjb250YWlucyBnZXR0ZXIgYW5kIHNldHRlciBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufSBpcyBvcGVyYXRpb24gc3VjY2Vzc2Z1bFxuICovXG5mdW5jdGlvbiBzZXRQcm9wZXJ0eUFjY2VzcyhvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gIHZhciBjdXJyZW50RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGN1cnJlbnREZXNjcmlwdG9yICYmICFjdXJyZW50RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIENoYWluXG4gKiBAcHJvcGVydHkge09iamVjdH0gYmFzZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3BcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2hhaW5dXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGluIHRoZSBiYXNlIG9iamVjdCAocmVjdXJzaXZlbHkpXG4gKlxuICogSWYgcHJvcGVydHkgZG9lc24ndCBleGlzdCBpbiBiYXNlIG9iamVjdCxcbiAqIGRlZmluZXMgdGhpcyBwcm9wZXJ0eSBhcyAndW5kZWZpbmVkJ1xuICogYW5kIHJldHVybnMgYmFzZSwgcHJvcGVydHkgbmFtZSBhbmQgcmVtYWluaW5nIHBhcnQgb2YgcHJvcGVydHkgY2hhaW5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYmFzZVxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluXG4gKiBAcmV0dXJucyB7Q2hhaW59XG4gKi9cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5DaGFpbihiYXNlLCBjaGFpbikge1xuICB2YXIgcG9zID0gY2hhaW4uaW5kZXhPZignLicpO1xuXG4gIGlmIChwb3MgPT09IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGJhc2UsXG4gICAgICBwcm9wOiBjaGFpblxuICAgIH07XG4gIH1cblxuICB2YXIgcHJvcCA9IGNoYWluLnNsaWNlKDAsIHBvcyk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMjhcblxuICBpZiAoYmFzZSA9PT0gbnVsbCkge1xuICAgIC8vIGlmIGJhc2UgaXMgbnVsbCwgcmV0dXJuICdudWxsJyBhcyBiYXNlLlxuICAgIC8vIGl0J3MgbmVlZGVkIGZvciB0cmlnZ2VyaW5nIHRoZSByZWFzb24gbG9nZ2luZyB3aGlsZSBkZWJ1Z2dpbmdcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogYmFzZSxcbiAgICAgIHByb3A6IHByb3AsXG4gICAgICBjaGFpbjogY2hhaW5cbiAgICB9O1xuICB9XG5cbiAgdmFyIG5leHRCYXNlID0gYmFzZVtwcm9wXTtcbiAgY2hhaW4gPSBjaGFpbi5zbGljZShwb3MgKyAxKTtcblxuICBpZiAobmV4dEJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRQcm9wZXJ0eUluQ2hhaW4obmV4dEJhc2UsIGNoYWluKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYXNlLCBwcm9wLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGJhc2U6IG5leHRCYXNlLFxuICAgIHByb3A6IHByb3AsXG4gICAgY2hhaW46IGNoYWluXG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYgQ2hhaW5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBiYXNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJvcFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjaGFpbl1cbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMgaW4gdGhlIGJhc2Ugb2JqZWN0IChyZWN1cnNpdmVseSkuXG4gKiBTaW1pbGFyIHRvIGdldFByb3BlcnR5SW5DaGFpbiBidXQgdXBncmFkZWQgZm9yIGpzb24tcHJ1bmU6XG4gKiBoYW5kbGUgd2lsZGNhcmQgcHJvcGVydGllcyBhbmQgZG9lcyBub3QgZGVmaW5lIG5vbmV4aXN0ZW50IGJhc2UgcHJvcGVydHkgYXMgJ3VuZGVmaW5lZCdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYmFzZVxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29rVGhyb3VnaD1mYWxzZV1cbiAqIHNob3VsZCB0aGUgbWV0aG9kIGxvb2sgdGhyb3VnaCBpdCdzIHByb3BzIGluIG9yZGVyIHRvIHdpbGRjYXJkXG4gKiBAcGFyYW0ge0FycmF5fSBbb3V0cHV0PVtdXSByZXN1bHQgYWNjXG4gKiBAcmV0dXJucyB7Q2hhaW5bXX0gYXJyYXkgb2Ygb2JqZWN0c1xuICovXG5cbmZ1bmN0aW9uIGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluKGJhc2UsIGNoYWluKSB7XG4gIHZhciBsb29rVGhyb3VnaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBvdXRwdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICB2YXIgcG9zID0gY2hhaW4uaW5kZXhPZignLicpO1xuXG4gIGlmIChwb3MgPT09IC0xKSB7XG4gICAgLy8gZm9yIHBhdGhzIGxpa2UgJ2EuYi4qJyBldmVyeSBmaW5hbCBuZXN0ZWQgcHJvcCBzaG91bGQgYmUgcHJvY2Vzc2VkXG4gICAgaWYgKGNoYWluID09PSBnZXRXaWxkY2FyZFN5bWJvbCgpIHx8IGNoYWluID09PSAnW10nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIGZvciAodmFyIGtleSBpbiBiYXNlKSB7XG4gICAgICAgIC8vIHRvIHByb2Nlc3MgZWFjaCBrZXkgaW4gYmFzZSBleGNlcHQgaW5oZXJpdGVkIG9uZXNcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiYXNlLCBrZXkpKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goe1xuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIHByb3A6IGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgcHJvcDogY2hhaW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICB2YXIgcHJvcCA9IGNoYWluLnNsaWNlKDAsIHBvcyk7XG4gIHZhciBzaG91bGRMb29rVGhyb3VnaCA9IHByb3AgPT09ICdbXScgJiYgQXJyYXkuaXNBcnJheShiYXNlKSB8fCBwcm9wID09PSBnZXRXaWxkY2FyZFN5bWJvbCgpICYmIGJhc2UgaW5zdGFuY2VvZiBPYmplY3Q7XG5cbiAgaWYgKHNob3VsZExvb2tUaHJvdWdoKSB7XG4gICAgdmFyIG5leHRQcm9wID0gY2hhaW4uc2xpY2UocG9zICsgMSk7XG4gICAgdmFyIGJhc2VLZXlzID0gT2JqZWN0LmtleXMoYmFzZSk7IC8vIGlmIHRoZXJlIGlzIGEgd2lsZGNhcmQgcHJvcCBpbiBpbnB1dCBjaGFpbiAoZS5nLiAnYWQuKi5zcmMnIGZvciAnYWQuMC5zcmMgYWQuMS5zcmMnKSxcbiAgICAvLyBlYWNoIG9uZSBvZiBiYXNlIGtleXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgY2hhaW4gcHJvcCBpbiBmaW5hbCBwYXRoXG5cbiAgICBiYXNlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBpdGVtID0gYmFzZVtrZXldO1xuICAgICAgZ2V0V2lsZGNhcmRQcm9wZXJ0eUluQ2hhaW4oaXRlbSwgbmV4dFByb3AsIGxvb2tUaHJvdWdoLCBvdXRwdXQpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG5leHRCYXNlID0gYmFzZVtwcm9wXTtcbiAgY2hhaW4gPSBjaGFpbi5zbGljZShwb3MgKyAxKTtcblxuICBpZiAobmV4dEJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluKG5leHRCYXNlLCBjaGFpbiwgbG9va1Rocm91Z2gsIG91dHB1dCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIE5hTlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzTmFOXG4gKiBAcGFyYW0geyp9IG51bVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBuYXRpdmVJc05hTiA9IGZ1bmN0aW9uIG5hdGl2ZUlzTmFOKG51bSkge1xuICB2YXIgbmF0aXZlID0gTnVtYmVyLmlzTmFOIHx8IHdpbmRvdy5pc05hTjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb21wYXQvY29tcGF0XG5cbiAgcmV0dXJuIG5hdGl2ZShudW0pO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNGaW5pdGVcbiAqIEBwYXJhbSB7Kn0gbnVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgbmF0aXZlSXNGaW5pdGUgPSBmdW5jdGlvbiBuYXRpdmVJc0Zpbml0ZShudW0pIHtcbiAgdmFyIG5hdGl2ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCB3aW5kb3cuaXNGaW5pdGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuXG4gIHJldHVybiBuYXRpdmUobnVtKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgb2JqZWN0IHRvIGFycmF5IG9mIHBhaXJzLlxuICogT2JqZWN0LmVudHJpZXMoKSBwb2x5ZmlsbCBiZWNhdXNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUVcbiAqIGh0dHBzOi8vY2FuaXVzZS5jb20vP3NlYXJjaD1PYmplY3QuZW50cmllc1xuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fSBhcnJheSBvZiBwYWlyc1xuICovXG52YXIgZ2V0T2JqZWN0RW50cmllcyA9IGZ1bmN0aW9uIGdldE9iamVjdEVudHJpZXMob2JqZWN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgdmFyIGVudHJpZXMgPSBbXTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZW50cmllcy5wdXNoKFtrZXksIG9iamVjdFtrZXldXSk7XG4gIH0pO1xuICByZXR1cm4gZW50cmllcztcbn07XG4vKipcbiAqIENvbnZlcnRzIGFycmF5IG9mIHBhaXJzIHRvIG9iamVjdC5cbiAqIE9iamVjdC5mcm9tRW50cmllcygpIHBvbHlmaWxsIGJlY2F1c2UgaXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRVxuICogaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPU9iamVjdC5mcm9tRW50cmllc1xuICogQHBhcmFtIHtBcnJheX0gZW50cmllcyAtIGFycmF5IG9mIHBhaXJzXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbnZhciBnZXRPYmplY3RGcm9tRW50cmllcyA9IGZ1bmN0aW9uIGdldE9iamVjdEZyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgdmFyIG91dHB1dCA9IGVudHJpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGVsKSB7XG4gICAgdmFyIGtleSA9IGVsWzBdO1xuICAgIHZhciB2YWx1ZSA9IGVsWzFdO1xuICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gb3V0cHV0O1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIG9iaiBpcyBhbiBlbXB0eSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKiBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwgcG9saWZpbGxcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBpbnB1dCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWJzdHIgdG8gbG9vayBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTdWJzdHIgcmVwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIHJlcGxhY2VBbGwgPSBmdW5jdGlvbiByZXBsYWNlQWxsKGlucHV0LCBzdWJzdHIsIG5ld1N1YnN0cikge1xuICByZXR1cm4gaW5wdXQuc3BsaXQoc3Vic3RyKS5qb2luKG5ld1N1YnN0cik7XG59O1xuLyoqXG4gKiBFc2NhcGVzIHNwZWNpYWwgY2hhcnMgaW4gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHNlYXJjaCBzdHJpbmcgdG8gdGhlIHJlZ2V4cFxuICogVE9ETyB0aGluayBhYm91dCBuZXN0ZWQgZGVwZW5kZW5jaWVzLCBidXQgYmUgY2FyZWZ1bCB3aXRoIGRlcGVuZGVuY3kgbG9vcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc2VhcmNoIHN0cmluZ1xuICogQHJldHVybnMge1JlZ0V4cH1cbiAqL1xuXG52YXIgdG9SZWdFeHAgPSBmdW5jdGlvbiB0b1JlZ0V4cChzdHIpIHtcbiAgaWYgKCFzdHIgfHwgc3RyID09PSAnJykge1xuICAgIHZhciBERUZBVUxUX1ZBTFVFID0gJy4/JztcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChERUZBVUxUX1ZBTFVFKTtcbiAgfVxuXG4gIGlmIChzdHJbMF0gPT09ICcvJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzdHIuc2xpY2UoMSwgLTEpKTtcbiAgfVxuXG4gIHZhciBlc2NhcGVkID0gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGVzY2FwZWQpO1xufTtcbi8qKlxuICogR2V0IHN0cmluZyBiZWZvcmUgcmVnZXhwIGZpcnN0IG1hdGNoXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcnhcbiAqL1xuXG52YXIgZ2V0QmVmb3JlUmVnRXhwID0gZnVuY3Rpb24gZ2V0QmVmb3JlUmVnRXhwKHN0ciwgcngpIHtcbiAgdmFyIGluZGV4ID0gc3RyLnNlYXJjaChyeCk7XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIGluZGV4KTtcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggdGhlIHN1YnN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBmdWxsIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBzdWJzdHJpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkge1xuICAvLyBpZiBzdHIgPT09ICcnLCAoc3RyICYmIGZhbHNlKSB3aWxsIHJldHVybiAnJ1xuICAvLyB0aGF0J3Mgd2h5IGl0IGhhcyB0byBiZSAhIXN0clxuICByZXR1cm4gISFzdHIgJiYgc3RyLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgZnVsbCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRpbmcgc3Vic3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgZW5kc1dpdGggPSBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIGVuZGluZykge1xuICAvLyBpZiBzdHIgPT09ICcnLCAoc3RyICYmIGZhbHNlKSB3aWxsIHJldHVybiAnJ1xuICAvLyB0aGF0J3Mgd2h5IGl0IGhhcyB0byBiZSAhIXN0clxuICByZXR1cm4gISFzdHIgJiYgc3RyLmluZGV4T2YoZW5kaW5nKSA9PT0gc3RyLmxlbmd0aCAtIGVuZGluZy5sZW5ndGg7XG59O1xudmFyIHN1YnN0cmluZ0FmdGVyID0gZnVuY3Rpb24gc3Vic3RyaW5nQWZ0ZXIoc3RyLCBzZXBhcmF0b3IpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/ICcnIDogc3RyLnN1YnN0cmluZyhpbmRleCArIHNlcGFyYXRvci5sZW5ndGgpO1xufTtcbnZhciBzdWJzdHJpbmdCZWZvcmUgPSBmdW5jdGlvbiBzdWJzdHJpbmdCZWZvcmUoc3RyLCBzZXBhcmF0b3IpIHtcbiAgaWYgKCFzdHIgfHwgIXNlcGFyYXRvcikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZihzZXBhcmF0b3IpO1xuICByZXR1cm4gaW5kZXggPCAwID8gc3RyIDogc3RyLnN1YnN0cmluZygwLCBpbmRleCk7XG59O1xuLyoqXG4gKiBXcmFwIHN0ciBpbiBzaW5nbGUgcW91dGVzIGFuZCByZXBsYWNlcyBzaW5nbGUgcXVvdGVzIHRvIGRvdWRsZSBvbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuXG52YXIgd3JhcEluU2luZ2xlUXVvdGVzID0gZnVuY3Rpb24gd3JhcEluU2luZ2xlUXVvdGVzKHN0cikge1xuICBpZiAoc3RyWzBdID09PSAnXFwnJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnXFwnJyB8fCBzdHJbMF0gPT09ICdcIicgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aCAtIDEpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG5cbiAgc3RyID0gc3RyLnJlcGxhY2UoL1xcJy9nLCAnXCInKTtcbiAgcmV0dXJuIFwiJ1wiLmNvbmNhdChzdHIsIFwiJ1wiKTtcbn07XG4vKipcbiAqIFJldHVybnMgc3Vic3RyaW5nIGVuY2xvc2VkIGluIHRoZSB3aWRlc3QgYnJhY2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cblxudmFyIGdldFN0cmluZ0luQnJhY2VzID0gZnVuY3Rpb24gZ2V0U3RyaW5nSW5CcmFjZXMoc3RyKSB7XG4gIHZhciBmaXJzdEluZGV4ID0gc3RyLmluZGV4T2YoJygnKTtcbiAgdmFyIGxhc3RJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignKScpO1xuICByZXR1cm4gc3RyLnN1YnN0cmluZyhmaXJzdEluZGV4ICsgMSwgbGFzdEluZGV4KTtcbn07XG4vKipcbiAqIFByZXBhcmVzIFJUQ1BlZXJDb25uZWN0aW9uIGNvbmZpZyBhcyBzdHJpbmcgZm9yIHByb3BlciBsb2dnaW5nXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xuICogQHJldHVybnMge3N0cmluZ30gc3RyaW5naWZpZWQgY29uZmlnXG4qL1xuXG52YXIgY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nID0gZnVuY3Rpb24gY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nKGNvbmZpZykge1xuICB2YXIgVU5ERUZfU1RSID0gJ3VuZGVmaW5lZCc7XG4gIHZhciBzdHIgPSBVTkRFRl9TVFI7XG5cbiAgaWYgKGNvbmZpZyA9PT0gbnVsbCkge1xuICAgIHN0ciA9ICdudWxsJztcbiAgfSBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgU0VSVkVSU19QUk9QX05BTUUgPSAnaWNlU2VydmVycyc7XG4gICAgdmFyIFVSTFNfUFJPUF9OQU1FID0gJ3VybHMnO1xuICAgIC8qXG4gICAgICAgIGNvbnN0IGV4YW1wbGVDb25maWcgPSB7XG4gICAgICAgICAgICAnaWNlU2VydmVycyc6IFtcbiAgICAgICAgICAgICAgICAndXJscyc6IFsnc3R1bjozNS42Ni4yMDYuMTg4OjQ0MyddLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAqL1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFNFUlZFUlNfUFJPUF9OQU1FKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnW1NFUlZFUlNfUFJPUF9OQU1FXVswXSwgVVJMU19QUk9QX05BTUUpICYmICEhY29uZmlnW1NFUlZFUlNfUFJPUF9OQU1FXVswXVtVUkxTX1BST1BfTkFNRV0pIHtcbiAgICAgIHN0ciA9IGNvbmZpZ1tTRVJWRVJTX1BST1BfTkFNRV1bMF1bVVJMU19QUk9QX05BTUVdLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hdGNoRGF0YVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0ludmVydGVkTWF0Y2hcbiAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBtYXRjaFJlZ2V4cFxuICovXG5cbi8qKlxuICogUGFyc2VzIG1hdGNoIGFyZyB3aXRoIHBvc3NpYmxlIG5lZ2F0aW9uIGZvciBubyBtYXRjaGluZy5cbiAqIE5lZWRlZCBmb3IgcHJldmVudC1zZXRUaW1lb3V0LCBwcmV2ZW50LXNldEludGVydmFsLFxuICogcHJldmVudC1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIHByZXZlbnQtd2luZG93LW9wZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFxuICogQHJldHVybnMge01hdGNoRGF0YX1cbiAqL1xuXG52YXIgcGFyc2VNYXRjaEFyZyA9IGZ1bmN0aW9uIHBhcnNlTWF0Y2hBcmcobWF0Y2gpIHtcbiAgdmFyIElOVkVSVF9NQVJLRVIgPSAnISc7XG4gIHZhciBpc0ludmVydGVkTWF0Y2ggPSBzdGFydHNXaXRoKG1hdGNoLCBJTlZFUlRfTUFSS0VSKTtcbiAgdmFyIG1hdGNoVmFsdWUgPSBpc0ludmVydGVkTWF0Y2ggPyBtYXRjaC5zbGljZSgxKSA6IG1hdGNoO1xuICB2YXIgbWF0Y2hSZWdleHAgPSB0b1JlZ0V4cChtYXRjaFZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0ludmVydGVkTWF0Y2g6IGlzSW52ZXJ0ZWRNYXRjaCxcbiAgICBtYXRjaFJlZ2V4cDogbWF0Y2hSZWdleHBcbiAgfTtcbn07XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlbGF5RGF0YVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0ludmVydGVkRGVsYXlNYXRjaFxuICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gZGVsYXlNYXRjaFxuICovXG5cbi8qKlxuICogUGFyc2VzIGRlbGF5IGFyZyB3aXRoIHBvc3NpYmxlIG5lZ2F0aW9uIGZvciBubyBtYXRjaGluZy5cbiAqIE5lZWRlZCBmb3IgcHJldmVudC1zZXRUaW1lb3V0IGFuZCBwcmV2ZW50LXNldEludGVydmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVsYXlcbiAqIEByZXR1cm5zIHtEZWxheURhdGF9XG4gKi9cblxudmFyIHBhcnNlRGVsYXlBcmcgPSBmdW5jdGlvbiBwYXJzZURlbGF5QXJnKGRlbGF5KSB7XG4gIHZhciBJTlZFUlRfTUFSS0VSID0gJyEnO1xuICB2YXIgaXNJbnZlcnRlZERlbGF5TWF0Y2ggPSBzdGFydHNXaXRoKGRlbGF5LCBJTlZFUlRfTUFSS0VSKTtcbiAgdmFyIGRlbGF5VmFsdWUgPSBpc0ludmVydGVkRGVsYXlNYXRjaCA/IGRlbGF5LnNsaWNlKDEpIDogZGVsYXk7XG4gIGRlbGF5VmFsdWUgPSBwYXJzZUludChkZWxheVZhbHVlLCAxMCk7XG4gIHZhciBkZWxheU1hdGNoID0gbmF0aXZlSXNOYU4oZGVsYXlWYWx1ZSkgPyBudWxsIDogZGVsYXlWYWx1ZTtcbiAgcmV0dXJuIHtcbiAgICBpc0ludmVydGVkRGVsYXlNYXRjaDogaXNJbnZlcnRlZERlbGF5TWF0Y2gsXG4gICAgZGVsYXlNYXRjaDogZGVsYXlNYXRjaFxuICB9O1xufTtcbi8qKlxuICogQ29udmVydHMgb2JqZWN0IHRvIHN0cmluZyBmb3IgbG9nZ2luZ1xuICogQHBhcmFtIHtPYmplY3R9IG9iaiBkYXRhIG9iamVjdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIGlzRW1wdHlPYmplY3Qob2JqKSA/ICd7fScgOiBnZXRPYmplY3RFbnRyaWVzKG9iaikubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgdmFyIGtleSA9IHBhaXJbMF07XG4gICAgdmFyIHZhbHVlID0gcGFpclsxXTtcbiAgICB2YXIgcmVjb3JkVmFsdWVTdHIgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgcmVjb3JkVmFsdWVTdHIgPSBcInsgXCIuY29uY2F0KG9iamVjdFRvU3RyaW5nKHZhbHVlKSwgXCIgfVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIjpcXFwiXCIpLmNvbmNhdChyZWNvcmRWYWx1ZVN0ciwgXCJcXFwiXCIpO1xuICB9KS5qb2luKCcgJyk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0eXBlcyBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBjb252ZXJ0VHlwZVRvU3RyaW5nID0gZnVuY3Rpb24gY29udmVydFR5cGVUb1N0cmluZyh2YWx1ZSkge1xuICB2YXIgb3V0cHV0O1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3V0cHV0ID0gJ3VuZGVmaW5lZCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgb3V0cHV0ID0gJ251bGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgZnVuY3Rpb24gd2hpY2ggc2lsZW50cyBnbG9iYWwgZXJyb3JzIG9uIHBhZ2UgZ2VuZXJhdGVkIGJ5IHNjcmlwdGxldFxuICogSWYgZXJyb3IgZG9lc24ndCBiZWxvbmcgdG8gb3VyIGVycm9yIHdlIHRyYW5zZmVyIGl0IHRvIHRoZSBuYXRpdmUgb25FcnJvciBoYW5kbGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmlkIC0gdW5pcXVlIGlkZW50aWZpZXIgb2Ygc2NyaXB0bGV0XG4gKiBAcmV0dXJuIHtvbkVycm9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIHZhciBuYXRpdmVPbkVycm9yID0gd2luZG93Lm9uZXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgJiYgZXJyb3IuaW5kZXhPZihyaWQpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5hdGl2ZU9uRXJyb3IgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZU9uRXJyb3IuYXBwbHkodGhpcywgW2Vycm9yXS5jb25jYXQoYXJncykpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBOb29wIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG52YXIgbm9vcEZ1bmMgPSBmdW5jdGlvbiBub29wRnVuYygpIHt9O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIG51bGxcbiAqIEByZXR1cm4ge251bGx9IG51bGxcbiAqL1xuXG52YXIgbm9vcE51bGwgPSBmdW5jdGlvbiBub29wTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIHRydWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWVcbiAqL1xuXG52YXIgdHJ1ZUZ1bmMgPSBmdW5jdGlvbiB0cnVlRnVuYygpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIGZhbHNlXG4gKiBAcmV0dXJuIHtib29sZWFufSBmYWxzZVxuICovXG5cbnZhciBmYWxzZUZ1bmMgPSBmdW5jdGlvbiBmYWxzZUZ1bmMoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybnMgdGhpc1xuICovXG5cbmZ1bmN0aW9uIG5vb3BUaGlzKCkge1xuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyBlbXB0eSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gZW1wdHkgc3RyaW5nXG4gKi9cblxudmFyIG5vb3BTdHIgPSBmdW5jdGlvbiBub29wU3RyKCkge1xuICByZXR1cm4gJyc7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIGVtcHR5IGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX0gZW1wdHkgYXJyYXlcbiAqL1xuXG52YXIgbm9vcEFycmF5ID0gZnVuY3Rpb24gbm9vcEFycmF5KCkge1xuICByZXR1cm4gW107XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIGVtcHR5IG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSBlbXB0eSBvYmplY3RcbiAqL1xuXG52YXIgbm9vcE9iamVjdCA9IGZ1bmN0aW9uIG5vb3BPYmplY3QoKSB7XG4gIHJldHVybiB7fTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybnMgUHJvbWlzZS5yZWplY3QoKVxuICovXG5cbnZhciBub29wUHJvbWlzZVJlamVjdCA9IGZ1bmN0aW9uIG5vb3BQcm9taXNlUmVqZWN0KCkge1xuICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuXG4vKipcbiAqIFJldHVybnMgUHJvbWlzZSBvYmplY3QgdGhhdCBpcyByZXNvbHZlZCB3aXRoIGFuIGVtcHR5IHJlc3BvbnNlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG5cbnZhciBub29wUHJvbWlzZVJlc29sdmUgPSBmdW5jdGlvbiBub29wUHJvbWlzZVJlc29sdmUoKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFJlc3BvbnNlKCkpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSwgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxuLyoqXG4gKiBIaXQgdXNlZCBvbmx5IGZvciBkZWJ1ZyBwdXJwb3NlcyBub3dcbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gLSBvcHRpb25hbCBtZXNzYWdlO1xuICogdXNlIExPR19NQVJLRVIgPSAnbG9nOiAnIGF0IHRoZSBzdGFydCBvZiBhIG1lc3NhZ2VcbiAqIGZvciBsb2dnaW5nIHNjcmlwdGxldHNcbiAqL1xudmFyIGhpdCA9IGZ1bmN0aW9uIGhpdChzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgaWYgKHNvdXJjZS52ZXJib3NlICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgbG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICB2YXIgdHJhY2UgPSBjb25zb2xlLnRyYWNlLmJpbmQoY29uc29sZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuXG4gICAgdmFyIHByZWZpeCA9IHNvdXJjZS5ydWxlVGV4dCB8fCAnJztcblxuICAgIGlmIChzb3VyY2UuZG9tYWluTmFtZSkge1xuICAgICAgdmFyIEFHX1NDUklQVExFVF9NQVJLRVIgPSAnIyUjLy8nO1xuICAgICAgdmFyIFVCT19TQ1JJUFRMRVRfTUFSS0VSID0gJyMjK2pzJztcbiAgICAgIHZhciBydWxlU3RhcnRJbmRleDtcblxuICAgICAgaWYgKHNvdXJjZS5ydWxlVGV4dC5pbmRleE9mKEFHX1NDUklQVExFVF9NQVJLRVIpID4gLTEpIHtcbiAgICAgICAgcnVsZVN0YXJ0SW5kZXggPSBzb3VyY2UucnVsZVRleHQuaW5kZXhPZihBR19TQ1JJUFRMRVRfTUFSS0VSKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlLnJ1bGVUZXh0LmluZGV4T2YoVUJPX1NDUklQVExFVF9NQVJLRVIpID4gLTEpIHtcbiAgICAgICAgcnVsZVN0YXJ0SW5kZXggPSBzb3VyY2UucnVsZVRleHQuaW5kZXhPZihVQk9fU0NSSVBUTEVUX01BUktFUik7XG4gICAgICB9IC8vIGRlbGV0ZSBhbGwgZG9tYWlucyBmcm9tIHJ1bGVUZXh0IGFuZCBsZWF2ZSBqdXN0IHJ1bGUgcGFydFxuXG5cbiAgICAgIHZhciBydWxlUGFydCA9IHNvdXJjZS5ydWxlVGV4dC5zbGljZShydWxlU3RhcnRJbmRleCk7IC8vIHByZXBhcmUgYXBwbGllZCBzY3JpcHRsZXQgcnVsZSBmb3Igc3BlY2lmaWMgZG9tYWluXG5cbiAgICAgIHByZWZpeCA9IFwiXCIuY29uY2F0KHNvdXJjZS5kb21haW5OYW1lKS5jb25jYXQocnVsZVBhcnQpO1xuICAgIH0gLy8gVXNlZCB0byBjaGVjayBpZiBzY3JpcHRsZXQgdXNlcyAnaGl0JyBmdW5jdGlvbiBmb3IgbG9nZ2luZ1xuXG5cbiAgICB2YXIgTE9HX01BUktFUiA9ICdsb2c6ICc7XG5cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgaWYgKG1lc3NhZ2UuaW5kZXhPZihMT0dfTUFSS0VSKSA9PT0gLTEpIHtcbiAgICAgICAgbG9nKFwiXCIuY29uY2F0KHByZWZpeCwgXCIgbWVzc2FnZTpcXG5cIikuY29uY2F0KG1lc3NhZ2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyhtZXNzYWdlLnNsaWNlKExPR19NQVJLRVIubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nKFwiXCIuY29uY2F0KHByZWZpeCwgXCIgdHJhY2Ugc3RhcnRcIikpO1xuXG4gICAgaWYgKHRyYWNlKSB7XG4gICAgICB0cmFjZSgpO1xuICAgIH1cblxuICAgIGxvZyhcIlwiLmNvbmNhdChwcmVmaXgsIFwiIHRyYWNlIGVuZFwiKSk7XG4gIH0gY2F0Y2ggKGUpIHsvLyB0cnkgY2F0Y2ggZm9yIEVkZ2UgMTVcbiAgICAvLyBJbiBhY2NvcmRpbmcgdG8gdGhpcyBpc3N1ZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xNDQ5NTIyMC9cbiAgICAvLyBjb25zb2xlLmxvZyB0aHJvd3MgYW4gZXJyb3JcbiAgfSAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdW5pdC10ZXN0cyBvbmx5IVxuXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cuX19kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdpbmRvdy5fX2RlYnVnKHNvdXJjZSk7XG4gIH1cbn07XG5cbi8qKlxuICogRE9NIHRyZWUgY2hhbmdlcyBvYnNlcnZlci4gVXNlZCBmb3IgJ3JlbW92ZS1hdHRyJyBhbmQgJ3JlbW92ZS1jbGFzcycgc2NyaXB0bGV0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb2JzZXJ2ZUF0dHJzIC0gb3B0aW9uYWwgcGFyYW1ldGVyIC0gc2hvdWxkIG9ic2VydmVyIGNoZWNrIGF0dGlidXRlcyBjaGFuZ2VzXG4gKi9cbnZhciBvYnNlcnZlRE9NQ2hhbmdlcyA9IGZ1bmN0aW9uIG9ic2VydmVET01DaGFuZ2VzKGNhbGxiYWNrKSB7XG4gIHZhciBvYnNlcnZlQXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgYXR0cnNUb09ic2VydiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyLCBwYXNzaW5nIHRoZSBjYWxsIHRvICdtZXRob2QnIGF0IG1heGltdW0gb25jZSBwZXIgJ2RlbGF5JyBtaWxsaXNlY29uZHMuXG4gICAqIFRob3NlIGNhbGxzIHRoYXQgZmFsbCBpbnRvIHRoZSBcImNvb2xkb3duXCIgcGVyaW9kLCBhcmUgaWdub3JlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IC0gbWlsbGlzZWNvbmRzXG4gICAqL1xuICB2YXIgdGhyb3R0bGUgPSBmdW5jdGlvbiB0aHJvdHRsZShtZXRob2QsIGRlbGF5KSB7XG4gICAgdmFyIHdhaXQgPSBmYWxzZTtcbiAgICB2YXIgc2F2ZWRBcmdzO1xuXG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmICh3YWl0KSB7XG4gICAgICAgIHNhdmVkQXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWV0aG9kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB3YWl0ID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB3YWl0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNhdmVkQXJncykge1xuICAgICAgICAgIHdyYXBwZXIoc2F2ZWRBcmdzKTtcbiAgICAgICAgICBzYXZlZEFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfTtcblxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9O1xuICAvKipcbiAgICogJ2RlbGF5JyBpbiBtaWxsaXNlY29uZHMgZm9yICd0aHJvdHRsZScgbWV0aG9kXG4gICAqL1xuXG5cbiAgdmFyIFRIUk9UVExFX0RFTEFZX01TID0gMjA7XG4gIC8qKlxuICAgKiBVc2VkIGZvciByZW1vdmUtY2xhc3NcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZSwgY29tcGF0L2NvbXBhdFxuXG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRocm90dGxlKGNhbGxiYWNrV3JhcHBlciwgVEhST1RUTEVfREVMQVlfTVMpKTtcblxuICB2YXIgY29ubmVjdCA9IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgaWYgKGF0dHJzVG9PYnNlcnYubGVuZ3RoID4gMCkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiBvYnNlcnZlQXR0cnMsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogYXR0cnNUb09ic2VydlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogb2JzZXJ2ZUF0dHJzXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRpc2Nvbm5lY3QgPSBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjYWxsYmFja1dyYXBwZXIoKSB7XG4gICAgZGlzY29ubmVjdCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgY29ubmVjdCgpO1xuICB9XG5cbiAgY29ubmVjdCgpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHN0YWNrVHJhY2UgY29udGFpbnMgc3RhY2tSZWdleHBcbiAqIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy84MlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzdGFja01hdGNoIC0gaW5wdXQgc3RhY2sgdmFsdWUgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja1RyYWNlIC0gc2NyaXB0IGVycm9yIHN0YWNrIHRyYWNlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgbWF0Y2hTdGFja1RyYWNlID0gZnVuY3Rpb24gbWF0Y2hTdGFja1RyYWNlKHN0YWNrTWF0Y2gsIHN0YWNrVHJhY2UpIHtcbiAgaWYgKCFzdGFja01hdGNoIHx8IHN0YWNrTWF0Y2ggPT09ICcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgc3RhY2tSZWdleHAgPSB0b1JlZ0V4cChzdGFja01hdGNoKTtcbiAgdmFyIHJlZmluZWRTdGFja1RyYWNlID0gc3RhY2tUcmFjZS5zcGxpdCgnXFxuJykuc2xpY2UoMikgLy8gZ2V0IHJpZCBvZiBvdXIgb3duIGZ1bmN0aW9ucyBpbiB0aGUgc3RhY2sgdHJhY2VcbiAgLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgfSkgLy8gdHJpbSB0aGUgbGluZXNcbiAgLmpvaW4oJ1xcbicpO1xuICByZXR1cm4gc3RhY2tSZWdleHAudGVzdChyZWZpbmVkU3RhY2tUcmFjZSk7XG59O1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgQXJyYXkucHJvdG90eXBlLmZsYXQoKVxuICogZm9yIGV4YW1wbGUsIE9wZXJhIDQyIHdoaWNoIGlzIHVzZWQgZm9yIGJyb3dzZXJzdGFjayB0ZXN0c1xuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmxhdFxuICogQHBhcmFtIHtBcnJheX0gaW5wdXRcbiAqL1xudmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuKGlucHV0KSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBzdGFjay5wdXNoKGVsKTtcbiAgfSk7XG4gIHZhciByZXMgPSBbXTtcblxuICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgLy8gcG9wIHZhbHVlIGZyb20gc3RhY2tcbiAgICB2YXIgbmV4dCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIC8vIHB1c2ggYmFjayBhcnJheSBpdGVtcywgd29uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBpbnB1dFxuICAgICAgbmV4dC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gc3RhY2sucHVzaChlbCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnB1c2gobmV4dCk7XG4gICAgfVxuICB9IC8vIHJldmVyc2UgdG8gcmVzdG9yZSBpbnB1dCBvcmRlclxuXG5cbiAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59O1xuXG4vKipcbiAqIEZpbmRzIHNoYWRvdy1kb20gaG9zdCAoZWxlbWVudHMgd2l0aCBzaGFkb3dSb290IHByb3BlcnR5KSBpbiBET00gb2Ygcm9vdEVsZW1lbnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290RWxlbWVudFxuICogQHJldHVybnMge0hUTUxFbGVtZW50W119IHNoYWRvdy1kb20gaG9zdHNcbiAqL1xuXG52YXIgZmluZEhvc3RFbGVtZW50cyA9IGZ1bmN0aW9uIGZpbmRIb3N0RWxlbWVudHMocm9vdEVsZW1lbnQpIHtcbiAgdmFyIGhvc3RzID0gW107IC8vIEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgpIHJldHVybnMgbGlzdCBvZiBlbGVtZW50c1xuICAvLyB3aGljaCBhcmUgZGVmaW5lZCBpbiBET00gb2YgRWxlbWVudC5cbiAgLy8gTWVhbndoaWxlLCBpbm5lciBET00gb2YgdGhlIGVsZW1lbnQgd2l0aCBzaGFkb3dSb290IHByb3BlcnR5XG4gIC8vIGlzIGFic29sdXRlbHkgYW5vdGhlciBET00gYW5kIHdoaWNoIGNhbiBub3QgYmUgcmVhY2hlZCBieSBxdWVyeVNlbGVjdG9yQWxsKCcqJylcblxuICB2YXIgZG9tRWxlbXMgPSByb290RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG4gIGRvbUVsZW1zLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLnNoYWRvd1Jvb3QpIHtcbiAgICAgIGhvc3RzLnB1c2goZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBob3N0cztcbn07XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBub2Rlcy5cbiAqXG4gKiBAZXh0ZXJuYWwgTm9kZUxpc3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlTGlzdCBOb2RlTGlzdH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBpZXJjZURhdGFcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gdGFyZ2V0cyBmb3VuZCBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3JcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gaW5uZXJIb3N0cyBpbm5lciBzaGFkb3ctZG9tIGhvc3RzXG4gKi9cblxuLyoqXG4gKiBQaWVyY2VzIG9wZW4gc2hhZG93LWRvbSBpbiBvcmRlciB0byBmaW5kOlxuICogLSBlbGVtZW50cyBieSAnc2VsZWN0b3InIG1hdGNoaW5nXG4gKiAtIGlubmVyIHNoYWRvdy1kb20gaG9zdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfGV4dGVybmFsOk5vZGVMaXN0fSBob3N0RWxlbWVudHNcbiAqIEByZXR1cm5zIHtQaWVyY2VEYXRhfVxuICovXG5cbnZhciBwaWVyY2VTaGFkb3dEb20gPSBmdW5jdGlvbiBwaWVyY2VTaGFkb3dEb20oc2VsZWN0b3IsIGhvc3RFbGVtZW50cykge1xuICB2YXIgdGFyZ2V0cyA9IFtdO1xuICB2YXIgaW5uZXJIb3N0c0FjYyA9IFtdOyAvLyBpdCdzIHBvc3NpYmxlIHRvIGdldCBhIGZldyBob3N0RWxlbWVudHMgZm91bmQgYnkgYmFzZVNlbGVjdG9yIG9uIHRoZSBwYWdlXG5cbiAgaG9zdEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAvLyBjaGVjayBwcmVzZW5jZSBvZiBzZWxlY3RvciBlbGVtZW50IGluc2lkZSBiYXNlIGVsZW1lbnQgaWYgaXQncyBub3QgaW4gc2hhZG93LWRvbVxuICAgIHZhciBzaW1wbGVFbGVtcyA9IGhvc3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KFtdLnNsaWNlLmNhbGwoc2ltcGxlRWxlbXMpKTtcbiAgICB2YXIgc2hhZG93Um9vdEVsZW0gPSBob3N0LnNoYWRvd1Jvb3Q7XG4gICAgdmFyIHNoYWRvd0NoaWxkcmVuID0gc2hhZG93Um9vdEVsZW0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KFtdLnNsaWNlLmNhbGwoc2hhZG93Q2hpbGRyZW4pKTsgLy8gZmluZCBpbm5lciBzaGFkb3ctZG9tIGhvc3RzIGluc2lkZSBwcm9jZXNzaW5nIHNoYWRvdy1kb21cblxuICAgIGlubmVySG9zdHNBY2MucHVzaChmaW5kSG9zdEVsZW1lbnRzKHNoYWRvd1Jvb3RFbGVtKSk7XG4gIH0pOyAvLyBpZiB0aGVyZSB3ZXJlIG1vcmUgdGhhbiBvbmUgaG9zdCBlbGVtZW50LFxuICAvLyBpbm5lckhvc3RzQWNjIGlzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgc2hvdWxkIGJlIGZsYXR0ZW5cblxuICB2YXIgaW5uZXJIb3N0cyA9IGZsYXR0ZW4oaW5uZXJIb3N0c0FjYyk7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0czogdGFyZ2V0cyxcbiAgICBpbm5lckhvc3RzOiBpbm5lckhvc3RzXG4gIH07XG59O1xuXG4vKipcbiAqIFByZXBhcmVzIGNvb2tpZSBzdHJpbmcgaWYgZ2l2ZW4gcGFyYW1ldGVycyBhcmUgb2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvb2tpZSBuYW1lIHRvIHNldFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIGNvb2tpZSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gY29va2llIHN0cmluZyBpZiBvayBPUiBudWxsIGlmIG5vdFxuICovXG5cbnZhciBwcmVwYXJlQ29va2llID0gZnVuY3Rpb24gcHJlcGFyZUNvb2tpZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIW5hbWUgfHwgIXZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgdmFsdWVUb1NldDtcblxuICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIHZhbHVlVG9TZXQgPSAndHJ1ZSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdUcnVlJykge1xuICAgIHZhbHVlVG9TZXQgPSAnVHJ1ZSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ2ZhbHNlJztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ0ZhbHNlJykge1xuICAgIHZhbHVlVG9TZXQgPSAnRmFsc2UnO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAneWVzJykge1xuICAgIHZhbHVlVG9TZXQgPSAneWVzJztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ1llcycpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ1llcyc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdZJykge1xuICAgIHZhbHVlVG9TZXQgPSAnWSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdubycpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ25vJztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ29rJykge1xuICAgIHZhbHVlVG9TZXQgPSAnb2snO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnT0snKSB7XG4gICAgdmFsdWVUb1NldCA9ICdPSyc7XG4gIH0gZWxzZSBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICB2YWx1ZVRvU2V0ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICBpZiAobmF0aXZlSXNOYU4odmFsdWVUb1NldCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh2YWx1ZVRvU2V0KSA8IDAgfHwgTWF0aC5hYnModmFsdWVUb1NldCkgPiAxNSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhdGhUb1NldCA9ICdwYXRoPS87JztcbiAgdmFyIGNvb2tpZURhdGEgPSBcIlwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQobmFtZSksIFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlVG9TZXQpLCBcIjsgXCIpLmNvbmNhdChwYXRoVG9TZXQpO1xuICByZXR1cm4gY29va2llRGF0YTtcbn07XG5cbnZhciBzaG91bGRNYXRjaEFueURlbGF5ID0gZnVuY3Rpb24gc2hvdWxkTWF0Y2hBbnlEZWxheShkZWxheSkge1xuICByZXR1cm4gZGVsYXkgPT09IGdldFdpbGRjYXJkU3ltYm9sKCk7XG59O1xuLyoqXG4gKiBIYW5kbGVzIGlucHV0IGRlbGF5IHZhbHVlXG4gKiBAcGFyYW0geyp9IGRlbGF5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBwcm9wZXIgbnVtYmVyIGRlbGF5IHZhbHVlXG4gKi9cblxudmFyIGdldE1hdGNoRGVsYXkgPSBmdW5jdGlvbiBnZXRNYXRjaERlbGF5KGRlbGF5KSB7XG4gIHZhciBERUZBVUxUX0RFTEFZID0gMTAwMDtcbiAgdmFyIHBhcnNlZERlbGF5ID0gcGFyc2VJbnQoZGVsYXksIDEwKTtcbiAgdmFyIGRlbGF5TWF0Y2ggPSBuYXRpdmVJc05hTihwYXJzZWREZWxheSkgPyBERUZBVUxUX0RFTEFZIC8vIGRlZmF1bHQgc2NyaXB0bGV0IHZhbHVlXG4gIDogcGFyc2VkRGVsYXk7XG4gIHJldHVybiBkZWxheU1hdGNoO1xufTtcbi8qKlxuICogQ2hlY2tzIGRlbGF5IG1hdGNoIGNvbmRpdGlvblxuICogQHBhcmFtIHsqfSBpbnB1dERlbGF5XG4gKiBAcGFyYW0ge251bWJlcn0gcmVhbERlbGF5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgaXNEZWxheU1hdGNoZWQgPSBmdW5jdGlvbiBpc0RlbGF5TWF0Y2hlZChpbnB1dERlbGF5LCByZWFsRGVsYXkpIHtcbiAgcmV0dXJuIHNob3VsZE1hdGNoQW55RGVsYXkoaW5wdXREZWxheSkgfHwgcmVhbERlbGF5ID09PSBnZXRNYXRjaERlbGF5KGlucHV0RGVsYXkpO1xufTtcbi8qKlxuICogSGFuZGxlcyBpbnB1dCBib29zdCB2YWx1ZVxuICogQHBhcmFtIHsqfSBib29zdFxuICogQHJldHVybnMge251bWJlcn0gcHJvcGVyIG51bWJlciBib29zdCBtdWx0aXBsaWVyIHZhbHVlXG4gKi9cblxudmFyIGdldEJvb3N0TXVsdGlwbGllciA9IGZ1bmN0aW9uIGdldEJvb3N0TXVsdGlwbGllcihib29zdCkge1xuICB2YXIgREVGQVVMVF9NVUxUSVBMSUVSID0gMC4wNTtcbiAgdmFyIE1JTl9NVUxUSVBMSUVSID0gMC4wMjtcbiAgdmFyIE1BWF9NVUxUSVBMSUVSID0gNTA7XG4gIHZhciBwYXJzZWRCb29zdCA9IHBhcnNlRmxvYXQoYm9vc3QpO1xuICB2YXIgYm9vc3RNdWx0aXBsaWVyID0gbmF0aXZlSXNOYU4ocGFyc2VkQm9vc3QpIHx8ICFuYXRpdmVJc0Zpbml0ZShwYXJzZWRCb29zdCkgPyBERUZBVUxUX01VTFRJUExJRVIgLy8gZGVmYXVsdCBzY3JpcHRsZXQgdmFsdWVcbiAgOiBwYXJzZWRCb29zdDtcblxuICBpZiAoYm9vc3RNdWx0aXBsaWVyIDwgTUlOX01VTFRJUExJRVIpIHtcbiAgICBib29zdE11bHRpcGxpZXIgPSBNSU5fTVVMVElQTElFUjtcbiAgfVxuXG4gIGlmIChib29zdE11bHRpcGxpZXIgPiBNQVhfTVVMVElQTElFUikge1xuICAgIGJvb3N0TXVsdGlwbGllciA9IE1BWF9NVUxUSVBMSUVSO1xuICB9XG5cbiAgcmV0dXJuIGJvb3N0TXVsdGlwbGllcjtcbn07XG5cbi8qKlxuICogQ29sbGVjdHMgUmVxdWVzdCBvcHRpb25zIHRvIG9iamVjdFxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkYXRhIG9iamVjdFxuICovXG5cbnZhciBnZXRSZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uIGdldFJlcXVlc3REYXRhKHJlcXVlc3QpIHtcbiAgdmFyIFJFUVVFU1RfSU5JVF9PUFRJT05TID0gWyd1cmwnLCAnbWV0aG9kJywgJ2hlYWRlcnMnLCAnYm9keScsICdtb2RlJywgJ2NyZWRlbnRpYWxzJywgJ2NhY2hlJywgJ3JlZGlyZWN0JywgJ3JlZmVycmVyJywgJ2ludGVncml0eSddO1xuICB2YXIgZW50cmllcyA9IFJFUVVFU1RfSU5JVF9PUFRJT05TLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgLy8gaWYgcmVxdWVzdCBoYXMgbm8gc3VjaCBvcHRpb24sIHZhbHVlIHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgdmFyIHZhbHVlID0gcmVxdWVzdFtrZXldO1xuICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gZ2V0T2JqZWN0RnJvbUVudHJpZXMoZW50cmllcyk7XG59O1xuLyoqXG4gKiBDb2xsZWN0cyBmZXRjaCBhcmdzIHRvIG9iamVjdFxuICogQHBhcmFtIHsqfSBhcmdzIGZldGNoIGFyZ3NcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRhdGEgb2JqZWN0XG4gKi9cblxudmFyIGdldEZldGNoRGF0YSA9IGZ1bmN0aW9uIGdldEZldGNoRGF0YShhcmdzKSB7XG4gIHZhciBmZXRjaFByb3BzT2JqID0ge307XG4gIHZhciBmZXRjaFVybDtcbiAgdmFyIGZldGNoSW5pdDtcblxuICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAvLyBpZiBSZXF1ZXN0IHBhc3NlZCB0byBmZXRjaCwgaXQgd2lsbCBiZSBpbiBhcnJheVxuICAgIHZhciByZXF1ZXN0RGF0YSA9IGdldFJlcXVlc3REYXRhKGFyZ3NbMF0pO1xuICAgIGZldGNoVXJsID0gcmVxdWVzdERhdGEudXJsO1xuICAgIGZldGNoSW5pdCA9IHJlcXVlc3REYXRhO1xuICB9IGVsc2Uge1xuICAgIGZldGNoVXJsID0gYXJnc1swXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gICAgZmV0Y2hJbml0ID0gYXJnc1sxXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICB9XG5cbiAgZmV0Y2hQcm9wc09iai51cmwgPSBmZXRjaFVybDtcblxuICBpZiAoZmV0Y2hJbml0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgT2JqZWN0LmtleXMoZmV0Y2hJbml0KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBmZXRjaFByb3BzT2JqW3Byb3BdID0gZmV0Y2hJbml0W3Byb3BdO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZldGNoUHJvcHNPYmo7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBwcmV2ZW50LWZldGNoIHByb3BzVG9NYXRjaCBpbnB1dCBzdHJpbmcgdG8gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHNUb01hdGNoU3RyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2hlcmUgJ2tleScgaXMgcHJvcCBuYW1lIGFuZCAndmFsdWUnIGlzIHByb3AgdmFsdWVcbiAqL1xuXG52YXIgY29udmVydE1hdGNoUHJvcHNUb09iaiA9IGZ1bmN0aW9uIGNvbnZlcnRNYXRjaFByb3BzVG9PYmoocHJvcHNUb01hdGNoU3RyKSB7XG4gIHZhciBQUk9QU19ESVZJREVSID0gJyAnO1xuICB2YXIgUEFJUlNfTUFSS0VSID0gJzonO1xuICB2YXIgcHJvcHNPYmogPSB7fTtcbiAgdmFyIHByb3BzID0gcHJvcHNUb01hdGNoU3RyLnNwbGl0KFBST1BTX0RJVklERVIpO1xuICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIGRpdmlkZXJJbmQgPSBwcm9wLmluZGV4T2YoUEFJUlNfTUFSS0VSKTtcblxuICAgIGlmIChkaXZpZGVySW5kID09PSAtMSkge1xuICAgICAgcHJvcHNPYmoudXJsID0gdG9SZWdFeHAocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wLnNsaWNlKDAsIGRpdmlkZXJJbmQpO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcC5zbGljZShkaXZpZGVySW5kICsgMSk7XG4gICAgICBwcm9wc09ialtrZXldID0gdG9SZWdFeHAodmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm9wc09iajtcbn07XG5cbnZhciBoYW5kbGVPbGRSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGhhbmRsZU9sZFJlcGxhY2VtZW50KHJlcGxhY2VtZW50KSB7XG4gIHZhciByZXN1bHQ7IC8vIGRlZmF1bHRzIHRvIHJldHVybiBub29wRnVuYyBpbnN0ZWFkIG9mIHdpbmRvdy5vcGVuXG5cbiAgaWYgKCFyZXBsYWNlbWVudCkge1xuICAgIHJlc3VsdCA9IG5vb3BGdW5jO1xuICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSAndHJ1ZUZ1bmMnKSB7XG4gICAgcmVzdWx0ID0gdHJ1ZUZ1bmM7XG4gIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQuaW5kZXhPZignPScpID4gLTEpIHtcbiAgICAvLyBXZSBzaG91bGQgcmV0dXJuIG5vb3BGdW5jIGluc3RlYWQgb2Ygd2luZG93Lm9wZW5cbiAgICAvLyBidXQgd2l0aCBzb21lIHByb3BlcnR5IGlmIHdlYnNpdGUgY2hlY2tzIGl0IChleGFtcGxlcyA1LCA2KVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy83MVxuICAgIHZhciBpc1Byb3AgPSBzdGFydHNXaXRoKHJlcGxhY2VtZW50LCAneycpICYmIGVuZHNXaXRoKHJlcGxhY2VtZW50LCAnfScpO1xuXG4gICAgaWYgKGlzUHJvcCkge1xuICAgICAgdmFyIHByb3BlcnR5UGFydCA9IHJlcGxhY2VtZW50LnNsaWNlKDEsIC0xKTtcbiAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBzdWJzdHJpbmdCZWZvcmUocHJvcGVydHlQYXJ0LCAnPScpO1xuICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBzdWJzdHJpbmdBZnRlcihwcm9wZXJ0eVBhcnQsICc9Jyk7XG5cbiAgICAgIGlmIChwcm9wZXJ0eVZhbHVlID09PSAnbm9vcEZ1bmMnKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbcHJvcGVydHlOYW1lXSA9IG5vb3BGdW5jO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGNyZWF0ZURlY295ID0gZnVuY3Rpb24gY3JlYXRlRGVjb3koYXJncykge1xuICB2YXIgT0JKRUNUX1RBR19OQU1FID0gJ29iamVjdCc7XG4gIHZhciBPQkpFQ1RfVVJMX1BST1BfTkFNRSA9ICdkYXRhJztcbiAgdmFyIElGUkFNRV9UQUdfTkFNRSA9ICdpZnJhbWUnO1xuICB2YXIgSUZSQU1FX1VSTF9QUk9QX05BTUUgPSAnc3JjJztcbiAgdmFyIHJlcGxhY2VtZW50ID0gYXJncy5yZXBsYWNlbWVudCxcbiAgICAgIHVybCA9IGFyZ3MudXJsLFxuICAgICAgZGVsYXkgPSBhcmdzLmRlbGF5O1xuICB2YXIgdGFnO1xuICB2YXIgdXJsUHJvcDtcblxuICBpZiAocmVwbGFjZW1lbnQgPT09ICdvYmonKSB7XG4gICAgdGFnID0gT0JKRUNUX1RBR19OQU1FO1xuICAgIHVybFByb3AgPSBPQkpFQ1RfVVJMX1BST1BfTkFNRTtcbiAgfSBlbHNlIHtcbiAgICB0YWcgPSBJRlJBTUVfVEFHX05BTUU7XG4gICAgdXJsUHJvcCA9IElGUkFNRV9VUkxfUFJPUF9OQU1FO1xuICB9XG5cbiAgdmFyIGRlY295ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBkZWNveVt1cmxQcm9wXSA9IHVybDtcbiAgZGVjb3kuc3R5bGUuc2V0UHJvcGVydHkoJ2hlaWdodCcsICcxcHgnLCAnaW1wb3J0YW50Jyk7XG4gIGRlY295LnN0eWxlLnNldFByb3BlcnR5KCdwb3NpdGlvbicsICdmaXhlZCcsICdpbXBvcnRhbnQnKTtcbiAgZGVjb3kuc3R5bGUuc2V0UHJvcGVydHkoJ3RvcCcsICctMXB4JywgJ2ltcG9ydGFudCcpO1xuICBkZWNveS5zdHlsZS5zZXRQcm9wZXJ0eSgnd2lkdGgnLCAnMXB4JywgJ2ltcG9ydGFudCcpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRlY295KTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlY295LnJlbW92ZSgpO1xuICB9LCBkZWxheSAqIDEwMDApO1xuICByZXR1cm4gZGVjb3k7XG59O1xudmFyIGdldFByZXZlbnRHZXR0ZXIgPSBmdW5jdGlvbiBnZXRQcmV2ZW50R2V0dGVyKG5hdGl2ZUdldHRlcikge1xuICB2YXIgcHJldmVudEdldHRlciA9IGZ1bmN0aW9uIHByZXZlbnRHZXR0ZXIodGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKHByb3AgJiYgcHJvcCA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUdldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5vb3BGdW5jO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wICYmIHRhcmdldFtwcm9wXTtcbiAgfTtcblxuICByZXR1cm4gcHJldmVudEdldHRlcjtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciB2YWxpZGF0ZVR5cGUgPSBmdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTI1XG4gIHJldHVybiB0eXBlb2YgdHlwZSAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgZXZlbnQgbGlzdGVuZXJcbiAqIEBwYXJhbSB7Kn0gbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbnZhciB2YWxpZGF0ZUxpc3RlbmVyID0gZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNwYXJhbWV0ZXJzXG4gIHJldHVybiB0eXBlb2YgbGlzdGVuZXIgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvNzZcbiAgJiYgbGlzdGVuZXIgIT09IG51bGwgJiYgdHlwZW9mIGxpc3RlbmVyLmhhbmRsZUV2ZW50ID09PSAnZnVuY3Rpb24nKTtcbn07XG4vKipcbiAqIFNlcmlhbGl6ZSB2YWxpZCBldmVudCBsaXN0ZW5lclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50TGlzdGVuZXJcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gbGlzdGVuZXIgdmFsaWQgbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIGxpc3RlbmVyVG9TdHJpbmcgPSBmdW5jdGlvbiBsaXN0ZW5lclRvU3RyaW5nKGxpc3RlbmVyKSB7XG4gIHJldHVybiB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgPyBsaXN0ZW5lci50b1N0cmluZygpIDogbGlzdGVuZXIuaGFuZGxlRXZlbnQudG9TdHJpbmcoKTtcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIG11c3QgZXhwb3J0IGFsbCB1c2VkIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBkZXBlbmRlbmNpZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldFdpbGRjYXJkU3ltYm9sOiBnZXRXaWxkY2FyZFN5bWJvbCxcbiAgICByYW5kb21JZDogcmFuZG9tSWQsXG4gICAgc2V0UHJvcGVydHlBY2Nlc3M6IHNldFByb3BlcnR5QWNjZXNzLFxuICAgIGdldFByb3BlcnR5SW5DaGFpbjogZ2V0UHJvcGVydHlJbkNoYWluLFxuICAgIGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluOiBnZXRXaWxkY2FyZFByb3BlcnR5SW5DaGFpbixcbiAgICByZXBsYWNlQWxsOiByZXBsYWNlQWxsLFxuICAgIGVzY2FwZVJlZ0V4cDogZXNjYXBlUmVnRXhwLFxuICAgIHRvUmVnRXhwOiB0b1JlZ0V4cCxcbiAgICBnZXRCZWZvcmVSZWdFeHA6IGdldEJlZm9yZVJlZ0V4cCxcbiAgICBzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuICAgIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgICBzdWJzdHJpbmdBZnRlcjogc3Vic3RyaW5nQWZ0ZXIsXG4gICAgc3Vic3RyaW5nQmVmb3JlOiBzdWJzdHJpbmdCZWZvcmUsXG4gICAgd3JhcEluU2luZ2xlUXVvdGVzOiB3cmFwSW5TaW5nbGVRdW90ZXMsXG4gICAgZ2V0U3RyaW5nSW5CcmFjZXM6IGdldFN0cmluZ0luQnJhY2VzLFxuICAgIGNvbnZlcnRSdGNDb25maWdUb1N0cmluZzogY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nLFxuICAgIHBhcnNlTWF0Y2hBcmc6IHBhcnNlTWF0Y2hBcmcsXG4gICAgcGFyc2VEZWxheUFyZzogcGFyc2VEZWxheUFyZyxcbiAgICBvYmplY3RUb1N0cmluZzogb2JqZWN0VG9TdHJpbmcsXG4gICAgY29udmVydFR5cGVUb1N0cmluZzogY29udmVydFR5cGVUb1N0cmluZyxcbiAgICBjcmVhdGVPbkVycm9ySGFuZGxlcjogY3JlYXRlT25FcnJvckhhbmRsZXIsXG4gICAgbm9vcEZ1bmM6IG5vb3BGdW5jLFxuICAgIG5vb3BOdWxsOiBub29wTnVsbCxcbiAgICB0cnVlRnVuYzogdHJ1ZUZ1bmMsXG4gICAgZmFsc2VGdW5jOiBmYWxzZUZ1bmMsXG4gICAgbm9vcFRoaXM6IG5vb3BUaGlzLFxuICAgIG5vb3BTdHI6IG5vb3BTdHIsXG4gICAgbm9vcEFycmF5OiBub29wQXJyYXksXG4gICAgbm9vcE9iamVjdDogbm9vcE9iamVjdCxcbiAgICBub29wUHJvbWlzZVJlamVjdDogbm9vcFByb21pc2VSZWplY3QsXG4gICAgbm9vcFByb21pc2VSZXNvbHZlOiBub29wUHJvbWlzZVJlc29sdmUsXG4gICAgaGl0OiBoaXQsXG4gICAgb2JzZXJ2ZURPTUNoYW5nZXM6IG9ic2VydmVET01DaGFuZ2VzLFxuICAgIG1hdGNoU3RhY2tUcmFjZTogbWF0Y2hTdGFja1RyYWNlLFxuICAgIGZpbmRIb3N0RWxlbWVudHM6IGZpbmRIb3N0RWxlbWVudHMsXG4gICAgcGllcmNlU2hhZG93RG9tOiBwaWVyY2VTaGFkb3dEb20sXG4gICAgZmxhdHRlbjogZmxhdHRlbixcbiAgICBwcmVwYXJlQ29va2llOiBwcmVwYXJlQ29va2llLFxuICAgIG5hdGl2ZUlzTmFOOiBuYXRpdmVJc05hTixcbiAgICBuYXRpdmVJc0Zpbml0ZTogbmF0aXZlSXNGaW5pdGUsXG4gICAgc2hvdWxkTWF0Y2hBbnlEZWxheTogc2hvdWxkTWF0Y2hBbnlEZWxheSxcbiAgICBnZXRNYXRjaERlbGF5OiBnZXRNYXRjaERlbGF5LFxuICAgIGlzRGVsYXlNYXRjaGVkOiBpc0RlbGF5TWF0Y2hlZCxcbiAgICBnZXRCb29zdE11bHRpcGxpZXI6IGdldEJvb3N0TXVsdGlwbGllcixcbiAgICBnZXRSZXF1ZXN0RGF0YTogZ2V0UmVxdWVzdERhdGEsXG4gICAgZ2V0RmV0Y2hEYXRhOiBnZXRGZXRjaERhdGEsXG4gICAgY29udmVydE1hdGNoUHJvcHNUb09iajogY29udmVydE1hdGNoUHJvcHNUb09iaixcbiAgICBnZXRPYmplY3RFbnRyaWVzOiBnZXRPYmplY3RFbnRyaWVzLFxuICAgIGdldE9iamVjdEZyb21FbnRyaWVzOiBnZXRPYmplY3RGcm9tRW50cmllcyxcbiAgICBpc0VtcHR5T2JqZWN0OiBpc0VtcHR5T2JqZWN0LFxuICAgIGhhbmRsZU9sZFJlcGxhY2VtZW50OiBoYW5kbGVPbGRSZXBsYWNlbWVudCxcbiAgICBjcmVhdGVEZWNveTogY3JlYXRlRGVjb3ksXG4gICAgZ2V0UHJldmVudEdldHRlcjogZ2V0UHJldmVudEdldHRlcixcbiAgICB2YWxpZGF0ZVR5cGU6IHZhbGlkYXRlVHlwZSxcbiAgICB2YWxpZGF0ZUxpc3RlbmVyOiB2YWxpZGF0ZUxpc3RlbmVyLFxuICAgIGxpc3RlbmVyVG9TdHJpbmc6IGxpc3RlbmVyVG9TdHJpbmdcbn0pO1xuXG4vKipcbiAqIENvbmNhdCBkZXBlbmRlbmNpZXMgdG8gc2NyaXB0bGV0IGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRsZXQgc3RyaW5nIHZpZXcgb2Ygc2NyaXB0bGV0XG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoRGVwZW5kZW5jaWVzKHNjcmlwdGxldCkge1xuICB2YXIgX3NjcmlwdGxldCRpbmplY3Rpb25zID0gc2NyaXB0bGV0LmluamVjdGlvbnMsXG4gICAgICBpbmplY3Rpb25zID0gX3NjcmlwdGxldCRpbmplY3Rpb25zID09PSB2b2lkIDAgPyBbXSA6IF9zY3JpcHRsZXQkaW5qZWN0aW9ucztcbiAgcmV0dXJuIGluamVjdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgZGVwKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGFjY3VtLCBcIlxcblwiKS5jb25jYXQoZGVwZW5kZW5jaWVzW2RlcC5uYW1lXSk7XG4gIH0sIHNjcmlwdGxldC50b1N0cmluZygpKTtcbn1cbi8qKlxuICogQWRkIHNjcmlwdGxldCBjYWxsIHRvIGV4aXN0aW5nIGNvZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNjcmlwdGxldFxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqL1xuXG5mdW5jdGlvbiBhZGRDYWxsKHNjcmlwdGxldCwgY29kZSkge1xuICByZXR1cm4gXCJcIi5jb25jYXQoY29kZSwgXCI7XFxuICAgICAgICBjb25zdCB1cGRhdGVkQXJncyA9IGFyZ3MgPyBbXS5jb25jYXQoc291cmNlKS5jb25jYXQoYXJncykgOiBbc291cmNlXTtcXG4gICAgICAgIFwiKS5jb25jYXQoc2NyaXB0bGV0Lm5hbWUsIFwiLmFwcGx5KHRoaXMsIHVwZGF0ZWRBcmdzKTtcXG4gICAgXCIpO1xufVxuLyoqXG4gKiBXcmFwIGZ1bmN0aW9uIGludG8gSUlGRSAoSW1tZWRpYXRlbHkgaW52b2tlZCBmdW5jdGlvbiBleHByZXNzaW9uKVxuICpcbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2UgLSBvYmplY3Qgd2l0aCBzY3JpcHRsZXQgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSBzY3JpcHRsZXQgc291cmNlIGNvZGUgd2l0aCBkZXBlbmRlbmNpZXNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBmdWxsIHNjcmlwdGxldCBjb2RlXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNvdXJjZSA9IHtcbiAqICAgICAgYXJnczogW1wiYWFhXCIsIFwiYmJiXCJdLFxuICogICAgICBuYW1lOiAnbm9ldmFsJyxcbiAqIH07XG4gKiBjb25zdCBjb2RlID0gXCJmdW5jdGlvbiBub2V2YWwoc291cmNlLCBhcmdzKSB7IGFsZXJ0KHNvdXJjZSk7IH0gbm9ldmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1wiXG4gKiBjb25zdCByZXN1bHQgPSB3cmFwSW5JSUZFKHNvdXJjZSwgY29kZSk7XG4gKlxuICogLy8gcmVzdWx0XG4gKiBgKGZ1bmN0aW9uKHNvdXJjZSwgYXJncykge1xuICogICAgICBmdW5jdGlvbiBub2V2YWwoc291cmNlKSB7IGFsZXJ0KHNvdXJjZSk7IH1cbiAqICAgICAgbm9ldmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICogKSh7XCJhcmdzXCI6IFtcImFhYVwiLCBcImJiYlwiXSwgXCJuYW1lXCI6XCJub2V2YWxcIn0sIFtcImFhYVwiLCBcImJiYlwiXSlgXG4gKi9cblxuZnVuY3Rpb24gcGFzc1NvdXJjZUFuZFByb3BzKHNvdXJjZSwgY29kZSkge1xuICBpZiAoc291cmNlLmhpdCkge1xuICAgIHNvdXJjZS5oaXQgPSBzb3VyY2UuaGl0LnRvU3RyaW5nKCk7XG4gIH1cblxuICB2YXIgc291cmNlU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoc291cmNlKTtcbiAgdmFyIGFyZ3NTdHJpbmcgPSBzb3VyY2UuYXJncyA/IFwiW1wiLmNvbmNhdChzb3VyY2UuYXJncy5tYXAoSlNPTi5zdHJpbmdpZnkpLCBcIl1cIikgOiB1bmRlZmluZWQ7XG4gIHZhciBwYXJhbXMgPSBhcmdzU3RyaW5nID8gXCJcIi5jb25jYXQoc291cmNlU3RyaW5nLCBcIiwgXCIpLmNvbmNhdChhcmdzU3RyaW5nKSA6IHNvdXJjZVN0cmluZztcbiAgcmV0dXJuIFwiKGZ1bmN0aW9uKHNvdXJjZSwgYXJncyl7XFxuXCIuY29uY2F0KGNvZGUsIFwiXFxufSkoXCIpLmNvbmNhdChwYXJhbXMsIFwiKTtcIik7XG59XG4vKipcbiAqIFdyYXAgY29kZSBpbiBubyBuYW1lIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSB3aGljaCBtdXN0IGJlIHdyYXBwZWRcbiAqL1xuXG5mdW5jdGlvbiB3cmFwSW5Ob25hbWVGdW5jKGNvZGUpIHtcbiAgcmV0dXJuIFwiZnVuY3Rpb24oc291cmNlLCBhcmdzKXtcXG5cIi5jb25jYXQoY29kZSwgXCJcXG59XCIpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGRlZmluZVByb3BlcnR5ID0gX2RlZmluZVByb3BlcnR5O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBpdGVyYWJsZSBhcmd1bWVudCBhbmQgZXZhbHVhdGUgY3VycmVudCBzdGF0ZSB3aXRoIHRyYW5zaXRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5pdCBmaXJzdCB0cmFuc2l0aW9uIG5hbWVcbiAqIEBwYXJhbSB7QXJyYXl8Q29sbGVjdGlvbnxzdHJpbmd9IGl0ZXJhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbnMgdHJhbnN0aW9uIGZ1bmN0aW9uc1xuICogQHBhcmFtIHthbnl9IGFyZ3MgYXJndW1lbnRzIHdoaWNoIHNob3VsZCBiZSBwYXNzZWQgdG8gdHJhbnNpdGlvbiBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gaXRlcmF0ZVdpdGhUcmFuc2l0aW9ucyhpdGVyYWJsZSwgdHJhbnNpdGlvbnMsIGluaXQsIGFyZ3MpIHtcbiAgdmFyIHN0YXRlID0gaW5pdCB8fCBPYmplY3Qua2V5cyh0cmFuc2l0aW9ucylbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHN0YXRlID0gdHJhbnNpdGlvbnNbc3RhdGVdKGl0ZXJhYmxlLCBpLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbi8qKlxuICogQWRHdWFyZCBzY3JpcHRsZXQgcnVsZSBtYXNrXG4gKi9cblxuXG52YXIgQURHX1NDUklQVExFVF9NQVNLID0gJyMvL3NjcmlwdGxldCc7XG4vKipcbiAqIEhlbHBlciB0byBhY2N1bXVsYXRlIGFuIGFycmF5IG9mIHN0cmluZ3MgY2hhciBieSBjaGFyXG4gKi9cblxudmFyIHdvcmRTYXZlciA9IGZ1bmN0aW9uIHdvcmRTYXZlcigpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgc3RycyA9IFtdO1xuXG4gIHZhciBzYXZlU3ltYiA9IGZ1bmN0aW9uIHNhdmVTeW1iKHMpIHtcbiAgICBzdHIgKz0gcztcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHZhciBzYXZlU3RyID0gZnVuY3Rpb24gc2F2ZVN0cigpIHtcbiAgICBzdHJzLnB1c2goc3RyKTtcbiAgICBzdHIgPSAnJztcbiAgfTtcblxuICB2YXIgZ2V0QWxsID0gZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoc3Rycyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzYXZlU3ltYjogc2F2ZVN5bWIsXG4gICAgc2F2ZVN0cjogc2F2ZVN0cixcbiAgICBnZXRBbGw6IGdldEFsbFxuICB9O1xufTtcblxudmFyIHN1YnN0cmluZ0FmdGVyJDEgPSBmdW5jdGlvbiBzdWJzdHJpbmdBZnRlcihzdHIsIHNlcGFyYXRvcikge1xuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZihzZXBhcmF0b3IpO1xuICByZXR1cm4gaW5kZXggPCAwID8gJycgOiBzdHIuc3Vic3RyaW5nKGluZGV4ICsgc2VwYXJhdG9yLmxlbmd0aCk7XG59O1xuLyoqXG4gKiBQYXJzZSBhbmQgdmFsaWRhdGUgc2NyaXB0bGV0IHJ1bGVcbiAqIEBwYXJhbSB7Kn0gcnVsZVRleHRcbiAqIEByZXR1cm5zIHt7bmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxzdHJpbmc+fX1cbiAqL1xuXG5cbnZhciBwYXJzZVJ1bGUgPSBmdW5jdGlvbiBwYXJzZVJ1bGUocnVsZVRleHQpIHtcbiAgdmFyIF90cmFuc2l0aW9ucztcblxuICBydWxlVGV4dCA9IHN1YnN0cmluZ0FmdGVyJDEocnVsZVRleHQsIEFER19TQ1JJUFRMRVRfTUFTSyk7XG4gIC8qKlxuICAgKiBUcmFuc2l0aW9uIG5hbWVzXG4gICAqL1xuXG4gIHZhciBUUkFOU0lUSU9OID0ge1xuICAgIE9QRU5FRDogJ29wZW5lZCcsXG4gICAgUEFSQU06ICdwYXJhbScsXG4gICAgQ0xPU0VEOiAnY2xvc2VkJ1xuICB9O1xuICAvKipcbiAgICogVHJhbnNpdGlvbiBmdW5jdGlvbjogdGhlIGN1cnJlbnQgaW5kZXggcG9zaXRpb24gaW4gc3RhcnQsIGVuZCBvciBiZXR3ZWVuIHBhcmFtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IE9iamVjdFxuICAgKiBAcHJvcGVydHkge09iamVjdH0gT2JqZWN0LnNlcCBjb250YWlucyBwcm9wIHN5bWIgd2l0aCBjdXJyZW50IHNlcGFyYXRvciBjaGFyXG4gICAqL1xuXG4gIHZhciBvcGVuZWQgPSBmdW5jdGlvbiBvcGVuZWQocnVsZSwgaW5kZXgsIF9yZWYpIHtcbiAgICB2YXIgc2VwID0gX3JlZi5zZXA7XG4gICAgdmFyIGNoYXIgPSBydWxlW2luZGV4XTtcbiAgICB2YXIgdHJhbnNpdGlvbjtcblxuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSAnICc6XG4gICAgICBjYXNlICcoJzpcbiAgICAgIGNhc2UgJywnOlxuICAgICAgICB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IFRSQU5TSVRJT04uT1BFTkVEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ1xcJyc6XG4gICAgICBjYXNlICdcIic6XG4gICAgICAgIHtcbiAgICAgICAgICBzZXAuc3ltYiA9IGNoYXI7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IFRSQU5TSVRJT04uUEFSQU07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gaW5kZXggPT09IHJ1bGUubGVuZ3RoIC0gMSA/IFRSQU5TSVRJT04uQ0xPU0VEIDogVFJBTlNJVElPTi5PUEVORUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJ1bGUgaXMgbm90IGEgc2NyaXB0bGV0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNpdGlvbjtcbiAgfTtcbiAgLyoqXG4gICAqIFRyYW5zaXRpb24gZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4IHBvc2l0aW9uIGluc2lkZSBwYXJhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IE9iamVjdFxuICAgKiBAcHJvcGVydHkge09iamVjdH0gT2JqZWN0LnNlcCBjb250YWlucyBwcm9wIGBzeW1iYCB3aXRoIGN1cnJlbnQgc2VwYXJhdG9yIGNoYXJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IE9iamVjdC5zYXZlciBoZWxwZXIgd2hpY2ggYWxsb3cgdG8gc2F2ZSBzdHJpbmdzIGJ5IGNhciBieSBjaGFyXG4gICAqL1xuXG5cbiAgdmFyIHBhcmFtID0gZnVuY3Rpb24gcGFyYW0ocnVsZSwgaW5kZXgsIF9yZWYyKSB7XG4gICAgdmFyIHNhdmVyID0gX3JlZjIuc2F2ZXIsXG4gICAgICAgIHNlcCA9IF9yZWYyLnNlcDtcbiAgICB2YXIgY2hhciA9IHJ1bGVbaW5kZXhdO1xuXG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlICdcXCcnOlxuICAgICAgY2FzZSAnXCInOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZUluZGV4ID0gaW5kZXggLSAxO1xuICAgICAgICAgIHZhciBiZWZvcmUgPSBydWxlW3ByZUluZGV4XTtcblxuICAgICAgICAgIGlmIChjaGFyID09PSBzZXAuc3ltYiAmJiBiZWZvcmUgIT09ICdcXFxcJykge1xuICAgICAgICAgICAgc2VwLnN5bWIgPSBudWxsO1xuICAgICAgICAgICAgc2F2ZXIuc2F2ZVN0cigpO1xuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT04uT1BFTkVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYXZlci5zYXZlU3ltYihjaGFyKTtcbiAgICAgICAgICByZXR1cm4gVFJBTlNJVElPTi5QQVJBTTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbnMgPSAoX3RyYW5zaXRpb25zID0ge30sIGRlZmluZVByb3BlcnR5KF90cmFuc2l0aW9ucywgVFJBTlNJVElPTi5PUEVORUQsIG9wZW5lZCksIGRlZmluZVByb3BlcnR5KF90cmFuc2l0aW9ucywgVFJBTlNJVElPTi5QQVJBTSwgcGFyYW0pLCBkZWZpbmVQcm9wZXJ0eShfdHJhbnNpdGlvbnMsIFRSQU5TSVRJT04uQ0xPU0VELCBmdW5jdGlvbiAoKSB7fSksIF90cmFuc2l0aW9ucyk7XG4gIHZhciBzZXAgPSB7XG4gICAgc3ltYjogbnVsbFxuICB9O1xuICB2YXIgc2F2ZXIgPSB3b3JkU2F2ZXIoKTtcbiAgdmFyIHN0YXRlID0gaXRlcmF0ZVdpdGhUcmFuc2l0aW9ucyhydWxlVGV4dCwgdHJhbnNpdGlvbnMsIFRSQU5TSVRJT04uT1BFTkVELCB7XG4gICAgc2VwOiBzZXAsXG4gICAgc2F2ZXI6IHNhdmVyXG4gIH0pO1xuXG4gIGlmIChzdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNjcmlwdGxldCBydWxlIFwiLmNvbmNhdChydWxlVGV4dCkpO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSBzYXZlci5nZXRBbGwoKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBhcmdzWzBdLFxuICAgIGFyZ3M6IGFyZ3Muc2xpY2UoMSlcbiAgfTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGFib3J0LW9uLXByb3BlcnR5LXJlYWRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFib3J0cyBhIHNjcmlwdCB3aGVuIGl0IGF0dGVtcHRzIHRvICoqcmVhZCoqIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjYWJvcnQtb24tcHJvcGVydHktcmVhZGpzLVxuICpcbiAqIFJlbGF0ZWQgQUJQIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hZGJsb2NrcGx1cy9hZGJsb2NrcGx1c2NvcmUvYmxvYi82YjJhMzA5MDU0Y2MyMzQzMjEwMmI4NWQxM2YxMjU1OTYzOWVmNDk1L2xpYi9jb250ZW50L3NuaXBwZXRzLmpzI0w4NjRcbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXJlYWQnLCBwcm9wZXJ0eVssIHN0YWNrXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BlcnR5YCAtIHJlcXVpcmVkLCBwYXRoIHRvIGEgcHJvcGVydHkgKGpvaW5lZCB3aXRoIGAuYCBpZiBuZWVkZWQpLiBUaGUgcHJvcGVydHkgbXVzdCBiZSBhdHRhY2hlZCB0byBgd2luZG93YFxuICogLSBgc3RhY2tgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtdXN0IG1hdGNoIHRoZSBjdXJyZW50IGZ1bmN0aW9uIGNhbGwgc3RhY2sgdHJhY2VcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gYWNjZXNzIGB3aW5kb3cuYWxlcnRgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkJywgJ2FsZXJ0JylcbiAqXG4gKiAhIEFib3J0cyBzY3JpcHQgd2hlbiBpdCB0cmllcyB0byBhY2Nlc3MgYG5hdmlnYXRvci5sYW5ndWFnZWBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXJlYWQnLCAnbmF2aWdhdG9yLmxhbmd1YWdlJylcbiAqXG4gKiAhIEFib3J0cyBzY3JpcHQgd2hlbiBpdCB0cmllcyB0byBhY2Nlc3MgYHdpbmRvdy5hZGJsb2NrYCBhbmQgaXQncyBlcnJvciBzdGFjayB0cmFjZSBjb250YWlucyBgdGVzdC5qc2BcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXJlYWQnLCAnYWRibG9jaycsICd0ZXN0LmpzJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBhYm9ydE9uUHJvcGVydHlSZWFkKHNvdXJjZSwgcHJvcGVydHksIHN0YWNrKSB7XG4gIGlmICghcHJvcGVydHkgfHwgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJpZCA9IHJhbmRvbUlkKCk7XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKHJpZCk7XG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjtcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgZ2V0OiBhYm9ydCxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge31cbiAgICB9KTtcbiAgfTtcblxuICBzZXRDaGFpblByb3BBY2Nlc3Mod2luZG93LCBwcm9wZXJ0eSk7XG4gIHdpbmRvdy5vbmVycm9yID0gY3JlYXRlT25FcnJvckhhbmRsZXIocmlkKS5iaW5kKCk7XG59XG5hYm9ydE9uUHJvcGVydHlSZWFkLm5hbWVzID0gWydhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2Fib3J0LW9uLXByb3BlcnR5LXJlYWQuanMnLCAndWJvLWFib3J0LW9uLXByb3BlcnR5LXJlYWQuanMnLCAnYW9wci5qcycsICd1Ym8tYW9wci5qcycsICd1Ym8tYWJvcnQtb24tcHJvcGVydHktcmVhZCcsICd1Ym8tYW9wcicsICdhYnAtYWJvcnQtb24tcHJvcGVydHktcmVhZCddO1xuYWJvcnRPblByb3BlcnR5UmVhZC5pbmplY3Rpb25zID0gW3JhbmRvbUlkLCB0b1JlZ0V4cCwgc2V0UHJvcGVydHlBY2Nlc3MsIGdldFByb3BlcnR5SW5DaGFpbiwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdCwgbWF0Y2hTdGFja1RyYWNlXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgYWJvcnQtb24tcHJvcGVydHktd3JpdGVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFib3J0cyBhIHNjcmlwdCB3aGVuIGl0IGF0dGVtcHRzIHRvICoqd3JpdGUqKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlanMtXG4gKlxuICogUmVsYXRlZCBBQlAgc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FkYmxvY2twbHVzL2FkYmxvY2twbHVzY29yZS9ibG9iLzZiMmEzMDkwNTRjYzIzNDMyMTAyYjg1ZDEzZjEyNTU5NjM5ZWY0OTUvbGliL2NvbnRlbnQvc25pcHBldHMuanMjTDg5NlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWJvcnQtb24tcHJvcGVydHktd3JpdGUnLCBwcm9wZXJ0eVssIHN0YWNrXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BlcnR5YCAtIHJlcXVpcmVkLCBwYXRoIHRvIGEgcHJvcGVydHkgKGpvaW5lZCB3aXRoIGAuYCBpZiBuZWVkZWQpLiBUaGUgcHJvcGVydHkgbXVzdCBiZSBhdHRhY2hlZCB0byBgd2luZG93YFxuICogLSBgc3RhY2tgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtdXN0IG1hdGNoIHRoZSBjdXJyZW50IGZ1bmN0aW9uIGNhbGwgc3RhY2sgdHJhY2VcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gc2V0IGB3aW5kb3cuYWRibG9ja2AgdmFsdWVcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlJywgJ2FkYmxvY2snKVxuICpcbiAqICEgQWJvcnRzIHNjcmlwdCB3aGVuIGl0IHRyaWVzIHRvIHNldCBgd2luZG93LmFkYmxvY2tgIHZhbHVlIGFuZCBpdCdzIGVycm9yIHN0YWNrIHRyYWNlIGNvbnRhaW5zIGBjaGVja2luZy5qc2BcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlJywgJ2FkYmxvY2snLCAnY2hlY2tpbmcuanMnKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIGFib3J0T25Qcm9wZXJ0eVdyaXRlKHNvdXJjZSwgcHJvcGVydHksIHN0YWNrKSB7XG4gIGlmICghcHJvcGVydHkgfHwgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJpZCA9IHJhbmRvbUlkKCk7XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKHJpZCk7XG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjtcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgc2V0OiBhYm9ydFxuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbiAgd2luZG93Lm9uZXJyb3IgPSBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpLmJpbmQoKTtcbn1cbmFib3J0T25Qcm9wZXJ0eVdyaXRlLm5hbWVzID0gWydhYm9ydC1vbi1wcm9wZXJ0eS13cml0ZScsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidhYm9ydC1vbi1wcm9wZXJ0eS13cml0ZS5qcycsICd1Ym8tYWJvcnQtb24tcHJvcGVydHktd3JpdGUuanMnLCAnYW9wdy5qcycsICd1Ym8tYW9wdy5qcycsICd1Ym8tYWJvcnQtb24tcHJvcGVydHktd3JpdGUnLCAndWJvLWFvcHcnLCAnYWJwLWFib3J0LW9uLXByb3BlcnR5LXdyaXRlJ107XG5hYm9ydE9uUHJvcGVydHlXcml0ZS5pbmplY3Rpb25zID0gW3JhbmRvbUlkLCBzZXRQcm9wZXJ0eUFjY2VzcywgZ2V0UHJvcGVydHlJbkNoYWluLCBjcmVhdGVPbkVycm9ySGFuZGxlciwgaGl0LCB0b1JlZ0V4cCwgbWF0Y2hTdGFja1RyYWNlXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1zZXRUaW1lb3V0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBhIGBzZXRUaW1lb3V0YCBjYWxsIGlmOlxuICogMSkgdGhlIHRleHQgb2YgdGhlIGNhbGxiYWNrIGlzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgc2VhcmNoIHN0cmluZy9yZWdleHAgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCBgIWA7XG4gKiBvdGhlcndpc2UgbWlzbWF0Y2hlZCBjYWxscyBzaG91bGQgYmUgZGVmdXNlZDtcbiAqIDIpIHRoZSB0aW1lb3V0IGlzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXk7IG90aGVyd2lzZSBtaXNtYXRjaGVkIGNhbGxzIHNob3VsZCBiZSBkZWZ1c2VkLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vLXNldHRpbWVvdXQtaWZqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0VGltZW91dCdbLCBzZWFyY2hbLCBkZWxheV1dKVxuICogYGBgXG4gKlxuICogQ2FsbCB3aXRoIG5vIGFyZ3VtZW50cyB3aWxsIGxvZyBjYWxscyB0byBzZXRUaW1lb3V0IHdoaWxlIGRlYnVnZ2luZyAoYGxvZy1zZXRUaW1lb3V0YCBzdXBlcnNlZGluZyksXG4gKiBzbyBwcm9kdWN0aW9uIGZpbHRlciBsaXN0cycgcnVsZXMgZGVmaW5pdGVseSByZXF1aXJlIGF0IGxlYXN0IG9uZSBvZiB0aGUgcGFyYW1ldGVyczpcbiAqIC0gYHNlYXJjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIElmIHN0YXJ0cyB3aXRoIGAhYCwgc2NyaXB0bGV0IHdpbGwgbm90IG1hdGNoIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayBidXQgYWxsIG90aGVyIHdpbGwgYmUgZGVmdXNlZC5cbiAqIElmIGRvIG5vdCBzdGFydCB3aXRoIGAhYCwgdGhlIHN0cmluZ2lmaWVkIGNhbGxiYWNrIHdpbGwgYmUgbWF0Y2hlZC5cbiAqIElmIG5vdCBzZXQsIHByZXZlbnRzIGFsbCBgc2V0VGltZW91dGAgY2FsbHMgZHVlIHRvIHNwZWNpZmllZCBgZGVsYXlgLlxuICogLSBgZGVsYXlgIC0gb3B0aW9uYWwsIG11c3QgYmUgYW4gaW50ZWdlci5cbiAqIElmIHN0YXJ0cyB3aXRoIGAhYCwgc2NyaXB0bGV0IHdpbGwgbm90IG1hdGNoIHRoZSBkZWxheSBidXQgYWxsIG90aGVyIHdpbGwgYmUgZGVmdXNlZC5cbiAqIElmIGRvIG5vdCBzdGFydCB3aXRoIGAhYCwgdGhlIGRlbGF5IHBhc3NlZCB0byB0aGUgYHNldFRpbWVvdXRgIGNhbGwgd2lsbCBiZSBtYXRjaGVkLlxuICpcbiAqID4gSWYgYHByZXZlbnQtc2V0VGltZW91dGAgd2l0aG91dCBwYXJhbWV0ZXJzIGxvZ3Mgc210aCBsaWtlIGBzZXRUaW1lb3V0KHVuZGVmaW5lZCwgMTAwMClgLFxuICogaXQgbWVhbnMgdGhhdCBubyBjYWxsYmFjayB3YXMgcGFzc2VkIHRvIHNldFRpbWVvdXQoKSBhbmQgdGhhdCdzIG5vdCBzY3JpcHRsZXQgaXNzdWVcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIFByZXZlbnRzIGBzZXRUaW1lb3V0YCBjYWxscyBpZiB0aGUgY2FsbGJhY2sgbWF0Y2hlcyBgL1xcLnRlc3QvYCByZWdhcmRsZXNzIG9mIHRoZSBkZWxheS5cbiAqICAgICBgYGBiYXNoXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRUaW1lb3V0JywgJy9cXC50ZXN0LycpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBjYWxsIHdpbGwgYmUgcHJldmVudGVkOlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlXCI7XG4gKiAgICAgfSwgMTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBQcmV2ZW50cyBgc2V0VGltZW91dGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGRvZXMgbm90IGNvbnRhaW4gYHZhbHVlYC5cbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldFRpbWVvdXQnLCAnIXZhbHVlJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBmaXJzdCBvZiB0aGUgZm9sbG93aW5nIGNhbGxzIHdpbGwgYmUgcHJldmVudGVkOlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInRlc3QgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnZhbHVlID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiAzLiBQcmV2ZW50cyBgc2V0VGltZW91dGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGNvbnRhaW5zIGB2YWx1ZWAgYW5kIHRoZSBkZWxheSBpcyBub3Qgc2V0IHRvIGAzMDBgLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0VGltZW91dCcsICd2YWx1ZScsICchMzAwJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBmaXJzdCBvZiB0aGUgZm9sbG93aW5nIGNhbGxzIHdpbGwgbm90IGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZSAxIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIDIgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIDMgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiA0LiBQcmV2ZW50cyBgc2V0VGltZW91dGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGRvZXMgbm90IGNvbnRhaW4gYHZhbHVlYCBhbmQgdGhlIGRlbGF5IGlzIG5vdCBzZXQgdG8gYDMwMGAuXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRUaW1lb3V0JywgJyF2YWx1ZScsICchMzAwJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBzZWNvbmQgb2YgdGhlIGZvbGxvd2luZyBjYWxscyB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInRlc3QgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnZhbHVlID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcHJldmVudFNldFRpbWVvdXQoc291cmNlLCBtYXRjaCwgZGVsYXkpIHtcbiAgdmFyIG5hdGl2ZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcbiAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAvLyBsb2dzIHNldFRpbWVvdXRzIHRvIGNvbnNvbGUgaWYgbm8gYXJndW1lbnRzIGhhdmUgYmVlbiBzcGVjaWZpZWRcblxuICB2YXIgc2hvdWxkTG9nID0gdHlwZW9mIG1hdGNoID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVsYXkgPT09ICd1bmRlZmluZWQnO1xuXG4gIHZhciBfcGFyc2VNYXRjaEFyZyA9IHBhcnNlTWF0Y2hBcmcobWF0Y2gpLFxuICAgICAgaXNJbnZlcnRlZE1hdGNoID0gX3BhcnNlTWF0Y2hBcmcuaXNJbnZlcnRlZE1hdGNoLFxuICAgICAgbWF0Y2hSZWdleHAgPSBfcGFyc2VNYXRjaEFyZy5tYXRjaFJlZ2V4cDtcblxuICB2YXIgX3BhcnNlRGVsYXlBcmcgPSBwYXJzZURlbGF5QXJnKGRlbGF5KSxcbiAgICAgIGlzSW52ZXJ0ZWREZWxheU1hdGNoID0gX3BhcnNlRGVsYXlBcmcuaXNJbnZlcnRlZERlbGF5TWF0Y2gsXG4gICAgICBkZWxheU1hdGNoID0gX3BhcnNlRGVsYXlBcmcuZGVsYXlNYXRjaDtcblxuICB2YXIgdGltZW91dFdyYXBwZXIgPSBmdW5jdGlvbiB0aW1lb3V0V3JhcHBlcihjYWxsYmFjaywgdGltZW91dCkge1xuICAgIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMDVcblxuICAgIHZhciBjYlN0cmluZyA9IFN0cmluZyhjYWxsYmFjayk7XG5cbiAgICBpZiAoc2hvdWxkTG9nKSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIGxvZyhcInNldFRpbWVvdXQoXCIuY29uY2F0KGNiU3RyaW5nLCBcIiwgXCIpLmNvbmNhdCh0aW1lb3V0LCBcIilcIikpO1xuICAgIH0gZWxzZSBpZiAoIWRlbGF5TWF0Y2gpIHtcbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KGNiU3RyaW5nKSAhPT0gaXNJbnZlcnRlZE1hdGNoO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gdGltZW91dCA9PT0gZGVsYXlNYXRjaCAhPT0gaXNJbnZlcnRlZERlbGF5TWF0Y2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KGNiU3RyaW5nKSAhPT0gaXNJbnZlcnRlZE1hdGNoICYmIHRpbWVvdXQgPT09IGRlbGF5TWF0Y2ggIT09IGlzSW52ZXJ0ZWREZWxheU1hdGNoO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHJldHVybiBuYXRpdmVUaW1lb3V0KG5vb3BGdW5jLCB0aW1lb3V0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlVGltZW91dC5hcHBseSh3aW5kb3csIFtjYWxsYmFjaywgdGltZW91dF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0VGltZW91dCA9IHRpbWVvdXRXcmFwcGVyO1xufVxucHJldmVudFNldFRpbWVvdXQubmFtZXMgPSBbJ3ByZXZlbnQtc2V0VGltZW91dCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbiduby1zZXRUaW1lb3V0LWlmLmpzJywgLy8gbmV3IGltcGxlbWVudGF0aW9uIG9mIHNldFRpbWVvdXQtZGVmdXNlci5qc1xuJ3Viby1uby1zZXRUaW1lb3V0LWlmLmpzJywgJ25vc3RpZi5qcycsIC8vIG5ldyBzaG9ydCBuYW1lIG9mIG5vLXNldFRpbWVvdXQtaWZcbid1Ym8tbm9zdGlmLmpzJywgJ3Viby1uby1zZXRUaW1lb3V0LWlmJywgJ3Viby1ub3N0aWYnLCAvLyBvbGQgc2NyaXB0bGV0IG5hbWVzIHdoaWNoIHNob3VsZCBiZSBzdXBwb3J0ZWQgYXMgd2VsbC5cbi8vIHNob3VsZCBiZSByZW1vdmVkIGV2ZW50dWFsbHkuXG4vLyBkbyBub3QgcmVtb3ZlIHVudGlsIG90aGVyIGZpbHRlciBsaXN0cyBtYWludGFpbmVycyB1c2UgdGhlbVxuJ3NldFRpbWVvdXQtZGVmdXNlci5qcycsICd1Ym8tc2V0VGltZW91dC1kZWZ1c2VyLmpzJywgJ3Viby1zZXRUaW1lb3V0LWRlZnVzZXInLCAnc3RkLmpzJywgJ3Viby1zdGQuanMnLCAndWJvLXN0ZCddO1xucHJldmVudFNldFRpbWVvdXQuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BGdW5jLCBwYXJzZU1hdGNoQXJnLCBwYXJzZURlbGF5QXJnLCB0b1JlZ0V4cCwgc3RhcnRzV2l0aCwgbmF0aXZlSXNOYU5dO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBwcmV2ZW50LXNldEludGVydmFsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBhIGBzZXRJbnRlcnZhbGAgY2FsbCBpZjpcbiAqIDEpIHRoZSB0ZXh0IG9mIHRoZSBjYWxsYmFjayBpcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGBzZWFyY2hgIHN0cmluZy9yZWdleHAgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCBgIWA7XG4gKiBvdGhlcndpc2UgbWlzbWF0Y2hlZCBjYWxscyBzaG91bGQgYmUgZGVmdXNlZDtcbiAqIDIpIHRoZSBpbnRlcnZhbCBpcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGBkZWxheWA7IG90aGVyd2lzZSBtaXNtYXRjaGVkIGNhbGxzIHNob3VsZCBiZSBkZWZ1c2VkLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vLXNldGludGVydmFsLWlmanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldEludGVydmFsJ1ssIHNlYXJjaFssIGRlbGF5XV0pXG4gKiBgYGBcbiAqXG4gKiBDYWxsIHdpdGggbm8gYXJndW1lbnRzIHdpbGwgbG9nIGNhbGxzIHRvIHNldEludGVydmFsIHdoaWxlIGRlYnVnZ2luZyAoYGxvZy1zZXRJbnRlcnZhbGAgc3VwZXJzZWRpbmcpLFxuICogc28gcHJvZHVjdGlvbiBmaWx0ZXIgbGlzdHMnIHJ1bGVzIGRlZmluaXRlbHkgcmVxdWlyZSBhdCBsZWFzdCBvbmUgb2YgdGhlIHBhcmFtZXRlcnM6XG4gKiAtIGBzZWFyY2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBJZiBzdGFydHMgd2l0aCBgIWAsIHNjcmlwdGxldCB3aWxsIG5vdCBtYXRjaCB0aGUgc3RyaW5naWZpZWQgY2FsbGJhY2sgYnV0IGFsbCBvdGhlciB3aWxsIGJlIGRlZnVzZWQuXG4gKiBJZiBkbyBub3Qgc3RhcnQgd2l0aCBgIWAsIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayB3aWxsIGJlIG1hdGNoZWQuXG4gKiBJZiBub3Qgc2V0LCBwcmV2ZW50cyBhbGwgYHNldEludGVydmFsYCBjYWxscyBkdWUgdG8gc3BlY2lmaWVkIGBkZWxheWAuXG4gKiAtIGBkZWxheWAgLSBvcHRpb25hbCwgbXVzdCBiZSBhbiBpbnRlZ2VyLlxuICogSWYgc3RhcnRzIHdpdGggYCFgLCBzY3JpcHRsZXQgd2lsbCBub3QgbWF0Y2ggdGhlIGRlbGF5IGJ1dCBhbGwgb3RoZXIgd2lsbCBiZSBkZWZ1c2VkLlxuICogSWYgZG8gbm90IHN0YXJ0IHdpdGggYCFgLCB0aGUgZGVsYXkgcGFzc2VkIHRvIHRoZSBgc2V0SW50ZXJ2YWxgIGNhbGwgd2lsbCBiZSBtYXRjaGVkLlxuICpcbiAqID4gSWYgYHByZXZlbnQtc2V0SW50ZXJ2YWxgIHdpdGhvdXQgcGFyYW1ldGVycyBsb2dzIHNtdGggbGlrZSBgc2V0SW50ZXJ2YWwodW5kZWZpbmVkLCAxMDAwKWAsXG4gKiBpdCBtZWFucyB0aGF0IG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQgdG8gc2V0SW50ZXJ2YWwoKSBhbmQgdGhhdCdzIG5vdCBzY3JpcHRsZXQgaXNzdWVcblxuICogICoqRXhhbXBsZXMqKlxuICogMS4gUHJldmVudHMgYHNldEludGVydmFsYCBjYWxscyBpZiB0aGUgY2FsbGJhY2sgbWF0Y2hlcyBgL1xcLnRlc3QvYCByZWdhcmRsZXNzIG9mIHRoZSBkZWxheS5cbiAqICAgICBgYGBiYXNoXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRJbnRlcnZhbCcsICcvXFwudGVzdC8nKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgY2FsbCB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWVcIjtcbiAqICAgICB9LCAxMDApO1xuICogICAgIGBgYFxuICpcbiAqIDIuIFByZXZlbnRzIGBzZXRJbnRlcnZhbGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGRvZXMgbm90IGNvbnRhaW4gYHZhbHVlYC5cbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldEludGVydmFsJywgJyF2YWx1ZScpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgb25seSB0aGUgZmlyc3Qgb2YgdGhlIGZvbGxvd2luZyBjYWxscyB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidGVzdCAtLSBwcmV2ZW50ZWRcIjtcbiAqICAgICB9LCAzMDApO1xuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy52YWx1ZSA9IFwidGVzdCAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDUwMCk7XG4gKiAgICAgYGBgXG4gKlxuICogMy4gUHJldmVudHMgYHNldEludGVydmFsYCBjYWxscyBpZiB0aGUgY2FsbGJhY2sgY29udGFpbnMgYHZhbHVlYCBhbmQgdGhlIGRlbGF5IGlzIG5vdCBzZXQgdG8gYDMwMGAuXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRJbnRlcnZhbCcsICd2YWx1ZScsICchMzAwJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBmaXJzdCBvZiB0aGUgZm9sbG93aW5nIGNhbGxzIHdpbGwgbm90IGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWUgMSAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDMwMCk7XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWUgMiAtLSBwcmV2ZW50ZWRcIjtcbiAqICAgICB9LCA0MDApO1xuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIDMgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiA0LiBQcmV2ZW50cyBgc2V0SW50ZXJ2YWxgIGNhbGxzIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCBjb250YWluIGB2YWx1ZWAgYW5kIHRoZSBkZWxheSBpcyBub3Qgc2V0IHRvIGAzMDBgLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0SW50ZXJ2YWwnLCAnIXZhbHVlJywgJyEzMDAnKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIG9ubHkgdGhlIHNlY29uZCBvZiB0aGUgZm9sbG93aW5nIGNhbGxzIHdpbGwgYmUgcHJldmVudGVkOlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ0ZXN0IC0tIHByZXZlbnRlZFwiO1xuICogICAgIH0sIDQwMCk7XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWUgLS0gZXhlY3V0ZWRcIjtcbiAqICAgICB9LCA0MDApO1xuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnZhbHVlID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcHJldmVudFNldEludGVydmFsKHNvdXJjZSwgbWF0Y2gsIGRlbGF5KSB7XG4gIHZhciBuYXRpdmVJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbDtcbiAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAvLyBsb2dzIHNldEludGVydmFscyB0byBjb25zb2xlIGlmIG5vIGFyZ3VtZW50cyBoYXZlIGJlZW4gc3BlY2lmaWVkXG5cbiAgdmFyIHNob3VsZExvZyA9IHR5cGVvZiBtYXRjaCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlbGF5ID09PSAndW5kZWZpbmVkJztcblxuICB2YXIgX3BhcnNlTWF0Y2hBcmcgPSBwYXJzZU1hdGNoQXJnKG1hdGNoKSxcbiAgICAgIGlzSW52ZXJ0ZWRNYXRjaCA9IF9wYXJzZU1hdGNoQXJnLmlzSW52ZXJ0ZWRNYXRjaCxcbiAgICAgIG1hdGNoUmVnZXhwID0gX3BhcnNlTWF0Y2hBcmcubWF0Y2hSZWdleHA7XG5cbiAgdmFyIF9wYXJzZURlbGF5QXJnID0gcGFyc2VEZWxheUFyZyhkZWxheSksXG4gICAgICBpc0ludmVydGVkRGVsYXlNYXRjaCA9IF9wYXJzZURlbGF5QXJnLmlzSW52ZXJ0ZWREZWxheU1hdGNoLFxuICAgICAgZGVsYXlNYXRjaCA9IF9wYXJzZURlbGF5QXJnLmRlbGF5TWF0Y2g7XG5cbiAgdmFyIGludGVydmFsV3JhcHBlciA9IGZ1bmN0aW9uIGludGVydmFsV3JhcHBlcihjYWxsYmFjaywgaW50ZXJ2YWwpIHtcbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlOyAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTA1XG5cbiAgICB2YXIgY2JTdHJpbmcgPSBTdHJpbmcoY2FsbGJhY2spO1xuXG4gICAgaWYgKHNob3VsZExvZykge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICBsb2coXCJzZXRJbnRlcnZhbChcIi5jb25jYXQoY2JTdHJpbmcsIFwiLCBcIikuY29uY2F0KGludGVydmFsLCBcIilcIikpO1xuICAgIH0gZWxzZSBpZiAoIWRlbGF5TWF0Y2gpIHtcbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KGNiU3RyaW5nKSAhPT0gaXNJbnZlcnRlZE1hdGNoO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gaW50ZXJ2YWwgPT09IGRlbGF5TWF0Y2ggIT09IGlzSW52ZXJ0ZWREZWxheU1hdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gbWF0Y2hSZWdleHAudGVzdChjYlN0cmluZykgIT09IGlzSW52ZXJ0ZWRNYXRjaCAmJiBpbnRlcnZhbCA9PT0gZGVsYXlNYXRjaCAhPT0gaXNJbnZlcnRlZERlbGF5TWF0Y2g7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgcmV0dXJuIG5hdGl2ZUludGVydmFsKG5vb3BGdW5jLCBpbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZUludGVydmFsLmFwcGx5KHdpbmRvdywgW2NhbGxiYWNrLCBpbnRlcnZhbF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0SW50ZXJ2YWwgPSBpbnRlcnZhbFdyYXBwZXI7XG59XG5wcmV2ZW50U2V0SW50ZXJ2YWwubmFtZXMgPSBbJ3ByZXZlbnQtc2V0SW50ZXJ2YWwnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm8tc2V0SW50ZXJ2YWwtaWYuanMnLCAvLyBuZXcgaW1wbGVtZW50YXRpb24gb2Ygc2V0SW50ZXJ2YWwtZGVmdXNlci5qc1xuJ3Viby1uby1zZXRJbnRlcnZhbC1pZi5qcycsICdzZXRJbnRlcnZhbC1kZWZ1c2VyLmpzJywgLy8gb2xkIG5hbWUgc2hvdWxkIGJlIHN1cHBvcnRlZCBhcyB3ZWxsXG4ndWJvLXNldEludGVydmFsLWRlZnVzZXIuanMnLCAnbm9zaWlmLmpzJywgLy8gbmV3IHNob3J0IG5hbWUgb2Ygbm8tc2V0SW50ZXJ2YWwtaWZcbid1Ym8tbm9zaWlmLmpzJywgJ3NpZC5qcycsIC8vIG9sZCBzaG9ydCBzY3JpcHRsZXQgbmFtZVxuJ3Viby1zaWQuanMnLCAndWJvLW5vLXNldEludGVydmFsLWlmJywgJ3Viby1zZXRJbnRlcnZhbC1kZWZ1c2VyJywgJ3Viby1ub3NpaWYnLCAndWJvLXNpZCddO1xucHJldmVudFNldEludGVydmFsLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgcGFyc2VNYXRjaEFyZywgcGFyc2VEZWxheUFyZywgdG9SZWdFeHAsIHN0YXJ0c1dpdGgsIG5hdGl2ZUlzTmFOXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC13aW5kb3ctb3BlblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgYHdpbmRvdy5vcGVuYCBjYWxscyB3aGVuIFVSTCBlaXRoZXIgbWF0Y2hlcyBvciBub3QgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHN0cmluZy9yZWdleHAuIFVzaW5nIGl0IHdpdGhvdXQgcGFyYW1ldGVycyBwcmV2ZW50cyBhbGwgYHdpbmRvdy5vcGVuYCBjYWxscy5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSN3aW5kb3dvcGVuLWRlZnVzZXJqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtd2luZG93LW9wZW4nWywgbWF0Y2hbLCBkZWxheVssIHJlcGxhY2VtZW50XV1dKVxuICogYGBgXG4gKlxuICogLSBgbWF0Y2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uIElmIG5vdCBzZXQsIGFsbCB3aW5kb3cub3BlbiBjYWxscyB3aWxsIGJlIG1hdGNoZWQuXG4gKiBJZiBzdGFydHMgd2l0aCBgIWAsIHNjcmlwdGxldCB3aWxsIG5vdCBtYXRjaCB0aGUgc3RyaW5naWZpZWQgY2FsbGJhY2sgYnV0IGFsbCBvdGhlciB3aWxsIGJlIGRlZnVzZWQuXG4gKiBJZiBkbyBub3Qgc3RhcnQgd2l0aCBgIWAsIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayB3aWxsIGJlIG1hdGNoZWQuXG4gKiAtIGBkZWxheWAgLSBvcHRpb25hbCwgbnVtYmVyIG9mIHNlY29uZHMuIElmIG5vdCBzZXQsIHNjcmlwdGxldCB3aWxsIHJldHVybiBgbnVsbGAsXG4gKiBvdGhlcndpc2UgdmFsaWQgc2hhbSB3aW5kb3cgb2JqZWN0IGFzIGluamVjdGVkIGBpZnJhbWVgIHdpbGwgYmUgcmV0dXJuZWRcbiAqIGZvciBhY2Nlc3NpbmcgaXQncyBtZXRob2RzIChibHVyKCksIGZvY3VzKCkgZXRjLikgYW5kIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciB0aGUgZGVsYXkuXG4gKiAtIGByZXBsYWNlbWVudGAgLSBvcHRpb25hbCwgc3RyaW5nOyBvbmUgb2YgdGhlIHByZWRlZmluZWQgY29uc3RhbnRzOlxuICogICAgIC0gYG9iamAgLSBmb3IgcmV0dXJuaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGRlZmF1bHQgaWZyYW1lO1xuICogICAgICAgIGZvciBjYXNlcyB3aGVuIHRoZSBwYWdlIHJlcXVpcmVzIGEgdmFsaWQgYHdpbmRvd2AgaW5zdGFuY2UgdG8gYmUgcmV0dXJuZWRcbiAqICAgICAtIGBsb2dgIC0gZm9yIGxvZ2dpbmcgd2luZG93Lm9wZW4gY2FsbHM7IHBlcm1pdHRlZCBmb3IgcHJvZHVjdGlvbiBmaWx0ZXIgbGlzdHMuXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBQcmV2ZW50IGFsbCBgd2luZG93Lm9wZW5gIGNhbGxzOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicpXG4gKiBgYGBcbiAqXG4gKiAyLiBQcmV2ZW50IGB3aW5kb3cub3BlbmAgZm9yIGFsbCBVUkxzIGNvbnRhaW5pbmcgYGV4YW1wbGVgOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICdleGFtcGxlJylcbiAqIGBgYFxuICpcbiAqIDMuIFByZXZlbnQgYHdpbmRvdy5vcGVuYCBmb3IgYWxsIFVSTHMgbWF0Y2hpbmcgUmVnRXhwIGAvZXhhbXBsZVxcLi9gOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICcvZXhhbXBsZVxcLi8nKVxuICogYGBgXG4gKlxuICogNC4gUHJldmVudCBgd2luZG93Lm9wZW5gIGZvciBhbGwgVVJMcyAqKk5PVCoqIGNvbnRhaW5pbmcgYGV4YW1wbGVgOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICchZXhhbXBsZScpXG4gKiBgYGBcbiAqXG4gKiBPbGQgc3ludGF4IG9mIHByZXZlbnQtd2luZG93LW9wZW4gcGFyYW1ldGVyczpcbiAqIC0gYG1hdGNoYCAtIG9wdGlvbmFsLCBkZWZhdWx0cyB0byBcIm1hdGNoaW5nXCIsIGFueSBwb3NpdGl2ZSBudW1iZXIgb3Igbm90aGluZyBmb3IgXCJtYXRjaGluZ1wiLCAwIG9yIGVtcHR5IHN0cmluZyBmb3IgXCJub3QgbWF0Y2hpbmdcIlxuICogLSBgc2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVnZXhwIGZvciBtYXRjaGluZyB0aGUgVVJMIHBhc3NlZCB0byBgd2luZG93Lm9wZW5gIGNhbGw7IGRlZmF1bHRzIHRvIHNlYXJjaCBhbGwgYHdpbmRvdy5vcGVuYCBjYWxsXG4gKiAtIGByZXBsYWNlbWVudGAgLSBvcHRpb25hbCwgc3RyaW5nIHRvIHJldHVybiBwcm9wIHZhbHVlIG9yIHByb3BlcnR5IGluc3RlYWQgb2Ygd2luZG93Lm9wZW47IGRlZmF1bHRzIHRvIHJldHVybiBub29wRnVuYy5cbiAqICoqRXhhbXBsZXMqKlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICcxJywgJy9leGFtcGxlXFwuLydcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXdpbmRvdy1vcGVuJywgJzAnLCAnZXhhbXBsZScpXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICcnLCAnJywgJ3RydWVGdW5jJylcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXdpbmRvdy1vcGVuJywgJzEnLCAnJywgJ3twcm9wTmFtZT1ub29wRnVuY30nKVxuICogYGBgXG4gKlxuICogPiBGb3IgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCB1Qk8sIG9sZCBzeW50YXggaXMgbm90IHJlY29tbWVuZGVkIHRvIHVzZS5cbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcHJldmVudFdpbmRvd09wZW4oc291cmNlKSB7XG4gIHZhciBtYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZ2V0V2lsZGNhcmRTeW1ib2woKTtcbiAgdmFyIGRlbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciByZXBsYWNlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAvLyBkZWZhdWx0IG1hdGNoIHZhbHVlIGlzIG5lZWRlZCBmb3IgcHJldmVudGluZyBhbGwgd2luZG93Lm9wZW4gY2FsbHNcbiAgLy8gaWYgc2NyaXB0bGV0IHJ1bnMgd2l0aG91dCBhcmdzXG4gIHZhciBuYXRpdmVPcGVuID0gd2luZG93Lm9wZW47XG4gIHZhciBpc05ld1N5bnRheCA9IG1hdGNoICE9PSAnMCcgJiYgbWF0Y2ggIT09ICcxJztcblxuICB2YXIgb2xkT3BlbldyYXBwZXIgPSBmdW5jdGlvbiBvbGRPcGVuV3JhcHBlcihzdHIpIHtcbiAgICBtYXRjaCA9IE51bWJlcihtYXRjaCkgPiAwOyAvLyAnZGVsYXknIHdhcyAnc2VhcmNoJyBwcm9wIGZvciBtYXRjaGluZyBpbiBvbGQgc3ludGF4XG5cbiAgICB2YXIgc2VhcmNoUmVnZXhwID0gdG9SZWdFeHAoZGVsYXkpO1xuXG4gICAgaWYgKG1hdGNoICE9PSBzZWFyY2hSZWdleHAudGVzdChzdHIpKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlT3Blbi5hcHBseSh3aW5kb3csIFtzdHJdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuXG4gICAgaGl0KHNvdXJjZSk7XG4gICAgcmV0dXJuIGhhbmRsZU9sZFJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcbiAgfTtcblxuICB2YXIgbmV3T3BlbldyYXBwZXIgPSBmdW5jdGlvbiBuZXdPcGVuV3JhcHBlcih1cmwpIHtcbiAgICB2YXIgc2hvdWxkTG9nID0gcmVwbGFjZW1lbnQgJiYgcmVwbGFjZW1lbnQuaW5kZXhPZignbG9nJykgPiAtMTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRMb2cpIHtcbiAgICAgIHZhciBhcmdzU3RyID0gYXJncyAmJiBhcmdzLmxlbmd0aCA+IDAgPyBcIiwgXCIuY29uY2F0KGFyZ3Muam9pbignLCAnKSkgOiAnJztcbiAgICAgIHZhciBsb2dNZXNzYWdlID0gXCJsb2c6IHdpbmRvdy1vcGVuOiBcIi5jb25jYXQodXJsKS5jb25jYXQoYXJnc1N0cik7XG4gICAgICBoaXQoc291cmNlLCBsb2dNZXNzYWdlKTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xuXG4gICAgaWYgKG1hdGNoID09PSBnZXRXaWxkY2FyZFN5bWJvbCgpKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9wYXJzZU1hdGNoQXJnID0gcGFyc2VNYXRjaEFyZyhtYXRjaCksXG4gICAgICAgICAgaXNJbnZlcnRlZE1hdGNoID0gX3BhcnNlTWF0Y2hBcmcuaXNJbnZlcnRlZE1hdGNoLFxuICAgICAgICAgIG1hdGNoUmVnZXhwID0gX3BhcnNlTWF0Y2hBcmcubWF0Y2hSZWdleHA7XG5cbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KHVybCkgIT09IGlzSW52ZXJ0ZWRNYXRjaDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgdmFyIHBhcnNlZERlbGF5ID0gcGFyc2VJbnQoZGVsYXksIDEwKTtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmIChuYXRpdmVJc05hTihwYXJzZWREZWxheSkpIHtcbiAgICAgICAgcmVzdWx0ID0gbm9vcE51bGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWNveUFyZ3MgPSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQ6IHJlcGxhY2VtZW50LFxuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIGRlbGF5OiBwYXJzZWREZWxheVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVjb3kgPSBjcmVhdGVEZWNveShkZWNveUFyZ3MpO1xuICAgICAgICB2YXIgcG9wdXAgPSBkZWNveS5jb250ZW50V2luZG93O1xuXG4gICAgICAgIGlmICh0eXBlb2YgcG9wdXAgPT09ICdvYmplY3QnICYmIHBvcHVwICE9PSBudWxsKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBvcHVwLCAnY2xvc2VkJywge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZUdldHRlciA9IGRlY295LmNvbnRlbnRXaW5kb3cgJiYgZGVjb3kuY29udGVudFdpbmRvdy5nZXQ7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY295LCAnY29udGVudFdpbmRvdycsIHtcbiAgICAgICAgICAgIGdldDogZ2V0UHJldmVudEdldHRlcihuYXRpdmVHZXR0ZXIpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9wdXAgPSBkZWNveS5jb250ZW50V2luZG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcG9wdXA7XG4gICAgICB9XG5cbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlT3Blbi5hcHBseSh3aW5kb3csIFt1cmxdLmNvbmNhdChhcmdzKSk7XG4gIH07XG5cbiAgd2luZG93Lm9wZW4gPSBpc05ld1N5bnRheCA/IG5ld09wZW5XcmFwcGVyIDogb2xkT3BlbldyYXBwZXI7XG59XG5wcmV2ZW50V2luZG93T3Blbi5uYW1lcyA9IFsncHJldmVudC13aW5kb3ctb3BlbicsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbid3aW5kb3cub3Blbi1kZWZ1c2VyLmpzJywgJ3Viby13aW5kb3cub3Blbi1kZWZ1c2VyLmpzJywgJ3Viby13aW5kb3cub3Blbi1kZWZ1c2VyJywgJ25vd29pZi5qcycsICd1Ym8tbm93b2lmLmpzJywgJ3Viby1ub3dvaWYnXTtcbnByZXZlbnRXaW5kb3dPcGVuLmluamVjdGlvbnMgPSBbaGl0LCB0b1JlZ0V4cCwgbmF0aXZlSXNOYU4sIHBhcnNlTWF0Y2hBcmcsIGhhbmRsZU9sZFJlcGxhY2VtZW50LCBjcmVhdGVEZWNveSwgZ2V0UHJldmVudEdldHRlciwgbm9vcE51bGwsIGdldFdpbGRjYXJkU3ltYm9sLCBub29wRnVuYywgdHJ1ZUZ1bmMsIHN0YXJ0c1dpdGgsIGVuZHNXaXRoLCBzdWJzdHJpbmdCZWZvcmUsIHN1YnN0cmluZ0FmdGVyXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBYm9ydHMgYW4gaW5saW5lIHNjcmlwdCB3aGVuIGl0IGF0dGVtcHRzIHRvICoqcmVhZCoqIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAqIEFORCB3aGVuIHRoZSBjb250ZW50cyBvZiB0aGUgYDxzY3JpcHQ+YCBlbGVtZW50IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWRcbiAqIHRleHQgb3IgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdGpzLVxuICpcbiAqIFJlbGF0ZWQgQUJQIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hZGJsb2NrcGx1cy9hZGJsb2NrcGx1c2NvcmUvYmxvYi82YjJhMzA5MDU0Y2MyMzQzMjEwMmI4NWQxM2YxMjU1OTYzOWVmNDk1L2xpYi9jb250ZW50L3NuaXBwZXRzLmpzI0w5MjhcbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCcsIHByb3BlcnR5Wywgc2VhcmNoXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BlcnR5YCAtIHJlcXVpcmVkLCBwYXRoIHRvIGEgcHJvcGVydHkgKGpvaW5lZCB3aXRoIGAuYCBpZiBuZWVkZWQpLiBUaGUgcHJvcGVydHkgbXVzdCBiZSBhdHRhY2hlZCB0byBgd2luZG93YFxuICogLSBgc2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbXVzdCBtYXRjaCB0aGUgaW5saW5lIHNjcmlwdCBjb250ZW50cy4gSWYgbm90IHNldCwgYWJvcnQgYWxsIGlubGluZSBzY3JpcHRzIHdoaWNoIGFyZSB0cnlpbmcgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAqXG4gKiA+IE5vdGUgcGxlYXNlIHRoYXQgZm9yIGlubGluZSBzY3JpcHQgd2l0aCBhZGRFdmVudExpc3RlbmVyIGluIGl0XG4gKiBgcHJvcGVydHlgIHNob3VsZCBiZSBzZXQgYXMgYEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyYCxcbiAqIG5vdCBqdXN0IGBhZGRFdmVudExpc3RlbmVyYC5cbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIEFib3J0cyBhbGwgaW5saW5lIHNjcmlwdHMgdHJ5aW5nIHRvIGFjY2VzcyBgd2luZG93LmFsZXJ0YFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCcsICdhbGVydCcpXG4gKiAgICAgYGBgXG4gKlxuICogMi4gQWJvcnRzIGlubGluZSBzY3JpcHRzIHdoaWNoIGFyZSB0cnlpbmcgdG8gYWNjZXNzIGB3aW5kb3cuYWxlcnRgIGFuZCBjb250YWluIGBIZWxsbywgd29ybGRgLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCcsICdhbGVydCcsICdIZWxsbywgd29ybGQnKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgc2NyaXB0IHdpbGwgYmUgYWJvcnRlZFxuICogICAgIGBgYGh0bWxcbiAqICAgICA8c2NyaXB0PmFsZXJ0KFwiSGVsbG8sIHdvcmxkXCIpOzwvc2NyaXB0PlxuICogICAgIGBgYFxuICpcbiAqIDMuIEFib3J0cyBpbmxpbmUgc2NyaXB0cyB3aGljaCBhcmUgdHJ5aW5nIHRvIGFjY2VzcyBgd2luZG93LmFsZXJ0YCBhbmQgbWF0Y2ggdGhpcyByZWdleHA6IGAvSGVsbG8uK3dvcmxkL2AuXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0JywgJ2FsZXJ0JywgJy9IZWxsby4rd29ybGQvJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCB0aGUgZm9sbG93aW5nIHNjcmlwdHMgd2lsbCBiZSBhYm9ydGVkOlxuICogICAgIGBgYGh0bWxcbiAqICAgICA8c2NyaXB0PmFsZXJ0KFwiSGVsbG8sIGJpZyB3b3JsZFwiKTs8L3NjcmlwdD5cbiAqICAgICBgYGBcbiAqICAgICBgYGBodG1sXG4gKiAgICAgPHNjcmlwdD5hbGVydChcIkhlbGxvLCBsaXR0bGUgd29ybGRcIik7PC9zY3JpcHQ+XG4gKiAgICAgYGBgXG4gKlxuICogICAgIFRoaXMgc2NyaXB0IHdpbGwgbm90IGJlIGFib3J0ZWQ6XG4gKiAgICAgYGBgaHRtbFxuICogICAgIDxzY3JpcHQ+YWxlcnQoXCJIaSwgbGl0dGxlIHdvcmxkXCIpOzwvc2NyaXB0PlxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBhYm9ydEN1cnJlbnRJbmxpbmVTY3JpcHQoc291cmNlLCBwcm9wZXJ0eSwgc2VhcmNoKSB7XG4gIHZhciBzZWFyY2hSZWdleHAgPSB0b1JlZ0V4cChzZWFyY2gpO1xuICB2YXIgcmlkID0gcmFuZG9tSWQoKTtcblxuICB2YXIgZ2V0Q3VycmVudFNjcmlwdCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHQoKSB7XG4gICAgaWYgKCdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIH1cblxuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHJldHVybiBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV07XG4gIH07XG5cbiAgdmFyIG91clNjcmlwdCA9IGdldEN1cnJlbnRTY3JpcHQoKTtcblxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB2YXIgc2NyaXB0RWwgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG5cbiAgICBpZiAoIXNjcmlwdEVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBzY3JpcHRFbC50ZXh0Q29udGVudDsgLy8gV2UgYXJlIHVzaW5nIE5vZGUucHJvdG90eXBlLnRleHRDb250ZW50IHByb3BlcnR5IGRlc2NyaXB0b3JcbiAgICAvLyB0byBnZXQgdGhlIHJlYWwgc2NyaXB0IGNvbnRlbnRcbiAgICAvLyBldmVuIHdoZW4gZG9jdW1lbnQuY3VycmVudFNjcmlwdC50ZXh0Q29udGVudCBpcyByZXBsYWNlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvNTcjaXNzdWVjb21tZW50LTU5MzYzODk5MVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciB0ZXh0Q29udGVudEdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsICd0ZXh0Q29udGVudCcpLmdldDtcbiAgICAgIGNvbnRlbnQgPSB0ZXh0Q29udGVudEdldHRlci5jYWxsKHNjcmlwdEVsKTtcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cblxuICAgIGlmIChzY3JpcHRFbCBpbnN0YW5jZW9mIEhUTUxTY3JpcHRFbGVtZW50ICYmIGNvbnRlbnQubGVuZ3RoID4gMCAmJiBzY3JpcHRFbCAhPT0gb3VyU2NyaXB0ICYmIHNlYXJjaFJlZ2V4cC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihyaWQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0Q2hhaW5Qcm9wQWNjZXNzID0gZnVuY3Rpb24gc2V0Q2hhaW5Qcm9wQWNjZXNzKG93bmVyLCBwcm9wZXJ0eSkge1xuICAgIHZhciBjaGFpbkluZm8gPSBnZXRQcm9wZXJ0eUluQ2hhaW4ob3duZXIsIHByb3BlcnR5KTtcbiAgICB2YXIgYmFzZSA9IGNoYWluSW5mby5iYXNlO1xuICAgIHZhciBwcm9wID0gY2hhaW5JbmZvLnByb3AsXG4gICAgICAgIGNoYWluID0gY2hhaW5JbmZvLmNoYWluOyAvLyBUaGUgc2NyaXB0bGV0IG1pZ2h0IGJlIGV4ZWN1dGVkIGJlZm9yZSB0aGUgY2hhaW4gcHJvcGVydHkgaGFzIGJlZW4gY3JlYXRlZFxuICAgIC8vIChmb3IgaW5zdGFuY2UsIGRvY3VtZW50LmJvZHkgYmVmb3JlIHRoZSBIVE1MIGJvZHkgd2FzIGxvYWRlZCkuXG4gICAgLy8gSW4gdGhpcyBjYXNlIHdlJ3JlIGNoZWNraW5nIHdoZXRoZXIgdGhlIGJhc2UgZWxlbWVudCBleGlzdHMgb3Igbm90XG4gICAgLy8gYW5kIGlmIG5vdCwgd2Ugc2ltcGx5IGV4aXQgd2l0aG91dCBvdmVycmlkaW5nIGFueXRoaW5nLlxuICAgIC8vIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzU3I2lzc3VlY29tbWVudC01NzU4NDEwOTJcblxuICAgIGlmIChiYXNlIGluc3RhbmNlb2YgT2JqZWN0ID09PSBmYWxzZSAmJiBiYXNlID09PSBudWxsKSB7XG4gICAgICB2YXIgcHJvcHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgICAgdmFyIHByb3BJbmRleCA9IHByb3BzLmluZGV4T2YocHJvcCk7XG4gICAgICB2YXIgYmFzZU5hbWUgPSBwcm9wc1twcm9wSW5kZXggLSAxXTtcbiAgICAgIGNvbnNvbGUubG9nKFwiVGhlIHNjcmlwdGxldCBoYWQgYmVlbiBleGVjdXRlZCBiZWZvcmUgdGhlIFwiLmNvbmNhdChiYXNlTmFtZSwgXCIgd2FzIGxvYWRlZC5cIikpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGJhc2VbcHJvcF07XG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgc2V0Q2hhaW5Qcm9wQWNjZXNzKHdpbmRvdywgcHJvcGVydHkpO1xuICB3aW5kb3cub25lcnJvciA9IGNyZWF0ZU9uRXJyb3JIYW5kbGVyKHJpZCkuYmluZCgpO1xufVxuYWJvcnRDdXJyZW50SW5saW5lU2NyaXB0Lm5hbWVzID0gWydhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0LmpzJywgJ3Viby1hYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQuanMnLCAnYWNpcy5qcycsICd1Ym8tYWNpcy5qcycsICd1Ym8tYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0JywgJ3Viby1hY2lzJywgJ2FicC1hYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQnXTtcbmFib3J0Q3VycmVudElubGluZVNjcmlwdC5pbmplY3Rpb25zID0gW3JhbmRvbUlkLCBzZXRQcm9wZXJ0eUFjY2VzcywgZ2V0UHJvcGVydHlJbkNoYWluLCB0b1JlZ0V4cCwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IHNldC1jb25zdGFudFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIGNvbnN0YW50IHByb3BlcnR5IGFuZCBhc3NpZ25zIGl0IG9uZSBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIHByZWRlZmluZWQgbGlzdC5cbiAqXG4gKiA+IEFjdHVhbGx5LCBpdCdzIG5vdCBhIGNvbnN0YW50LiBQbGVhc2Ugbm90ZSwgdGhhdCBpdCBjYW4gYmUgcmV3cml0dGVuIHdpdGggYSB2YWx1ZSBvZiBhIGRpZmZlcmVudCB0eXBlLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I3NldC1jb25zdGFudGpzLVxuICpcbiAqIFJlbGF0ZWQgQUJQIHNuaXBwZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWRibG9ja3BsdXMvYWRibG9ja3BsdXNjb3JlL2Jsb2IvYWRibG9ja3BsdXNjaHJvbWUtMy45LjQvbGliL2NvbnRlbnQvc25pcHBldHMuanMjTDEzNjFcbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb25zdGFudCcsIHByb3BlcnR5LCB2YWx1ZVssIHN0YWNrXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BlcnR5YCAtIHJlcXVpcmVkLCBwYXRoIHRvIGEgcHJvcGVydHkgKGpvaW5lZCB3aXRoIGAuYCBpZiBuZWVkZWQpLiBUaGUgcHJvcGVydHkgbXVzdCBiZSBhdHRhY2hlZCB0byBgd2luZG93YC5cbiAqIC0gYHZhbHVlYCAtIHJlcXVpcmVkLiBQb3NzaWJsZSB2YWx1ZXM6XG4gKiAgICAgLSBwb3NpdGl2ZSBkZWNpbWFsIGludGVnZXIgYDw9IDMyNzY3YFxuICogICAgIC0gb25lIG9mIHRoZSBwcmVkZWZpbmVkIGNvbnN0YW50czpcbiAqICAgICAgICAgLSBgdW5kZWZpbmVkYFxuICogICAgICAgICAtIGBmYWxzZWBcbiAqICAgICAgICAgLSBgdHJ1ZWBcbiAqICAgICAgICAgLSBgbnVsbGBcbiAqICAgICAgICAgLSBgZW1wdHlPYmpgIC0gZW1wdHkgb2JqZWN0XG4gKiAgICAgICAgIC0gYGVtcHR5QXJyYCAtIGVtcHR5IGFycmF5XG4gKiAgICAgICAgIC0gYG5vb3BGdW5jYCAtIGZ1bmN0aW9uIHdpdGggZW1wdHkgYm9keVxuICogICAgICAgICAtIGB0cnVlRnVuY2AgLSBmdW5jdGlvbiByZXR1cm5pbmcgdHJ1ZVxuICogICAgICAgICAtIGBmYWxzZUZ1bmNgIC0gZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlXG4gKiAgICAgICAgIC0gYCcnYCAtIGVtcHR5IHN0cmluZ1xuICogICAgICAgICAtIGAtMWAgLSBudW1iZXIgdmFsdWUgYC0xYFxuICogLSBgc3RhY2tgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtdXN0IG1hdGNoIHRoZSBjdXJyZW50IGZ1bmN0aW9uIGNhbGwgc3RhY2sgdHJhY2VcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogISB3aW5kb3cuZmlyc3RDb25zdCA9PT0gZmFsc2UgLy8gdGhpcyBjb21wYXJpc2lvbiB3aWxsIHJldHVybiBmYWxzZVxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvbnN0YW50JywgJ2ZpcnN0Q29uc3QnLCAnZmFsc2UnKVxuICpcbiAqICEgd2luZG93LnNlY29uZCgpID09PSB0cnVlRnVuYyAvLyAnc2Vjb25kJyBjYWxsIHdpbGwgcmV0dXJuIHRydWVcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb25zdGFudCcsICdzZWNvbmRDb25zdCcsICd0cnVlRnVuYycpXG4gKlxuICogISBkb2N1bWVudC50aGlyZCgpID09PSBmYWxzZUZ1bmMgIC8vICd0aGlyZCcgY2FsbCB3aWxsIHJldHVybiBmYWxzZSBpZiB0aGUgbWV0aG9kIGlzIHJlbGF0ZWQgdG8gY2hlY2tpbmcuanNcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb25zdGFudCcsICdzZWNvbmRDb25zdCcsICd0cnVlRnVuYycsICdjaGVja2luZy5qcycpXG4gKiBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gc2V0Q29uc3RhbnQoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YWNrKSB7XG4gIGlmICghcHJvcGVydHkgfHwgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVtcHR5QXJyID0gbm9vcEFycmF5KCk7XG4gIHZhciBlbXB0eU9iaiA9IG5vb3BPYmplY3QoKTtcbiAgdmFyIGNvbnN0YW50VmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICBjb25zdGFudFZhbHVlID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnbnVsbCcpIHtcbiAgICBjb25zdGFudFZhbHVlID0gbnVsbDtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2VtcHR5QXJyJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSBlbXB0eUFycjtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2VtcHR5T2JqJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSBlbXB0eU9iajtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ25vb3BGdW5jJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSBub29wRnVuYztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3RydWVGdW5jJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSB0cnVlRnVuYztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlRnVuYycpIHtcbiAgICBjb25zdGFudFZhbHVlID0gZmFsc2VGdW5jO1xuICB9IGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgY29uc3RhbnRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgaWYgKG5hdGl2ZUlzTmFOKGNvbnN0YW50VmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGNvbnN0YW50VmFsdWUpID4gMHg3RkZGKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLTEnKSB7XG4gICAgY29uc3RhbnRWYWx1ZSA9IC0xO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcblxuICB2YXIgbXVzdENhbmNlbCA9IGZ1bmN0aW9uIG11c3RDYW5jZWwodmFsdWUpIHtcbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBjYW5jZWxlZDtcbiAgICB9XG5cbiAgICBjYW5jZWxlZCA9IHZhbHVlICE9PSB1bmRlZmluZWQgJiYgY29uc3RhbnRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gdHlwZW9mIGNvbnN0YW50VmFsdWU7XG4gICAgcmV0dXJuIGNhbmNlbGVkO1xuICB9O1xuXG4gIHZhciBzZXRDaGFpblByb3BBY2Nlc3MgPSBmdW5jdGlvbiBzZXRDaGFpblByb3BBY2Nlc3Mob3duZXIsIHByb3BlcnR5KSB7XG4gICAgdmFyIGNoYWluSW5mbyA9IGdldFByb3BlcnR5SW5DaGFpbihvd25lciwgcHJvcGVydHkpO1xuICAgIHZhciBiYXNlID0gY2hhaW5JbmZvLmJhc2U7XG4gICAgdmFyIHByb3AgPSBjaGFpbkluZm8ucHJvcCxcbiAgICAgICAgY2hhaW4gPSBjaGFpbkluZm8uY2hhaW47IC8vIFRoZSBzY3JpcHRsZXQgbWlnaHQgYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBjaGFpbiBwcm9wZXJ0eSBoYXMgYmVlbiBjcmVhdGVkLlxuICAgIC8vIEluIHRoaXMgY2FzZSB3ZSdyZSBjaGVja2luZyB3aGV0aGVyIHRoZSBiYXNlIGVsZW1lbnQgZXhpc3RzIG9yIG5vdFxuICAgIC8vIGFuZCBpZiBub3QsIHdlIHNpbXBseSBleGl0IHdpdGhvdXQgb3ZlcnJpZGluZyBhbnl0aGluZ1xuXG4gICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBPYmplY3QgPT09IGZhbHNlICYmIGJhc2UgPT09IG51bGwpIHtcbiAgICAgIC8vIGxvZyB0aGUgcmVhc29uIG9ubHkgd2hpbGUgZGVidWdnaW5nXG4gICAgICBpZiAoc291cmNlLnZlcmJvc2UpIHtcbiAgICAgICAgdmFyIHByb3BzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIHByb3BJbmRleCA9IHByb3BzLmluZGV4T2YocHJvcCk7XG4gICAgICAgIHZhciBiYXNlTmFtZSA9IHByb3BzW3Byb3BJbmRleCAtIDFdO1xuICAgICAgICBjb25zb2xlLmxvZyhcInNldC1jb25zdGFudCBmYWlsZWQgYmVjYXVzZSB0aGUgcHJvcGVydHkgJ1wiLmNvbmNhdChiYXNlTmFtZSwgXCInIGRvZXMgbm90IGV4aXN0XCIpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2hhaW4pIHtcbiAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIoYSkge1xuICAgICAgICBiYXNlID0gYTtcblxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHNldENoYWluUHJvcEFjY2VzcyhhLCBjaGFpbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgcHJvcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtdXN0Q2FuY2VsKGJhc2VbcHJvcF0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGl0KHNvdXJjZSk7XG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGEpIHtcbiAgICAgICAgaWYgKG11c3RDYW5jZWwoYSkpIHtcbiAgICAgICAgICBjb25zdGFudFZhbHVlID0gYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbn1cbnNldENvbnN0YW50Lm5hbWVzID0gWydzZXQtY29uc3RhbnQnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nc2V0LWNvbnN0YW50LmpzJywgJ3Viby1zZXQtY29uc3RhbnQuanMnLCAnc2V0LmpzJywgJ3Viby1zZXQuanMnLCAndWJvLXNldC1jb25zdGFudCcsICd1Ym8tc2V0JywgJ2FicC1vdmVycmlkZS1wcm9wZXJ0eS1yZWFkJ107XG5zZXRDb25zdGFudC5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEFycmF5LCBub29wT2JqZWN0LCBub29wRnVuYywgdHJ1ZUZ1bmMsIGZhbHNlRnVuYywgZ2V0UHJvcGVydHlJbkNoYWluLCBzZXRQcm9wZXJ0eUFjY2VzcywgdG9SZWdFeHAsIG1hdGNoU3RhY2tUcmFjZSwgbmF0aXZlSXNOYU5dO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCByZW1vdmUtY29va2llXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZW1vdmVzIGN1cnJlbnQgcGFnZSBjb29raWVzIGJ5IHBhc3NlZCBzdHJpbmcgbWF0Y2hpbmcgd2l0aCBuYW1lLiBGb3IgY3VycmVudCBkb21haW4gYW5kIHN1YmRvbWFpbnMuIFJ1bnMgb24gbG9hZCBhbmQgYmVmb3JlIHVubG9hZC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNjb29raWUtcmVtb3ZlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWNvb2tpZSdbLCBtYXRjaF0pXG4gKiBgYGBcbiAqXG4gKiAtIGBtYXRjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ2V4IG1hdGNoaW5nIHRoZSBjb29raWUgbmFtZS4gSWYgbm90IHNwZWNpZmllZCBhbGwgYWNjZXNzaWJsZSBjb29raWVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIFJlbW92ZXMgYWxsIGNvb2tpZXM6XG4gKiBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtY29va2llJylcbiAqIGBgYFxuICpcbiAqIDIuIFJlbW92ZXMgY29va2llcyB3aGljaCBuYW1lIGNvbnRhaW5zIGBleGFtcGxlYCBzdHJpbmcuXG4gKiBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtY29va2llJywgJ2V4YW1wbGUnKVxuICogYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSB0aGlzIGNvb2tpZSB3aWxsIGJlIHJlbW92ZWRcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgZG9jdW1lbnQuY29va2llID0gJ19fZXhhbXBsZT1yYW5kb21WYWx1ZSc7XG4gKiAgICAgYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUNvb2tpZShzb3VyY2UsIG1hdGNoKSB7XG4gIHZhciBtYXRjaFJlZ2V4cCA9IHRvUmVnRXhwKG1hdGNoKTtcblxuICB2YXIgcmVtb3ZlQ29va2llRnJvbUhvc3QgPSBmdW5jdGlvbiByZW1vdmVDb29raWVGcm9tSG9zdChjb29raWVOYW1lLCBob3N0TmFtZSkge1xuICAgIHZhciBjb29raWVTcGVjID0gXCJcIi5jb25jYXQoY29va2llTmFtZSwgXCI9XCIpO1xuICAgIHZhciBkb21haW4xID0gXCI7IGRvbWFpbj1cIi5jb25jYXQoaG9zdE5hbWUpO1xuICAgIHZhciBkb21haW4yID0gXCI7IGRvbWFpbj0uXCIuY29uY2F0KGhvc3ROYW1lKTtcbiAgICB2YXIgcGF0aCA9ICc7IHBhdGg9Lyc7XG4gICAgdmFyIGV4cGlyYXRpb24gPSAnOyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UJztcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVTcGVjICsgZXhwaXJhdGlvbjtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVTcGVjICsgZG9tYWluMSArIGV4cGlyYXRpb247XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llU3BlYyArIGRvbWFpbjIgKyBleHBpcmF0aW9uO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZVNwZWMgKyBwYXRoICsgZXhwaXJhdGlvbjtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVTcGVjICsgZG9tYWluMSArIHBhdGggKyBleHBpcmF0aW9uO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZVNwZWMgKyBkb21haW4yICsgcGF0aCArIGV4cGlyYXRpb247XG4gICAgaGl0KHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIHJtQ29va2llID0gZnVuY3Rpb24gcm1Db29raWUoKSB7XG4gICAgZG9jdW1lbnQuY29va2llLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoY29va2llU3RyKSB7XG4gICAgICB2YXIgcG9zID0gY29va2llU3RyLmluZGV4T2YoJz0nKTtcblxuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29va2llTmFtZSA9IGNvb2tpZVN0ci5zbGljZSgwLCBwb3MpLnRyaW0oKTtcblxuICAgICAgaWYgKCFtYXRjaFJlZ2V4cC50ZXN0KGNvb2tpZU5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvc3RQYXJ0cyA9IGRvY3VtZW50LmxvY2F0aW9uLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGhvc3RQYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGhvc3ROYW1lID0gaG9zdFBhcnRzLnNsaWNlKGkpLmpvaW4oJy4nKTtcblxuICAgICAgICBpZiAoaG9zdE5hbWUpIHtcbiAgICAgICAgICByZW1vdmVDb29raWVGcm9tSG9zdChjb29raWVOYW1lLCBob3N0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBybUNvb2tpZSgpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgcm1Db29raWUpO1xufVxucmVtb3ZlQ29va2llLm5hbWVzID0gWydyZW1vdmUtY29va2llJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2Nvb2tpZS1yZW1vdmVyLmpzJywgJ3Viby1jb29raWUtcmVtb3Zlci5qcycsICd1Ym8tY29va2llLXJlbW92ZXInXTtcbnJlbW92ZUNvb2tpZS5pbmplY3Rpb25zID0gW3RvUmVnRXhwLCBoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGFkZGluZyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBjYWxsYmFja3MuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjYWRkZXZlbnRsaXN0ZW5lci1kZWZ1c2VyanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXInWywgZXZlbnRTZWFyY2hbLCBmdW5jdGlvblNlYXJjaF1dKVxuICogYGBgXG4gKlxuICogLSBgZXZlbnRTZWFyY2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWdleCBtYXRjaGluZyB0aGUgZXZlbnQgbmFtZS4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHNjcmlwdGxldHMgcHJldmVudHMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICogLSBgZnVuY3Rpb25TZWFyY2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWdleCBtYXRjaGluZyB0aGUgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gYm9keS4gSWYgbm90IHNldCwgdGhlIHNjcmlwdGxldCBwcmV2ZW50cyBhbGwgZXZlbnQgbGlzdGVuZXJzIHdpdGggZXZlbnQgbmFtZSBtYXRjaGluZyBgZXZlbnRTZWFyY2hgXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBQcmV2ZW50IGFsbCBgY2xpY2tgIGxpc3RlbmVyczpcbiAqIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtYWRkRXZlbnRMaXN0ZW5lcicsICdjbGljaycpXG4gKiBgYGBcblxuMi4gUHJldmVudCAnY2xpY2snIGxpc3RlbmVycyB3aXRoIHRoZSBjYWxsYmFjayBib2R5IGNvbnRhaW5pbmcgYHNlYXJjaFN0cmluZ2AuXG4gKiBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXInLCAnY2xpY2snLCAnc2VhcmNoU3RyaW5nJylcbiAqIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoaXMgbGlzdGVuZXIgd2lsbCBub3QgYmUgY2FsbGVkOlxuICogYGBgamF2YXNjcmlwdFxuICogICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9ICdzZWFyY2hTdHJpbmcnO1xuICogICAgIH0pO1xuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRBZGRFdmVudExpc3RlbmVyKHNvdXJjZSwgZXZlbnRTZWFyY2gsIGZ1bmNTZWFyY2gpIHtcbiAgdmFyIGV2ZW50U2VhcmNoUmVnZXhwID0gdG9SZWdFeHAoZXZlbnRTZWFyY2gpO1xuICB2YXIgZnVuY1NlYXJjaFJlZ2V4cCA9IHRvUmVnRXhwKGZ1bmNTZWFyY2gpO1xuICB2YXIgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyV3JhcHBlcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG5cbiAgICBpZiAodmFsaWRhdGVUeXBlKHR5cGUpICYmIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gZXZlbnRTZWFyY2hSZWdleHAudGVzdCh0eXBlLnRvU3RyaW5nKCkpICYmIGZ1bmNTZWFyY2hSZWdleHAudGVzdChsaXN0ZW5lclRvU3RyaW5nKGxpc3RlbmVyKSk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbdHlwZSwgbGlzdGVuZXJdLmNvbmNhdChhcmdzKSk7XG4gIH1cblxuICB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyV3JhcHBlcjtcbn1cbnByZXZlbnRBZGRFdmVudExpc3RlbmVyLm5hbWVzID0gWydwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXInLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nYWRkRXZlbnRMaXN0ZW5lci1kZWZ1c2VyLmpzJywgJ3Viby1hZGRFdmVudExpc3RlbmVyLWRlZnVzZXIuanMnLCAnYWVsZC5qcycsICd1Ym8tYWVsZC5qcycsICd1Ym8tYWRkRXZlbnRMaXN0ZW5lci1kZWZ1c2VyJywgJ3Viby1hZWxkJ107XG5wcmV2ZW50QWRkRXZlbnRMaXN0ZW5lci5pbmplY3Rpb25zID0gW2hpdCwgdG9SZWdFeHAsIHZhbGlkYXRlVHlwZSwgdmFsaWRhdGVMaXN0ZW5lciwgbGlzdGVuZXJUb1N0cmluZ107XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuLCBuby1ldmFsICovXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1iYWJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIEJsb2NrQWRibG9jayBzY3JpcHQgZnJvbSBkZXRlY3RpbmcgYW4gYWQgYmxvY2tlci5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNiYWItZGVmdXNlcmpzLVxuICpcbiAqIEl0IGFsc28gY2FuIGJlIHVzZWQgYXMgYCRyZWRpcmVjdGAgc29tZXRpbWVzLlxuICogU2VlIFtyZWRpcmVjdCBkZXNjcmlwdGlvbl0oLi4vd2lraS9hYm91dC1yZWRpcmVjdHMubWQjcHJldmVudC1iYWIpLlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1iYWInKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcHJldmVudEJhYihzb3VyY2UpIHtcbiAgdmFyIG5hdGl2ZVNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcbiAgdmFyIGJhYlJlZ2V4ID0gL1xcLmJhYl9lbGVtZW50aWQuJC87XG5cbiAgdmFyIHRpbWVvdXRXcmFwcGVyID0gZnVuY3Rpb24gdGltZW91dFdyYXBwZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnc3RyaW5nJyB8fCAhYmFiUmVnZXgudGVzdChjYWxsYmFjaykpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVTZXRUaW1lb3V0LmFwcGx5KHdpbmRvdywgW2NhbGxiYWNrXS5jb25jYXQoYXJncykpO1xuICAgIH1cblxuICAgIGhpdChzb3VyY2UpO1xuICB9O1xuXG4gIHdpbmRvdy5zZXRUaW1lb3V0ID0gdGltZW91dFdyYXBwZXI7XG4gIHZhciBzaWduYXR1cmVzID0gW1snYmxvY2thZGJsb2NrJ10sIFsnYmFiYXNibSddLCBbL2dldEl0ZW1cXCgnYmFibidcXCkvXSwgWydnZXRFbGVtZW50QnlJZCcsICdTdHJpbmcuZnJvbUNoYXJDb2RlJywgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JywgJ2NoYXJBdCcsICdET01Db250ZW50TG9hZGVkJywgJ0FkQmxvY2snLCAnYWRkRXZlbnRMaXN0ZW5lcicsICdkb1Njcm9sbCcsICdmcm9tQ2hhckNvZGUnLCAnPDwyfHI+PjQnLCAnc2Vzc2lvblN0b3JhZ2UnLCAnY2xpZW50V2lkdGgnLCAnbG9jYWxTdG9yYWdlJywgJ01hdGgnLCAncmFuZG9tJ11dO1xuXG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKHN0cikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIHRva2VucyA9IHNpZ25hdHVyZXNbaV07XG4gICAgICB2YXIgbWF0Y2ggPSAwO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbal07XG4gICAgICAgIHZhciBmb3VuZCA9IHRva2VuIGluc3RhbmNlb2YgUmVnRXhwID8gdG9rZW4udGVzdChzdHIpIDogc3RyLmluZGV4T2YodG9rZW4pID4gLTE7XG5cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgbWF0Y2ggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggLyB0b2tlbnMubGVuZ3RoID49IDAuOCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdmFyIG5hdGl2ZUV2YWwgPSB3aW5kb3cuZXZhbDtcblxuICB2YXIgZXZhbFdyYXBwZXIgPSBmdW5jdGlvbiBldmFsV3JhcHBlcihzdHIpIHtcbiAgICBpZiAoIWNoZWNrKHN0cikpIHtcbiAgICAgIHJldHVybiBuYXRpdmVFdmFsKHN0cik7XG4gICAgfVxuXG4gICAgaGl0KHNvdXJjZSk7XG4gICAgdmFyIGJvZHlFbCA9IGRvY3VtZW50LmJvZHk7XG5cbiAgICBpZiAoYm9keUVsKSB7XG4gICAgICBib2R5RWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3Zpc2liaWxpdHknKTtcbiAgICB9XG5cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFiYXNibXNneCcpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG4gIH07XG5cbiAgd2luZG93LmV2YWwgPSBldmFsV3JhcHBlci5iaW5kKHdpbmRvdyk7XG59XG5wcmV2ZW50QmFiLm5hbWVzID0gWydwcmV2ZW50LWJhYicsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidub2JhYi5qcycsICd1Ym8tbm9iYWIuanMnLCAnYmFiLWRlZnVzZXIuanMnLCAndWJvLWJhYi1kZWZ1c2VyLmpzJywgJ3Viby1ub2JhYicsICd1Ym8tYmFiLWRlZnVzZXInXTtcbnByZXZlbnRCYWIuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tZXh0cmEtYmluZCwgZnVuYy1uYW1lcyAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgbm93ZWJydGNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERpc2FibGVzIFdlYlJUQyBieSBvdmVycmlkaW5nIGBSVENQZWVyQ29ubmVjdGlvbmAuIFRoZSBvdmVycmlkZW4gZnVuY3Rpb24gd2lsbCBsb2cgZXZlcnkgYXR0ZW1wdCB0byBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbi5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNub3dlYnJ0Y2pzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnbm93ZWJydGMnKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIG5vd2VicnRjKHNvdXJjZSkge1xuICB2YXIgcHJvcGVydHlOYW1lID0gJyc7XG5cbiAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHByb3BlcnR5TmFtZSA9ICdSVENQZWVyQ29ubmVjdGlvbic7XG4gIH0gZWxzZSBpZiAod2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcHJvcGVydHlOYW1lID0gJ3dlYmtpdFJUQ1BlZXJDb25uZWN0aW9uJztcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eU5hbWUgPT09ICcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJ0Y1JlcGxhY2VtZW50ID0gZnVuY3Rpb24gcnRjUmVwbGFjZW1lbnQoY29uZmlnKSB7XG4gICAgaGl0KHNvdXJjZSwgXCJEb2N1bWVudCB0cmllZCB0byBjcmVhdGUgYW4gUlRDUGVlckNvbm5lY3Rpb246IFwiLmNvbmNhdChjb252ZXJ0UnRjQ29uZmlnVG9TdHJpbmcoY29uZmlnKSkpO1xuICB9O1xuXG4gIHJ0Y1JlcGxhY2VtZW50LnByb3RvdHlwZSA9IHtcbiAgICBjbG9zZTogbm9vcEZ1bmMsXG4gICAgY3JlYXRlRGF0YUNoYW5uZWw6IG5vb3BGdW5jLFxuICAgIGNyZWF0ZU9mZmVyOiBub29wRnVuYyxcbiAgICBzZXRSZW1vdGVEZXNjcmlwdGlvbjogbm9vcEZ1bmNcbiAgfTtcbiAgdmFyIHJ0YyA9IHdpbmRvd1twcm9wZXJ0eU5hbWVdO1xuICB3aW5kb3dbcHJvcGVydHlOYW1lXSA9IHJ0Y1JlcGxhY2VtZW50O1xuXG4gIGlmIChydGMucHJvdG90eXBlKSB7XG4gICAgcnRjLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZTogbm9vcEZ1bmMsXG4gICAgICAgIHNlbmQ6IG5vb3BGdW5jXG4gICAgICB9O1xuICAgIH0uYmluZChudWxsKTtcbiAgfVxufVxubm93ZWJydGMubmFtZXMgPSBbJ25vd2VicnRjJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25vd2VicnRjLmpzJywgJ3Viby1ub3dlYnJ0Yy5qcycsICd1Ym8tbm93ZWJydGMnXTtcbm5vd2VicnRjLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IGxvZy1hZGRFdmVudExpc3RlbmVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBMb2dzIGFsbCBhZGRFdmVudExpc3RlbmVyIGNhbGxzIHRvIHRoZSBjb25zb2xlLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2FkZGV2ZW50bGlzdGVuZXItbG9nZ2VyanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdsb2ctYWRkRXZlbnRMaXN0ZW5lcicpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBsb2dBZGRFdmVudExpc3RlbmVyKHNvdXJjZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICB2YXIgbG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgdmFyIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcldyYXBwZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodmFsaWRhdGVUeXBlKHR5cGUpICYmIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICB2YXIgbG9nTWVzc2FnZSA9IFwibG9nOiBhZGRFdmVudExpc3RlbmVyKFxcXCJcIi5jb25jYXQodHlwZSwgXCJcXFwiLCBcIikuY29uY2F0KGxpc3RlbmVyVG9TdHJpbmcobGlzdGVuZXIpLCBcIilcIik7XG4gICAgICBoaXQoc291cmNlLCBsb2dNZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZS52ZXJib3NlKSB7XG4gICAgICAvLyBsb2dnaW5nIHdoaWxlIGRlYnVnZ2luZ1xuICAgICAgdmFyIF9sb2dNZXNzYWdlID0gXCJJbnZhbGlkIGV2ZW50IHR5cGUgb3IgbGlzdGVuZXIgcGFzc2VkIHRvIGFkZEV2ZW50TGlzdGVuZXI6XFxudHlwZTogXCIuY29uY2F0KGNvbnZlcnRUeXBlVG9TdHJpbmcodHlwZSksIFwiXFxubGlzdGVuZXI6IFwiKS5jb25jYXQoY29udmVydFR5cGVUb1N0cmluZyhsaXN0ZW5lcikpO1xuXG4gICAgICBsb2coX2xvZ01lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFt0eXBlLCBsaXN0ZW5lcl0uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG4gIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXJXcmFwcGVyO1xufVxubG9nQWRkRXZlbnRMaXN0ZW5lci5uYW1lcyA9IFsnbG9nLWFkZEV2ZW50TGlzdGVuZXInLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nYWRkRXZlbnRMaXN0ZW5lci1sb2dnZXIuanMnLCAndWJvLWFkZEV2ZW50TGlzdGVuZXItbG9nZ2VyLmpzJywgJ2FlbGwuanMnLCAndWJvLWFlbGwuanMnLCAndWJvLWFkZEV2ZW50TGlzdGVuZXItbG9nZ2VyJywgJ3Viby1hZWxsJ107XG5sb2dBZGRFdmVudExpc3RlbmVyLmluamVjdGlvbnMgPSBbaGl0LCB2YWxpZGF0ZVR5cGUsIHZhbGlkYXRlTGlzdGVuZXIsIGxpc3RlbmVyVG9TdHJpbmcsIGNvbnZlcnRUeXBlVG9TdHJpbmcsIG9iamVjdFRvU3RyaW5nLCBpc0VtcHR5T2JqZWN0LCBnZXRPYmplY3RFbnRyaWVzXTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSwgbm8tZXZhbCAqL1xuLyoqXG4gKiBAc2NyaXB0bGV0IGxvZy1ldmFsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBMb2dzIGFsbCBgZXZhbCgpYCBvciBgbmV3IEZ1bmN0aW9uKClgIGNhbGxzIHRvIHRoZSBjb25zb2xlLlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnbG9nLWV2YWwnKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gbG9nRXZhbChzb3VyY2UpIHtcbiAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7IC8vIHdyYXAgZXZhbCBmdW5jdGlvblxuXG4gIHZhciBuYXRpdmVFdmFsID0gd2luZG93LmV2YWw7XG5cbiAgZnVuY3Rpb24gZXZhbFdyYXBwZXIoc3RyKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgbG9nKFwiZXZhbChcXFwiXCIuY29uY2F0KHN0ciwgXCJcXFwiKVwiKSk7XG4gICAgcmV0dXJuIG5hdGl2ZUV2YWwoc3RyKTtcbiAgfVxuXG4gIHdpbmRvdy5ldmFsID0gZXZhbFdyYXBwZXI7IC8vIHdyYXAgbmV3IEZ1bmN0aW9uXG5cbiAgdmFyIG5hdGl2ZUZ1bmN0aW9uID0gd2luZG93LkZ1bmN0aW9uO1xuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uV3JhcHBlcigpIHtcbiAgICBoaXQoc291cmNlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsb2coXCJuZXcgRnVuY3Rpb24oXCIuY29uY2F0KGFyZ3Muam9pbignLCAnKSwgXCIpXCIpKTtcbiAgICByZXR1cm4gbmF0aXZlRnVuY3Rpb24uYXBwbHkodGhpcywgW10uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG4gIEZ1bmN0aW9uV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hdGl2ZUZ1bmN0aW9uLnByb3RvdHlwZSk7XG4gIEZ1bmN0aW9uV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGdW5jdGlvbldyYXBwZXI7XG4gIHdpbmRvdy5GdW5jdGlvbiA9IEZ1bmN0aW9uV3JhcHBlcjtcbn1cbmxvZ0V2YWwubmFtZXMgPSBbJ2xvZy1ldmFsJ107XG5sb2dFdmFsLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IGxvZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBzaW1wbGUgc2NyaXB0bGV0IHdoaWNoIG9ubHkgcHVycG9zZSBpcyB0byBwcmludCBhcmd1bWVudHMgdG8gY29uc29sZS5cbiAqIFRoaXMgc2NyaXB0bGV0IGNhbiBiZSBoZWxwZnVsIGZvciBkZWJ1Z2dpbmcgYW5kIHRyb3VibGVzaG9vdGluZyBvdGhlciBzY3JpcHRsZXRzLlxuICpcbiAqICoqRXhhbXBsZSoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2xvZycsICdhcmcxJywgJ2FyZzInKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKGFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cbmxvZy5uYW1lcyA9IFsnbG9nJ107XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWV2YWwsIG5vLWV4dHJhLWJpbmQgKi9cbi8qKlxuICogQHNjcmlwdGxldCBub2V2YWxcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIHBhZ2UgdG8gdXNlIGV2YWwuXG4gKiBOb3RpZmllcyBhYm91dCBhdHRlbXB0cyBpbiB0aGUgY29uc29sZVxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vZXZhbGpzLVxuICpcbiAqIEl0IGFsc28gY2FuIGJlIHVzZWQgYXMgYCRyZWRpcmVjdGAgcnVsZXMgc29tZXRpbWVzLlxuICogU2VlIFtyZWRpcmVjdCBkZXNjcmlwdGlvbl0oLi4vd2lraS9hYm91dC1yZWRpcmVjdHMubWQjbm9ldmFsKS5cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ25vZXZhbCcpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBub2V2YWwoc291cmNlKSB7XG4gIHdpbmRvdy5ldmFsID0gZnVuY3Rpb24gZXZhbFdyYXBwZXIocykge1xuICAgIGhpdChzb3VyY2UsIFwiQWRHdWFyZCBoYXMgcHJldmVudGVkIGV2YWw6XFxuXCIuY29uY2F0KHMpKTtcbiAgfS5iaW5kKCk7XG59XG5ub2V2YWwubmFtZXMgPSBbJ25vZXZhbCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidub2V2YWwuanMnLCAnc2lsZW50LW5vZXZhbC5qcycsICd1Ym8tbm9ldmFsLmpzJywgJ3Viby1zaWxlbnQtbm9ldmFsLmpzJywgJ3Viby1ub2V2YWwnLCAndWJvLXNpbGVudC1ub2V2YWwnXTtcbm5vZXZhbC5pbmplY3Rpb25zID0gW2hpdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWV2YWwsIG5vLWV4dHJhLWJpbmQsIGZ1bmMtbmFtZXMgKi9cbi8qKlxuICogQHNjcmlwdGxldCBwcmV2ZW50LWV2YWwtaWZcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIHBhZ2UgdG8gdXNlIGV2YWwgbWF0Y2hpbmcgcGF5bG9hZC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNub2V2YWwtaWZqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZXZhbC1pZidbLCBzZWFyY2hdKVxuICogYGBgXG4gKlxuICogLSBgc2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVnZXhwIGZvciBtYXRjaGluZyBzdHJpbmdpZmllZCBldmFsIHBheWxvYWQuXG4gKiBJZiAnc2VhcmNoIGlzIG5vdCBzcGVjaWZpZWQg4oCUIGFsbCBzdHJpbmdpZmllZCBldmFsIHBheWxvYWQgd2lsbCBiZSBtYXRjaGVkXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiBgYGBcbiAqICEgUHJldmVudHMgZXZhbCBpZiBpdCBtYXRjaGVzICd0ZXN0J1xuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1ldmFsLWlmJywgJ3Rlc3QnKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBbc2VhcmNoXSBzdHJpbmcgb3IgcmVnZXhwIG1hdGNoaW5nIHN0cmluZ2lmaWVkIGV2YWwgcGF5bG9hZFxuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRFdmFsSWYoc291cmNlLCBzZWFyY2gpIHtcbiAgdmFyIHNlYXJjaFJlZ2V4cCA9IHRvUmVnRXhwKHNlYXJjaCk7XG4gIHZhciBuYXRpdmVFdmFsID0gd2luZG93LmV2YWw7XG5cbiAgd2luZG93LmV2YWwgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIGlmICghc2VhcmNoUmVnZXhwLnRlc3QocGF5bG9hZC50b1N0cmluZygpKSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUV2YWwuY2FsbCh3aW5kb3csIHBheWxvYWQpO1xuICAgIH1cblxuICAgIGhpdChzb3VyY2UsIHBheWxvYWQpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0uYmluZCh3aW5kb3cpO1xufVxucHJldmVudEV2YWxJZi5uYW1lcyA9IFsncHJldmVudC1ldmFsLWlmJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25vZXZhbC1pZi5qcycsICd1Ym8tbm9ldmFsLWlmLmpzJywgJ3Viby1ub2V2YWwtaWYnXTtcbnByZXZlbnRFdmFsSWYuaW5qZWN0aW9ucyA9IFt0b1JlZ0V4cCwgaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSwgZnVuYy1uYW1lcywgbm8tbXVsdGktYXNzaWduICovXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1mYWItMy4yLjBcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGV4ZWN1dGlvbiBvZiB0aGUgRkFCIHNjcmlwdCB2My4yLjAuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjZnVja2FkYmxvY2tqcy0zMjAtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWZhYi0zLjIuMCcpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50RmFiKHNvdXJjZSkge1xuICBoaXQoc291cmNlKTsgLy8gcmVkZWZpbmVzIEZhYiBmdW5jdGlvbiBmb3IgYWRibG9jayBkZXRlY3Rpb25cblxuICB2YXIgRmFiID0gZnVuY3Rpb24gRmFiKCkge307XG5cbiAgRmFiLnByb3RvdHlwZS5jaGVjayA9IG5vb3BGdW5jO1xuICBGYWIucHJvdG90eXBlLmNsZWFyRXZlbnQgPSBub29wRnVuYztcbiAgRmFiLnByb3RvdHlwZS5lbWl0RXZlbnQgPSBub29wRnVuYztcblxuICBGYWIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoIWEpIHtcbiAgICAgIGIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBGYWIucHJvdG90eXBlLm9uRGV0ZWN0ZWQgPSBub29wVGhpcztcblxuICBGYWIucHJvdG90eXBlLm9uTm90RGV0ZWN0ZWQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBGYWIucHJvdG90eXBlLnNldE9wdGlvbiA9IG5vb3BGdW5jO1xuICBGYWIucHJvdG90eXBlLm9wdGlvbnMgPSB7XG4gICAgc2V0OiBub29wRnVuYyxcbiAgICBnZXQ6IG5vb3BGdW5jXG4gIH07XG4gIHZhciBmYWIgPSBuZXcgRmFiKCk7XG4gIHZhciBnZXRTZXRGYWIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gRmFiO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7fVxuICB9O1xuICB2YXIgZ2V0c2V0ZmFiID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhYjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KCkge31cbiAgfTsgLy8gcmVkZWZpbmVkIEZhYiBkYXRhIHByb3BlcnRpZXMgd2hpY2ggaWYgJ0Z1Y2tBZEJsb2NrJyB2YXJpYWJsZSBleGlzdHNcblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdpbmRvdywgJ0Z1Y2tBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuRnVja0FkQmxvY2sgPSBGYWI7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3IgcmVkZWZpbmVkIEZhYiBhY2Nlc3NvciBwcm9wZXJ0aWVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ0Z1Y2tBZEJsb2NrJywgZ2V0U2V0RmFiKTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2luZG93LCAnQmxvY2tBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuQmxvY2tBZEJsb2NrID0gRmFiO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdCbG9ja0FkQmxvY2snLCBnZXRTZXRGYWIpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3aW5kb3csICdTbmlmZkFkQmxvY2snKSkge1xuICAgIHdpbmRvdy5TbmlmZkFkQmxvY2sgPSBGYWI7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ1NuaWZmQWRCbG9jaycsIGdldFNldEZhYik7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdpbmRvdywgJ2Z1Y2tBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuZnVja0FkQmxvY2sgPSBmYWI7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2Z1Y2tBZEJsb2NrJywgZ2V0c2V0ZmFiKTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2luZG93LCAnYmxvY2tBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuYmxvY2tBZEJsb2NrID0gZmFiO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdibG9ja0FkQmxvY2snLCBnZXRzZXRmYWIpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3aW5kb3csICdzbmlmZkFkQmxvY2snKSkge1xuICAgIHdpbmRvdy5zbmlmZkFkQmxvY2sgPSBmYWI7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ3NuaWZmQWRCbG9jaycsIGdldHNldGZhYik7XG4gIH1cbn1cbnByZXZlbnRGYWIubmFtZXMgPSBbJ3ByZXZlbnQtZmFiLTMuMi4wJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25vZmFiLmpzJywgJ3Viby1ub2ZhYi5qcycsICdmdWNrYWRibG9jay5qcy0zLjIuMCcsICd1Ym8tZnVja2FkYmxvY2suanMtMy4yLjAnLCAndWJvLW5vZmFiJ107XG5wcmV2ZW50RmFiLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgbm9vcFRoaXNdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlLCBmdW5jLW5hbWVzLCBuby1tdWx0aS1hc3NpZ24gKi9cbi8qKlxuICogQHNjcmlwdGxldCBzZXQtcG9wYWRzLWR1bW15XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXRzIHN0YXRpYyBwcm9wZXJ0aWVzIFBvcEFkcyBhbmQgcG9wbnMuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjcG9wYWRzLWR1bW15anMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtcG9wYWRzLWR1bW15JylcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHNldFBvcGFkc0R1bW15KHNvdXJjZSkge1xuICBkZWxldGUgd2luZG93LlBvcEFkcztcbiAgZGVsZXRlIHdpbmRvdy5wb3BucztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod2luZG93LCB7XG4gICAgUG9wQWRzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBvcG5zOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuc2V0UG9wYWRzRHVtbXkubmFtZXMgPSBbJ3NldC1wb3BhZHMtZHVtbXknLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4ncG9wYWRzLWR1bW15LmpzJywgJ3Viby1wb3BhZHMtZHVtbXkuanMnLCAndWJvLXBvcGFkcy1kdW1teSddO1xuc2V0UG9wYWRzRHVtbXkuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1wb3BhZHMtbmV0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBYm9ydHMgb24gcHJvcGVydHkgd3JpdGUgKFBvcEFkcywgcG9wbnMpLCB0aHJvd3MgcmVmZXJlbmNlIGVycm9yIHdpdGggcmFuZG9tIGlkLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I3BvcGFkc25ldGpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1wb3BhZHMtbmV0JylcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRQb3BhZHNOZXQoc291cmNlKSB7XG4gIHZhciByaWQgPSByYW5kb21JZCgpO1xuXG4gIHZhciB0aHJvd0Vycm9yID0gZnVuY3Rpb24gdGhyb3dFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IocmlkKTtcbiAgfTtcblxuICBkZWxldGUgd2luZG93LlBvcEFkcztcbiAgZGVsZXRlIHdpbmRvdy5wb3BucztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod2luZG93LCB7XG4gICAgUG9wQWRzOiB7XG4gICAgICBzZXQ6IHRocm93RXJyb3JcbiAgICB9LFxuICAgIHBvcG5zOiB7XG4gICAgICBzZXQ6IHRocm93RXJyb3JcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cub25lcnJvciA9IGNyZWF0ZU9uRXJyb3JIYW5kbGVyKHJpZCkuYmluZCgpO1xuICBoaXQoc291cmNlKTtcbn1cbnByZXZlbnRQb3BhZHNOZXQubmFtZXMgPSBbJ3ByZXZlbnQtcG9wYWRzLW5ldCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidwb3BhZHMubmV0LmpzJywgJ3Viby1wb3BhZHMubmV0LmpzJywgJ3Viby1wb3BhZHMubmV0J107XG5wcmV2ZW50UG9wYWRzTmV0LmluamVjdGlvbnMgPSBbY3JlYXRlT25FcnJvckhhbmRsZXIsIHJhbmRvbUlkLCBoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1hZGZseVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgYW50aS1hZGJsb2NrIHNjcmlwdHMgb24gYWRmbHkgc2hvcnQgbGlua3MuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjYWRmbHktZGVmdXNlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1hZGZseScpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50QWRmbHkoc291cmNlKSB7XG4gIHZhciBpc0RpZ2l0ID0gZnVuY3Rpb24gaXNEaWdpdChkYXRhKSB7XG4gICAgcmV0dXJuIC9eXFxkJC8udGVzdChkYXRhKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZW5jb2RlZFVSTCkge1xuICAgIHZhciBldmVuQ2hhcnMgPSAnJztcbiAgICB2YXIgb2RkQ2hhcnMgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgIGV2ZW5DaGFycyArPSBlbmNvZGVkVVJMLmNoYXJBdChpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9kZENoYXJzID0gZW5jb2RlZFVSTC5jaGFyQXQoaSkgKyBvZGRDaGFycztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IChldmVuQ2hhcnMgKyBvZGRDaGFycykuc3BsaXQoJycpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRhdGEubGVuZ3RoOyBfaSArPSAxKSB7XG4gICAgICBpZiAoaXNEaWdpdChkYXRhW19pXSkpIHtcbiAgICAgICAgZm9yICh2YXIgaWkgPSBfaSArIDE7IGlpIDwgZGF0YS5sZW5ndGg7IGlpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaXNEaWdpdChkYXRhW2lpXSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB2YXIgdGVtcCA9IHBhcnNlSW50KGRhdGFbX2ldLCAxMCkgXiBwYXJzZUludChkYXRhW2lpXSwgMTApO1xuXG4gICAgICAgICAgICBpZiAodGVtcCA8IDEwKSB7XG4gICAgICAgICAgICAgIGRhdGFbX2ldID0gdGVtcC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaSA9IGlpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEuam9pbignJyk7XG4gICAgdmFyIGRlY29kZWRVUkwgPSB3aW5kb3cuYXRvYihkYXRhKS5zbGljZSgxNiwgLTE2KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wYXQvY29tcGF0ICovXG5cbiAgICBpZiAod2luZG93LnN0b3ApIHtcbiAgICAgIHdpbmRvdy5zdG9wKCk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgY29tcGF0L2NvbXBhdCAqL1xuXG5cbiAgICB3aW5kb3cub25iZWZvcmV1bmxvYWQgPSBudWxsO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVjb2RlZFVSTDtcbiAgfTtcblxuICB2YXIgdmFsOyAvLyBEbyBub3QgYXBwbHkgaGFuZGxlciBtb3JlIHRoYW4gb25lIHRpbWVcblxuICB2YXIgYXBwbHlIYW5kbGVyID0gdHJ1ZTtcbiAgdmFyIHJlc3VsdCA9IHNldFByb3BlcnR5QWNjZXNzKHdpbmRvdywgJ3lzbW0nLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKGFwcGx5SGFuZGxlcikge1xuICAgICAgICBhcHBseUhhbmRsZXIgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXG4gICAgICB9XG5cbiAgICAgIHZhbCA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIGhpdChzb3VyY2UpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2V0IHVwIHByZXZlbnQtYWRmbHkgc2NyaXB0bGV0Jyk7XG4gIH1cbn1cbnByZXZlbnRBZGZseS5uYW1lcyA9IFsncHJldmVudC1hZGZseScsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidhZGZseS1kZWZ1c2VyLmpzJywgJ3Viby1hZGZseS1kZWZ1c2VyLmpzJywgJ3Viby1hZGZseS1kZWZ1c2VyJ107XG5wcmV2ZW50QWRmbHkuaW5qZWN0aW9ucyA9IFtzZXRQcm9wZXJ0eUFjY2VzcywgaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgZGVidWctb24tcHJvcGVydHktcmVhZFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzY3JpcHRsZXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIFthYm9ydC1vbi1wcm9wZXJ0eS1yZWFkXSgjYWJvcnQtb24tcHJvcGVydHktcmVhZCksIGJ1dCBpbnN0ZWFkIG9mIGFib3J0aW5nIGl0IHN0YXJ0cyB0aGUgZGVidWdnZXIuXG4gKlxuICogKipJdCBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBwcm9kdWN0aW9uIGZpbHRlciBsaXN0cyEqKlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogISBEZWJ1ZyBzY3JpcHQgaWYgaXQgdHJpZXMgdG8gYWNjZXNzIGB3aW5kb3cuYWxlcnRgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkZWJ1Zy1vbi1wcm9wZXJ0eS1yZWFkJywgJ2FsZXJ0JylcbiAqICEgb2YgYHdpbmRvdy5vcGVuYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnZGVidWctb24tcHJvcGVydHktcmVhZCcsICdvcGVuJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBkZWJ1Z09uUHJvcGVydHlSZWFkKHNvdXJjZSwgcHJvcGVydHksIHN0YWNrKSB7XG4gIGlmICghcHJvcGVydHkgfHwgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJpZCA9IHJhbmRvbUlkKCk7XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgfTtcblxuICB2YXIgc2V0Q2hhaW5Qcm9wQWNjZXNzID0gZnVuY3Rpb24gc2V0Q2hhaW5Qcm9wQWNjZXNzKG93bmVyLCBwcm9wZXJ0eSkge1xuICAgIHZhciBjaGFpbkluZm8gPSBnZXRQcm9wZXJ0eUluQ2hhaW4ob3duZXIsIHByb3BlcnR5KTtcbiAgICB2YXIgYmFzZSA9IGNoYWluSW5mby5iYXNlO1xuICAgIHZhciBwcm9wID0gY2hhaW5JbmZvLnByb3AsXG4gICAgICAgIGNoYWluID0gY2hhaW5JbmZvLmNoYWluO1xuXG4gICAgaWYgKGNoYWluKSB7XG4gICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKGEpIHtcbiAgICAgICAgYmFzZSA9IGE7XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBzZXRDaGFpblByb3BBY2Nlc3MoYSwgY2hhaW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3duZXIsIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogc2V0dGVyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRQcm9wZXJ0eUFjY2VzcyhiYXNlLCBwcm9wLCB7XG4gICAgICBnZXQ6IGFib3J0LFxuICAgICAgc2V0OiBub29wRnVuY1xuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbiAgd2luZG93Lm9uZXJyb3IgPSBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpLmJpbmQoKTtcbn1cbmRlYnVnT25Qcm9wZXJ0eVJlYWQubmFtZXMgPSBbJ2RlYnVnLW9uLXByb3BlcnR5LXJlYWQnXTtcbmRlYnVnT25Qcm9wZXJ0eVJlYWQuaW5qZWN0aW9ucyA9IFtyYW5kb21JZCwgc2V0UHJvcGVydHlBY2Nlc3MsIGdldFByb3BlcnR5SW5DaGFpbiwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdCwgdG9SZWdFeHAsIG1hdGNoU3RhY2tUcmFjZSwgbm9vcEZ1bmNdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBkZWJ1Zy1vbi1wcm9wZXJ0eS13cml0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzY3JpcHRsZXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIFthYm9ydC1vbi1wcm9wZXJ0eS13cml0ZV0oI2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlKSwgYnV0IGluc3RlYWQgb2YgYWJvcnRpbmcgaXQgc3RhcnRzIHRoZSBkZWJ1Z2dlci5cbiAqXG4gKiAqKkl0IGlzIG5vdCBzdXBwb3NlZCB0byBiZSB1c2VkIGluIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzISoqXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiAhIEFib3J0cyBzY3JpcHQgd2hlbiBpdCB0cmllcyB0byB3cml0ZSBpbiBwcm9wZXJ0eSBgd2luZG93LnRlc3RgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkZWJ1Zy1vbi1wcm9wZXJ0eS13cml0ZScsICd0ZXN0JylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBkZWJ1Z09uUHJvcGVydHlXcml0ZShzb3VyY2UsIHByb3BlcnR5LCBzdGFjaykge1xuICBpZiAoIXByb3BlcnR5IHx8ICFtYXRjaFN0YWNrVHJhY2Uoc3RhY2ssIG5ldyBFcnJvcigpLnN0YWNrKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByaWQgPSByYW5kb21JZCgpO1xuXG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGhpdChzb3VyY2UpO1xuICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjtcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgc2V0OiBhYm9ydFxuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbiAgd2luZG93Lm9uZXJyb3IgPSBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpLmJpbmQoKTtcbn1cbmRlYnVnT25Qcm9wZXJ0eVdyaXRlLm5hbWVzID0gWydkZWJ1Zy1vbi1wcm9wZXJ0eS13cml0ZSddO1xuZGVidWdPblByb3BlcnR5V3JpdGUuaW5qZWN0aW9ucyA9IFtyYW5kb21JZCwgc2V0UHJvcGVydHlBY2Nlc3MsIGdldFByb3BlcnR5SW5DaGFpbiwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdCwgdG9SZWdFeHAsIG1hdGNoU3RhY2tUcmFjZV07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGRlYnVnLWN1cnJlbnQtaW5saW5lLXNjcmlwdFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzY3JpcHRsZXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIFthYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHRdKCNhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQpLCBidXQgaW5zdGVhZCBvZiBhYm9ydGluZyBpdCBzdGFydHMgdGhlIGRlYnVnZ2VyLlxuICpcbiAqICoqSXQgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gcHJvZHVjdGlvbiBmaWx0ZXIgbGlzdHMhKipcbiAqXG4gKiAqKlN5bnRheCoqXG4gKmBgYFxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gYWNjZXNzIGB3aW5kb3cuYWxlcnRgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkZWJ1Zy1jdXJyZW50LWlubGluZS1zY3JpcHQnLCAnYWxlcnQnKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIGRlYnVnQ3VycmVudElubGluZVNjcmlwdChzb3VyY2UsIHByb3BlcnR5KSB7XG4gIHZhciBzZWFyY2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gIHZhciBzZWFyY2hSZWdleHAgPSB0b1JlZ0V4cChzZWFyY2gpO1xuICB2YXIgcmlkID0gcmFuZG9tSWQoKTtcblxuICB2YXIgZ2V0Q3VycmVudFNjcmlwdCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHQoKSB7XG4gICAgaWYgKCdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIH1cblxuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHJldHVybiBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV07XG4gIH07XG5cbiAgdmFyIG91clNjcmlwdCA9IGdldEN1cnJlbnRTY3JpcHQoKTtcblxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB2YXIgc2NyaXB0RWwgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG5cbiAgICBpZiAoc2NyaXB0RWwgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCAmJiBzY3JpcHRFbC50ZXh0Q29udGVudC5sZW5ndGggPiAwICYmIHNjcmlwdEVsICE9PSBvdXJTY3JpcHQgJiYgKCFzZWFyY2ggfHwgc2VhcmNoUmVnZXhwLnRlc3Qoc2NyaXB0RWwudGV4dENvbnRlbnQpKSkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0Q2hhaW5Qcm9wQWNjZXNzID0gZnVuY3Rpb24gc2V0Q2hhaW5Qcm9wQWNjZXNzKG93bmVyLCBwcm9wZXJ0eSkge1xuICAgIHZhciBjaGFpbkluZm8gPSBnZXRQcm9wZXJ0eUluQ2hhaW4ob3duZXIsIHByb3BlcnR5KTtcbiAgICB2YXIgYmFzZSA9IGNoYWluSW5mby5iYXNlO1xuICAgIHZhciBwcm9wID0gY2hhaW5JbmZvLnByb3AsXG4gICAgICAgIGNoYWluID0gY2hhaW5JbmZvLmNoYWluO1xuXG4gICAgaWYgKGNoYWluKSB7XG4gICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKGEpIHtcbiAgICAgICAgYmFzZSA9IGE7XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBzZXRDaGFpblByb3BBY2Nlc3MoYSwgY2hhaW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3duZXIsIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogc2V0dGVyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFZhbHVlID0gYmFzZVtwcm9wXTtcbiAgICBzZXRQcm9wZXJ0eUFjY2VzcyhiYXNlLCBwcm9wLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBzZXRDaGFpblByb3BBY2Nlc3Mod2luZG93LCBwcm9wZXJ0eSk7XG4gIHdpbmRvdy5vbmVycm9yID0gY3JlYXRlT25FcnJvckhhbmRsZXIocmlkKS5iaW5kKCk7XG59XG5kZWJ1Z0N1cnJlbnRJbmxpbmVTY3JpcHQubmFtZXMgPSBbJ2RlYnVnLWN1cnJlbnQtaW5saW5lLXNjcmlwdCddO1xuZGVidWdDdXJyZW50SW5saW5lU2NyaXB0LmluamVjdGlvbnMgPSBbcmFuZG9tSWQsIHNldFByb3BlcnR5QWNjZXNzLCBnZXRQcm9wZXJ0eUluQ2hhaW4sIHRvUmVnRXhwLCBjcmVhdGVPbkVycm9ySGFuZGxlciwgaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcmVtb3ZlLWF0dHJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzIGZyb20gRE9NIG5vZGVzLiBUaGlzIHNjcmlwdGxldCBydW5zIG9uY2Ugd2hlbiB0aGUgcGFnZSBsb2Fkc1xuICogYW5kIGFmdGVyIHRoYXQgcGVyaW9kaWNhbGx5IGluIG9yZGVyIHRvIERPTSB0cmVlIGNoYW5nZXMuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjcmVtb3ZlLWF0dHJqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3JlbW92ZS1hdHRyJywgYXR0cnNbLCBzZWxlY3Rvcl0pXG4gKiBgYGBcbiAqXG4gKiAtIGBhdHRyc2Ag4oCUIHJlcXVpcmVkLCBhdHRyaWJ1dGUgb3IgbGlzdCBvZiBhdHRyaWJ1dGVzIGpvaW5lZCBieSAnfCdcbiAqIC0gYHNlbGVjdG9yYCDigJQgb3B0aW9uYWwsIENTUyBzZWxlY3Rvciwgc3BlY2lmaWVzIERPTSBub2RlcyBmcm9tIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgcmVtb3ZlZFxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gIFJlbW92ZXMgYnkgYXR0cmlidXRlXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWF0dHInLCAnZXhhbXBsZXx0ZXN0JylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDwhLS0gYmVmb3JlICAtLT5cbiAqICAgICA8ZGl2IGV4YW1wbGU9XCJ0cnVlXCIgdGVzdD1cInRydWVcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqXG4gKiAgICAgPCEtLSBhZnRlciAtLT5cbiAqICAgICA8ZGl2PlNvbWUgdGV4dDwvZGl2PlxuICogICAgIGBgYFxuICpcbiAqIDIuIFJlbW92ZXMgd2l0aCBzcGVjaWZpZWQgc2VsZWN0b3JcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtYXR0cicsICdleGFtcGxlJywgJ2RpdltjbGFzcz1cImlubmVyXCJdJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDwhLS0gYmVmb3JlIC0tPlxuICogICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyXCIgZXhhbXBsZT1cInRydWVcIj5cbiAqICAgICAgICAgPGRpdiBjbGFzcz1cImlubmVyXCIgZXhhbXBsZT1cInRydWVcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgPCEtLSBhZnRlciAtLT5cbiAqICAgICA8ZGl2IGNsYXNzPVwid3JhcHBlclwiIGV4YW1wbGU9XCJ0cnVlXCI+XG4gKiAgICAgICAgIDxkaXYgY2xhc3M9XCJpbm5lclwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDwvZGl2PlxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVBdHRyKHNvdXJjZSwgYXR0cnMsIHNlbGVjdG9yKSB7XG4gIGlmICghYXR0cnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhdHRycyA9IGF0dHJzLnNwbGl0KC9cXHMqXFx8XFxzKi8pO1xuXG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICBzZWxlY3RvciA9IFwiW1wiLmNvbmNhdChhdHRycy5qb2luKCddLFsnKSwgXCJdXCIpO1xuICB9XG5cbiAgdmFyIHJtYXR0ciA9IGZ1bmN0aW9uIHJtYXR0cigpIHtcbiAgICB2YXIgbm9kZXMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgfVxuICB9O1xuXG4gIHJtYXR0cigpOyAvLyAndHJ1ZScgZm9yIG9ic2VydmluZyBhdHRyaWJ1dGVzXG5cbiAgb2JzZXJ2ZURPTUNoYW5nZXMocm1hdHRyLCB0cnVlKTtcbn1cbnJlbW92ZUF0dHIubmFtZXMgPSBbJ3JlbW92ZS1hdHRyJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ3JlbW92ZS1hdHRyLmpzJywgJ3Viby1yZW1vdmUtYXR0ci5qcycsICdyYS5qcycsICd1Ym8tcmEuanMnLCAndWJvLXJlbW92ZS1hdHRyJywgJ3Viby1yYSddO1xucmVtb3ZlQXR0ci5pbmplY3Rpb25zID0gW2hpdCwgb2JzZXJ2ZURPTUNoYW5nZXNdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCByZW1vdmUtY2xhc3NcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjbGFzc2VzIGZyb20gRE9NIG5vZGVzLiBUaGlzIHNjcmlwdGxldCBydW5zIG9uY2UgYWZ0ZXIgdGhlIHBhZ2UgbG9hZHNcbiAqIGFuZCBhZnRlciB0aGF0IHBlcmlvZGljYWxseSBpbiBvcmRlciB0byBET00gdHJlZSBjaGFuZ2VzLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I3JlbW92ZS1jbGFzc2pzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWNsYXNzJywgY2xhc3Nlc1ssIHNlbGVjdG9yXSlcbiAqIGBgYFxuICpcbiAqIC0gYGNsYXNzZXNgIOKAlCByZXF1aXJlZCwgY2xhc3Mgb3IgbGlzdCBvZiBjbGFzc2VzIHNlcGFyYXRlZCBieSAnfCdcbiAqIC0gYHNlbGVjdG9yYCDigJQgb3B0aW9uYWwsIENTUyBzZWxlY3Rvciwgc3BlY2lmaWVzIERPTSBub2RlcyBmcm9tIHdoaWNoIHRoZSBjbGFzc2VzIHdpbGwgYmUgcmVtb3ZlZC5cbiAqIElmIHRoZXJlIGlzIG5vIGBzZWxlY3RvcmAsIGVhY2ggY2xhc3Mgb2YgYGNsYXNzZXNgIGluZGVwZW5kZW50bHkgd2lsbCBiZSByZW1vdmVkIGZyb20gYWxsIG5vZGVzIHdoaWNoIGhhcyBvbmVcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuICBSZW1vdmVzIGJ5IGNsYXNzZXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtY2xhc3MnLCAnZXhhbXBsZXx0ZXN0JylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDwhLS0gYmVmb3JlICAtLT5cbiAqICAgICA8ZGl2IGlkPVwiZmlyc3RcIiBjbGFzcz1cIm5pY2UgdGVzdFwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDxkaXYgaWQ9XCJzZWNvbmRcIiBjbGFzcz1cInJhcmUgZXhhbXBsZSBmb3IgdGVzdFwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDxkaXYgaWQ9XCJ0aGlyZFwiIGNsYXNzPVwidGVzdGluZyBiZXR0ZXIgZXhhbXBsZVwiPlNvbWUgdGV4dDwvZGl2PlxuICpcbiAqICAgICA8IS0tIGFmdGVyIC0tPlxuICogICAgIDxkaXYgaWQ9XCJmaXJzdFwiIGNsYXNzPVwibmljZVwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDxkaXYgaWQ9XCJzZWNvbmRcIiBjbGFzcz1cInJhcmUgZm9yXCI+U29tZSB0ZXh0PC9kaXY+XG4gKiAgICAgPGRpdiBpZD1cInRoaXJkXCIgY2xhc3M9XCJ0ZXN0aW5nIGJldHRlclwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIGBgYFxuICpcbiAqIDIuIFJlbW92ZXMgd2l0aCBzcGVjaWZpZWQgc2VsZWN0b3JcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtY2xhc3MnLCAnYnJhbmRpbmcnLCAnZGl2W2NsYXNzXj1cImlubmVyXCJdJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDwhLS0gYmVmb3JlIC0tPlxuICogICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyIHRydWUgYnJhbmRpbmdcIj5cbiAqICAgICAgICAgPGRpdiBjbGFzcz1cImlubmVyIGJhZCBicmFuZGluZ1wiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDwvZGl2PlxuICpcbiAqICAgICA8IS0tIGFmdGVyIC0tPlxuICogICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyIHRydWUgYnJhbmRpbmdcIj5cbiAqICAgICAgICAgPGRpdiBjbGFzcz1cImlubmVyIGJhZFwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDwvZGl2PlxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhzb3VyY2UsIGNsYXNzTmFtZXMsIHNlbGVjdG9yKSB7XG4gIGlmICghY2xhc3NOYW1lcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLnNwbGl0KC9cXHMqXFx8XFxzKi8pO1xuICB2YXIgc2VsZWN0b3JzID0gW107XG5cbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHNlbGVjdG9ycyA9IGNsYXNzTmFtZXMubWFwKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBcIi5cIi5jb25jYXQoY2xhc3NOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciByZW1vdmVDbGFzc0hhbmRsZXIgPSBmdW5jdGlvbiByZW1vdmVDbGFzc0hhbmRsZXIoKSB7XG4gICAgdmFyIG5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZm91bmRlZE5vZGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICBmb3VuZGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbm9kZXMuYWRkKG4pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzZWxlY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICBub2Rlcy5hZGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbW92ZUNsYXNzSGFuZGxlcigpO1xuICB2YXIgQ0xBU1NfQVRUUl9OQU1FID0gWydjbGFzcyddOyAvLyAndHJ1ZScgZm9yIG9ic2VydmluZyBhdHRyaWJ1dGVzXG4gIC8vICdjbGFzcycgZm9yIG9ic2VydmluZyBvbmx5IGNsYXNzZXNcblxuICBvYnNlcnZlRE9NQ2hhbmdlcyhyZW1vdmVDbGFzc0hhbmRsZXIsIHRydWUsIENMQVNTX0FUVFJfTkFNRSk7XG59XG5yZW1vdmVDbGFzcy5uYW1lcyA9IFsncmVtb3ZlLWNsYXNzJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ3JlbW92ZS1jbGFzcy5qcycsICd1Ym8tcmVtb3ZlLWNsYXNzLmpzJywgJ3JjLmpzJywgJ3Viby1yYy5qcycsICd1Ym8tcmVtb3ZlLWNsYXNzJywgJ3Viby1yYyddO1xucmVtb3ZlQ2xhc3MuaW5qZWN0aW9ucyA9IFtoaXQsIG9ic2VydmVET01DaGFuZ2VzXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IGRpc2FibGUtbmV3dGFiLWxpbmtzXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBvcGVuaW5nIG5ldyB0YWJzIGFuZCB3aW5kb3dzIGlmIHRoZXJlIGlzIGB0YXJnZXRgIGF0dHJpYnV0ZSBpbiBlbGVtZW50LlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2Rpc2FibGUtbmV3dGFiLWxpbmtzanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkaXNhYmxlLW5ld3RhYi1saW5rcycpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlTmV3dGFiTGlua3Moc291cmNlKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcblxuICAgIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgIGlmICh0YXJnZXQubG9jYWxOYW1lID09PSAnYScgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgndGFyZ2V0JykpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgfVxuICB9KTtcbn1cbmRpc2FibGVOZXd0YWJMaW5rcy5uYW1lcyA9IFsnZGlzYWJsZS1uZXd0YWItbGlua3MnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nZGlzYWJsZS1uZXd0YWItbGlua3MuanMnLCAndWJvLWRpc2FibGUtbmV3dGFiLWxpbmtzLmpzJywgJ3Viby1kaXNhYmxlLW5ld3RhYi1saW5rcyddO1xuZGlzYWJsZU5ld3RhYkxpbmtzLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgYWRqdXN0LXNldEludGVydmFsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGp1c3RzIGludGVydmFsIGZvciBzcGVjaWZpZWQgc2V0SW50ZXJ2YWwoKSBjYWxsYmFja3MuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjbmFuby1zZXRpbnRlcnZhbC1ib29zdGVyanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnWywgbWF0Y2ggWywgaW50ZXJ2YWxbLCBib29zdF1dXSlcbiAqIGBgYFxuICpcbiAqIC0gYG1hdGNoYCAtIG9wdGlvbmFsLCBzdHJpbmcvcmVndWxhciBleHByZXNzaW9uLCBtYXRjaGluZyBpbiBzdHJpbmdpZmllZCBjYWxsYmFjayBmdW5jdGlvblxuICogLSBgaW50ZXJ2YWxgIC0gb3B0aW9uYWwsIGRlZmF1bHRzIHRvIDEwMDAsIG1hdGNoaW5nIHNldEludGVydmFsIGRlbGF5OyBkZWNpbWFsIGludGVnZXIgT1IgJyonIGZvciBhbnkgZGVsYXlcbiAqIC0gYGJvb3N0YCAtIG9wdGlvbmFsLCBkZWZhdWx0IHRvIDAuMDUsIGZsb2F0LCBjYXBwZWQgYXQgNTAgdGltZXMgZm9yIHVwIGFuZCBkb3duICgwLjAyLi4uNTApLCBpbnRlcnZhbCBtdWx0aXBsaWVyXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBBZGp1c3QgYWxsIHNldEludGVydmFsKCkgeDIwIHRpbWVzIHdoZXJlIGludGVydmFsIGVxdWFsIDEwMDBtczpcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnKVxuICogICAgIGBgYFxuICpcbiAqIDIuIEFkanVzdCBhbGwgc2V0SW50ZXJ2YWwoKSB4MjAgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0aGVkIHdpdGggYGV4YW1wbGVgIGFuZCBpbnRlcnZhbCBlcXVhbCAxMDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnLCAnZXhhbXBsZScpXG4gKiAgICAgYGBgXG4gKlxuICogMy4gQWRqdXN0IGFsbCBzZXRJbnRlcnZhbCgpIHgyMCB0aW1lcyB3aGVyZSBjYWxsYmFjayBtYXRoZWQgd2l0aCBgZXhhbXBsZWAgYW5kIGludGVydmFsIGVxdWFsIDQwMG1zXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldEludGVydmFsJywgJ2V4YW1wbGUnLCAnNDAwJylcbiAqICAgICBgYGBcbiAqXG4gKiA0LiBTbG93IGRvd24gc2V0SW50ZXJ2YWwoKSB4MiB0aW1lcyB3aGVyZSBjYWxsYmFjayBtYXRjaGVkIHdpdGggYGV4YW1wbGVgIGFuZCBpbnRlcnZhbCBlcXVhbCAxMDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnLCAnZXhhbXBsZScsICcnLCAnMicpXG4gKiAgICAgYGBgXG4gKiA1LiBBZGp1c3QgYWxsIHNldEludGVydmFsKCkgeDUwIHRpbWVzIHdoZXJlIGludGVydmFsIGVxdWFsIDIwMDBtc1xuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRJbnRlcnZhbCcsICcnLCAnMjAwMCcsICcwLjAyJylcbiAqICAgICBgYGBcbiAqIDYuIEFkanVzdCBhbGwgc2V0SW50ZXJ2YWwoKSB4NTAgdGltZXMgd2hlcmUgaW50ZXJ2YWwgaXMgcmFuZG9taXplZFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRJbnRlcnZhbCcsICcnLCAnKicsICcwLjAyJylcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gYWRqdXN0U2V0SW50ZXJ2YWwoc291cmNlLCBtYXRjaCwgaW50ZXJ2YWwsIGJvb3N0KSB7XG4gIHZhciBuYXRpdmVTZXRJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbDtcbiAgdmFyIG1hdGNoUmVnZXhwID0gdG9SZWdFeHAobWF0Y2gpO1xuXG4gIHZhciBpbnRlcnZhbFdyYXBwZXIgPSBmdW5jdGlvbiBpbnRlcnZhbFdyYXBwZXIoY2IsIGQpIHtcbiAgICBpZiAobWF0Y2hSZWdleHAudGVzdChjYi50b1N0cmluZygpKSAmJiBpc0RlbGF5TWF0Y2hlZChpbnRlcnZhbCwgZCkpIHtcbiAgICAgIGQgKj0gZ2V0Qm9vc3RNdWx0aXBsaWVyKGJvb3N0KTtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVTZXRJbnRlcnZhbC5hcHBseSh3aW5kb3csIFtjYiwgZF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0SW50ZXJ2YWwgPSBpbnRlcnZhbFdyYXBwZXI7XG59XG5hZGp1c3RTZXRJbnRlcnZhbC5uYW1lcyA9IFsnYWRqdXN0LXNldEludGVydmFsJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25hbm8tc2V0SW50ZXJ2YWwtYm9vc3Rlci5qcycsICd1Ym8tbmFuby1zZXRJbnRlcnZhbC1ib29zdGVyLmpzJywgJ25hbm8tc2liLmpzJywgJ3Viby1uYW5vLXNpYi5qcycsICd1Ym8tbmFuby1zZXRJbnRlcnZhbC1ib29zdGVyJywgJ3Viby1uYW5vLXNpYiddO1xuYWRqdXN0U2V0SW50ZXJ2YWwuaW5qZWN0aW9ucyA9IFtoaXQsIHRvUmVnRXhwLCBnZXRCb29zdE11bHRpcGxpZXIsIGlzRGVsYXlNYXRjaGVkLCBuYXRpdmVJc05hTiwgbmF0aXZlSXNGaW5pdGUsIGdldE1hdGNoRGVsYXksIGdldFdpbGRjYXJkU3ltYm9sLCBzaG91bGRNYXRjaEFueURlbGF5XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgYWRqdXN0LXNldFRpbWVvdXRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkanVzdHMgdGltZW91dCBmb3Igc3BlY2lmaWVkIHNldFRpbW91dCgpIGNhbGxiYWNrcy5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNuYW5vLXNldHRpbWVvdXQtYm9vc3RlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldFRpbWVvdXQnWywgbWF0Y2ggWywgdGltZW91dFssIGJvb3N0XV1dKVxuICogYGBgXG4gKlxuICogLSBgbWF0Y2hgIC0gb3B0aW9uYWwsIHN0cmluZy9yZWd1bGFyIGV4cHJlc3Npb24sIG1hdGNoaW5nIGluIHN0cmluZ2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAtIGB0aW1lb3V0YCAtIG9wdGlvbmFsLCBkZWZhdWx0cyB0byAxMDAwLCBtYXRjaGluZyBzZXRUaW1vdXQgZGVsYXk7IGRlY2ltYWwgaW50ZWdlciBPUiAnKicgZm9yIGFueSBkZWxheVxuICogLSBgYm9vc3RgIC0gb3B0aW9uYWwsIGRlZmF1bHQgdG8gMC4wNSwgZmxvYXQsIGNhcHBlZCBhdCA1MCB0aW1lcyBmb3IgdXAgYW5kIGRvd24gKDAuMDIuLi41MCksIHRpbWVvdXQgbXVsdGlwbGllclxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gQWRqdXN0IGFsbCBzZXRUaW1lb3V0KCkgeDIwIHRpbWVzIHdoZXJlIHRpbWVvdXQgZXF1YWwgMTAwMG1zOlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRUaW1lb3V0JylcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBBZGp1c3QgYWxsIHNldFRpbWVvdXQoKSB4MjAgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0aGVkIHdpdGggYGV4YW1wbGVgIGFuZCB0aW1lb3V0IGVxdWFsIDEwMDBtc1xuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRUaW1lb3V0JywgJ2V4YW1wbGUnKVxuICogICAgIGBgYFxuICpcbiAqIDMuIEFkanVzdCBhbGwgc2V0VGltZW91dCgpIHgyMCB0aW1lcyB3aGVyZSBjYWxsYmFjayBtYXRoZWQgd2l0aCBgZXhhbXBsZWAgYW5kIHRpbWVvdXQgZXF1YWwgNDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0VGltZW91dCcsICdleGFtcGxlJywgJzQwMCcpXG4gKiAgICAgYGBgXG4gKlxuICogNC4gU2xvdyBkb3duIHNldFRpbWVvdXQoKSB4MiB0aW1lcyB3aGVyZSBjYWxsYmFjayBtYXRjaGVkIHdpdGggYGV4YW1wbGVgIGFuZCB0aW1lb3V0IGVxdWFsIDEwMDBtc1xuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRUaW1lb3V0JywgJ2V4YW1wbGUnLCAnJywgJzInKVxuICogICAgIGBgYFxuICogNS4gQWRqdXN0IGFsbCBzZXRUaW1lb3V0KCkgeDUwIHRpbWVzIHdoZXJlIHRpbWVvdXQgZXF1YWwgMjAwMG1zXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldFRpbWVvdXQnLCAnJywgJzIwMDAnLCAnMC4wMicpXG4gKiAgICAgYGBgXG4gKiA2LiBBZGp1c3QgYWxsIHNldFRpbWVvdXQoKSB4MjAgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0aGVkIHdpdGggYHRlc3RgIGFuZCB0aW1lb3V0IGlzIHJhbmRvbWl6ZWRcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0VGltZW91dCcsICd0ZXN0JywgJyonKVxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBhZGp1c3RTZXRUaW1lb3V0KHNvdXJjZSwgbWF0Y2gsIHRpbWVvdXQsIGJvb3N0KSB7XG4gIHZhciBuYXRpdmVTZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG4gIHZhciBtYXRjaFJlZ2V4cCA9IHRvUmVnRXhwKG1hdGNoKTtcblxuICB2YXIgdGltZW91dFdyYXBwZXIgPSBmdW5jdGlvbiB0aW1lb3V0V3JhcHBlcihjYiwgZCkge1xuICAgIGlmIChtYXRjaFJlZ2V4cC50ZXN0KGNiLnRvU3RyaW5nKCkpICYmIGlzRGVsYXlNYXRjaGVkKHRpbWVvdXQsIGQpKSB7XG4gICAgICBkICo9IGdldEJvb3N0TXVsdGlwbGllcihib29zdCk7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlU2V0VGltZW91dC5hcHBseSh3aW5kb3csIFtjYiwgZF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0VGltZW91dCA9IHRpbWVvdXRXcmFwcGVyO1xufVxuYWRqdXN0U2V0VGltZW91dC5uYW1lcyA9IFsnYWRqdXN0LXNldFRpbWVvdXQnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbmFuby1zZXRUaW1lb3V0LWJvb3N0ZXIuanMnLCAndWJvLW5hbm8tc2V0VGltZW91dC1ib29zdGVyLmpzJywgJ25hbm8tc3RiLmpzJywgJ3Viby1uYW5vLXN0Yi5qcycsICd1Ym8tbmFuby1zZXRUaW1lb3V0LWJvb3N0ZXInLCAndWJvLW5hbm8tc3RiJ107XG5hZGp1c3RTZXRUaW1lb3V0LmluamVjdGlvbnMgPSBbaGl0LCB0b1JlZ0V4cCwgZ2V0Qm9vc3RNdWx0aXBsaWVyLCBpc0RlbGF5TWF0Y2hlZCwgbmF0aXZlSXNOYU4sIG5hdGl2ZUlzRmluaXRlLCBnZXRNYXRjaERlbGF5LCBnZXRXaWxkY2FyZFN5bWJvbCwgc2hvdWxkTWF0Y2hBbnlEZWxheV07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGRpci1zdHJpbmdcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdyYXBzIHRoZSBgY29uc29sZS5kaXJgIEFQSSB0byBjYWxsIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiB0aGUgYXJndW1lbnQuXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBhZGJsb2NrIGNpcmN1bXZlbnRpb24gc3lzdGVtcyB0aGF0IGRldGVjdCBicm93c2VyIGRldnRvb2xzXG4gKiBhbmQgaGlkZSB0aGVtc2VsdmVzLiBUaGVyZWZvcmUsIGlmIHdlIGZvcmNlIHRoZW0gdG8gdGhpbmtcbiAqIHRoYXQgZGV2dG9vbHMgYXJlIG9wZW4gKHVzaW5nIHRoaXMgc2NyY2lwdGxldCksXG4gKiBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzYWJsZSB0aGUgYWRibG9jayBjaXJjdW12ZW50aW9uIHNjcmlwdC5cbiAqXG4gKiBSZWxhdGVkIEFCUCBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWRibG9ja3BsdXMvYWRibG9ja3BsdXNjb3JlL2Jsb2IvNmIyYTMwOTA1NGNjMjM0MzIxMDJiODVkMTNmMTI1NTk2MzllZjQ5NS9saWIvY29udGVudC9zbmlwcGV0cy5qcyNMNzY2XG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkaXItc3RyaW5nJ1ssIHRpbWVzXSlcbiAqIGBgYFxuICogLSBgdGltZXNgIC0gb3B0aW9uYWwsIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gY2FsbCB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgdGhlIGFyZ3VtZW50IHRvIGBjb25zb2xlLmRpcmBcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiAhIFJ1biAyIHRpbWVzXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkaXItc3RyaW5nJywgJzInKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIGRpclN0cmluZyhzb3VyY2UsIHRpbWVzKSB7XG4gIHZhciBfY29uc29sZSA9IGNvbnNvbGUsXG4gICAgICBkaXIgPSBfY29uc29sZS5kaXI7XG4gIHRpbWVzID0gcGFyc2VJbnQodGltZXMsIDEwKTtcblxuICBmdW5jdGlvbiBkaXJXcmFwcGVyKG9iamVjdCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciB0ZW1wO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lczsgaSArPSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICB0ZW1wID0gXCJcIi5jb25jYXQob2JqZWN0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRpciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGlyLmNhbGwodGhpcywgb2JqZWN0KTtcbiAgICB9XG5cbiAgICBoaXQoc291cmNlLCB0ZW1wKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG5cbiAgY29uc29sZS5kaXIgPSBkaXJXcmFwcGVyO1xufVxuZGlyU3RyaW5nLm5hbWVzID0gWydkaXItc3RyaW5nJywgJ2FicC1kaXItc3RyaW5nJ107XG5kaXJTdHJpbmcuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBqc29uLXBydW5lXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZW1vdmVzIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIEpTT04ucGFyc2UgYW5kIHJldHVybnMgdGhlIGNhbGxlclxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2pzb24tcHJ1bmVqcy1cbiAqXG4gKiBSZWxhdGVkIEFCUCBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWRibG9ja3BsdXMvYWRibG9ja3BsdXNjb3JlL2Jsb2IvbWFzdGVyL2xpYi9jb250ZW50L3NuaXBwZXRzLmpzI0wxMjg1XG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJ1ssIHByb3BzVG9SZW1vdmUgWywgb2JsaWdhdG9yeVByb3BzIFssIHN0YWNrXV1dKVxuICogYGBgXG4gKlxuICogLSBgcHJvcHNUb1JlbW92ZWAgLSBvcHRpb25hbCwgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCBwcm9wZXJ0aWVzIHRvIHJlbW92ZVxuICogLSBgb2JsaWdhdG9yeVByb3BzYCAtIG9wdGlvbmFsLCBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHByb3BlcnRpZXMgd2hpY2ggbXVzdCBiZSBhbGwgcHJlc2VudCBmb3IgdGhlIHBydW5pbmcgdG8gb2NjdXJcbiAqIC0gYHN0YWNrYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbXVzdCBtYXRjaCB0aGUgY3VycmVudCBmdW5jdGlvbiBjYWxsIHN0YWNrIHRyYWNlXG4gKlxuICogPiBOb3RlIHBsZWFzZSB0aGF0IHlvdSBjYW4gdXNlIHdpbGRjYXJkIGAqYCBmb3IgY2hhaW4gcHJvcGVydHkgbmFtZS5cbiAqIGUuZy4gJ2FkLiouc3JjJyBpbnN0ZWFkIG9mICdhZC4wLnNyYyBhZC4xLnNyYyBhZC4yLnNyYyAuLi4nXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBSZW1vdmVzIHByb3BlcnR5IGBleGFtcGxlYCBmcm9tIHRoZSByZXN1bHRzIG9mIEpTT04ucGFyc2UgY2FsbFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2pzb24tcHJ1bmUnLCAnZXhhbXBsZScpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBjYWxsIHdpbGwgcmV0dXJuIGB7IG9uZTogMX1gXG4gKlxuICogICAgIGBgYGh0bWxcbiAqICAgICBKU09OLnBhcnNlKCd7XCJvbmVcIjoxLFwiZXhhbXBsZVwiOnRydWV9JylcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBJZiB0aGVyZSBhcmUgbm8gc3BlY2lmaWVkIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCBvZiBKU09OLnBhcnNlIGNhbGwsIHBydW5pbmcgd2lsbCBOT1Qgb2NjdXJcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJywgJ29uZScsICdvYmxpZ2F0b3J5UHJvcCcpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBjYWxsIHdpbGwgcmV0dXJuIGB7IG9uZTogMSwgdHdvOiAyfWBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIEpTT04ucGFyc2UoJ3tcIm9uZVwiOjEsXCJ0d29cIjoyfScpXG4gKiAgICAgYGBgXG4gKlxuICogMy4gQSBwcm9wZXJ0eSBpbiBhIGxpc3Qgb2YgcHJvcGVydGllcyBjYW4gYmUgYSBjaGFpbiBvZiBwcm9wZXJ0aWVzXG4gKlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2pzb24tcHJ1bmUnLCAnYS5iJywgJ2FkcGF0aC51cmwuZmlyc3QnKVxuICogICAgIGBgYFxuICpcbiAqIDQuIFJlbW92ZXMgcHJvcGVydHkgYGNvbnRlbnQuYWRgIGZyb20gdGhlIHJlc3VsdHMgb2YgSlNPTi5wYXJzZSBjYWxsIGl0J3MgZXJyb3Igc3RhY2sgdHJhY2UgY29udGFpbnMgYHRlc3QuanNgXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnanNvbi1wcnVuZScsICdjb250ZW50LmFkJywgJycsICd0ZXN0LmpzJylcbiAqICAgICBgYGBcbiAqXG4gKiA1LiBBIHByb3BlcnR5IGluIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGNhbiBiZSBhIGNoYWluIG9mIHByb3BlcnRpZXMgd2l0aCB3aWxkY2FyZCBpbiBpdFxuICpcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJywgJ2NvbnRlbnQuKi5tZWRpYS5zcmMnLCAnY29udGVudC4qLm1lZGlhLnByZXJvbGwnKVxuICogICAgIGBgYFxuICpcbiAqIDYuIENhbGwgd2l0aCBubyBhcmd1bWVudHMgd2lsbCBsb2cgdGhlIGN1cnJlbnQgaG9zdG5hbWUgYW5kIGpzb24gcGF5bG9hZCBhdCB0aGUgY29uc29sZVxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2pzb24tcHJ1bmUnKVxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBqc29uUHJ1bmUoc291cmNlLCBwcm9wc1RvUmVtb3ZlLCByZXF1aXJlZEluaXRpYWxQcm9wcywgc3RhY2spIHtcbiAgaWYgKCEhc3RhY2sgJiYgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cblxuICB2YXIgbG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgdmFyIHBydW5lUGF0aHMgPSBwcm9wc1RvUmVtb3ZlICE9PSB1bmRlZmluZWQgJiYgcHJvcHNUb1JlbW92ZSAhPT0gJycgPyBwcm9wc1RvUmVtb3ZlLnNwbGl0KC8gKy8pIDogW107XG4gIHZhciByZXF1aXJlZFBhdGhzID0gcmVxdWlyZWRJbml0aWFsUHJvcHMgIT09IHVuZGVmaW5lZCAmJiByZXF1aXJlZEluaXRpYWxQcm9wcyAhPT0gJycgPyByZXF1aXJlZEluaXRpYWxQcm9wcy5zcGxpdCgvICsvKSA6IFtdO1xuXG4gIGZ1bmN0aW9uIGlzUHJ1bmluZ05lZWRlZChyb290KSB7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFByb2Nlc3M7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVpcmVkUGF0aHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciByZXF1aXJlZFBhdGggPSByZXF1aXJlZFBhdGhzW2ldO1xuICAgICAgdmFyIGxhc3ROZXN0ZWRQcm9wTmFtZSA9IHJlcXVpcmVkUGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICAgICAgdmFyIGhhc1dpbGRjYXJkID0gcmVxdWlyZWRQYXRoLmluZGV4T2YoJy4qLicpID4gLTEgfHwgcmVxdWlyZWRQYXRoLmluZGV4T2YoJyouJykgPiAtMSB8fCByZXF1aXJlZFBhdGguaW5kZXhPZignLionKSA+IC0xIHx8IHJlcXVpcmVkUGF0aC5pbmRleE9mKCcuW10uJykgPiAtMSB8fCByZXF1aXJlZFBhdGguaW5kZXhPZignW10uJykgPiAtMSB8fCByZXF1aXJlZFBhdGguaW5kZXhPZignLltdJykgPiAtMTsgLy8gaWYgdGhlIHBhdGggaGFzIHdpbGRjYXJkLCBnZXRQcm9wZXJ0eUluQ2hhaW4gc2hvdWxkICdsb29rIHRocm91Z2gnIGNoYWluIHByb3BzXG5cbiAgICAgIHZhciBkZXRhaWxzID0gZ2V0V2lsZGNhcmRQcm9wZXJ0eUluQ2hhaW4ocm9vdCwgcmVxdWlyZWRQYXRoLCBoYXNXaWxkY2FyZCk7IC8vIHN0YXJ0IHZhbHVlIG9mICdzaG91bGRQcm9jZXNzJyBkdWUgdG8gY2hlY2tpbmcgYmVsb3dcblxuICAgICAgc2hvdWxkUHJvY2VzcyA9ICFoYXNXaWxkY2FyZDtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRldGFpbHMubGVuZ3RoOyBfaSArPSAxKSB7XG4gICAgICAgIGlmIChoYXNXaWxkY2FyZCkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgd2lsZGNhcmQsXG4gICAgICAgICAgLy8gYXQgbGVhc3Qgb25lICh8fCkgb2YgcHJvcHMgY2hhaW4gc2hvdWxkIGJlIHByZXNlbnQgaW4gb2JqZWN0XG4gICAgICAgICAgc2hvdWxkUHJvY2VzcyA9ICEoZGV0YWlsc1tfaV0uYmFzZVtsYXN0TmVzdGVkUHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHx8IHNob3VsZFByb2Nlc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGVhY2ggb25lICgmJikgb2YgdGhlbSBzaG91bGQgYmUgdGhlcmVcbiAgICAgICAgICBzaG91bGRQcm9jZXNzID0gIShkZXRhaWxzW19pXS5iYXNlW2xhc3ROZXN0ZWRQcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkgJiYgc2hvdWxkUHJvY2VzcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaG91bGRQcm9jZXNzO1xuICB9XG4gIC8qKlxuICAgKiBQcnVuZXMgcHJvcGVydGllcyBvZiAncm9vdCcgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSByb290XG4gICAqL1xuXG5cbiAgdmFyIGpzb25QcnVuZXIgPSBmdW5jdGlvbiBqc29uUHJ1bmVyKHJvb3QpIHtcbiAgICBpZiAocHJ1bmVQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZyh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIHJvb3QpO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc1BydW5pbmdOZWVkZWQocm9vdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByb290O1xuICAgICAgfSAvLyBpZiBwcnVuaW5nIGlzIG5lZWRlZCwgd2UgY2hlY2sgZXZlcnkgaW5wdXQgcGF0aFRvUmVtb3ZlXG4gICAgICAvLyBhbmQgZGVsZXRlIGl0IGlmIHJvb3QgaGFzIGl0XG5cblxuICAgICAgcHJ1bmVQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBvd25lck9iakFyciA9IGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluKHJvb3QsIHBhdGgsIHRydWUpO1xuICAgICAgICBvd25lck9iakFyci5mb3JFYWNoKGZ1bmN0aW9uIChvd25lck9iaikge1xuICAgICAgICAgIGlmIChvd25lck9iaiAhPT0gdW5kZWZpbmVkICYmIG93bmVyT2JqLmJhc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvd25lck9iai5iYXNlW293bmVyT2JqLnByb3BdO1xuICAgICAgICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHJldHVybiByb290O1xuICB9O1xuXG4gIHZhciBuYXRpdmVKU09OUGFyc2UgPSBKU09OLnBhcnNlO1xuXG4gIHZhciBqc29uUGFyc2VXcmFwcGVyID0gZnVuY3Rpb24ganNvblBhcnNlV3JhcHBlcigpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgLy8gZGVhbGluZyB3aXRoIHN0cmluZ2lmaWVkIGpzb24gaW4gYXJncywgd2hpY2ggc2hvdWxkIGJlIHBhcnNlZC5cbiAgICAvLyBzbyB3ZSBjYWxsIG5hdGl2ZUpTT05QYXJzZSBhcyBKU09OLnBhcnNlIHdoaWNoIGlzIGJvdW5kIHRvIEpTT04gb2JqZWN0XG4gICAgdmFyIHJvb3QgPSBuYXRpdmVKU09OUGFyc2UuYXBwbHkoSlNPTiwgYXJncyk7XG4gICAgcmV0dXJuIGpzb25QcnVuZXIocm9vdCk7XG4gIH07IC8vIEpTT04ucGFyc2UgbW9ja2luZ1xuXG5cbiAganNvblBhcnNlV3JhcHBlci50b1N0cmluZyA9IG5hdGl2ZUpTT05QYXJzZS50b1N0cmluZy5iaW5kKG5hdGl2ZUpTT05QYXJzZSk7XG4gIEpTT04ucGFyc2UgPSBqc29uUGFyc2VXcmFwcGVyOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXG4gIHZhciBuYXRpdmVSZXNwb25zZUpzb24gPSBSZXNwb25zZS5wcm90b3R5cGUuanNvbjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuICB2YXIgcmVzcG9uc2VKc29uV3JhcHBlciA9IGZ1bmN0aW9uIHJlc3BvbnNlSnNvbldyYXBwZXIoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuYXRpdmVSZXNwb25zZUpzb24uYXBwbHkodGhpcyk7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4ganNvblBydW5lcihvYmopO1xuICAgIH0pO1xuICB9OyAvLyBkbyBub3RoaW5nIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBSZXNwb25zZSAoZS5nLiBJbnRlcm5ldCBFeHBsb3JlcilcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc3BvbnNlXG5cblxuICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmpzb24gPSByZXNwb25zZUpzb25XcmFwcGVyO1xufVxuanNvblBydW5lLm5hbWVzID0gWydqc29uLXBydW5lJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2pzb24tcHJ1bmUuanMnLCAndWJvLWpzb24tcHJ1bmUuanMnLCAndWJvLWpzb24tcHJ1bmUnLCAnYWJwLWpzb24tcHJ1bmUnXTtcbmpzb25QcnVuZS5pbmplY3Rpb25zID0gW2hpdCwgbWF0Y2hTdGFja1RyYWNlLCBnZXRXaWxkY2FyZFByb3BlcnR5SW5DaGFpbiwgdG9SZWdFeHAsIGdldFdpbGRjYXJkU3ltYm9sXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbFxuICogaWYgdGhlIHRleHQgb2YgdGhlIGNhbGxiYWNrIGlzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgc2VhcmNoIHN0cmluZyB3aGljaCBkb2VzIG5vdCBzdGFydCB3aXRoIGAhYDtcbiAqIG90aGVyd2lzZSBtaXNtYXRjaGVkIGNhbGxzIHNob3VsZCBiZSBkZWZ1c2VkLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vLXJlcXVlc3RhbmltYXRpb25mcmFtZS1pZmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnWywgc2VhcmNoXSlcbiAqIGBgYFxuICpcbiAqIC0gYHNlYXJjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIElmIHN0YXJ0cyB3aXRoIGAhYCwgc2NyaXB0bGV0IHdpbGwgbm90IG1hdGNoIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayBidXQgYWxsIG90aGVyIHdpbGwgYmUgZGVmdXNlZC5cbiAqIElmIGRvIG5vdCBzdGFydCB3aXRoIGAhYCwgdGhlIHN0cmluZ2lmaWVkIGNhbGxiYWNrIHdpbGwgYmUgbWF0Y2hlZC5cbiAqXG4gKiBDYWxsIHdpdGggbm8gYXJndW1lbnQgd2lsbCBsb2cgYWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjYWxscyB3aGlsZSBkZWJ1Z2dpbmcuXG4gKiBTbyBkbyBub3QgdXNlIHRoZSBzY3JpcHRsZXQgd2l0aG91dCBhbnkgcGFyYW1ldGVyIGluIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzLlxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gUHJldmVudHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIG1hdGNoZXMgYC9cXC50ZXN0L2AuXG4gKiAgICAgYGBgYmFzaFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtcmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgJy9cXC50ZXN0LycpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBjYWxsIHdpbGwgYmUgcHJldmVudGVkOlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICB2YXIgdGltZXMgPSAwO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBjaGFuZ2UoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gJ25ldyB2YWx1ZSc7XG4gKiAgICAgICAgIGlmICh0aW1lcyA8IDIpIHtcbiAqICAgICAgICAgICAgIHRpbWVzICs9IDE7XG4gKiAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2hhbmdlKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGBgYFxuICogMi4gUHJldmVudHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbHMgaWYgKipkb2VzIG5vdCBtYXRjaCoqICdjaGVjaycuXG4gKiAgICAgYGBgYmFzaFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtcmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgJyFjaGVjaycpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgb25seSB0aGUgZmlyc3QgY2FsbCB3aWxsIGJlIHByZXZlbnRlZDpcbiAqXG4gKiAgICAgYGBgamF2YXNjcmlwdFxuICogICAgIHZhciB0aW1lc0ZpcnN0ID0gMDtcbiAqICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gY2hhbmdlRmlyc3QoKSB7XG4gKiAgICAgICAgIHdpbmRvdy5jaGVjayA9ICdzaG91bGQgbm90IGJlIHByZXZlbnRlZCc7XG4gKiAgICAgICAgIGlmICh0aW1lc0ZpcnN0IDwgMikge1xuICogICAgICAgICAgICAgdGltZXNGaXJzdCArPSAxO1xuICogICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNoYW5nZUZpcnN0KTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqICAgICB2YXIgdGltZXNTZWNvbmQgPSAwO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBjaGFuZ2VTZWNvbmQoKSB7XG4gKiAgICAgICAgIHdpbmRvdy5zZWNvbmQgPSAnc2hvdWxkIGJlIHByZXZlbnRlZCc7XG4gKiAgICAgICAgIGlmICh0aW1lc1NlY29uZCA8IDIpIHtcbiAqICAgICAgICAgICAgIHRpbWVzU2Vjb25kICs9IDE7XG4gKiAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2hhbmdlU2Vjb25kKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50UmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNvdXJjZSwgbWF0Y2gpIHtcbiAgdmFyIG5hdGl2ZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7IC8vIGxvZ3MgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIGNvbnNvbGUgaWYgbm8gYXJndW1lbnRzIGhhdmUgYmVlbiBzcGVjaWZpZWRcblxuICB2YXIgc2hvdWxkTG9nID0gdHlwZW9mIG1hdGNoID09PSAndW5kZWZpbmVkJztcblxuICB2YXIgX3BhcnNlTWF0Y2hBcmcgPSBwYXJzZU1hdGNoQXJnKG1hdGNoKSxcbiAgICAgIGlzSW52ZXJ0ZWRNYXRjaCA9IF9wYXJzZU1hdGNoQXJnLmlzSW52ZXJ0ZWRNYXRjaCxcbiAgICAgIG1hdGNoUmVnZXhwID0gX3BhcnNlTWF0Y2hBcmcubWF0Y2hSZWdleHA7XG5cbiAgdmFyIHJhZldyYXBwZXIgPSBmdW5jdGlvbiByYWZXcmFwcGVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcblxuICAgIGlmIChzaG91bGRMb2cpIHtcbiAgICAgIHZhciBsb2dNZXNzYWdlID0gXCJsb2c6IHJlcXVlc3RBbmltYXRpb25GcmFtZShcXFwiXCIuY29uY2F0KGNhbGxiYWNrLnRvU3RyaW5nKCksIFwiXFxcIilcIik7XG4gICAgICBoaXQoc291cmNlLCBsb2dNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkUHJldmVudCA9IG1hdGNoUmVnZXhwLnRlc3QoY2FsbGJhY2sudG9TdHJpbmcoKSkgIT09IGlzSW52ZXJ0ZWRNYXRjaDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICByZXR1cm4gbmF0aXZlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5vb3BGdW5jKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmFwcGx5KHdpbmRvdywgW2NhbGxiYWNrXS5jb25jYXQoYXJncykpO1xuICB9O1xuXG4gIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByYWZXcmFwcGVyO1xufVxucHJldmVudFJlcXVlc3RBbmltYXRpb25GcmFtZS5uYW1lcyA9IFsncHJldmVudC1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm8tcmVxdWVzdEFuaW1hdGlvbkZyYW1lLWlmLmpzJywgJ3Viby1uby1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUtaWYuanMnLCAnbm9yYWZpZi5qcycsICd1Ym8tbm9yYWZpZi5qcycsICd1Ym8tbm8tcmVxdWVzdEFuaW1hdGlvbkZyYW1lLWlmJywgJ3Viby1ub3JhZmlmJ107XG5wcmV2ZW50UmVxdWVzdEFuaW1hdGlvbkZyYW1lLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgcGFyc2VNYXRjaEFyZywgdG9SZWdFeHAsIHN0YXJ0c1dpdGhdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBzZXQtY29va2llXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXRzIGEgY29va2llIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGFuZCB2YWx1ZS4gQ29va2llIHBhdGggZGVmYXVsdHMgdG8gcm9vdC5cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb29raWUnLCBuYW1lLCB2YWx1ZSlcbiAqIGBgYFxuICpcbiAqIC0gYG5hbWVgIC0gcmVxdWlyZWQsIGNvb2tpZSBuYW1lIHRvIGJlIHNldFxuICogLSBgdmFsdWVgIC0gcmVxdWlyZWQsIGNvb2tpZSB2YWx1ZTsgcG9zc2libGUgdmFsdWVzOlxuICogICAgIC0gbnVtYmVyIGA+PSAwICYmIDw9IDE1YFxuICogICAgIC0gb25lIG9mIHRoZSBwcmVkZWZpbmVkIGNvbnN0YW50czpcbiAqICAgICAgICAgLSBgdHJ1ZWAgLyBgVHJ1ZWBcbiAqICAgICAgICAgLSBgZmFsc2VgIC8gYEZhbHNlYFxuICogICAgICAgICAtIGB5ZXNgIC8gYFllc2AgLyBgWWBcbiAqICAgICAgICAgLSBgbm9gXG4gKiAgICAgICAgIC0gYG9rYCAvIGBPS2BcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvb2tpZScsICdSZWFkbHlDb29raWVDb25zZW50JywgJzEnXG4gKlxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvb2tpZScsICdnZHByLXNldHRpbmdzLWNvb2tpZScsICd0cnVlJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBzZXRDb29raWUoc291cmNlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgY29va2llRGF0YSA9IHByZXBhcmVDb29raWUobmFtZSwgdmFsdWUpO1xuXG4gIGlmIChjb29raWVEYXRhKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llRGF0YTtcbiAgfVxufVxuc2V0Q29va2llLm5hbWVzID0gWydzZXQtY29va2llJ107XG5zZXRDb29raWUuaW5qZWN0aW9ucyA9IFtoaXQsIG5hdGl2ZUlzTmFOLCBwcmVwYXJlQ29va2llXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IHNldC1jb29raWUtcmVsb2FkXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXRzIGEgY29va2llIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGFuZCB2YWx1ZSwgYW5kIHRoZW4gcmVsb2FkcyB0aGUgY3VycmVudCBwYWdlLlxuICogSWYgcmVsb2FkaW5nIG9wdGlvbiBpcyBub3QgbmVlZGVkLCB1c2UgW3NldC1jb29raWVdKCNzZXQtY29va2llKSBzY3JpcHRsZXQuXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtY29va2llLXJlbG9hZCcsIG5hbWUsIHZhbHVlKVxuICogYGBgXG4gKlxuICogLSBgbmFtZWAgLSByZXF1aXJlZCwgY29va2llIG5hbWUgdG8gYmUgc2V0XG4gKiAtIGB2YWx1ZWAgLSByZXF1aXJlZCwgY29va2llIHZhbHVlOyBwb3NzaWJsZSB2YWx1ZXM6XG4gKiAgICAgLSBudW1iZXIgYD49IDAgJiYgPD0gMTVgXG4gKiAgICAgLSBvbmUgb2YgdGhlIHByZWRlZmluZWQgY29uc3RhbnRzOlxuICogICAgICAgICAtIGB0cnVlYCAvIGBUcnVlYFxuICogICAgICAgICAtIGBmYWxzZWAgLyBgRmFsc2VgXG4gKiAgICAgICAgIC0gYHllc2AgLyBgWWVzYCAvIGBZYFxuICogICAgICAgICAtIGBub2BcbiAqICAgICAgICAgLSBgb2tgIC8gYE9LYFxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtY29va2llLXJlbG9hZCcsICdjaGVja2luZycsICdvaycpXG4gKlxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvb2tpZS1yZWxvYWQnLCAnZ2Rwci1zZXR0aW5ncy1jb29raWUnLCAnMScpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBzZXRDb29raWVSZWxvYWQoc291cmNlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgaXNDb29raWVBbHJlYWR5U2V0ID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jykuc29tZShmdW5jdGlvbiAoY29va2llU3RyKSB7XG4gICAgdmFyIHBvcyA9IGNvb2tpZVN0ci5pbmRleE9mKCc9Jyk7XG5cbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjb29raWVOYW1lID0gY29va2llU3RyLnNsaWNlKDAsIHBvcykudHJpbSgpO1xuICAgIHZhciBjb29raWVWYWx1ZSA9IGNvb2tpZVN0ci5zbGljZShwb3MgKyAxKS50cmltKCk7XG4gICAgcmV0dXJuIG5hbWUgPT09IGNvb2tpZU5hbWUgJiYgdmFsdWUgPT09IGNvb2tpZVZhbHVlO1xuICB9KTtcbiAgdmFyIHNob3VsZFJlbG9hZCA9ICFpc0Nvb2tpZUFscmVhZHlTZXQ7XG4gIHZhciBjb29raWVEYXRhID0gcHJlcGFyZUNvb2tpZShuYW1lLCB2YWx1ZSk7XG5cbiAgaWYgKGNvb2tpZURhdGEpIHtcbiAgICBoaXQoc291cmNlKTtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVEYXRhO1xuXG4gICAgaWYgKHNob3VsZFJlbG9hZCkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgfVxufVxuc2V0Q29va2llUmVsb2FkLm5hbWVzID0gWydzZXQtY29va2llLXJlbG9hZCddO1xuc2V0Q29va2llUmVsb2FkLmluamVjdGlvbnMgPSBbaGl0LCBuYXRpdmVJc05hTiwgcHJlcGFyZUNvb2tpZV07XG5cbi8qKlxuICogQHNjcmlwdGxldCBoaWRlLWluLXNoYWRvdy1kb21cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEhpZGVzIGVsZW1lbnRzIGluc2lkZSBvcGVuIHNoYWRvdyBET00gZWxlbWVudHMuXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdoaWRlLWluLXNoYWRvdy1kb20nLCBzZWxlY3RvclssIGJhc2VTZWxlY3Rvcl0pXG4gKiBgYGBcbiAqXG4gKiAtIGBzZWxlY3RvcmAg4oCUIHJlcXVpcmVkLCBDU1Mgc2VsZWN0b3Igb2YgZWxlbWVudCBpbiBzaGFkb3ctZG9tIHRvIGhpZGVcbiAqIC0gYGJhc2VTZWxlY3RvcmAg4oCUIG9wdGlvbmFsLCBzZWxlY3RvciBvZiBzcGVjaWZpYyBwYWdlIERPTSBlbGVtZW50LFxuICogbmFycm93cyBkb3duIHRoZSBwYXJ0IG9mIHRoZSBwYWdlIERPTSB3aGVyZSBzaGFkb3ctZG9tIGhvc3Qgc3VwcG9zZWQgdG8gYmUsXG4gKiBkZWZhdWx0cyB0byBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAqXG4gKiA+IGBiYXNlU2VsZWN0b3JgIHNob3VsZCBtYXRjaCBlbGVtZW50IG9mIHRoZSBwYWdlIERPTSwgYnV0IG5vdCBvZiBzaGFkb3cgRE9NXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiBgYGBcbiAqICEgaGlkZXMgbWVudSBiYXJcbiAqIHZpcnVzdG90YWwuY29tIyUjLy9zY3JpcHRsZXQoJ2hpZGUtaW4tc2hhZG93LWRvbScsICdpcm9uLXBhZ2VzJywgJ3Z0LXZpcnVzdG90YWwtYXBwJylcbiAqXG4gKiAhIGhpZGVzIGZsb2F0aW5nIGVsZW1lbnRcbiAqIHZpcnVzdG90YWwuY29tIyUjLy9zY3JpcHRsZXQoJ2hpZGUtaW4tc2hhZG93LWRvbScsICd2dC11aS1jb250YWN0LWZhYicpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBoaWRlSW5TaGFkb3dEb20oc291cmNlLCBzZWxlY3RvciwgYmFzZVNlbGVjdG9yKSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFNoYWRvd1Jvb3RcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NoYWRvd1Jvb3RcbiAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGlkZUVsZW1lbnQgPSBmdW5jdGlvbiBoaWRlRWxlbWVudCh0YXJnZXRFbGVtZW50KSB7XG4gICAgdmFyIERJU1BMQVlfTk9ORV9DU1MgPSAnZGlzcGxheTpub25lIWltcG9ydGFudDsnO1xuICAgIHRhcmdldEVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IERJU1BMQVlfTk9ORV9DU1M7XG4gIH07XG4gIC8qKlxuICAgKiBIYW5kbGVzIHNoYWRvdy1kb20gcGllcmNpbmcgYW5kIGhpZGluZyBvZiBmb3VuZCBlbGVtZW50c1xuICAgKi9cblxuXG4gIHZhciBoaWRlSGFuZGxlciA9IGZ1bmN0aW9uIGhpZGVIYW5kbGVyKCkge1xuICAgIC8vIHN0YXJ0IHZhbHVlIG9mIHNoYWRvdy1kb20gaG9zdHMgZm9yIHRoZSBwYWdlIGRvbVxuICAgIHZhciBob3N0RWxlbWVudHMgPSAhYmFzZVNlbGVjdG9yID8gZmluZEhvc3RFbGVtZW50cyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChiYXNlU2VsZWN0b3IpOyAvLyBpZiB0aGVyZSBpcyBzaGFkb3ctZG9tIGhvc3QsIHRoZXkgc2hvdWxkIGJlIGV4cGxvcmVkXG5cbiAgICB3aGlsZSAoaG9zdEVsZW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIGlzSGlkZGVuID0gZmFsc2U7XG5cbiAgICAgIHZhciBfcGllcmNlU2hhZG93RG9tID0gcGllcmNlU2hhZG93RG9tKHNlbGVjdG9yLCBob3N0RWxlbWVudHMpLFxuICAgICAgICAgIHRhcmdldHMgPSBfcGllcmNlU2hhZG93RG9tLnRhcmdldHMsXG4gICAgICAgICAgaW5uZXJIb3N0cyA9IF9waWVyY2VTaGFkb3dEb20uaW5uZXJIb3N0cztcblxuICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICAgICAgICBoaWRlRWxlbWVudCh0YXJnZXRFbCk7XG4gICAgICAgIGlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICB9IC8vIGNvbnRpbnVlIHRvIHBpZXJjZSBmb3IgaW5uZXIgc2hhZG93LWRvbSBob3N0c1xuICAgICAgLy8gYW5kIHNlYXJjaCBpbnNpZGUgdGhlbSB3aGlsZSB0aGUgbmV4dCBpdGVyYXRpb25cblxuXG4gICAgICBob3N0RWxlbWVudHMgPSBpbm5lckhvc3RzO1xuICAgIH1cbiAgfTtcblxuICBoaWRlSGFuZGxlcigpO1xuICBvYnNlcnZlRE9NQ2hhbmdlcyhoaWRlSGFuZGxlciwgdHJ1ZSk7XG59XG5oaWRlSW5TaGFkb3dEb20ubmFtZXMgPSBbJ2hpZGUtaW4tc2hhZG93LWRvbSddO1xuaGlkZUluU2hhZG93RG9tLmluamVjdGlvbnMgPSBbaGl0LCBvYnNlcnZlRE9NQ2hhbmdlcywgZmxhdHRlbiwgZmluZEhvc3RFbGVtZW50cywgcGllcmNlU2hhZG93RG9tXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IHJlbW92ZS1pbi1zaGFkb3ctZG9tXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZW1vdmVzIGVsZW1lbnRzIGluc2lkZSBvcGVuIHNoYWRvdyBET00gZWxlbWVudHMuXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtaW4tc2hhZG93LWRvbScsIHNlbGVjdG9yWywgYmFzZVNlbGVjdG9yXSlcbiAqIGBgYFxuICpcbiAqIC0gYHNlbGVjdG9yYCDigJQgcmVxdWlyZWQsIENTUyBzZWxlY3RvciBvZiBlbGVtZW50IGluIHNoYWRvdy1kb20gdG8gcmVtb3ZlXG4gKiAtIGBiYXNlU2VsZWN0b3JgIOKAlCBvcHRpb25hbCwgc2VsZWN0b3Igb2Ygc3BlY2lmaWMgcGFnZSBET00gZWxlbWVudCxcbiAqIG5hcnJvd3MgZG93biB0aGUgcGFydCBvZiB0aGUgcGFnZSBET00gd2hlcmUgc2hhZG93LWRvbSBob3N0IHN1cHBvc2VkIHRvIGJlLFxuICogZGVmYXVsdHMgdG8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gKlxuICogPiBgYmFzZVNlbGVjdG9yYCBzaG91bGQgbWF0Y2ggZWxlbWVudCBvZiB0aGUgcGFnZSBET00sIGJ1dCBub3Qgb2Ygc2hhZG93IERPTVxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogYGBgXG4gKiAhIHJlbW92ZXMgbWVudSBiYXJcbiAqIHZpcnVzdG90YWwuY29tIyUjLy9zY3JpcHRsZXQoJ3JlbW92ZS1pbi1zaGFkb3ctZG9tJywgJ2lyb24tcGFnZXMnLCAndnQtdmlydXN0b3RhbC1hcHAnKVxuICpcbiAqICEgcmVtb3ZlcyBmbG9hdGluZyBlbGVtZW50XG4gKiB2aXJ1c3RvdGFsLmNvbSMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtaW4tc2hhZG93LWRvbScsICd2dC11aS1jb250YWN0LWZhYicpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVJblNoYWRvd0RvbShzb3VyY2UsIHNlbGVjdG9yLCBiYXNlU2VsZWN0b3IpIHtcbiAgLy8gZG8gbm90aGluZyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgU2hhZG93Um9vdFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2hhZG93Um9vdFxuICBpZiAoIUVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCh0YXJnZXRFbGVtZW50KSB7XG4gICAgdGFyZ2V0RWxlbWVudC5yZW1vdmUoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEhhbmRsZXMgc2hhZG93LWRvbSBwaWVyY2luZyBhbmQgcmVtb3Zpbmcgb2YgZm91bmQgZWxlbWVudHNcbiAgICovXG5cblxuICB2YXIgcmVtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoKSB7XG4gICAgLy8gc3RhcnQgdmFsdWUgb2Ygc2hhZG93LWRvbSBob3N0cyBmb3IgdGhlIHBhZ2UgZG9tXG4gICAgdmFyIGhvc3RFbGVtZW50cyA9ICFiYXNlU2VsZWN0b3IgPyBmaW5kSG9zdEVsZW1lbnRzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGJhc2VTZWxlY3Rvcik7IC8vIGlmIHRoZXJlIGlzIHNoYWRvdy1kb20gaG9zdCwgdGhleSBzaG91bGQgYmUgZXhwbG9yZWRcblxuICAgIHdoaWxlIChob3N0RWxlbWVudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgaXNSZW1vdmVkID0gZmFsc2U7XG5cbiAgICAgIHZhciBfcGllcmNlU2hhZG93RG9tID0gcGllcmNlU2hhZG93RG9tKHNlbGVjdG9yLCBob3N0RWxlbWVudHMpLFxuICAgICAgICAgIHRhcmdldHMgPSBfcGllcmNlU2hhZG93RG9tLnRhcmdldHMsXG4gICAgICAgICAgaW5uZXJIb3N0cyA9IF9waWVyY2VTaGFkb3dEb20uaW5uZXJIb3N0cztcblxuICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICAgICAgICByZW1vdmVFbGVtZW50KHRhcmdldEVsKTtcbiAgICAgICAgaXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNSZW1vdmVkKSB7XG4gICAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgfSAvLyBjb250aW51ZSB0byBwaWVyY2UgZm9yIGlubmVyIHNoYWRvdy1kb20gaG9zdHNcbiAgICAgIC8vIGFuZCBzZWFyY2ggaW5zaWRlIHRoZW0gd2hpbGUgdGhlIG5leHQgaXRlcmF0aW9uXG5cblxuICAgICAgaG9zdEVsZW1lbnRzID0gaW5uZXJIb3N0cztcbiAgICB9XG4gIH07XG5cbiAgcmVtb3ZlSGFuZGxlcigpO1xuICBvYnNlcnZlRE9NQ2hhbmdlcyhyZW1vdmVIYW5kbGVyLCB0cnVlKTtcbn1cbnJlbW92ZUluU2hhZG93RG9tLm5hbWVzID0gWydyZW1vdmUtaW4tc2hhZG93LWRvbSddO1xucmVtb3ZlSW5TaGFkb3dEb20uaW5qZWN0aW9ucyA9IFtoaXQsIG9ic2VydmVET01DaGFuZ2VzLCBmbGF0dGVuLCBmaW5kSG9zdEVsZW1lbnRzLCBwaWVyY2VTaGFkb3dEb21dO1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgbm8tZmxvY1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgdXNpbmcgR29vZ2xlIENocm9tZSB0cmFja2luZyBmZWF0dXJlIGNhbGxlZCBGZWRlcmF0ZWQgTGVhcm5pbmcgb2YgQ29ob3J0cyAoYWthIFwiRkxvQ1wiKVxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vLWZsb2Nqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ25vLWZsb2MnKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gbm9GbG9jKHNvdXJjZSkge1xuICB2YXIgRkxPQ19QUk9QRVJUWV9OQU1FID0gJ2ludGVyZXN0Q29ob3J0JztcblxuICBpZiAoRG9jdW1lbnQgaW5zdGFuY2VvZiBPYmplY3QgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoRG9jdW1lbnQucHJvdG90eXBlLCBGTE9DX1BST1BFUlRZX05BTUUpIHx8IERvY3VtZW50LnByb3RvdHlwZVtGTE9DX1BST1BFUlRZX05BTUVdIGluc3RhbmNlb2YgRnVuY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGRvY3VtZW50LmludGVyZXN0Q29ob3J0KCkgaXMgYXN5bmMgZnVuY3Rpb24gc28gaXQncyBiZXR0ZXIgdG8gcmV0dXJuIFByb21pc2UucmVqZWN0KClcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZmxvYy9ibG9iL2RjZDRjMDQyZmE2YTgxYjA0OGUwNGE3OGIxODRlYTQyMDNhNzUyMTkvUkVBRE1FLm1kXG5cblxuICBEb2N1bWVudC5wcm90b3R5cGVbRkxPQ19QUk9QRVJUWV9OQU1FXSA9IG5vb3BQcm9taXNlUmVqZWN0O1xuICBoaXQoc291cmNlKTtcbn1cbm5vRmxvYy5uYW1lcyA9IFsnbm8tZmxvYycsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbiduby1mbG9jLmpzJywgJ3Viby1uby1mbG9jLmpzJywgJ3Viby1uby1mbG9jJ107XG5ub0Zsb2MuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BQcm9taXNlUmVqZWN0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1mZXRjaFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgYGZldGNoYCBjYWxscyBpZiAqKmFsbCoqIGdpdmVuIHBhcmFtZXRlcnMgbWF0Y2hcbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNuby1mZXRjaC1pZmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1mZXRjaCdbLCBwcm9wc1RvTWF0Y2hdKVxuICogYGBgXG4gKlxuICogLSBgcHJvcHNUb01hdGNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHByb3BlcnRpZXMgdG8gbWF0Y2g7IHBvc3NpYmxlIHByb3BzOlxuICogICAtIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHRoZSBVUkwgcGFzc2VkIHRvIGZldGNoIGNhbGw7IGVtcHR5IHN0cmluZyBvciB3aWxkY2FyZCBgKmAgZm9yIGFsbCBmZXRjaCBjYWxscyBtYXRjaFxuICogICAtIGNvbG9uLXNlcGFyYXRlZCBwYWlycyBgbmFtZTp2YWx1ZWAgd2hlcmVcbiAqICAgICAtIGBuYW1lYCBpcyBbYGluaXRgIG9wdGlvbiBuYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaCNwYXJhbWV0ZXJzKVxuICogICAgIC0gYHZhbHVlYCBpcyBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBwYXNzZWQgdG8gZmV0Y2ggY2FsbFxuICpcbiAqID4gVXNhZ2Ugd2l0aCBubyBhcmd1bWVudHMgd2lsbCBsb2cgZmV0Y2ggY2FsbHMgdG8gYnJvd3NlciBjb25zb2xlO1xuICogd2hpY2ggaXMgdXNlZnVsbCBmb3IgZGVidWdnaW5nIGJ1dCBwZXJtaXR0ZWQgZm9yIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzLlxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gUHJldmVudCBhbGwgZmV0Y2ggY2FsbHNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWZldGNoJywgJyonKVxuICogICAgIGBgYFxuICpcbiAqIDIuIFByZXZlbnQgZmV0Y2ggY2FsbCBmb3Igc3BlY2lmaWMgdXJsXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1mZXRjaCcsICcvdXJsXFxcXC5wYXJ0LycpXG4gKiAgICAgYGBgXG4gKlxuICogMy4gUHJldmVudCBmZXRjaCBjYWxsIGZvciBzcGVjaWZpYyByZXF1ZXN0IG1ldGhvZFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZmV0Y2gnLCAnbWV0aG9kOkhFQUQnKVxuICogICAgIGBgYFxuICpcbiAqIDQuIFByZXZlbnQgZmV0Y2ggY2FsbCBmb3Igc3BlY2lmaWMgdXJsIGFuZCByZXF1ZXN0IG1ldGhvZFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZmV0Y2gnLCAnL3NwZWNpZmllZF91cmxfcGFydC8gbWV0aG9kOi9IRUFEfEdFVC8nKVxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50RmV0Y2goc291cmNlLCBwcm9wc1RvTWF0Y2gpIHtcbiAgLy8gZG8gbm90aGluZyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgZmV0Y2ggb3IgUHJveHkgKGUuZy4gSW50ZXJuZXQgRXhwbG9yZXIpXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dPcldvcmtlckdsb2JhbFNjb3BlL2ZldGNoXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGFuZGxlcldyYXBwZXIgPSBmdW5jdGlvbiBoYW5kbGVyV3JhcHBlcih0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xuICAgIHZhciBmZXRjaERhdGEgPSBnZXRGZXRjaERhdGEoYXJncyk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzVG9NYXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGxvZyBpZiBubyBwcm9wc1RvTWF0Y2ggZ2l2ZW5cbiAgICAgIHZhciBsb2dNZXNzYWdlID0gXCJsb2c6IGZldGNoKCBcIi5jb25jYXQob2JqZWN0VG9TdHJpbmcoZmV0Y2hEYXRhKSwgXCIgKVwiKTtcbiAgICAgIGhpdChzb3VyY2UsIGxvZ01lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAocHJvcHNUb01hdGNoID09PSAnJyB8fCBwcm9wc1RvTWF0Y2ggPT09IGdldFdpbGRjYXJkU3ltYm9sKCkpIHtcbiAgICAgIC8vIHByZXZlbnQgYWxsIGZldGNoIGNhbGxzXG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hdGNoRGF0YSA9IGNvbnZlcnRNYXRjaFByb3BzVG9PYmoocHJvcHNUb01hdGNoKTsgLy8gcHJldmVudCBvbmx5IGlmIGFsbCBwcm9wcyBtYXRjaFxuXG4gICAgICBzaG91bGRQcmV2ZW50ID0gT2JqZWN0LmtleXMobWF0Y2hEYXRhKS5ldmVyeShmdW5jdGlvbiAobWF0Y2hLZXkpIHtcbiAgICAgICAgdmFyIG1hdGNoVmFsdWUgPSBtYXRjaERhdGFbbWF0Y2hLZXldO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZldGNoRGF0YSwgbWF0Y2hLZXkpICYmIG1hdGNoVmFsdWUudGVzdChmZXRjaERhdGFbbWF0Y2hLZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHJldHVybiBub29wUHJvbWlzZVJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xuXG4gIHZhciBmZXRjaEhhbmRsZXIgPSB7XG4gICAgYXBwbHk6IGhhbmRsZXJXcmFwcGVyXG4gIH07XG4gIGZldGNoID0gbmV3IFByb3h5KGZldGNoLCBmZXRjaEhhbmRsZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWdsb2JhbC1hc3NpZ25cbn1cbnByZXZlbnRGZXRjaC5uYW1lcyA9IFsncHJldmVudC1mZXRjaCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbiduby1mZXRjaC1pZi5qcycsICd1Ym8tbm8tZmV0Y2gtaWYuanMnLCAndWJvLW5vLWZldGNoLWlmJ107XG5wcmV2ZW50RmV0Y2guaW5qZWN0aW9ucyA9IFtoaXQsIGdldEZldGNoRGF0YSwgb2JqZWN0VG9TdHJpbmcsIGNvbnZlcnRNYXRjaFByb3BzVG9PYmosIG5vb3BQcm9taXNlUmVzb2x2ZSwgZ2V0V2lsZGNhcmRTeW1ib2wsIHRvUmVnRXhwLCBpc0VtcHR5T2JqZWN0LCBnZXRSZXF1ZXN0RGF0YSwgZ2V0T2JqZWN0RW50cmllcywgZ2V0T2JqZWN0RnJvbUVudHJpZXNdO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBtdXN0IGV4cG9ydCBhbGwgc2NyaXB0bGV0cyB3aGljaCBzaG91bGQgYmUgYWNjZXNzaWJsZVxuICovXG5cbnZhciBzY3JpcHRsZXRMaXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBhYm9ydE9uUHJvcGVydHlSZWFkOiBhYm9ydE9uUHJvcGVydHlSZWFkLFxuICAgIGFib3J0T25Qcm9wZXJ0eVdyaXRlOiBhYm9ydE9uUHJvcGVydHlXcml0ZSxcbiAgICBwcmV2ZW50U2V0VGltZW91dDogcHJldmVudFNldFRpbWVvdXQsXG4gICAgcHJldmVudFNldEludGVydmFsOiBwcmV2ZW50U2V0SW50ZXJ2YWwsXG4gICAgcHJldmVudFdpbmRvd09wZW46IHByZXZlbnRXaW5kb3dPcGVuLFxuICAgIGFib3J0Q3VycmVudElubGluZVNjcmlwdDogYWJvcnRDdXJyZW50SW5saW5lU2NyaXB0LFxuICAgIHNldENvbnN0YW50OiBzZXRDb25zdGFudCxcbiAgICByZW1vdmVDb29raWU6IHJlbW92ZUNvb2tpZSxcbiAgICBwcmV2ZW50QWRkRXZlbnRMaXN0ZW5lcjogcHJldmVudEFkZEV2ZW50TGlzdGVuZXIsXG4gICAgcHJldmVudEJhYjogcHJldmVudEJhYixcbiAgICBub3dlYnJ0Yzogbm93ZWJydGMsXG4gICAgbG9nQWRkRXZlbnRMaXN0ZW5lcjogbG9nQWRkRXZlbnRMaXN0ZW5lcixcbiAgICBsb2dFdmFsOiBsb2dFdmFsLFxuICAgIGxvZzogbG9nLFxuICAgIG5vZXZhbDogbm9ldmFsLFxuICAgIHByZXZlbnRFdmFsSWY6IHByZXZlbnRFdmFsSWYsXG4gICAgcHJldmVudEZhYjogcHJldmVudEZhYixcbiAgICBzZXRQb3BhZHNEdW1teTogc2V0UG9wYWRzRHVtbXksXG4gICAgcHJldmVudFBvcGFkc05ldDogcHJldmVudFBvcGFkc05ldCxcbiAgICBwcmV2ZW50QWRmbHk6IHByZXZlbnRBZGZseSxcbiAgICBkZWJ1Z09uUHJvcGVydHlSZWFkOiBkZWJ1Z09uUHJvcGVydHlSZWFkLFxuICAgIGRlYnVnT25Qcm9wZXJ0eVdyaXRlOiBkZWJ1Z09uUHJvcGVydHlXcml0ZSxcbiAgICBkZWJ1Z0N1cnJlbnRJbmxpbmVTY3JpcHQ6IGRlYnVnQ3VycmVudElubGluZVNjcmlwdCxcbiAgICByZW1vdmVBdHRyOiByZW1vdmVBdHRyLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICBkaXNhYmxlTmV3dGFiTGlua3M6IGRpc2FibGVOZXd0YWJMaW5rcyxcbiAgICBhZGp1c3RTZXRJbnRlcnZhbDogYWRqdXN0U2V0SW50ZXJ2YWwsXG4gICAgYWRqdXN0U2V0VGltZW91dDogYWRqdXN0U2V0VGltZW91dCxcbiAgICBkaXJTdHJpbmc6IGRpclN0cmluZyxcbiAgICBqc29uUHJ1bmU6IGpzb25QcnVuZSxcbiAgICBwcmV2ZW50UmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBwcmV2ZW50UmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuICAgIHNldENvb2tpZTogc2V0Q29va2llLFxuICAgIHNldENvb2tpZVJlbG9hZDogc2V0Q29va2llUmVsb2FkLFxuICAgIGhpZGVJblNoYWRvd0RvbTogaGlkZUluU2hhZG93RG9tLFxuICAgIHJlbW92ZUluU2hhZG93RG9tOiByZW1vdmVJblNoYWRvd0RvbSxcbiAgICBub0Zsb2M6IG5vRmxvYyxcbiAgICBwcmV2ZW50RmV0Y2g6IHByZXZlbnRGZXRjaFxufSk7XG5cbi8qKlxuICogU3RvcmUgb2YgQURHIHJlZGlyZWN0cyBuYW1lcyBhbmQgdGhpZXIgYW5hbG9ncy5cbiAqIEFzIGl0IGlzIG5vdCBhIGNvbXBhdGliaWxpdHkgdGFibGUsIG5vIG5lZWQgdG8ga2VlcCBpbiByZWRpcmVjdHMgYXJyYXkgdGhpcmQtcGFydHkgcmVkaXJlY3RzLlxuICpcbiAqIE5lZWRlZCBvbmx5IGZvciBjb252ZXJpb24gcHVycG9zZXMuXG4gKiBlLmcuIGdvb2dsZXRhZ21hbmFnZXItZ3RtIGlzIHJlbW92ZWQgYW5kIHNob3VsZCBiZSByZW1vdmVkIGZyb20gY29tcGF0aWJpbGl0eSB0YWJsZSBhcyB3ZWxsXG4gKiBidXQgbm93IGl0IHdvcmtzIGFzIGFsaWFzIGZvciBnb29nbGUtYW5hbHl0aWNzIHNvIGl0IHNob3VsZCBzdGF5IHZhbGlkIGZvciBjb21waWxlclxuICovXG52YXIgcmVkaXJlY3RzID0gW3tcbiAgYWRnOiAnMXgxLXRyYW5zcGFyZW50LmdpZicsXG4gIHVibzogJzF4MS5naWYnLFxuICBhYnA6ICcxeDEtdHJhbnNwYXJlbnQtZ2lmJ1xufSwge1xuICBhZGc6ICcyeDItdHJhbnNwYXJlbnQucG5nJyxcbiAgdWJvOiAnMngyLnBuZycsXG4gIGFicDogJzJ4Mi10cmFuc3BhcmVudC1wbmcnXG59LCB7XG4gIGFkZzogJzN4Mi10cmFuc3BhcmVudC5wbmcnLFxuICB1Ym86ICczeDIucG5nJyxcbiAgYWJwOiAnM3gyLXRyYW5zcGFyZW50LXBuZydcbn0sIHtcbiAgYWRnOiAnMzJ4MzItdHJhbnNwYXJlbnQucG5nJyxcbiAgdWJvOiAnMzJ4MzIucG5nJyxcbiAgYWJwOiAnMzJ4MzItdHJhbnNwYXJlbnQtcG5nJ1xufSwge1xuICBhZGc6ICdhbWF6b24tYXBzdGFnJyxcbiAgdWJvOiAnYW1hem9uX2Fwc3RhZy5qcydcbn0sIHtcbiAgYWRnOiAnZ29vZ2xlLWFuYWx5dGljcycsXG4gIHVibzogJ2dvb2dsZS1hbmFseXRpY3NfYW5hbHl0aWNzLmpzJ1xufSwge1xuICBhZGc6ICdnb29nbGUtYW5hbHl0aWNzLWdhJyxcbiAgdWJvOiAnZ29vZ2xlLWFuYWx5dGljc19nYS5qcydcbn0sIHtcbiAgYWRnOiAnZ29vZ2xlc3luZGljYXRpb24tYWRzYnlnb29nbGUnLFxuICB1Ym86ICdnb29nbGVzeW5kaWNhdGlvbl9hZHNieWdvb2dsZS5qcydcbn0sIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzEyN1xuICBhZGc6ICdnb29nbGV0YWdtYW5hZ2VyLWd0bScsXG4gIHVibzogJ2dvb2dsZS1hbmFseXRpY3NfZ2EuanMnXG59LCB7XG4gIGFkZzogJ2dvb2dsZXRhZ3NlcnZpY2VzLWdwdCcsXG4gIHVibzogJ2dvb2dsZXRhZ3NlcnZpY2VzX2dwdC5qcydcbn0sIHtcbiAgYWRnOiAnbWV0cmlrYS15YW5kZXgtd2F0Y2gnXG59LCB7XG4gIGFkZzogJ21ldHJpa2EteWFuZGV4LXRhZydcbn0sIHtcbiAgYWRnOiAnbm9ldmFsJyxcbiAgdWJvOiAnbm9ldmFsLXNpbGVudC5qcydcbn0sIHtcbiAgYWRnOiAnbm9vcGNzcycsXG4gIGFicDogJ2JsYW5rLWNzcydcbn0sIHtcbiAgYWRnOiAnbm9vcGZyYW1lJyxcbiAgdWJvOiAnbm9vcC5odG1sJyxcbiAgYWJwOiAnYmxhbmstaHRtbCdcbn0sIHtcbiAgYWRnOiAnbm9vcGpzJyxcbiAgdWJvOiAnbm9vcC5qcycsXG4gIGFicDogJ2JsYW5rLWpzJ1xufSwge1xuICBhZGc6ICdub29wdGV4dCcsXG4gIHVibzogJ25vb3AudHh0JyxcbiAgYWJwOiAnYmxhbmstdGV4dCdcbn0sIHtcbiAgYWRnOiAnbm9vcG1wMy0wLjFzJyxcbiAgdWJvOiAnbm9vcC0wLjFzLm1wMycsXG4gIGFicDogJ2JsYW5rLW1wMydcbn0sIHtcbiAgYWRnOiAnbm9vcG1wNC0xcycsXG4gIHVibzogJ25vb3AtMXMubXA0JyxcbiAgYWJwOiAnYmxhbmstbXA0J1xufSwge1xuICBhZGc6ICdub29wdm1hcC0xLjAnLFxuICB1Ym86ICdub29wLXZtYXAxLjAueG1sJ1xufSwge1xuICBhZGc6ICdub29wdmFzdC0yLjAnXG59LCB7XG4gIGFkZzogJ25vb3B2YXN0LTMuMCdcbn0sIHtcbiAgYWRnOiAncHJldmVudC1iYWInLFxuICB1Ym86ICdub2JhYi5qcydcbn0sIHtcbiAgYWRnOiAncHJldmVudC1mYWItMy4yLjAnLFxuICB1Ym86ICdub2ZhYi5qcydcbn0sIHtcbiAgYWRnOiAncHJldmVudC1wb3BhZHMtbmV0JyxcbiAgdWJvOiAncG9wYWRzLmpzJ1xufSwge1xuICBhZGc6ICdzY29yZWNhcmRyZXNlYXJjaC1iZWFjb24nLFxuICB1Ym86ICdzY29yZWNhcmRyZXNlYXJjaF9iZWFjb24uanMnXG59LCB7XG4gIGFkZzogJ3NldC1wb3BhZHMtZHVtbXknLFxuICB1Ym86ICdwb3BhZHMtZHVtbXkuanMnXG59LCB7XG4gIGFkZzogJ2VtcHR5JyxcbiAgdWJvOiAnZW1wdHknXG59XTtcblxudmFyIEpTX1JVTEVfTUFSS0VSID0gJyMlIyc7XG52YXIgQ09NTUVOVF9NQVJLRVIgPSAnISc7XG4vKipcbiAqIENoZWNrcyBpZiBydWxlIHRleHQgaXMgY29tbWVudCBlLmcuICEhZXhhbXBsZS5vcmcjIytqcyhzZXQtY29uc3RhbnQuanMsIHRlc3QsIGZhbHNlKVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxudmFyIGlzQ29tbWVudCA9IGZ1bmN0aW9uIGlzQ29tbWVudChydWxlKSB7XG4gIHJldHVybiBzdGFydHNXaXRoKHJ1bGUsIENPTU1FTlRfTUFSS0VSKTtcbn07XG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXG4gKiBTY3JpcHRsZXRzXG4gKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qKlxuICogdUJsb2NrIHNjcmlwdGxldCBydWxlIG1hc2tcbiAqL1xuXG5cbnZhciBVQk9fU0NSSVBUTEVUX01BU0tfUkVHID0gLyNAPyNzY3JpcHQ6aW5qZWN0fCNAPyNcXHMqXFwranMvO1xudmFyIFVCT19TQ1JJUFRMRVRfTUFTS18xID0gJyMjK2pzJztcbnZhciBVQk9fU0NSSVBUTEVUX01BU0tfMiA9ICcjI3NjcmlwdDppbmplY3QnO1xudmFyIFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0tfMSA9ICcjQCMranMnO1xudmFyIFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0tfMiA9ICcjQCNzY3JpcHQ6aW5qZWN0Jztcbi8qKlxuICogQWRCbG9jayBQbHVzIHNuaXBwZXQgcnVsZSBtYXNrXG4gKi9cblxudmFyIEFCUF9TQ1JJUFRMRVRfTUFTSyA9ICcjJCMnO1xudmFyIEFCUF9TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0sgPSAnI0AkIyc7XG4vKipcbiAqIEFkR3VhcmQgQ1NTIHJ1bGUgbWFza1xuICovXG5cbnZhciBBREdfQ1NTX01BU0tfUkVHID0gLyNAP1xcJCMuKz9cXHMqXFx7LipcXH1cXHMqJC9nO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBydWxlYCBpcyBBZEd1YXJkIHNjcmlwdGxldCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIHJ1bGUgdGV4dFxuICovXG5cbnZhciBpc0FkZ1NjcmlwdGxldFJ1bGUgPSBmdW5jdGlvbiBpc0FkZ1NjcmlwdGxldFJ1bGUocnVsZSkge1xuICByZXR1cm4gIWlzQ29tbWVudChydWxlKSAmJiBydWxlLmluZGV4T2YoQURHX1NDUklQVExFVF9NQVNLKSA+IC0xO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBgcnVsZWAgaXMgdUJPIHNjcmlwdGxldCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBydWxlIHRleHRcbiAqL1xuXG5cbnZhciBpc1Vib1NjcmlwdGxldFJ1bGUgPSBmdW5jdGlvbiBpc1Vib1NjcmlwdGxldFJ1bGUocnVsZSkge1xuICByZXR1cm4gKHJ1bGUuaW5kZXhPZihVQk9fU0NSSVBUTEVUX01BU0tfMSkgPiAtMSB8fCBydWxlLmluZGV4T2YoVUJPX1NDUklQVExFVF9NQVNLXzIpID4gLTEgfHwgcnVsZS5pbmRleE9mKFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0tfMSkgPiAtMSB8fCBydWxlLmluZGV4T2YoVUJPX1NDUklQVExFVF9FWENFUFRJT05fTUFTS18yKSA+IC0xKSAmJiBVQk9fU0NSSVBUTEVUX01BU0tfUkVHLnRlc3QocnVsZSkgJiYgIWlzQ29tbWVudChydWxlKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYHJ1bGVgIGlzIEFkQmxvY2sgUGx1cyBzbmlwcGV0XG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBydWxlIHRleHRcbiAqL1xuXG5cbnZhciBpc0FicFNuaXBwZXRSdWxlID0gZnVuY3Rpb24gaXNBYnBTbmlwcGV0UnVsZShydWxlKSB7XG4gIHJldHVybiAocnVsZS5pbmRleE9mKEFCUF9TQ1JJUFRMRVRfTUFTSykgPiAtMSB8fCBydWxlLmluZGV4T2YoQUJQX1NDUklQVExFVF9FWENFUFRJT05fTUFTSykgPiAtMSkgJiYgcnVsZS5zZWFyY2goQURHX0NTU19NQVNLX1JFRykgPT09IC0xICYmICFpc0NvbW1lbnQocnVsZSk7XG59O1xuLyoqXG4gKiBGaW5kcyBzY3JpcHRsZXQgYnkgaXQncyBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHNjcmlwdGxldCBuYW1lXG4gKi9cblxuXG52YXIgZ2V0U2NyaXB0bGV0QnlOYW1lID0gZnVuY3Rpb24gZ2V0U2NyaXB0bGV0QnlOYW1lKG5hbWUpIHtcbiAgdmFyIHNjcmlwdGxldHMgPSBPYmplY3Qua2V5cyhzY3JpcHRsZXRMaXN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBzY3JpcHRsZXRMaXN0W2tleV07XG4gIH0pO1xuICByZXR1cm4gc2NyaXB0bGV0cy5maW5kKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMubmFtZXMgLy8gZnVsbCBtYXRjaCBuYW1lIGNoZWNraW5nXG4gICAgJiYgKHMubmFtZXMuaW5kZXhPZihuYW1lKSA+IC0xIC8vIG9yIGNoZWNrIHVibyBhbGlhcyBuYW1lIHdpdGhvdXQgJy5qcycgYXQgdGhlIGVuZFxuICAgIHx8ICFlbmRzV2l0aChuYW1lLCAnLmpzJykgJiYgcy5uYW1lcy5pbmRleE9mKFwiXCIuY29uY2F0KG5hbWUsIFwiLmpzXCIpKSA+IC0xKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjcmlwdGxldCBuYW1lIGlzIHZhbGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFNjcmlwdGxldCBuYW1lXG4gKi9cblxuXG52YXIgaXNWYWxpZFNjcmlwdGxldE5hbWUgPSBmdW5jdGlvbiBpc1ZhbGlkU2NyaXB0bGV0TmFtZShuYW1lKSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzY3JpcHRsZXQgPSBnZXRTY3JpcHRsZXRCeU5hbWUobmFtZSk7XG5cbiAgaWYgKCFzY3JpcHRsZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXG4gKiBSZWRpcmVjdHNcbiAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyoqXG4gKiBSZWRpcmVjdCByZXNvdXJjZXMgbWFya2Vyc1xuICovXG5cblxudmFyIEFER19VQk9fUkVESVJFQ1RfTUFSS0VSID0gJ3JlZGlyZWN0PSc7XG52YXIgQUJQX1JFRElSRUNUX01BUktFUiA9ICdyZXdyaXRlPWFicC1yZXNvdXJjZTonO1xudmFyIEVNUFRZX1JFRElSRUNUX01BUktFUiA9ICdlbXB0eSc7XG52YXIgVkFMSURfU09VUkNFX1RZUEVTID0gWydpbWFnZScsICdtZWRpYScsICdzdWJkb2N1bWVudCcsICdzdHlsZXNoZWV0JywgJ3NjcmlwdCcsICd4bWxodHRwcmVxdWVzdCcsICdvdGhlciddO1xuLyoqXG4gKiBTb3VyY2UgdHlwZXMgZm9yIHJlZGlyZWN0IHJ1bGVzIGlmIHRoZXJlIGlzIG5vIG9uZSBvZiB0aGVtLlxuICogVXNlZCBmb3IgQURHIC0+IFVCTyBjb252ZXJzaW9uLlxuICovXG5cbnZhciBBQlNFTlRfU09VUkNFX1RZUEVfUkVQTEFDRU1FTlQgPSBbe1xuICBOQU1FOiAnbm9vcHRleHQnLFxuICBUWVBFUzogVkFMSURfU09VUkNFX1RZUEVTXG59LCB7XG4gIE5BTUU6ICdub29wanMnLFxuICBUWVBFUzogWydzY3JpcHQnXVxufSwge1xuICBOQU1FOiAnbm9vcGZyYW1lJyxcbiAgVFlQRVM6IFsnc3ViZG9jdW1lbnQnXVxufSwge1xuICBOQU1FOiAnMXgxLXRyYW5zcGFyZW50LmdpZicsXG4gIFRZUEVTOiBbJ2ltYWdlJ11cbn0sIHtcbiAgTkFNRTogJ25vb3BtcDMtMC4xcycsXG4gIFRZUEVTOiBbJ21lZGlhJ11cbn0sIHtcbiAgTkFNRTogJ25vb3BtcDQtMXMnLFxuICBUWVBFUzogWydtZWRpYSddXG59LCB7XG4gIE5BTUU6ICdnb29nbGVzeW5kaWNhdGlvbi1hZHNieWdvb2dsZScsXG4gIFRZUEVTOiBbJ3htbGh0dHByZXF1ZXN0JywgJ3NjcmlwdCddXG59LCB7XG4gIE5BTUU6ICdnb29nbGUtYW5hbHl0aWNzJyxcbiAgVFlQRVM6IFsnc2NyaXB0J11cbn0sIHtcbiAgTkFNRTogJ2dvb2dsZXRhZ3NlcnZpY2VzLWdwdCcsXG4gIFRZUEVTOiBbJ3NjcmlwdCddXG59XTtcbnZhciB2YWxpZEFkZ1JlZGlyZWN0cyA9IHJlZGlyZWN0cy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBlbC5hZGc7XG59KTtcbi8qKlxuICogQ29tcGF0aWJpbGl0eSBvYmplY3Qgd2hlcmUgS0VZUyA9IFVCTyByZWRpcmVjdCBuYW1lcyBhbmQgVkFMVUVTID0gQURHIHJlZGlyZWN0IG5hbWVzXG4gKiBJdCdzIHVzZWQgZm9yIFVCTyAtPiBBREcgY29udmVydGluZ1xuICovXG5cbnZhciB1Ym9Ub0FkZ0NvbXBhdGliaWxpdHkgPSBnZXRPYmplY3RGcm9tRW50cmllcyh2YWxpZEFkZ1JlZGlyZWN0cy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBlbC51Ym87XG59KS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBbZWwudWJvLCBlbC5hZGddO1xufSkpO1xuLyoqXG4gKiBDb21wYXRpYmlsaXR5IG9iamVjdCB3aGVyZSBLRVlTID0gQUJQIHJlZGlyZWN0IG5hbWVzIGFuZCBWQUxVRVMgPSBBREcgcmVkaXJlY3QgbmFtZXNcbiAqIEl0J3MgdXNlZCBmb3IgQUJQIC0+IEFERyBjb252ZXJ0aW5nXG4gKi9cblxudmFyIGFicFRvQWRnQ29tcGF0aWJpbGl0eSA9IGdldE9iamVjdEZyb21FbnRyaWVzKHZhbGlkQWRnUmVkaXJlY3RzLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmFicDtcbn0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIFtlbC5hYnAsIGVsLmFkZ107XG59KSk7XG4vKipcbiAqIENvbXBhdGliaWxpdHkgb2JqZWN0IHdoZXJlIEtFWVMgPSBVQk8gcmVkaXJlY3QgbmFtZXMgYW5kIFZBTFVFUyA9IEFERyByZWRpcmVjdCBuYW1lc1xuICogSXQncyB1c2VkIGZvciBBREcgLT4gVUJPIGNvbnZlcnRpbmdcbiAqL1xuXG52YXIgYWRnVG9VYm9Db21wYXRpYmlsaXR5ID0gZ2V0T2JqZWN0RnJvbUVudHJpZXModmFsaWRBZGdSZWRpcmVjdHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZWwudWJvO1xufSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gW2VsLmFkZywgZWwudWJvXTtcbn0pKTtcbi8qKlxuICogTmVlZGVkIGZvciBBZEd1YXJkIHJlZGlyZWN0IG5hbWVzIHZhbGlkYXRpb24gd2hlcmUgS0VZUyA9ICoqdmFsaWQqKiBBZEd1YXJkIHJlZGlyZWN0IG5hbWVzXG4gKiAnYWRnVG9VYm9Db21wYXRpYmlsaXR5JyBpcyBzdGlsbCBuZWVkZWQgZm9yIEFERyAtPiBVQk8gY29udmVydGluZ1xuICovXG5cbnZhciB2YWxpZEFkZ0NvbXBhdGliaWxpdHkgPSBnZXRPYmplY3RGcm9tRW50cmllcyh2YWxpZEFkZ1JlZGlyZWN0cy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBbZWwuYWRnLCAndmFsaWQgYWRnIHJlZGlyZWN0J107XG59KSk7XG52YXIgUkVESVJFQ1RfUlVMRV9UWVBFUyA9IHtcbiAgVkFMSURfQURHOiB7XG4gICAgbWFya2VyOiBBREdfVUJPX1JFRElSRUNUX01BUktFUixcbiAgICBjb21wYXRpYmlsaXR5OiB2YWxpZEFkZ0NvbXBhdGliaWxpdHlcbiAgfSxcbiAgQURHOiB7XG4gICAgbWFya2VyOiBBREdfVUJPX1JFRElSRUNUX01BUktFUixcbiAgICBjb21wYXRpYmlsaXR5OiBhZGdUb1Vib0NvbXBhdGliaWxpdHlcbiAgfSxcbiAgVUJPOiB7XG4gICAgbWFya2VyOiBBREdfVUJPX1JFRElSRUNUX01BUktFUixcbiAgICBjb21wYXRpYmlsaXR5OiB1Ym9Ub0FkZ0NvbXBhdGliaWxpdHlcbiAgfSxcbiAgQUJQOiB7XG4gICAgbWFya2VyOiBBQlBfUkVESVJFQ1RfTUFSS0VSLFxuICAgIGNvbXBhdGliaWxpdHk6IGFicFRvQWRnQ29tcGF0aWJpbGl0eVxuICB9XG59O1xuLyoqXG4gKiBQYXJzZXMgcmVkaXJlY3QgcnVsZSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblxudmFyIHBhcnNlTW9kaWZpZXJzID0gZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMocnVsZSkge1xuICByZXR1cm4gc3Vic3RyaW5nQWZ0ZXIocnVsZSwgJyQnKS5zcGxpdCgnLCcpO1xufTtcbi8qKlxuICogR2V0cyByZWRpcmVjdCByZXNvdXJjZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmtlciAtIHNwZWNpZmljIEFkZy9VYm8gb3IgQWJwIHJlZGlyZWN0IHJlc291cmNlcyBtYXJrZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gcmVkaXJlY3QgcmVzb3VyY2UgbmFtZVxuICovXG5cblxudmFyIGdldFJlZGlyZWN0TmFtZSA9IGZ1bmN0aW9uIGdldFJlZGlyZWN0TmFtZShydWxlLCBtYXJrZXIpIHtcbiAgdmFyIHJ1bGVNb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhydWxlKTtcbiAgdmFyIHJlZGlyZWN0TmFtZVBhcnQgPSBydWxlTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLmluZGV4T2YobWFya2VyKSA+IC0xO1xuICB9KTtcbiAgcmV0dXJuIHN1YnN0cmluZ0FmdGVyKHJlZGlyZWN0TmFtZVBhcnQsIG1hcmtlcik7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBydWxlYCBpcyBBZEd1YXJkIHJlZGlyZWN0IHJ1bGUuXG4gKiBEaXNjYXJkcyBjb21tZW50cyBhbmQgSlMgcnVsZXMgYW5kIGNoZWNrcyBpZiB0aGUgYHJ1bGVgIGhhcyAncmVkaXJlY3QnIG1vZGlmaWVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBydWxlIHRleHRcbiAqL1xuXG5cbnZhciBpc0FkZ1JlZGlyZWN0UnVsZSA9IGZ1bmN0aW9uIGlzQWRnUmVkaXJlY3RSdWxlKHJ1bGUpIHtcbiAgdmFyIE1BUktFUl9JTl9CQVNFX1BBUlRfTUFTSyA9ICcvKCg/IVxcXFwkfFxcXFwsKS57MX0pcmVkaXJlY3Q9KC57MCx9PylcXFxcJChwb3B1cCk/Lyc7XG4gIHJldHVybiAhaXNDb21tZW50KHJ1bGUpICYmIHJ1bGUuaW5kZXhPZihSRURJUkVDVF9SVUxFX1RZUEVTLkFERy5tYXJrZXIpID4gLTEgLy8gc29tZSBqcyBydWxlcyBtYXkgaGF2ZSAncmVkaXJlY3Q9JyBpbiBpdCwgc28gd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhlbVxuICAmJiBydWxlLmluZGV4T2YoSlNfUlVMRV9NQVJLRVIpID09PSAtMSAvLyBnZXQgcmlkIG9mIHJ1bGVzIGxpa2UgJ19yZWRpcmVjdD0qOi8vbG9vay4kcG9wdXAnXG4gICYmICF0b1JlZ0V4cChNQVJLRVJfSU5fQkFTRV9QQVJUX01BU0spLnRlc3QocnVsZSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBydWxlYCBzYXRpc2ZpZXMgdGhlIGB0eXBlYFxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBydWxlIHRleHRcbiAqIEBwYXJhbSB7J1ZBTElEX0FERyd8J0FERyd8J1VCTyd8J0FCUCd9IHR5cGUgLSB0eXBlIG9mIGEgcmVkaXJlY3QgcnVsZVxuICovXG5cblxudmFyIGlzUmVkaXJlY3RSdWxlQnlUeXBlID0gZnVuY3Rpb24gaXNSZWRpcmVjdFJ1bGVCeVR5cGUocnVsZSwgdHlwZSkge1xuICB2YXIgX1JFRElSRUNUX1JVTEVfVFlQRVMkID0gUkVESVJFQ1RfUlVMRV9UWVBFU1t0eXBlXSxcbiAgICAgIG1hcmtlciA9IF9SRURJUkVDVF9SVUxFX1RZUEVTJC5tYXJrZXIsXG4gICAgICBjb21wYXRpYmlsaXR5ID0gX1JFRElSRUNUX1JVTEVfVFlQRVMkLmNvbXBhdGliaWxpdHk7XG5cbiAgaWYgKHJ1bGUgJiYgIWlzQ29tbWVudChydWxlKSAmJiBydWxlLmluZGV4T2YobWFya2VyKSA+IC0xKSB7XG4gICAgdmFyIHJlZGlyZWN0TmFtZSA9IGdldFJlZGlyZWN0TmFtZShydWxlLCBtYXJrZXIpO1xuXG4gICAgaWYgKCFyZWRpcmVjdE5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkaXJlY3ROYW1lID09PSBPYmplY3Qua2V5cyhjb21wYXRpYmlsaXR5KS5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsID09PSByZWRpcmVjdE5hbWU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4qIENoZWNrcyBpZiB0aGUgYHJ1bGVgIGlzICoqdmFsaWQqKiBBZEd1YXJkIHJlZGlyZWN0IHJlc291cmNlIHJ1bGVcbiogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBydWxlIHRleHRcbiogQHJldHVybnMge2Jvb2xlYW59XG4qL1xuXG5cbnZhciBpc1ZhbGlkQWRnUmVkaXJlY3RSdWxlID0gZnVuY3Rpb24gaXNWYWxpZEFkZ1JlZGlyZWN0UnVsZShydWxlKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0UnVsZUJ5VHlwZShydWxlLCAnVkFMSURfQURHJyk7XG59O1xuLyoqXG4qIENoZWNrcyBpZiB0aGUgQWRHdWFyZCByZWRpcmVjdCBgcnVsZWAgaGFzIFVibyBhbmFsb2cuIE5lZWRlZCBmb3IgQWRnLT5VYm8gY29udmVyc2lvblxuKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIEFkR3VhcmQgcnVsZSB0ZXh0XG4qIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIHJ1bGUgY2FuIGJlIGNvbnZlcnRlZCB0byBVYm9cbiovXG5cblxudmFyIGlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibyA9IGZ1bmN0aW9uIGlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibyhydWxlKSB7XG4gIHJldHVybiBpc0FkZ1JlZGlyZWN0UnVsZShydWxlKSAmJiBpc1JlZGlyZWN0UnVsZUJ5VHlwZShydWxlLCAnQURHJyk7XG59O1xuLyoqXG4qIENoZWNrcyBpZiB0aGUgVWJvIHJlZGlyZWN0IGBydWxlYCBoYXMgQWRHdWFyZCBhbmFsb2cuIE5lZWRlZCBmb3IgVWJvLT5BZGcgY29udmVyc2lvblxuKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIFVibyBydWxlIHRleHRcbiogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgcnVsZSBjYW4gYmUgY29udmVydGVkIHRvIEFkR3VhcmRcbiovXG5cblxudmFyIGlzVWJvUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyA9IGZ1bmN0aW9uIGlzVWJvUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyhydWxlKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0UnVsZUJ5VHlwZShydWxlLCAnVUJPJyk7XG59O1xuLyoqXG4qIENoZWNrcyBpZiB0aGUgQWJwIHJlZGlyZWN0IGBydWxlYCBoYXMgQWRHdWFyZCBhbmFsb2cuIE5lZWRlZCBmb3IgQWJwLT5BZGcgY29udmVyc2lvblxuKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIEFicCBydWxlIHRleHRcbiogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgcnVsZSBjYW4gYmUgY29udmVydGVkIHRvIEFkR3VhcmRcbiovXG5cblxudmFyIGlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyA9IGZ1bmN0aW9uIGlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyhydWxlKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0UnVsZUJ5VHlwZShydWxlLCAnQUJQJyk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHJ1bGUgaGFzIHNwZWNpZmllZCBjb250ZW50IHR5cGUgYmVmb3JlIEFkZyAtPiBVYm8gY29udmVyc2lvbi5cbiAqXG4gKiBVc2VkIE9OTFkgZm9yIEFkZyAtPiBVYm8gY29udmVyc2lvblxuICogYmVjYXVzZSBVYm8gcmVkaXJlY3QgcnVsZXMgbXVzdCBjb250YWluIGNvbnRlbnQgdHlwZSwgYnV0IEFkZyBhbmQgQWJwIG11c3Qgbm90LlxuICpcbiAqIEFsc28gc291cmNlIHR5cGUgY2FuIG5vdCBiZSBhZGRlZCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugb2Ygc3VjaCB2YWxpZCBydWxlczpcbiAqICEgQWJwOlxuICogJHJld3JpdGU9YWJwLXJlc291cmNlOmJsYW5rLWpzLHhtbGh0dHByZXF1ZXN0XG4gKiAhIEFkZzpcbiAqICRzY3JpcHQscmVkaXJlY3Q9bm9vcHZhc3QtMi4wXG4gKiAkeG1saHR0cHJlcXVlc3QscmVkaXJlY3Q9bm9vcHZhc3QtMi4wXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxudmFyIGhhc1ZhbGlkQ29udGVudFR5cGUgPSBmdW5jdGlvbiBoYXNWYWxpZENvbnRlbnRUeXBlKHJ1bGUpIHtcbiAgdmFyIHJ1bGVNb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhydWxlKTsgLy8gcnVsZSBjYW4gaGF2ZSBtb3JlIHRoYW4gb25lIHNvdXJjZSB0eXBlIG1vZGlmaWVyXG5cbiAgdmFyIHNvdXJjZVR5cGVzID0gcnVsZU1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIFZBTElEX1NPVVJDRV9UWVBFUy5pbmRleE9mKGVsKSA+IC0xO1xuICB9KTtcbiAgdmFyIGlzU291cmNlVHlwZVNwZWNpZmllZCA9IHNvdXJjZVR5cGVzLmxlbmd0aCA+IDA7XG4gIHZhciBpc0VtcHR5UmVkaXJlY3QgPSBydWxlTW9kaWZpZXJzLmluZGV4T2YoXCJcIi5jb25jYXQoQURHX1VCT19SRURJUkVDVF9NQVJLRVIpLmNvbmNhdChFTVBUWV9SRURJUkVDVF9NQVJLRVIpKSA+IC0xO1xuXG4gIGlmIChpc0VtcHR5UmVkaXJlY3QpIHtcbiAgICAvLyBubyBzb3VyY2UgdHlwZSBmb3IgJ2VtcHR5JyBpcyBhbGxvd2VkXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gaXNTb3VyY2VUeXBlU3BlY2lmaWVkO1xufTtcblxudmFyIHZhbGlkYXRvciA9IHtcbiAgVUJPX1NDUklQVExFVF9NQVNLX1JFRzogVUJPX1NDUklQVExFVF9NQVNLX1JFRyxcbiAgQUJQX1NDUklQVExFVF9NQVNLOiBBQlBfU0NSSVBUTEVUX01BU0ssXG4gIEFCUF9TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0s6IEFCUF9TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0ssXG4gIGlzQ29tbWVudDogaXNDb21tZW50LFxuICBpc0FkZ1NjcmlwdGxldFJ1bGU6IGlzQWRnU2NyaXB0bGV0UnVsZSxcbiAgaXNVYm9TY3JpcHRsZXRSdWxlOiBpc1Vib1NjcmlwdGxldFJ1bGUsXG4gIGlzQWJwU25pcHBldFJ1bGU6IGlzQWJwU25pcHBldFJ1bGUsXG4gIGdldFNjcmlwdGxldEJ5TmFtZTogZ2V0U2NyaXB0bGV0QnlOYW1lLFxuICBpc1ZhbGlkU2NyaXB0bGV0TmFtZTogaXNWYWxpZFNjcmlwdGxldE5hbWUsXG4gIFJFRElSRUNUX1JVTEVfVFlQRVM6IFJFRElSRUNUX1JVTEVfVFlQRVMsXG4gIEFCU0VOVF9TT1VSQ0VfVFlQRV9SRVBMQUNFTUVOVDogQUJTRU5UX1NPVVJDRV9UWVBFX1JFUExBQ0VNRU5ULFxuICBpc0FkZ1JlZGlyZWN0UnVsZTogaXNBZGdSZWRpcmVjdFJ1bGUsXG4gIGlzVmFsaWRBZGdSZWRpcmVjdFJ1bGU6IGlzVmFsaWRBZGdSZWRpcmVjdFJ1bGUsXG4gIGlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibzogaXNBZGdSZWRpcmVjdENvbXBhdGlibGVXaXRoVWJvLFxuICBpc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGc6IGlzVWJvUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyxcbiAgaXNBYnBSZWRpcmVjdENvbXBhdGlibGVXaXRoQWRnOiBpc0FicFJlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcsXG4gIHBhcnNlTW9kaWZpZXJzOiBwYXJzZU1vZGlmaWVycyxcbiAgZ2V0UmVkaXJlY3ROYW1lOiBnZXRSZWRpcmVjdE5hbWUsXG4gIGhhc1ZhbGlkQ29udGVudFR5cGU6IGhhc1ZhbGlkQ29udGVudFR5cGVcbn07XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSBfYXJyYXlMaWtlVG9BcnJheTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG52YXIgYXJyYXlXaXRob3V0SG9sZXMgPSBfYXJyYXlXaXRob3V0SG9sZXM7XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IF9pdGVyYWJsZVRvQXJyYXk7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTtcblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gX25vbkl0ZXJhYmxlU3ByZWFkO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gX3RvQ29uc3VtYWJsZUFycmF5O1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbnZhciBhcnJheVdpdGhIb2xlcyA9IF9hcnJheVdpdGhIb2xlcztcblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IF9ub25JdGVyYWJsZVJlc3Q7XG5cbmZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG52YXIgdG9BcnJheSA9IF90b0FycmF5O1xuXG4vKipcbiAqIEFkR3VhcmQgc2NyaXB0bGV0IHJ1bGVcbiAqL1xuXG52YXIgQURHVUFSRF9TQ1JJUFRMRVRfTUFTS19SRUcgPSAvI0A/JSNcXC9cXC9zY3JpcHRsZXRcXCguK1xcKS87IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10ZW1wbGF0ZS1jdXJseS1pbi1zdHJpbmdcblxudmFyIEFER1VBUkRfU0NSSVBUTEVUX1RFTVBMQVRFID0gJyR7ZG9tYWluc30jJSMvL3NjcmlwdGxldCgke2FyZ3N9KSc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10ZW1wbGF0ZS1jdXJseS1pbi1zdHJpbmdcblxudmFyIEFER1VBUkRfU0NSSVBUTEVUX0VYQ0VQVElPTl9URU1QTEFURSA9ICcke2RvbWFpbnN9I0AlIy8vc2NyaXB0bGV0KCR7YXJnc30pJztcbi8qKlxuICogdUJsb2NrIHNjcmlwdGxldCBydWxlIG1hc2tcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRlbXBsYXRlLWN1cmx5LWluLXN0cmluZ1xuXG52YXIgVUJPX1NDUklQVExFVF9URU1QTEFURSA9ICcke2RvbWFpbnN9IyMranMoJHthcmdzfSknOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGVtcGxhdGUtY3VybHktaW4tc3RyaW5nXG5cbnZhciBVQk9fU0NSSVBUTEVUX0VYQ0VQVElPTl9URU1QTEFURSA9ICcke2RvbWFpbnN9I0AjK2pzKCR7YXJnc30pJztcbnZhciBVQk9fQUxJQVNfTkFNRV9NQVJLRVIgPSAndWJvLSc7XG52YXIgVUJPX1NDUklQVExFVF9KU19FTkRJTkcgPSAnLmpzJzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvU3RhdGljLWZpbHRlci1zeW50YXgjeGhyXG5cbnZhciBVQk9fWEhSX1RZUEUgPSAneGhyJztcbnZhciBBREdfWEhSX1RZUEUgPSAneG1saHR0cHJlcXVlc3QnO1xudmFyIEFER19TRVRfQ09OU1RBTlRfTkFNRSA9ICdzZXQtY29uc3RhbnQnO1xudmFyIEFER19TRVRfQ09OU1RBTlRfRU1QVFlfU1RSSU5HID0gJyc7XG52YXIgVUJPX1NFVF9DT05TVEFOVF9FTVBUWV9TVFJJTkcgPSAnXFwnXFwnJztcbnZhciBBREdfUFJFVkVOVF9GRVRDSF9OQU1FID0gJ3ByZXZlbnQtZmV0Y2gnO1xudmFyIEFER19QUkVWRU5UX0ZFVENIX0VNUFRZX1NUUklORyA9ICcnO1xudmFyIEFER19QUkVWRU5UX0ZFVENIX1dJTERDQVJEID0gZ2V0V2lsZGNhcmRTeW1ib2woKTtcbnZhciBVQk9fTk9fRkVUQ0hfSUZfV0lMRENBUkQgPSAnL14vJztcbnZhciBFU0NBUEVEX0NPTU1BX1NFUEFSQVRPUiA9ICdcXFxcLCc7XG52YXIgQ09NTUFfU0VQQVJBVE9SID0gJywnO1xudmFyIE1BWF9SRU1PVkVfQVRUUl9DTEFTU19BUkdTX0NPVU5UID0gMztcbnZhciBSRU1PVkVfQVRUUl9NRVRIT0QgPSAncmVtb3ZlQXR0cic7XG52YXIgUkVNT1ZFX0NMQVNTX01FVEhPRCA9ICdyZW1vdmVDbGFzcyc7XG52YXIgUkVNT1ZFX0FUVFJfQUxJQVNFUyA9IHNjcmlwdGxldExpc3RbUkVNT1ZFX0FUVFJfTUVUSE9EXS5uYW1lcztcbnZhciBSRU1PVkVfQ0xBU1NfQUxJQVNFUyA9IHNjcmlwdGxldExpc3RbUkVNT1ZFX0NMQVNTX01FVEhPRF0ubmFtZXM7XG52YXIgQURHX1JFTU9WRV9BVFRSX05BTUUgPSBSRU1PVkVfQVRUUl9BTElBU0VTWzBdO1xudmFyIEFER19SRU1PVkVfQ0xBU1NfTkFNRSA9IFJFTU9WRV9DTEFTU19BTElBU0VTWzBdO1xuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc2VwYXJhdGVkIGJ5IHNwYWNlIHdoaWNoIG5vdCBpbiBxdW90ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuXG52YXIgZ2V0U2VudGVuY2VzID0gZnVuY3Rpb24gZ2V0U2VudGVuY2VzKHN0cikge1xuICB2YXIgcmVnID0gLycuKj8nfFwiLio/XCJ8XFxTKy9nO1xuICByZXR1cm4gc3RyLm1hdGNoKHJlZyk7XG59O1xuLyoqXG4gKiBSZXBsYWNlcyBzdHJpbmcgd2l0aCBkYXRhIGJ5IHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB3aGVyZSBrZXlzIGFyZSBwbGFjZWhvbGRlcnMgbmFtZXNcbiAqL1xuXG5cbnZhciByZXBsYWNlUGxhY2Vob2xkZXJzID0gZnVuY3Rpb24gcmVwbGFjZVBsYWNlaG9sZGVycyhzdHIsIGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIlxcXFwkXFxcXHtcIi5jb25jYXQoa2V5LCBcIlxcXFx9XCIpLCAnZycpO1xuICAgIGFjYyA9IGFjYy5yZXBsYWNlKHJlZywgZGF0YVtrZXldKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBzdHIpO1xufTtcbi8qKlxuICogQ29udmVydHMgc3RyaW5nIG9mIFVCTyBzY3JpcHRsZXQgcnVsZSB0byBBZEd1YXJkIHNjcml0bGV0IHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIC0gVUJPIHNjcmlwdGxldCBydWxlXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gYXJyYXkgd2l0aCBvbmUgQWRHdWFyZCBzY3JpcHRsZXQgcnVsZVxuICovXG5cblxudmFyIGNvbnZlcnRVYm9TY3JpcHRsZXRUb0FkZyA9IGZ1bmN0aW9uIGNvbnZlcnRVYm9TY3JpcHRsZXRUb0FkZyhydWxlKSB7XG4gIHZhciBkb21haW5zID0gZ2V0QmVmb3JlUmVnRXhwKHJ1bGUsIHZhbGlkYXRvci5VQk9fU0NSSVBUTEVUX01BU0tfUkVHKTtcbiAgdmFyIG1hc2sgPSBydWxlLm1hdGNoKHZhbGlkYXRvci5VQk9fU0NSSVBUTEVUX01BU0tfUkVHKVswXTtcbiAgdmFyIHRlbXBsYXRlO1xuXG4gIGlmIChtYXNrLmluZGV4T2YoJ0AnKSA+IC0xKSB7XG4gICAgdGVtcGxhdGUgPSBBREdVQVJEX1NDUklQVExFVF9FWENFUFRJT05fVEVNUExBVEU7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGUgPSBBREdVQVJEX1NDUklQVExFVF9URU1QTEFURTtcbiAgfVxuXG4gIHZhciBwYXJzZWRBcmdzID0gZ2V0U3RyaW5nSW5CcmFjZXMocnVsZSkuc3BsaXQoLyxcXHMvZyk7XG5cbiAgaWYgKHBhcnNlZEFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gTW9zdCBwcm9iYWJseSB0aGlzIGlzIG5vdCBjb3JyZWN0IHNlcGFyYXRvciwgaW4gdGhpcyBjYXNlIHdlIHVzZSAnLCdcbiAgICBwYXJzZWRBcmdzID0gZ2V0U3RyaW5nSW5CcmFjZXMocnVsZSkuc3BsaXQoLywvZyk7XG4gIH1cblxuICB2YXIgc2NyaXB0bGV0TmFtZSA9IHBhcnNlZEFyZ3NbMF0uaW5kZXhPZihVQk9fU0NSSVBUTEVUX0pTX0VORElORykgPiAtMSA/IFwidWJvLVwiLmNvbmNhdChwYXJzZWRBcmdzWzBdKSA6IFwidWJvLVwiLmNvbmNhdChwYXJzZWRBcmdzWzBdKS5jb25jYXQoVUJPX1NDUklQVExFVF9KU19FTkRJTkcpO1xuXG4gIGlmICgoUkVNT1ZFX0FUVFJfQUxJQVNFUy5pbmRleE9mKHNjcmlwdGxldE5hbWUpID4gLTEgfHwgUkVNT1ZFX0NMQVNTX0FMSUFTRVMuaW5kZXhPZihzY3JpcHRsZXROYW1lKSA+IC0xKSAmJiBwYXJzZWRBcmdzLmxlbmd0aCA+IE1BWF9SRU1PVkVfQVRUUl9DTEFTU19BUkdTX0NPVU5UKSB7XG4gICAgcGFyc2VkQXJncyA9IFtwYXJzZWRBcmdzWzBdLCBwYXJzZWRBcmdzWzFdLCAvLyBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDMgYXJncyBmb3IgcmVtb3ZlLWF0dHIvY2xhc3Mgc2NyaXB0bGV0LFxuICAgIC8vIHVibyBydWxlIGhhcyBtYWx0aXBsZSBzZWxlY3RvciBzZXBhcmF0ZWQgYnkgY29tbWEuIHNvIHdlIHNob3VsZDpcbiAgICAvLyAxLiBqb2luIHRoZW0gaW50byBhIHNpbmdsZSBzdHJpbmdcbiAgICAvLyAyLiByZXBsYWNlIGVzY2FwZWQgY29tbWFzIGJ5IHJlZ3VsYXIgb25lc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMzNcbiAgICByZXBsYWNlQWxsKHBhcnNlZEFyZ3Muc2xpY2UoMikuam9pbihcIlwiLmNvbmNhdChDT01NQV9TRVBBUkFUT1IsIFwiIFwiKSksIEVTQ0FQRURfQ09NTUFfU0VQQVJBVE9SLCBDT01NQV9TRVBBUkFUT1IpXTtcbiAgfVxuXG4gIHZhciBhcmdzID0gcGFyc2VkQXJncy5tYXAoZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0QXJnID0gYXJnO1xuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvdXRwdXRBcmcgPSBzY3JpcHRsZXROYW1lO1xuICAgIH0gLy8gZm9yIGV4YW1wbGU6IGRyYW1hc2VyaWFsLnh5eiMjK2pzKGFib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCwgJCwgcG9wdXApXG5cblxuICAgIGlmIChhcmcgPT09ICckJykge1xuICAgICAgb3V0cHV0QXJnID0gJyQkJztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0QXJnO1xuICB9KS5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB3cmFwSW5TaW5nbGVRdW90ZXMoYXJnKTtcbiAgfSkuam9pbihcIlwiLmNvbmNhdChDT01NQV9TRVBBUkFUT1IsIFwiIFwiKSk7XG4gIHZhciBhZGdSdWxlID0gcmVwbGFjZVBsYWNlaG9sZGVycyh0ZW1wbGF0ZSwge1xuICAgIGRvbWFpbnM6IGRvbWFpbnMsXG4gICAgYXJnczogYXJnc1xuICB9KTtcbiAgcmV0dXJuIFthZGdSdWxlXTtcbn07XG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIG9mIEFCUCBzbmlwcGV0IHJ1bGUgdG8gQWRHdWFyZCBzY3JpdGxldCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIEFCUCBzbmlwcGV0IHJ1bGVcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBhcnJheSBvZiBBZEd1YXJkIHNjcmlwdGxldCBydWxlcyAtXG4gKiBvbmUgb3IgZmV3IGl0ZW1zIGRlcGVuZHMgb24gQWJwLXJ1bGVcbiAqL1xuXG52YXIgY29udmVydEFicFNuaXBwZXRUb0FkZyA9IGZ1bmN0aW9uIGNvbnZlcnRBYnBTbmlwcGV0VG9BZGcocnVsZSkge1xuICB2YXIgU0VNSUNPTE9OX0RJVklERVIgPSAvOyg/PSg/Oig/OlteXCJdKlwiKXsyfSkqW15cIl0qJCkvZztcbiAgdmFyIG1hc2sgPSBydWxlLmluZGV4T2YodmFsaWRhdG9yLkFCUF9TQ1JJUFRMRVRfTUFTSykgPiAtMSA/IHZhbGlkYXRvci5BQlBfU0NSSVBUTEVUX01BU0sgOiB2YWxpZGF0b3IuQUJQX1NDUklQVExFVF9FWENFUFRJT05fTUFTSztcbiAgdmFyIHRlbXBsYXRlID0gbWFzayA9PT0gdmFsaWRhdG9yLkFCUF9TQ1JJUFRMRVRfTUFTSyA/IEFER1VBUkRfU0NSSVBUTEVUX1RFTVBMQVRFIDogQURHVUFSRF9TQ1JJUFRMRVRfRVhDRVBUSU9OX1RFTVBMQVRFO1xuICB2YXIgZG9tYWlucyA9IHN1YnN0cmluZ0JlZm9yZShydWxlLCBtYXNrKTtcbiAgdmFyIGFyZ3MgPSBzdWJzdHJpbmdBZnRlcihydWxlLCBtYXNrKTtcbiAgcmV0dXJuIGFyZ3Muc3BsaXQoU0VNSUNPTE9OX0RJVklERVIpLm1hcChmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBnZXRTZW50ZW5jZXMoYXJncykuZmlsdGVyKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChhcmcsIGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggPT09IDAgPyBcImFicC1cIi5jb25jYXQoYXJnKSA6IGFyZztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIHdyYXBJblNpbmdsZVF1b3RlcyhhcmcpO1xuICAgIH0pLmpvaW4oXCJcIi5jb25jYXQoQ09NTUFfU0VQQVJBVE9SLCBcIiBcIikpO1xuICB9KS5tYXAoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gcmVwbGFjZVBsYWNlaG9sZGVycyh0ZW1wbGF0ZSwge1xuICAgICAgZG9tYWluczogZG9tYWlucyxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcbiAgfSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBzY3JpcHRsZXQgcnVsZSB0byBBZEd1YXJkIG9uZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBhcnJheSBvZiBBZEd1YXJkIHNjcmlwdGxldCBydWxlcyAtXG4gKiBvbmUgaXRlbSBmb3IgQWRnIGFuZCBVYm8gb3IgZmV3IGl0ZW1zIGZvciBBYnBcbiAqL1xuXG52YXIgY29udmVydFNjcmlwdGxldFRvQWRnID0gZnVuY3Rpb24gY29udmVydFNjcmlwdGxldFRvQWRnKHJ1bGUpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodmFsaWRhdG9yLmlzVWJvU2NyaXB0bGV0UnVsZShydWxlKSkge1xuICAgIHJlc3VsdCA9IGNvbnZlcnRVYm9TY3JpcHRsZXRUb0FkZyhydWxlKTtcbiAgfSBlbHNlIGlmICh2YWxpZGF0b3IuaXNBYnBTbmlwcGV0UnVsZShydWxlKSkge1xuICAgIHJlc3VsdCA9IGNvbnZlcnRBYnBTbmlwcGV0VG9BZGcocnVsZSk7XG4gIH0gZWxzZSBpZiAodmFsaWRhdG9yLmlzQWRnU2NyaXB0bGV0UnVsZShydWxlKSB8fCB2YWxpZGF0b3IuaXNDb21tZW50KHJ1bGUpKSB7XG4gICAgcmVzdWx0ID0gW3J1bGVdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENvbnZlcnRzIFVCTyBzY3JpcHRsZXQgcnVsZSB0byBBZEd1YXJkIG9uZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBBZEd1YXJkIHNjcmlwdGxldCBydWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVCTyBzY3JpcHRsZXQgcnVsZVxuICovXG5cbnZhciBjb252ZXJ0QWRnU2NyaXB0bGV0VG9VYm8gPSBmdW5jdGlvbiBjb252ZXJ0QWRnU2NyaXB0bGV0VG9VYm8ocnVsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmICh2YWxpZGF0b3IuaXNBZGdTY3JpcHRsZXRSdWxlKHJ1bGUpKSB7XG4gICAgdmFyIF9wYXJzZVJ1bGUgPSBwYXJzZVJ1bGUocnVsZSksXG4gICAgICAgIHBhcnNlZE5hbWUgPSBfcGFyc2VSdWxlLm5hbWUsXG4gICAgICAgIHBhcnNlZFBhcmFtcyA9IF9wYXJzZVJ1bGUuYXJncztcblxuICAgIHZhciBwcmVwYXJlZFBhcmFtczsgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0ZpbHRlcnNDb21waWxlci9pc3N1ZXMvMTAyXG5cbiAgICBpZiAocGFyc2VkTmFtZSA9PT0gQURHX1NFVF9DT05TVEFOVF9OQU1FICYmIHBhcnNlZFBhcmFtc1sxXSA9PT0gQURHX1NFVF9DT05TVEFOVF9FTVBUWV9TVFJJTkcpIHtcbiAgICAgIHByZXBhcmVkUGFyYW1zID0gW3BhcnNlZFBhcmFtc1swXSwgVUJPX1NFVF9DT05TVEFOVF9FTVBUWV9TVFJJTkddO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkTmFtZSA9PT0gQURHX1BSRVZFTlRfRkVUQ0hfTkFNRSAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTA5XG4gICAgJiYgKHBhcnNlZFBhcmFtc1swXSA9PT0gQURHX1BSRVZFTlRfRkVUQ0hfV0lMRENBUkQgfHwgcGFyc2VkUGFyYW1zWzBdID09PSBBREdfUFJFVkVOVF9GRVRDSF9FTVBUWV9TVFJJTkcpKSB7XG4gICAgICBwcmVwYXJlZFBhcmFtcyA9IFtVQk9fTk9fRkVUQ0hfSUZfV0lMRENBUkRdO1xuICAgIH0gZWxzZSBpZiAoKHBhcnNlZE5hbWUgPT09IEFER19SRU1PVkVfQVRUUl9OQU1FIHx8IHBhcnNlZE5hbWUgPT09IEFER19SRU1PVkVfQ0xBU1NfTkFNRSkgJiYgcGFyc2VkUGFyYW1zWzFdICYmIHBhcnNlZFBhcmFtc1sxXS5pbmRleE9mKENPTU1BX1NFUEFSQVRPUikgPiAtMSkge1xuICAgICAgcHJlcGFyZWRQYXJhbXMgPSBbcGFyc2VkUGFyYW1zWzBdLCByZXBsYWNlQWxsKHBhcnNlZFBhcmFtc1sxXSwgQ09NTUFfU0VQQVJBVE9SLCBFU0NBUEVEX0NPTU1BX1NFUEFSQVRPUildO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVwYXJlZFBhcmFtcyA9IHBhcnNlZFBhcmFtcztcbiAgICB9IC8vIG9iamVjdCBvZiBuYW1lIGFuZCBhbGlhc2VzIGZvciB0aGUgQWRnLXNjcmlwdGxldFxuXG5cbiAgICB2YXIgYWRnU2NyaXB0bGV0T2JqZWN0ID0gT2JqZWN0LmtleXMoc2NyaXB0bGV0TGlzdCkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIHNjcmlwdGxldExpc3RbZWxdO1xuICAgIH0pLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgdmFyIF9zJG5hbWVzID0gdG9BcnJheShzLm5hbWVzKSxcbiAgICAgICAgICBuYW1lID0gX3MkbmFtZXNbMF0sXG4gICAgICAgICAgYWxpYXNlcyA9IF9zJG5hbWVzLnNsaWNlKDEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhbGlhc2VzOiBhbGlhc2VzXG4gICAgICB9O1xuICAgIH0pLmZpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwubmFtZSA9PT0gcGFyc2VkTmFtZSB8fCBlbC5hbGlhc2VzLmluZGV4T2YocGFyc2VkTmFtZSkgPj0gMDtcbiAgICB9KTtcbiAgICB2YXIgYWxpYXNlcyA9IGFkZ1NjcmlwdGxldE9iamVjdC5hbGlhc2VzO1xuXG4gICAgaWYgKGFsaWFzZXMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHVib0FsaWFzID0gYWRnU2NyaXB0bGV0T2JqZWN0LmFsaWFzZXMgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgLmZpbmQoZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBhbGlhcy5pbmNsdWRlcyhVQk9fQUxJQVNfTkFNRV9NQVJLRVIpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh1Ym9BbGlhcykge1xuICAgICAgICB2YXIgbWFzayA9IHJ1bGUubWF0Y2goQURHVUFSRF9TQ1JJUFRMRVRfTUFTS19SRUcpWzBdO1xuICAgICAgICB2YXIgdGVtcGxhdGU7XG5cbiAgICAgICAgaWYgKG1hc2suaW5kZXhPZignQCcpID4gLTEpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX1RFTVBMQVRFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBsYXRlID0gVUJPX1NDUklQVExFVF9URU1QTEFURTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb21haW5zID0gZ2V0QmVmb3JlUmVnRXhwKHJ1bGUsIEFER1VBUkRfU0NSSVBUTEVUX01BU0tfUkVHKTtcbiAgICAgICAgdmFyIHVib05hbWUgPSB1Ym9BbGlhcy5yZXBsYWNlKFVCT19BTElBU19OQU1FX01BUktFUiwgJycpIC8vICcuanMnIGluIHRoZSBVYm8gc2NyaXB0bGV0IG5hbWUgY2FuIGJlIG9taXR0ZWRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjZ2VuZXJhbC1wdXJwb3NlLXNjcmlwdGxldHNcbiAgICAgICAgLnJlcGxhY2UoVUJPX1NDUklQVExFVF9KU19FTkRJTkcsICcnKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBwcmVwYXJlZFBhcmFtcy5sZW5ndGggPiAwID8gXCJcIi5jb25jYXQodWJvTmFtZSwgXCIsIFwiKS5jb25jYXQocHJlcGFyZWRQYXJhbXMuam9pbihcIlwiLmNvbmNhdChDT01NQV9TRVBBUkFUT1IsIFwiIFwiKSkpIDogdWJvTmFtZTtcbiAgICAgICAgdmFyIHVib1J1bGUgPSByZXBsYWNlUGxhY2Vob2xkZXJzKHRlbXBsYXRlLCB7XG4gICAgICAgICAgZG9tYWluczogZG9tYWlucyxcbiAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgIH0pO1xuICAgICAgICByZXMgPSB1Ym9SdWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgQURHIHNjcmlwdGxldCBleGlzdHMgb3IgVUJPL0FCUCBzY3JpcHRsZXQgaXMgY29tcGF0aWJsZSB0byBBREdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAtIGNhbiBiZSBBREcgb3IgVUJPIG9yIEFCUCBzY3JpcHRsZXQgcnVsZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxudmFyIGlzVmFsaWRTY3JpcHRsZXRSdWxlID0gZnVuY3Rpb24gaXNWYWxpZFNjcmlwdGxldFJ1bGUoaW5wdXQpIHtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBBQlAgJ2lucHV0JyBydWxlIG1heSBjb250YWluIG1vcmUgdGhhbiBvbmUgc25pcHBldFxuXG5cbiAgdmFyIHJ1bGVzQXJyYXkgPSBjb252ZXJ0U2NyaXB0bGV0VG9BZGcoaW5wdXQpOyAvLyBjaGVja2luZyBpZiBlYWNoIG9mIHBhcnNlZCBzY3JpcHRsZXRzIGlzIHZhbGlkXG4gIC8vIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzIG5vdCB2YWxpZCAtIHdob2xlICdpbnB1dCcgcnVsZSBpcyBub3QgdmFsaWQgdG9vXG5cbiAgdmFyIGlzVmFsaWQgPSBydWxlc0FycmF5LmV2ZXJ5KGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdmFyIHBhcnNlZFJ1bGUgPSBwYXJzZVJ1bGUocnVsZSk7XG4gICAgcmV0dXJuIHZhbGlkYXRvci5pc1ZhbGlkU2NyaXB0bGV0TmFtZShwYXJzZWRSdWxlLm5hbWUpO1xuICB9KTtcbiAgcmV0dXJuIGlzVmFsaWQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBVYm8gcmVkaXJlY3QgcnVsZSB0byBBZGcgb25lXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG52YXIgY29udmVydFVib1JlZGlyZWN0VG9BZGcgPSBmdW5jdGlvbiBjb252ZXJ0VWJvUmVkaXJlY3RUb0FkZyhydWxlKSB7XG4gIHZhciBmaXJzdFBhcnRPZlJ1bGUgPSBzdWJzdHJpbmdCZWZvcmUocnVsZSwgJyQnKTtcbiAgdmFyIHVib01vZGlmaWVycyA9IHZhbGlkYXRvci5wYXJzZU1vZGlmaWVycyhydWxlKTtcbiAgdmFyIGFkZ01vZGlmaWVycyA9IHVib01vZGlmaWVycy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLmluZGV4T2YodmFsaWRhdG9yLlJFRElSRUNUX1JVTEVfVFlQRVMuVUJPLm1hcmtlcikgPiAtMSkge1xuICAgICAgdmFyIHVib05hbWUgPSBzdWJzdHJpbmdBZnRlcihlbCwgdmFsaWRhdG9yLlJFRElSRUNUX1JVTEVfVFlQRVMuVUJPLm1hcmtlcik7XG4gICAgICB2YXIgYWRnTmFtZSA9IHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLlVCTy5jb21wYXRpYmlsaXR5W3Vib05hbWVdO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLkFERy5tYXJrZXIpLmNvbmNhdChhZGdOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZWwgPT09IFVCT19YSFJfVFlQRSkge1xuICAgICAgcmV0dXJuIEFER19YSFJfVFlQRTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH0pLmpvaW4oQ09NTUFfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGZpcnN0UGFydE9mUnVsZSwgXCIkXCIpLmNvbmNhdChhZGdNb2RpZmllcnMpO1xufTtcbi8qKlxuICogQ29udmVydHMgQWJwIHJlZGlyZWN0IHJ1bGUgdG8gQWRnIG9uZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIGNvbnZlcnRBYnBSZWRpcmVjdFRvQWRnID0gZnVuY3Rpb24gY29udmVydEFicFJlZGlyZWN0VG9BZGcocnVsZSkge1xuICB2YXIgZmlyc3RQYXJ0T2ZSdWxlID0gc3Vic3RyaW5nQmVmb3JlKHJ1bGUsICckJyk7XG4gIHZhciBhYnBNb2RpZmllcnMgPSB2YWxpZGF0b3IucGFyc2VNb2RpZmllcnMocnVsZSk7XG4gIHZhciBhZGdNb2RpZmllcnMgPSBhYnBNb2RpZmllcnMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5pbmRleE9mKHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLkFCUC5tYXJrZXIpID4gLTEpIHtcbiAgICAgIHZhciBhYnBOYW1lID0gc3Vic3RyaW5nQWZ0ZXIoZWwsIHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLkFCUC5tYXJrZXIpO1xuICAgICAgdmFyIGFkZ05hbWUgPSB2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BQlAuY29tcGF0aWJpbGl0eVthYnBOYW1lXTtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcubWFya2VyKS5jb25jYXQoYWRnTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9KS5qb2luKENPTU1BX1NFUEFSQVRPUik7XG4gIHJldHVybiBcIlwiLmNvbmNhdChmaXJzdFBhcnRPZlJ1bGUsIFwiJFwiKS5jb25jYXQoYWRnTW9kaWZpZXJzKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHJlZGlyZWN0IHJ1bGUgdG8gQWRHdWFyZCBvbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBjb252ZXJ0UmVkaXJlY3RUb0FkZyA9IGZ1bmN0aW9uIGNvbnZlcnRSZWRpcmVjdFRvQWRnKHJ1bGUpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodmFsaWRhdG9yLmlzVWJvUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyhydWxlKSkge1xuICAgIHJlc3VsdCA9IGNvbnZlcnRVYm9SZWRpcmVjdFRvQWRnKHJ1bGUpO1xuICB9IGVsc2UgaWYgKHZhbGlkYXRvci5pc0FicFJlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcocnVsZSkpIHtcbiAgICByZXN1bHQgPSBjb252ZXJ0QWJwUmVkaXJlY3RUb0FkZyhydWxlKTtcbiAgfSBlbHNlIGlmICh2YWxpZGF0b3IuaXNWYWxpZEFkZ1JlZGlyZWN0UnVsZShydWxlKSkge1xuICAgIHJlc3VsdCA9IHJ1bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgQWRnIHJlZGlyZWN0IHJ1bGUgdG8gVWJvIG9uZVxuICogMS4gQ2hlY2tzIGlmIHRoZXJlIGlzIFVibyBhbmFsb2cgZm9yIEFkZyBydWxlXG4gKiAyLiBQYXJzZXMgdGhlIHJ1bGUgYW5kIGNoZWNocyBpZiB0aGVyZSBhcmUgYW55IHNvdXJjZSB0eXBlIG1vZGlmaWVycyB3aGljaCBhcmUgcmVxdWlyZWQgYnkgVWJvXG4gKiAgICBhbmQgaWYgdGhlcmUgYXJlIG5vIG9uZSB3ZSBhZGQgaXQgbWFudWFsbHkgdG8gdGhlIGVuZC5cbiAqICAgIFNvdXJjZSB0eXBlcyBhcmUgY2hvc2VuIGFjY29yZGluZyB0byByZWRpcmVjdCBuYW1lXG4gKiAgICBlLmcuIHx8YWQuY29tXiRyZWRpcmVjdD08bmFtZT4saW1wb3J0YW50ICAtPj4gIHx8YWQuY29tXiRyZWRpcmVjdD08bmFtZT4saW1wb3J0YW50LHNjcmlwdFxuICogMy4gUmVwbGFjZXMgQWRnIHJlZGlyZWN0IG5hbWUgYnkgVWJvIGFuYWxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIGNvbnZlcnRBZGdSZWRpcmVjdFRvVWJvID0gZnVuY3Rpb24gY29udmVydEFkZ1JlZGlyZWN0VG9VYm8ocnVsZSkge1xuICBpZiAoIXZhbGlkYXRvci5pc0FkZ1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhVYm8ocnVsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29udmVydCBmb3IgdUJPIC0gdW5zdXBwb3J0ZWQgcmVkaXJlY3QgaW4gcnVsZTogXCIuY29uY2F0KHJ1bGUpKTtcbiAgfVxuXG4gIHZhciBiYXNlUGFydCA9IHN1YnN0cmluZ0JlZm9yZShydWxlLCAnJCcpO1xuICB2YXIgYWRnTW9kaWZpZXJzID0gdmFsaWRhdG9yLnBhcnNlTW9kaWZpZXJzKHJ1bGUpO1xuICB2YXIgYWRnUmVkaXJlY3RNb2RpZmllciA9IGFkZ01vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5pbmRleE9mKHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLkFERy5tYXJrZXIpID4gLTE7XG4gIH0pO1xuICB2YXIgYWRnUmVkaXJlY3ROYW1lID0gYWRnUmVkaXJlY3RNb2RpZmllci5zbGljZSh2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcubWFya2VyLmxlbmd0aCk7XG4gIHZhciB1Ym9SZWRpcmVjdE5hbWUgPSB2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcuY29tcGF0aWJpbGl0eVthZGdSZWRpcmVjdE5hbWVdO1xuICB2YXIgdWJvUmVkaXJlY3RNb2RpZmllciA9IFwiXCIuY29uY2F0KHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLlVCTy5tYXJrZXIpLmNvbmNhdCh1Ym9SZWRpcmVjdE5hbWUpO1xuXG4gIGlmICghdmFsaWRhdG9yLmhhc1ZhbGlkQ29udGVudFR5cGUocnVsZSkpIHtcbiAgICAvLyBhZGQgbWlzc2VkIHNvdXJjZSB0eXBlcyBhcyBjb250ZW50IHR5cGUgbW9kaWZpZXJzXG4gICAgdmFyIHNvdXJjZVR5cGVzRGF0YSA9IHZhbGlkYXRvci5BQlNFTlRfU09VUkNFX1RZUEVfUkVQTEFDRU1FTlQuZmluZChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbC5OQU1FID09PSBhZGdSZWRpcmVjdE5hbWU7XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZVR5cGVzRGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb252ZXJ0IGZvciB1Qk8gLSBubyB0eXBlcyB0byBhZGQgZm9yIHNwZWNpZmljIHJlZGlyZWN0IGluIHJ1bGU6IFwiLmNvbmNhdChydWxlKSk7XG4gICAgfVxuXG4gICAgdmFyIGFkZGl0aW9uTW9kaWZpZXJzID0gc291cmNlVHlwZXNEYXRhLlRZUEVTO1xuICAgIGFkZ01vZGlmaWVycy5wdXNoLmFwcGx5KGFkZ01vZGlmaWVycywgdG9Db25zdW1hYmxlQXJyYXkoYWRkaXRpb25Nb2RpZmllcnMpKTtcbiAgfVxuXG4gIHZhciB1Ym9Nb2RpZmllcnMgPSBhZGdNb2RpZmllcnMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCA9PT0gYWRnUmVkaXJlY3RNb2RpZmllcikge1xuICAgICAgcmV0dXJuIHVib1JlZGlyZWN0TW9kaWZpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9KS5qb2luKENPTU1BX1NFUEFSQVRPUik7XG4gIHJldHVybiBcIlwiLmNvbmNhdChiYXNlUGFydCwgXCIkXCIpLmNvbmNhdCh1Ym9Nb2RpZmllcnMpO1xufTtcblxuLyoqXG4gKiBAcmVkaXJlY3QgZ29vZ2xlLWFuYWx5dGljc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3MgR29vZ2xlJ3MgQW5hbHl0aWNzIGFuZCBUYWcgTWFuYWdlciBBUElzLlxuICogW0NvdmVycyBvYnNvbGV0ZSBnb29nbGV0YWdtYW5hZ2VyLWd0bSByZWRpcmVjdCBmdW5jdGlvbmFsaXR5XShodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTI3KS5cbiAqXG4gKiBSZWxhdGVkIFVCTyByZWRpcmVjdCByZXNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9ibG9iLzhjZDJhMWQyNjNhOTY0MjE0ODdiMzkwNDBjMWQyM2ViMDExNjk0ODQvc3JjL3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy9nb29nbGUtYW5hbHl0aWNzX2FuYWx5dGljcy5qc1xuICpcbiAqICoqRXhhbXBsZSoqXG4gKiBgYGBcbiAqIHx8Z29vZ2xlLWFuYWx5dGljcy5jb20vYW5hbHl0aWNzLmpzJHNjcmlwdCxyZWRpcmVjdD1nb29nbGUtYW5hbHl0aWNzXG4gKiB8fGdvb2dsZXRhZ21hbmFnZXIuY29tL2d0bS5qcyRzY3JpcHQscmVkaXJlY3Q9Z29vZ2xldGFnbWFuYWdlci1ndG1cbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIEdvb2dsZUFuYWx5dGljcyhzb3VyY2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgdmFyIFRyYWNrZXIgPSBmdW5jdGlvbiBUcmFja2VyKCkge307IC8vIGNvbnN0cnVjdG9yXG5cblxuICB2YXIgcHJvdG8gPSBUcmFja2VyLnByb3RvdHlwZTtcbiAgcHJvdG8uZ2V0ID0gbm9vcEZ1bmM7XG4gIHByb3RvLnNldCA9IG5vb3BGdW5jO1xuICBwcm90by5zZW5kID0gbm9vcEZ1bmM7XG4gIHZhciBnb29nbGVBbmFseXRpY3NOYW1lID0gd2luZG93Lkdvb2dsZUFuYWx5dGljc09iamVjdCB8fCAnZ2EnOyAvLyBhIC0tIGZha2UgYXJnIGZvciAnZ2EubGVuZ3RoIDwgMScgYW50aWFkYmxvY2sgY2hlY2tpbmdcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZnVuY3Rpb24gZ2EoYSkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuXG5cbiAgICB2YXIgbGFzdEFyZyA9IGFyZ3VtZW50c1tsZW4gLSAxXTtcbiAgICB2YXIgcmVwbGFjZXI7XG5cbiAgICBpZiAobGFzdEFyZyBpbnN0YW5jZW9mIE9iamVjdCAmJiBsYXN0QXJnICE9PSBudWxsICYmIHR5cGVvZiBsYXN0QXJnLmhpdENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXBsYWNlciA9IGxhc3RBcmcuaGl0Q2FsbGJhY2s7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzk4XG4gICAgICByZXBsYWNlciA9IGZ1bmN0aW9uIHJlcGxhY2VyKCkge1xuICAgICAgICBsYXN0QXJnKGdhLmNyZWF0ZSgpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldFRpbWVvdXQocmVwbGFjZXIsIDEpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChleCkge31cbiAgfVxuXG4gIGdhLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrZXIoKTtcbiAgfTtcblxuICBnYS5nZXRCeU5hbWUgPSBub29wTnVsbDtcbiAgZ2EuZ2V0QWxsID0gbm9vcEFycmF5O1xuICBnYS5yZW1vdmUgPSBub29wRnVuYztcbiAgZ2EubG9hZGVkID0gdHJ1ZTtcbiAgd2luZG93W2dvb2dsZUFuYWx5dGljc05hbWVdID0gZ2E7XG4gIHZhciBfd2luZG93ID0gd2luZG93LFxuICAgICAgZGF0YUxheWVyID0gX3dpbmRvdy5kYXRhTGF5ZXIsXG4gICAgICBnb29nbGVfb3B0aW1pemUgPSBfd2luZG93Lmdvb2dsZV9vcHRpbWl6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICBpZiAoZGF0YUxheWVyIGluc3RhbmNlb2YgT2JqZWN0ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhTGF5ZXIuaGlkZSBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgZGF0YUxheWVyLmhpZGUuZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YUxheWVyLmhpZGUuZW5kKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGRhdGFMYXllci5wdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YUxheWVyLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIGRhdGEuZXZlbnRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzZXRUaW1lb3V0KGRhdGEuZXZlbnRDYWxsYmFjaywgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvODFcblxuXG4gIGlmIChnb29nbGVfb3B0aW1pemUgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIGdvb2dsZV9vcHRpbWl6ZS5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgIHZhciBnb29nbGVPcHRpbWl6ZVdyYXBwZXIgPSB7fTtcbiAgICBnb29nbGVPcHRpbWl6ZVdyYXBwZXIuZ2V0ID0gbm9vcEZ1bmM7XG4gICAgd2luZG93Lmdvb2dsZV9vcHRpbWl6ZSA9IGdvb2dsZU9wdGltaXplV3JhcHBlcjtcbiAgfVxuXG4gIGhpdChzb3VyY2UpO1xufVxuR29vZ2xlQW5hbHl0aWNzLm5hbWVzID0gWydnb29nbGUtYW5hbHl0aWNzJywgJ3Viby1nb29nbGUtYW5hbHl0aWNzX2FuYWx5dGljcy5qcycsICdnb29nbGUtYW5hbHl0aWNzX2FuYWx5dGljcy5qcycsIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMjdcbidnb29nbGV0YWdtYW5hZ2VyLWd0bScsICd1Ym8tZ29vZ2xldGFnbWFuYWdlcl9ndG0uanMnLCAnZ29vZ2xldGFnbWFuYWdlcl9ndG0uanMnXTtcbkdvb2dsZUFuYWx5dGljcy5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmMsIG5vb3BOdWxsLCBub29wQXJyYXldO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuLyoqXG4gKiBAcmVkaXJlY3QgZ29vZ2xlLWFuYWx5dGljcy1nYVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3Mgb2xkIEdvb2dsZSBBbmFseXRpY3MgQVBJLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHJlZGlyZWN0IHJlc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL2Jsb2IvYTk0ZGY3ZjNiMjcwODBhZTJkY2IzYjkxNGFjZTM5YzBjMjk0ZDJmNi9zcmMvd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzL2dvb2dsZS1hbmFseXRpY3NfZ2EuanNcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fGdvb2dsZS1hbmFseXRpY3MuY29tL2dhLmpzJHNjcmlwdCxyZWRpcmVjdD1nb29nbGUtYW5hbHl0aWNzLWdhXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBHb29nbGVBbmFseXRpY3NHYShzb3VyY2UpIHtcbiAgLy8gR2FxIGNvbnN0cnVjdG9yXG4gIGZ1bmN0aW9uIEdhcSgpIHt9XG5cbiAgR2FxLnByb3RvdHlwZS5OYSA9IG5vb3BGdW5jO1xuICBHYXEucHJvdG90eXBlLk8gPSBub29wRnVuYztcbiAgR2FxLnByb3RvdHlwZS5TYSA9IG5vb3BGdW5jO1xuICBHYXEucHJvdG90eXBlLlRhID0gbm9vcEZ1bmM7XG4gIEdhcS5wcm90b3R5cGUuVmEgPSBub29wRnVuYztcbiAgR2FxLnByb3RvdHlwZS5fY3JlYXRlQXN5bmNUcmFja2VyID0gbm9vcEZ1bmM7XG4gIEdhcS5wcm90b3R5cGUuX2dldEFzeW5jVHJhY2tlciA9IG5vb3BGdW5jO1xuICBHYXEucHJvdG90eXBlLl9nZXRQbHVnaW4gPSBub29wRnVuYztcblxuICBHYXEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGF0YSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vYW5hbHl0aWNzL2Rldmd1aWRlcy9jb2xsZWN0aW9uL2dhanMvbWV0aG9kcy9nYUpTQXBpRG9tYWluRGlyZWN0b3J5I19nYXQuR0FfVHJhY2tlcl8uX2xpbmtcblxuXG4gICAgaWYgKGRhdGFbMF0gPT09ICdfbGluaycgJiYgdHlwZW9mIGRhdGFbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGRhdGFbMV0pO1xuICAgIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL2lzc3Vlcy8yMTYyXG5cblxuICAgIGlmIChkYXRhWzBdID09PSAnX3NldCcgJiYgZGF0YVsxXSA9PT0gJ2hpdENhbGxiYWNrJyAmJiB0eXBlb2YgZGF0YVsyXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGF0YVsyXSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2FxID0gbmV3IEdhcSgpO1xuICB2YXIgYXN5bmNUcmFja2VycyA9IHdpbmRvdy5fZ2FxIHx8IFtdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGFzeW5jVHJhY2tlcnMpKSB7XG4gICAgd2hpbGUgKGFzeW5jVHJhY2tlcnNbMF0pIHtcbiAgICAgIGdhcS5wdXNoKGFzeW5jVHJhY2tlcnMuc2hpZnQoKSk7XG4gICAgfVxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cblxuXG4gIHdpbmRvdy5fZ2FxID0gZ2FxLnFmID0gZ2FxOyAvLyBHYXQgY29uc3RydWN0b3JcblxuICBmdW5jdGlvbiBHYXQoKSB7fSAvLyBNb2NrIHRyYWNrZXIgYXBpXG5cblxuICB2YXIgYXBpID0gWydfYWRkSWdub3JlZE9yZ2FuaWMnLCAnX2FkZElnbm9yZWRSZWYnLCAnX2FkZEl0ZW0nLCAnX2FkZE9yZ2FuaWMnLCAnX2FkZFRyYW5zJywgJ19jbGVhcklnbm9yZWRPcmdhbmljJywgJ19jbGVhcklnbm9yZWRSZWYnLCAnX2NsZWFyT3JnYW5pYycsICdfY29va2llUGF0aENvcHknLCAnX2RlbGV0ZUN1c3RvbVZhcicsICdfZ2V0TmFtZScsICdfc2V0QWNjb3VudCcsICdfZ2V0QWNjb3VudCcsICdfZ2V0Q2xpZW50SW5mbycsICdfZ2V0RGV0ZWN0Rmxhc2gnLCAnX2dldERldGVjdFRpdGxlJywgJ19nZXRMaW5rZXJVcmwnLCAnX2dldExvY2FsR2lmUGF0aCcsICdfZ2V0U2VydmljZU1vZGUnLCAnX2dldFZlcnNpb24nLCAnX2dldFZpc2l0b3JDdXN0b21WYXInLCAnX2luaXREYXRhJywgJ19saW5rJywgJ19saW5rQnlQb3N0JywgJ19zZXRBbGxvd0FuY2hvcicsICdfc2V0QWxsb3dIYXNoJywgJ19zZXRBbGxvd0xpbmtlcicsICdfc2V0Q2FtcENvbnRlbnRLZXknLCAnX3NldENhbXBNZWRpdW1LZXknLCAnX3NldENhbXBOYW1lS2V5JywgJ19zZXRDYW1wTk9LZXknLCAnX3NldENhbXBTb3VyY2VLZXknLCAnX3NldENhbXBUZXJtS2V5JywgJ19zZXRDYW1wYWlnbkNvb2tpZVRpbWVvdXQnLCAnX3NldENhbXBhaWduVHJhY2snLCAnX3NldENsaWVudEluZm8nLCAnX3NldENvb2tpZVBhdGgnLCAnX3NldENvb2tpZVBlcnNpc3RlbmNlJywgJ19zZXRDb29raWVUaW1lb3V0JywgJ19zZXRDdXN0b21WYXInLCAnX3NldERldGVjdEZsYXNoJywgJ19zZXREZXRlY3RUaXRsZScsICdfc2V0RG9tYWluTmFtZScsICdfc2V0TG9jYWxHaWZQYXRoJywgJ19zZXRMb2NhbFJlbW90ZVNlcnZlck1vZGUnLCAnX3NldExvY2FsU2VydmVyTW9kZScsICdfc2V0UmVmZXJyZXJPdmVycmlkZScsICdfc2V0UmVtb3RlU2VydmVyTW9kZScsICdfc2V0U2FtcGxlUmF0ZScsICdfc2V0U2Vzc2lvblRpbWVvdXQnLCAnX3NldFNpdGVTcGVlZFNhbXBsZVJhdGUnLCAnX3NldFNlc3Npb25Db29raWVUaW1lb3V0JywgJ19zZXRWYXInLCAnX3NldFZpc2l0b3JDb29raWVUaW1lb3V0JywgJ190cmFja0V2ZW50JywgJ190cmFja1BhZ2VMb2FkVGltZScsICdfdHJhY2tQYWdldmlldycsICdfdHJhY2tTb2NpYWwnLCAnX3RyYWNrVGltaW5nJywgJ190cmFja1RyYW5zJywgJ192aXNpdENvZGUnXTtcbiAgdmFyIHRyYWNrZXIgPSBhcGkucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGZ1bmNOYW1lKSB7XG4gICAgcmVzW2Z1bmNOYW1lXSA9IG5vb3BGdW5jO1xuICAgIHJldHVybiByZXM7XG4gIH0sIHt9KTtcblxuICB0cmFja2VyLl9nZXRMaW5rZXJVcmwgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIEdhdC5wcm90b3R5cGUuX2Fub255bWl6ZUlQID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUuX2NyZWF0ZVRyYWNrZXIgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5fZm9yY2VTU0wgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5fZ2V0UGx1Z2luID0gbm9vcEZ1bmM7XG5cbiAgR2F0LnByb3RvdHlwZS5fZ2V0VHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhY2tlcjtcbiAgfTtcblxuICBHYXQucHJvdG90eXBlLl9nZXRUcmFja2VyQnlOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cmFja2VyO1xuICB9O1xuXG4gIEdhdC5wcm90b3R5cGUuX2dldFRyYWNrZXJzID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUuYWEgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5hYiA9IG5vb3BGdW5jO1xuICBHYXQucHJvdG90eXBlLmhiID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUubGEgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5vYSA9IG5vb3BGdW5jO1xuICBHYXQucHJvdG90eXBlLnBhID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUudSA9IG5vb3BGdW5jO1xuICB2YXIgZ2F0ID0gbmV3IEdhdCgpO1xuICB3aW5kb3cuX2dhdCA9IGdhdDtcbiAgaGl0KHNvdXJjZSk7XG59XG5Hb29nbGVBbmFseXRpY3NHYS5uYW1lcyA9IFsnZ29vZ2xlLWFuYWx5dGljcy1nYScsICd1Ym8tZ29vZ2xlLWFuYWx5dGljc19nYS5qcycsICdnb29nbGUtYW5hbHl0aWNzX2dhLmpzJ107XG5Hb29nbGVBbmFseXRpY3NHYS5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmNdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHJlZGlyZWN0IGdvb2dsZXN5bmRpY2F0aW9uLWFkc2J5Z29vZ2xlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBHb29nbGUgQWRTZW5zZSBBUEkuXG4gKlxuICogUmVsYXRlZCBVQk8gcmVkaXJlY3QgcmVzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svYmxvYi9hOTRkZjdmM2IyNzA4MGFlMmRjYjNiOTE0YWNlMzljMGMyOTRkMmY2L3NyYy93ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMvZ29vZ2xlc3luZGljYXRpb25fYWRzYnlnb29nbGUuanNcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fHBhZ2VhZDIuZ29vZ2xlc3luZGljYXRpb24uY29tL3BhZ2VhZC9qcy9hZHNieWdvb2dsZS5qcyRzY3JpcHQscmVkaXJlY3Q9Z29vZ2xlc3luZGljYXRpb24tYWRzYnlnb29nbGVcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBHb29nbGVTeW5kaWNhdGlvbkFkc0J5R29vZ2xlKHNvdXJjZSkge1xuICB3aW5kb3cuYWRzYnlnb29nbGUgPSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzExM1xuICAgIC8vIGxlbmd0aDogMCxcbiAgICBsb2FkZWQ6IHRydWUsXG4gICAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5sZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBhZEVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFkc2J5Z29vZ2xlJyk7XG4gIHZhciBjc3MgPSAnaGVpZ2h0OjFweCFpbXBvcnRhbnQ7bWF4LWhlaWdodDoxcHghaW1wb3J0YW50O21heC13aWR0aDoxcHghaW1wb3J0YW50O3dpZHRoOjFweCFpbXBvcnRhbnQ7JztcbiAgdmFyIHN0YXR1c0F0dHJOYW1lID0gJ2RhdGEtYWRzYnlnb29nbGUtc3RhdHVzJztcbiAgdmFyIEFTV0lGVF9JRlJBTUVfTUFSS0VSID0gJ2Fzd2lmdF8nO1xuICB2YXIgR09PR0xFX0FEU19JRlJBTUVfTUFSS0VSID0gJ2dvb2dsZV9hZHNfaWZyYW1lXyc7XG4gIHZhciBleGVjdXRlZCA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRFbGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBhZEVsZW1DaGlsZE5vZGVzID0gYWRFbGVtc1tpXS5jaGlsZE5vZGVzO1xuICAgIHZhciBjaGlsZE5vZGVzUXVhbnRpdHkgPSBhZEVsZW1DaGlsZE5vZGVzLmxlbmd0aDsgLy8gY2hpbGROb2RlcyBvZiAuYWRzYnlnb29nbGUgY2FuIGJlIGRlZmluZWQgaWYgc2NyaXB0bGV0IHdhcyBleGVjdXRlZCBiZWZvcmVcbiAgICAvLyBzbyB3ZSBzaG91bGQgY2hlY2sgYXJlIHRoYXQgY2hpbGROb2RlcyBleGFjdGx5IGRlZmluZWQgYnkgdXNcbiAgICAvLyBUT0RPOiByZW1ha2UgYWZ0ZXIgc2NyaXB0bGV0cyBjb250ZXh0IGRldmVsb3BpbmcgaW4gMS4zXG5cbiAgICB2YXIgYXJlSWZyYW1lc0RlZmluZWQgPSBmYWxzZTtcblxuICAgIGlmIChjaGlsZE5vZGVzUXVhbnRpdHkgPiAwKSB7XG4gICAgICAvLyBpdCBzaG91bGQgYmUgb25seSAyIGNoaWxkIGlmcmFtZXMgaWYgc2NyaXB0bGV0IHdhcyBleGVjdXRlZFxuICAgICAgYXJlSWZyYW1lc0RlZmluZWQgPSBjaGlsZE5vZGVzUXVhbnRpdHkgPT09IDIgLy8gdGhlIGZpcnN0IG9mIGNoaWxkIG5vZGVzIHNob3VsZCBiZSBhc3dpZnQgaWZyYW1lXG4gICAgICAmJiBhZEVsZW1DaGlsZE5vZGVzWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lmcmFtZScgJiYgYWRFbGVtQ2hpbGROb2Rlc1swXS5pZC5pbmRleE9mKEFTV0lGVF9JRlJBTUVfTUFSS0VSKSA+IC0xIC8vIHRoZSBzZWNvbmQgb2YgY2hpbGQgbm9kZXMgc2hvdWxkIGJlIGdvb2dsZV9hZHMgaWZyYW1lXG4gICAgICAmJiBhZEVsZW1DaGlsZE5vZGVzWzFdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lmcmFtZScgJiYgYWRFbGVtQ2hpbGROb2Rlc1sxXS5pZC5pbmRleE9mKEdPT0dMRV9BRFNfSUZSQU1FX01BUktFUikgPiAtMTtcbiAgICB9XG5cbiAgICBpZiAoIWFyZUlmcmFtZXNEZWZpbmVkKSB7XG4gICAgICAvLyBoZXJlIHdlIGRvIHRoZSBqb2IgaWYgc2NyaXB0bGV0IGhhcyBub3QgYmVlbiBleGVjdXRlZCBlYXJsaWVyXG4gICAgICBhZEVsZW1zW2ldLnNldEF0dHJpYnV0ZShzdGF0dXNBdHRyTmFtZSwgJ2RvbmUnKTtcbiAgICAgIHZhciBhc3dpZnRJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGFzd2lmdElmcmFtZS5pZCA9IFwiXCIuY29uY2F0KEFTV0lGVF9JRlJBTUVfTUFSS0VSKS5jb25jYXQoaSk7XG4gICAgICBhc3dpZnRJZnJhbWUuc3R5bGUgPSBjc3M7XG4gICAgICBhZEVsZW1zW2ldLmFwcGVuZENoaWxkKGFzd2lmdElmcmFtZSk7XG4gICAgICB2YXIgaW5uZXJBc3dpZnRJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGFzd2lmdElmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5uZXJBc3dpZnRJZnJhbWUpO1xuICAgICAgdmFyIGdvb2dsZWFkc0lmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZ29vZ2xlYWRzSWZyYW1lLmlkID0gXCJcIi5jb25jYXQoR09PR0xFX0FEU19JRlJBTUVfTUFSS0VSKS5jb25jYXQoaSk7XG4gICAgICBnb29nbGVhZHNJZnJhbWUuc3R5bGUgPSBjc3M7XG4gICAgICBhZEVsZW1zW2ldLmFwcGVuZENoaWxkKGdvb2dsZWFkc0lmcmFtZSk7XG4gICAgICB2YXIgaW5uZXJHb29nbGVhZHNJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGdvb2dsZWFkc0lmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5uZXJHb29nbGVhZHNJZnJhbWUpO1xuICAgICAgZXhlY3V0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleGVjdXRlZCkge1xuICAgIGhpdChzb3VyY2UpO1xuICB9XG59XG5Hb29nbGVTeW5kaWNhdGlvbkFkc0J5R29vZ2xlLm5hbWVzID0gWydnb29nbGVzeW5kaWNhdGlvbi1hZHNieWdvb2dsZScsICd1Ym8tZ29vZ2xlc3luZGljYXRpb25fYWRzYnlnb29nbGUuanMnLCAnZ29vZ2xlc3luZGljYXRpb25fYWRzYnlnb29nbGUuanMnXTtcbkdvb2dsZVN5bmRpY2F0aW9uQWRzQnlHb29nbGUuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKipcbiAqIEByZWRpcmVjdCBnb29nbGV0YWdzZXJ2aWNlcy1ncHRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1vY2tzIEdvb2dsZSBQdWJsaXNoZXIgVGFnIEFQSS5cbiAqXG4gKiBSZWxhdGVkIFVCTyByZWRpcmVjdCByZXNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9ibG9iL2E5NGRmN2YzYjI3MDgwYWUyZGNiM2I5MTRhY2UzOWMwYzI5NGQyZjYvc3JjL3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy9nb29nbGV0YWdzZXJ2aWNlc19ncHQuanNcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fGdvb2dsZXRhZ3NlcnZpY2VzLmNvbS90YWcvanMvZ3B0LmpzJHNjcmlwdCxyZWRpcmVjdD1nb29nbGV0YWdzZXJ2aWNlcy1ncHRcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIEdvb2dsZVRhZ1NlcnZpY2VzR3B0KHNvdXJjZSkge1xuICB2YXIgY29tcGFuaW9uQWRzU2VydmljZSA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBub29wVGhpcyxcbiAgICBlbmFibGVTeW5jTG9hZGluZzogbm9vcEZ1bmMsXG4gICAgc2V0UmVmcmVzaFVuZmlsbGVkU2xvdHM6IG5vb3BGdW5jXG4gIH07XG4gIHZhciBjb250ZW50U2VydmljZSA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBub29wVGhpcyxcbiAgICBzZXRDb250ZW50OiBub29wRnVuY1xuICB9O1xuXG4gIGZ1bmN0aW9uIFBhc3NiYWNrU2xvdCgpIHt9IC8vIGNvbnN0cnVjdG9yXG5cblxuICBQYXNzYmFja1Nsb3QucHJvdG90eXBlLmRpc3BsYXkgPSBub29wRnVuYztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5nZXQgPSBub29wTnVsbDtcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5zZXQgPSBub29wVGhpcztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5zZXRDbGlja1VybCA9IG5vb3BUaGlzO1xuICBQYXNzYmFja1Nsb3QucHJvdG90eXBlLnNldFRhZ0ZvckNoaWxkRGlyZWN0ZWRUcmVhdG1lbnQgPSBub29wVGhpcztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5zZXRUYXJnZXRpbmcgPSBub29wVGhpcztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS51cGRhdGVUYXJnZXRpbmdGcm9tTWFwID0gbm9vcFRoaXM7XG5cbiAgZnVuY3Rpb24gU2l6ZU1hcHBpbmdCdWlsZGVyKCkge30gLy8gY29uc3RydWN0b3JcblxuXG4gIFNpemVNYXBwaW5nQnVpbGRlci5wcm90b3R5cGUuYWRkU2l6ZSA9IG5vb3BUaGlzO1xuICBTaXplTWFwcGluZ0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gbm9vcE51bGw7XG5cbiAgZnVuY3Rpb24gU2xvdCgpIHt9IC8vIGNvbnN0cnVjdG9yXG5cblxuICBTbG90LnByb3RvdHlwZS5hZGRTZXJ2aWNlID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLmNsZWFyQ2F0ZWdvcnlFeGNsdXNpb25zID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLmNsZWFyVGFyZ2V0aW5nID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLmRlZmluZVNpemVNYXBwaW5nID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLmdldCA9IG5vb3BOdWxsO1xuICBTbG90LnByb3RvdHlwZS5nZXRBZFVuaXRQYXRoID0gbm9vcEFycmF5O1xuICBTbG90LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVLZXlzID0gbm9vcEFycmF5O1xuICBTbG90LnByb3RvdHlwZS5nZXRDYXRlZ29yeUV4Y2x1c2lvbnMgPSBub29wQXJyYXk7XG4gIFNsb3QucHJvdG90eXBlLmdldERvbUlkID0gbm9vcFN0cjtcbiAgU2xvdC5wcm90b3R5cGUuZ2V0U2xvdEVsZW1lbnRJZCA9IG5vb3BTdHI7XG4gIFNsb3QucHJvdG90eXBlLmdldFNsb3RJZCA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5nZXRUYXJnZXRpbmcgPSBub29wQXJyYXk7XG4gIFNsb3QucHJvdG90eXBlLmdldFRhcmdldGluZ0tleXMgPSBub29wQXJyYXk7XG4gIFNsb3QucHJvdG90eXBlLnNldCA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5zZXRDYXRlZ29yeUV4Y2x1c2lvbiA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5zZXRDbGlja1VybCA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5zZXRDb2xsYXBzZUVtcHR5RGl2ID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLnNldFRhcmdldGluZyA9IG5vb3BUaGlzO1xuICB2YXIgcHViQWRzU2VydmljZSA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBub29wVGhpcyxcbiAgICBjbGVhcjogbm9vcEZ1bmMsXG4gICAgY2xlYXJDYXRlZ29yeUV4Y2x1c2lvbnM6IG5vb3BUaGlzLFxuICAgIGNsZWFyVGFnRm9yQ2hpbGREaXJlY3RlZFRyZWF0bWVudDogbm9vcFRoaXMsXG4gICAgY2xlYXJUYXJnZXRpbmc6IG5vb3BUaGlzLFxuICAgIGNvbGxhcHNlRW1wdHlEaXZzOiBub29wRnVuYyxcbiAgICBkZWZpbmVPdXRPZlBhZ2VQYXNzYmFjazogZnVuY3Rpb24gZGVmaW5lT3V0T2ZQYWdlUGFzc2JhY2soKSB7XG4gICAgICByZXR1cm4gbmV3IFBhc3NiYWNrU2xvdCgpO1xuICAgIH0sXG4gICAgZGVmaW5lUGFzc2JhY2s6IGZ1bmN0aW9uIGRlZmluZVBhc3NiYWNrKCkge1xuICAgICAgcmV0dXJuIG5ldyBQYXNzYmFja1Nsb3QoKTtcbiAgICB9LFxuICAgIGRpc2FibGVJbml0aWFsTG9hZDogbm9vcEZ1bmMsXG4gICAgZGlzcGxheTogbm9vcEZ1bmMsXG4gICAgZW5hYmxlQXN5bmNSZW5kZXJpbmc6IG5vb3BGdW5jLFxuICAgIGVuYWJsZVNpbmdsZVJlcXVlc3Q6IG5vb3BGdW5jLFxuICAgIGVuYWJsZVN5bmNSZW5kZXJpbmc6IG5vb3BGdW5jLFxuICAgIGVuYWJsZVZpZGVvQWRzOiBub29wRnVuYyxcbiAgICBnZXQ6IG5vb3BOdWxsLFxuICAgIGdldEF0dHJpYnV0ZUtleXM6IG5vb3BBcnJheSxcbiAgICBnZXRUYXJnZXRpbmc6IG5vb3BGdW5jLFxuICAgIGdldFRhcmdldGluZ0tleXM6IG5vb3BBcnJheSxcbiAgICBnZXRTbG90czogbm9vcEFycmF5LFxuICAgIHJlZnJlc2g6IG5vb3BGdW5jLFxuICAgIHNldDogbm9vcFRoaXMsXG4gICAgc2V0Q2F0ZWdvcnlFeGNsdXNpb246IG5vb3BUaGlzLFxuICAgIHNldENlbnRlcmluZzogbm9vcEZ1bmMsXG4gICAgc2V0Q29va2llT3B0aW9uczogbm9vcFRoaXMsXG4gICAgc2V0Rm9yY2VTYWZlRnJhbWU6IG5vb3BUaGlzLFxuICAgIHNldExvY2F0aW9uOiBub29wVGhpcyxcbiAgICBzZXRQdWJsaXNoZXJQcm92aWRlZElkOiBub29wVGhpcyxcbiAgICBzZXRSZXF1ZXN0Tm9uUGVyc29uYWxpemVkQWRzOiBub29wVGhpcyxcbiAgICBzZXRTYWZlRnJhbWVDb25maWc6IG5vb3BUaGlzLFxuICAgIHNldFRhZ0ZvckNoaWxkRGlyZWN0ZWRUcmVhdG1lbnQ6IG5vb3BUaGlzLFxuICAgIHNldFRhcmdldGluZzogbm9vcFRoaXMsXG4gICAgc2V0VmlkZW9Db250ZW50OiBub29wVGhpcyxcbiAgICB1cGRhdGVDb3JyZWxhdG9yOiBub29wRnVuY1xuICB9O1xuICB2YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICAgIF93aW5kb3ckZ29vZ2xldGFnID0gX3dpbmRvdy5nb29nbGV0YWcsXG4gICAgICBnb29nbGV0YWcgPSBfd2luZG93JGdvb2dsZXRhZyA9PT0gdm9pZCAwID8ge30gOiBfd2luZG93JGdvb2dsZXRhZztcbiAgdmFyIF9nb29nbGV0YWckY21kID0gZ29vZ2xldGFnLmNtZCxcbiAgICAgIGNtZCA9IF9nb29nbGV0YWckY21kID09PSB2b2lkIDAgPyBbXSA6IF9nb29nbGV0YWckY21kO1xuICBnb29nbGV0YWcuYXBpUmVhZHkgPSB0cnVlO1xuICBnb29nbGV0YWcuY21kID0gW107XG5cbiAgZ29vZ2xldGFnLmNtZC5wdXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB0cnkge1xuICAgICAgYSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChleCkge31cblxuICAgIHJldHVybiAxO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5jb21wYW5pb25BZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbXBhbmlvbkFkc1NlcnZpY2U7XG4gIH07XG5cbiAgZ29vZ2xldGFnLmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRlbnRTZXJ2aWNlO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5kZWZpbmVPdXRPZlBhZ2VTbG90ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU2xvdCgpO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5kZWZpbmVTbG90ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU2xvdCgpO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5kZXN0cm95U2xvdHMgPSBub29wRnVuYztcbiAgZ29vZ2xldGFnLmRpc2FibGVQdWJsaXNoZXJDb25zb2xlID0gbm9vcEZ1bmM7XG4gIGdvb2dsZXRhZy5kaXNwbGF5ID0gbm9vcEZ1bmM7XG4gIGdvb2dsZXRhZy5lbmFibGVTZXJ2aWNlcyA9IG5vb3BGdW5jO1xuICBnb29nbGV0YWcuZ2V0VmVyc2lvbiA9IG5vb3BTdHI7XG5cbiAgZ29vZ2xldGFnLnB1YmFkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHViQWRzU2VydmljZTtcbiAgfTtcblxuICBnb29nbGV0YWcucHViYWRzUmVhZHkgPSB0cnVlO1xuICBnb29nbGV0YWcuc2V0QWRJZnJhbWVUaXRsZSA9IG5vb3BGdW5jO1xuXG4gIGdvb2dsZXRhZy5zaXplTWFwcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNpemVNYXBwaW5nQnVpbGRlcigpO1xuICB9O1xuXG4gIHdpbmRvdy5nb29nbGV0YWcgPSBnb29nbGV0YWc7XG5cbiAgd2hpbGUgKGNtZC5sZW5ndGggIT09IDApIHtcbiAgICBnb29nbGV0YWcuY21kLnB1c2goY21kLnNoaWZ0KCkpO1xuICB9XG5cbiAgaGl0KHNvdXJjZSk7XG59XG5Hb29nbGVUYWdTZXJ2aWNlc0dwdC5uYW1lcyA9IFsnZ29vZ2xldGFnc2VydmljZXMtZ3B0JywgJ3Viby1nb29nbGV0YWdzZXJ2aWNlc19ncHQuanMnLCAnZ29vZ2xldGFnc2VydmljZXNfZ3B0LmpzJ107XG5Hb29nbGVUYWdTZXJ2aWNlc0dwdC5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmMsIG5vb3BUaGlzLCBub29wTnVsbCwgbm9vcEFycmF5LCBub29wU3RyXTtcblxuLyoqXG4gKiBAcmVkaXJlY3Qgc2NvcmVjYXJkcmVzZWFyY2gtYmVhY29uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBTY29yZWNhcmQgUmVzZWFyY2ggQVBJLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHJlZGlyZWN0IHJlc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL2Jsb2IvYTk0ZGY3ZjNiMjcwODBhZTJkY2IzYjkxNGFjZTM5YzBjMjk0ZDJmNi9zcmMvd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzL3Njb3JlY2FyZHJlc2VhcmNoX2JlYWNvbi5qc1xuICpcbiAqICoqRXhhbXBsZSoqXG4gKiBgYGBcbiAqIHx8c2Iuc2NvcmVjYXJkcmVzZWFyY2guY29tL2JlYWNvbi5qcyRzY3JpcHQscmVkaXJlY3Q9c2NvcmVjYXJkcmVzZWFyY2gtYmVhY29uXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBTY29yZUNhcmRSZXNlYXJjaEJlYWNvbihzb3VyY2UpIHtcbiAgd2luZG93LkNPTVNDT1JFID0ge1xuICAgIHB1cmdlOiBmdW5jdGlvbiBwdXJnZSgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgd2luZG93Ll9jb21zY29yZSA9IFtdO1xuICAgIH0sXG4gICAgYmVhY29uOiBmdW5jdGlvbiBiZWFjb24oKSB7fVxuICB9O1xuICBoaXQoc291cmNlKTtcbn1cblNjb3JlQ2FyZFJlc2VhcmNoQmVhY29uLm5hbWVzID0gWydzY29yZWNhcmRyZXNlYXJjaC1iZWFjb24nLCAndWJvLXNjb3JlY2FyZHJlc2VhcmNoX2JlYWNvbi5qcycsICdzY29yZWNhcmRyZXNlYXJjaF9iZWFjb24uanMnXTtcblNjb3JlQ2FyZFJlc2VhcmNoQmVhY29uLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyoqXG4gKiBAcmVkaXJlY3QgbWV0cmlrYS15YW5kZXgtdGFnXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBZYW5kZXggTWV0cmlrYSBBUEkuXG4gKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9tZXRob2QtcmVmZXJlbmNlLmh0bWxcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fG1jLnlhbmRleC5ydS9tZXRyaWthL3RhZy5qcyRzY3JpcHQscmVkaXJlY3Q9bWV0cmlrYS15YW5kZXgtdGFnXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBtZXRyaWthWWFuZGV4VGFnKHNvdXJjZSkge1xuICB2YXIgYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zID0gZnVuY3Rpb24gYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zKHBhcmFtKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgdmFyIGN0eCA9IG9wdGlvbnMuY3R4O1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBjdHggIT09IHVuZGVmaW5lZCA/IGNhbGxiYWNrLmJpbmQoY3R4KSA6IGNhbGxiYWNrO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0ID0gbm9vcEZ1bmM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9hZGRmaWxlZXh0ZW5zaW9uLmh0bWxcbiAgICovXG5cbiAgdmFyIGFkZEZpbGVFeHRlbnNpb24gPSBub29wRnVuYztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL2V4dGxpbmsuaHRtbFxuICAgKi9cblxuICB2YXIgZXh0TGluayA9IGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL2ZpbGUuaHRtbFxuICAgKi9cblxuICB2YXIgZmlsZSA9IGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL2dldC1jbGllbnQtaWQuaHRtbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICB2YXIgZ2V0Q2xpZW50SUQgPSBmdW5jdGlvbiBnZXRDbGllbnRJRChjYikge1xuICAgIHNldFRpbWVvdXQoY2IobnVsbCkpO1xuICB9O1xuICAvKipcbiAgICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvaGl0Lmh0bWxcbiAgICovXG5cblxuICB2YXIgaGl0RnVuYyA9IGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL25vdGJvdW5jZS5odG1sXG4gICAqL1xuXG4gIHZhciBub3RCb3VuY2UgPSBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9wYXJhbXMtbWV0aG9kLmh0bWxcbiAgICovXG5cbiAgdmFyIHBhcmFtcyA9IG5vb3BGdW5jO1xuICAvKipcbiAgICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvcmVhY2hnb2FsLmh0bWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7YW55fSBjdHhcbiAgICovXG5cbiAgdmFyIHJlYWNoR29hbCA9IGZ1bmN0aW9uIHJlYWNoR29hbCh0YXJnZXQsIHBhcmFtcywgY2FsbGJhY2ssIGN0eCkge1xuICAgIGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucyhudWxsLCB7XG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjdHg6IGN0eFxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvc2V0LXVzZXItaWQuaHRtbFxuICAgKi9cblxuXG4gIHZhciBzZXRVc2VySUQgPSBub29wRnVuYztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL3VzZXItcGFyYW1zLmh0bWxcbiAgICovXG5cbiAgdmFyIHVzZXJQYXJhbXMgPSBub29wRnVuYztcbiAgdmFyIGFwaSA9IHtcbiAgICBpbml0OiBpbml0LFxuICAgIGFkZEZpbGVFeHRlbnNpb246IGFkZEZpbGVFeHRlbnNpb24sXG4gICAgZXh0TGluazogZXh0TGluayxcbiAgICBmaWxlOiBmaWxlLFxuICAgIGdldENsaWVudElEOiBnZXRDbGllbnRJRCxcbiAgICBoaXQ6IGhpdEZ1bmMsXG4gICAgbm90Qm91bmNlOiBub3RCb3VuY2UsXG4gICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgcmVhY2hHb2FsOiByZWFjaEdvYWwsXG4gICAgc2V0VXNlcklEOiBzZXRVc2VySUQsXG4gICAgdXNlclBhcmFtczogdXNlclBhcmFtc1xuICB9O1xuXG4gIGZ1bmN0aW9uIHltKGlkLCBmdW5jTmFtZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhcGlbZnVuY05hbWVdICYmIGFwaVtmdW5jTmFtZV0uYXBwbHkoYXBpLCBhcmdzKTtcbiAgfVxuXG4gIHdpbmRvdy55bSA9IHltO1xuICBoaXQoc291cmNlKTtcbn1cbm1ldHJpa2FZYW5kZXhUYWcubmFtZXMgPSBbJ21ldHJpa2EteWFuZGV4LXRhZyddO1xubWV0cmlrYVlhbmRleFRhZy5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmNdO1xuXG4vKipcbiAqIEByZWRpcmVjdCBtZXRyaWthLXlhbmRleC13YXRjaFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3MgdGhlIG9sZCBZYW5kZXggTWV0cmlrYSBBUEkuXG4gKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9fbWV0aG9kLXJlZmVyZW5jZS5odG1sXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogfHxtYy55YW5kZXgucnUvbWV0cmlrYS93YXRjaC5qcyRzY3JpcHQscmVkaXJlY3Q9bWV0cmlrYS15YW5kZXgtd2F0Y2hcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIG1ldHJpa2FZYW5kZXhXYXRjaChzb3VyY2UpIHtcbiAgdmFyIGNiTmFtZSA9ICd5YW5kZXhfbWV0cmlrYV9jYWxsYmFja3MnO1xuICAvKipcbiAgICogR2V0cyBjYWxsYmFjayBhbmQgaXRzIGNvbnRleHQgZnJvbSBvcHRpb25zIGFuZCBjYWxsIGl0IGluIGFzeW5jIHdheVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBZYW5kZXggTWV0cmlrYSBBUEkgb3B0aW9uc1xuICAgKi9cblxuICB2YXIgYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zID0gZnVuY3Rpb24gYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIHZhciBjdHggPSBvcHRpb25zLmN0eDtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gY3R4ICE9PSB1bmRlZmluZWQgPyBjYWxsYmFjay5iaW5kKGN0eCkgOiBjYWxsYmFjaztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBNZXRyaWthKCkge30gLy8gY29uc3RydWN0b3JcbiAgLy8gTWV0aG9kcyB3aXRob3V0IG9wdGlvbnNcblxuXG4gIE1ldHJpa2EucHJvdG90eXBlLmFkZEZpbGVFeHRlbnNpb24gPSBub29wRnVuYztcbiAgTWV0cmlrYS5wcm90b3R5cGUuZ2V0Q2xpZW50SUQgPSBub29wRnVuYztcbiAgTWV0cmlrYS5wcm90b3R5cGUuc2V0VXNlcklEID0gbm9vcEZ1bmM7XG4gIE1ldHJpa2EucHJvdG90eXBlLnVzZXJQYXJhbXMgPSBub29wRnVuYzsgLy8gTWV0aG9kcyB3aXRoIG9wdGlvbnNcbiAgLy8gVGhlIG9yZGVyIG9mIGFyZ3VtZW50cyBzaG91bGQgYmUga2VwdCBpbiBhY2NvcmRpbmcgdG8gQVBJXG5cbiAgTWV0cmlrYS5wcm90b3R5cGUuZXh0TGluayA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIH07XG5cbiAgTWV0cmlrYS5wcm90b3R5cGUuZmlsZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIH07XG5cbiAgTWV0cmlrYS5wcm90b3R5cGUuaGl0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgIGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgfTtcblxuICBNZXRyaWthLnByb3RvdHlwZS5yZWFjaEdvYWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJhbXMsIGNiLCBjdHgpIHtcbiAgICBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnMoe1xuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgY3R4OiBjdHhcbiAgICB9KTtcbiAgfTtcblxuICBNZXRyaWthLnByb3RvdHlwZS5ub3RCb3VuY2UgPSBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnM7XG5cbiAgaWYgKHdpbmRvdy5ZYSkge1xuICAgIHdpbmRvdy5ZYS5NZXRyaWthID0gTWV0cmlrYTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuWWEgPSB7XG4gICAgICBNZXRyaWthOiBNZXRyaWthXG4gICAgfTtcbiAgfVxuXG4gIGlmICh3aW5kb3dbY2JOYW1lXSAmJiBBcnJheS5pc0FycmF5KHdpbmRvd1tjYk5hbWVdKSkge1xuICAgIHdpbmRvd1tjYk5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmdW5jKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBoaXQoc291cmNlKTtcbn1cbm1ldHJpa2FZYW5kZXhXYXRjaC5uYW1lcyA9IFsnbWV0cmlrYS15YW5kZXgtd2F0Y2gnXTtcbm1ldHJpa2FZYW5kZXhXYXRjaC5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmNdO1xuXG4vKipcbiAqIEByZWRpcmVjdCBhbWF6b24tYXBzdGFnXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBBbWF6b24ncyBhcHN0YWcuanNcbiAqXG4gKiBSZWxhdGVkIFVCTyByZWRpcmVjdCByZXNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9ibG9iL2Y4NDJhYjZkM2MxY2YwMzk0Zjk1ZDI3MDkyYmY1OTYyNzI2MmRhNDAvc3JjL3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy9hbWF6b25fYXBzdGFnLmpzXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogfHxhbWF6b24tYWRzeXN0ZW0uY29tL2FheDIvYXBzdGFnLmpzJHNjcmlwdCxyZWRpcmVjdD1hbWF6b24tYXBzdGFnXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBBbWF6b25BcHN0YWcoc291cmNlKSB7XG4gIHZhciBhcHN0YWdXcmFwcGVyID0ge1xuICAgIGZldGNoQmlkczogZnVuY3Rpb24gZmV0Y2hCaWRzKGEsIGIpIHtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBiKFtdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXQ6IG5vb3BGdW5jLFxuICAgIHNldERpc3BsYXlCaWRzOiBub29wRnVuYyxcbiAgICB0YXJnZXRpbmdLZXlzOiBub29wRnVuY1xuICB9O1xuICB3aW5kb3cuYXBzdGFnID0gYXBzdGFnV3JhcHBlcjtcbiAgaGl0KHNvdXJjZSk7XG59XG5BbWF6b25BcHN0YWcubmFtZXMgPSBbJ2FtYXpvbi1hcHN0YWcnLCAndWJvLWFtYXpvbl9hcHN0YWcuanMnLCAnYW1hem9uX2Fwc3RhZy5qcyddO1xuQW1hem9uQXBzdGFnLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuY107XG5cbnZhciByZWRpcmVjdHNMaXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBub2V2YWw6IG5vZXZhbCxcbiAgICBHb29nbGVBbmFseXRpY3M6IEdvb2dsZUFuYWx5dGljcyxcbiAgICBHb29nbGVBbmFseXRpY3NHYTogR29vZ2xlQW5hbHl0aWNzR2EsXG4gICAgR29vZ2xlU3luZGljYXRpb25BZHNCeUdvb2dsZTogR29vZ2xlU3luZGljYXRpb25BZHNCeUdvb2dsZSxcbiAgICBHb29nbGVUYWdTZXJ2aWNlc0dwdDogR29vZ2xlVGFnU2VydmljZXNHcHQsXG4gICAgU2NvcmVDYXJkUmVzZWFyY2hCZWFjb246IFNjb3JlQ2FyZFJlc2VhcmNoQmVhY29uLFxuICAgIG1ldHJpa2FZYW5kZXhUYWc6IG1ldHJpa2FZYW5kZXhUYWcsXG4gICAgbWV0cmlrYVlhbmRleFdhdGNoOiBtZXRyaWthWWFuZGV4V2F0Y2gsXG4gICAgcHJldmVudEZhYjogcHJldmVudEZhYixcbiAgICBwcmV2ZW50QmFiOiBwcmV2ZW50QmFiLFxuICAgIHNldFBvcGFkc0R1bW15OiBzZXRQb3BhZHNEdW1teSxcbiAgICBwcmV2ZW50UG9wYWRzTmV0OiBwcmV2ZW50UG9wYWRzTmV0LFxuICAgIEFtYXpvbkFwc3RhZzogQW1hem9uQXBzdGFnXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gX2NsYXNzQ2FsbENoZWNrO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBjcmVhdGVDbGFzcyA9IF9jcmVhdGVDbGFzcztcblxuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJyB8fCBzdWJqZWN0ID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSQxKHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkgcmV0dXJuIHNlcXVlbmNlO2Vsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcbiAgcmV0dXJuIFtzZXF1ZW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBjb3VudCkge1xuICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIG51bWJlciA9PT0gMCAmJiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXI7XG59XG5cbnZhciBpc05vdGhpbmdfMSA9IGlzTm90aGluZztcbnZhciBpc09iamVjdF8xID0gaXNPYmplY3Q7XG52YXIgdG9BcnJheV8xID0gdG9BcnJheSQxO1xudmFyIHJlcGVhdF8xID0gcmVwZWF0O1xudmFyIGlzTmVnYXRpdmVaZXJvXzEgPSBpc05lZ2F0aXZlWmVybztcbnZhciBleHRlbmRfMSA9IGV4dGVuZDtcbnZhciBjb21tb24gPSB7XG4gIGlzTm90aGluZzogaXNOb3RoaW5nXzEsXG4gIGlzT2JqZWN0OiBpc09iamVjdF8xLFxuICB0b0FycmF5OiB0b0FycmF5XzEsXG4gIHJlcGVhdDogcmVwZWF0XzEsXG4gIGlzTmVnYXRpdmVaZXJvOiBpc05lZ2F0aXZlWmVyb18xLFxuICBleHRlbmQ6IGV4dGVuZF8xXG59O1xuXG4vLyBZQU1MIGVycm9yIGNsYXNzLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTg5ODRcblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgdGhpcy5uYW1lID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gKHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJykgKyAodGhpcy5tYXJrID8gJyAnICsgdGhpcy5tYXJrLnRvU3RyaW5nKCkgOiAnJyk7IC8vIEluY2x1ZGUgc3RhY2sgdHJhY2UgaW4gZXJyb3Igb2JqZWN0XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2sgfHwgJyc7XG4gIH1cbn0gLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb247XG5cbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5uYW1lICsgJzogJztcbiAgcmVzdWx0ICs9IHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBleGNlcHRpb24gPSBZQU1MRXhjZXB0aW9uO1xuXG5mdW5jdGlvbiBNYXJrKG5hbWUsIGJ1ZmZlciwgcG9zaXRpb24sIGxpbmUsIGNvbHVtbikge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB0aGlzLmxpbmUgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbn1cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG4gIGlmICghdGhpcy5idWZmZXIpIHJldHVybiBudWxsO1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgNDtcbiAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDc1O1xuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmIFwiXFwwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOVwiLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KHN0YXJ0IC0gMSkpID09PSAtMSkge1xuICAgIHN0YXJ0IC09IDE7XG5cbiAgICBpZiAodGhpcy5wb3NpdGlvbiAtIHN0YXJ0ID4gbWF4TGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIFwiXFwwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOVwiLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGVuZCkpID09PSAtMSkge1xuICAgIGVuZCArPSAxO1xuXG4gICAgaWYgKGVuZCAtIHRoaXMucG9zaXRpb24gPiBtYXhMZW5ndGggLyAyIC0gMSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcbiAgcmV0dXJuIGNvbW1vbi5yZXBlYXQoJyAnLCBpbmRlbnQpICsgaGVhZCArIHNuaXBwZXQgKyB0YWlsICsgJ1xcbicgKyBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuTWFyay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciBzbmlwcGV0LFxuICAgICAgd2hlcmUgPSAnJztcblxuICBpZiAodGhpcy5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIHRoaXMubmFtZSArICdcIiAnO1xuICB9XG5cbiAgd2hlcmUgKz0gJ2F0IGxpbmUgJyArICh0aGlzLmxpbmUgKyAxKSArICcsIGNvbHVtbiAnICsgKHRoaXMuY29sdW1uICsgMSk7XG5cbiAgaWYgKCFjb21wYWN0KSB7XG4gICAgc25pcHBldCA9IHRoaXMuZ2V0U25pcHBldCgpO1xuXG4gICAgaWYgKHNuaXBwZXQpIHtcbiAgICAgIHdoZXJlICs9ICc6XFxuJyArIHNuaXBwZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdoZXJlO1xufTtcblxudmFyIG1hcmsgPSBNYXJrO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gWydraW5kJywgJ3Jlc29sdmUnLCAnY29uc3RydWN0JywgJ2luc3RhbmNlT2YnLCAncHJlZGljYXRlJywgJ3JlcHJlc2VudCcsICdkZWZhdWx0U3R5bGUnLCAnc3R5bGVBbGlhc2VzJ107XG52YXIgWUFNTF9OT0RFX0tJTkRTID0gWydzY2FsYXInLCAnc2VxdWVuY2UnLCAnbWFwcGluZyddO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7IC8vIFRPRE86IEFkZCB0YWcgZm9ybWF0IGNoZWNrLlxuXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtpbmQgPSBvcHRpb25zWydraW5kJ10gfHwgbnVsbDtcblxuICB0aGlzLnJlc29sdmUgPSBvcHRpb25zWydyZXNvbHZlJ10gfHwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHRoaXMuY29uc3RydWN0ID0gb3B0aW9uc1snY29uc3RydWN0J10gfHwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICB0aGlzLmluc3RhbmNlT2YgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gfHwgbnVsbDtcbiAgdGhpcy5wcmVkaWNhdGUgPSBvcHRpb25zWydwcmVkaWNhdGUnXSB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudCA9IG9wdGlvbnNbJ3JlcHJlc2VudCddIHx8IG51bGw7XG4gIHRoaXMuZGVmYXVsdFN0eWxlID0gb3B0aW9uc1snZGVmYXVsdFN0eWxlJ10gfHwgbnVsbDtcbiAgdGhpcy5zdHlsZUFsaWFzZXMgPSBjb21waWxlU3R5bGVBbGlhc2VzKG9wdGlvbnNbJ3N0eWxlQWxpYXNlcyddIHx8IG51bGwpO1xuXG4gIGlmIChZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbnZhciB0eXBlID0gVHlwZTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuXG5mdW5jdGlvbiBjb21waWxlTGlzdChzY2hlbWEsIG5hbWUsIHJlc3VsdCkge1xuICB2YXIgZXhjbHVkZSA9IFtdO1xuICBzY2hlbWEuaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmNsdWRlZFNjaGVtYSkge1xuICAgIHJlc3VsdCA9IGNvbXBpbGVMaXN0KGluY2x1ZGVkU2NoZW1hLCBuYW1lLCByZXN1bHQpO1xuICB9KTtcbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJiBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCkge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2goY3VycmVudFR5cGUpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGV4Y2x1ZGUuaW5kZXhPZihpbmRleCkgPT09IC0xO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgpXG4vKiBsaXN0cy4uLiAqL1xue1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHNjYWxhcjoge30sXG4gICAgc2VxdWVuY2U6IHt9LFxuICAgIG1hcHBpbmc6IHt9LFxuICAgIGZhbGxiYWNrOiB7fVxuICB9LFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHRoaXMuaW5jbHVkZSA9IGRlZmluaXRpb24uaW5jbHVkZSB8fCBbXTtcbiAgdGhpcy5pbXBsaWNpdCA9IGRlZmluaXRpb24uaW1wbGljaXQgfHwgW107XG4gIHRoaXMuZXhwbGljaXQgPSBkZWZpbml0aW9uLmV4cGxpY2l0IHx8IFtdO1xuICB0aGlzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZS5sb2FkS2luZCAmJiB0eXBlLmxvYWRLaW5kICE9PSAnc2NhbGFyJykge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVGhlcmUgaXMgYSBub24tc2NhbGFyIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIEltcGxpY2l0IHJlc29sdmluZyBvZiBzdWNoIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2ltcGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnZXhwbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRUeXBlTWFwID0gY29tcGlsZU1hcCh0aGlzLmNvbXBpbGVkSW1wbGljaXQsIHRoaXMuY29tcGlsZWRFeHBsaWNpdCk7XG59XG5cblNjaGVtYS5ERUZBVUxUID0gbnVsbDtcblxuU2NoZW1hLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYSgpIHtcbiAgdmFyIHNjaGVtYXMsIHR5cGVzO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHNjaGVtYXMgPSBTY2hlbWEuREVGQVVMVDtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBzY2hlbWFzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBTY2hlbWEuY3JlYXRlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBzY2hlbWFzID0gY29tbW9uLnRvQXJyYXkoc2NoZW1hcyk7XG4gIHR5cGVzID0gY29tbW9uLnRvQXJyYXkodHlwZXMpO1xuXG4gIGlmICghc2NoZW1hcy5ldmVyeShmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYTtcbiAgfSkpIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSQxKSB7XG4gICAgcmV0dXJuIHR5cGUkMSBpbnN0YW5jZW9mIHR5cGU7XG4gIH0pKSB7XG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgIGluY2x1ZGU6IHNjaGVtYXMsXG4gICAgZXhwbGljaXQ6IHR5cGVzXG4gIH0pO1xufTtcblxudmFyIHNjaGVtYSA9IFNjaGVtYTtcblxudmFyIHN0ciA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogJyc7XG4gIH1cbn0pO1xuXG52YXIgc2VxID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoZGF0YSkge1xuICAgIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdO1xuICB9XG59KTtcblxudmFyIG1hcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoZGF0YSkge1xuICAgIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xuICB9XG59KTtcblxudmFyIGZhaWxzYWZlID0gbmV3IHNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbc3RyLCBzZXEsIG1hcF1cbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcbiAgcmV0dXJuIG1heCA9PT0gMSAmJiBkYXRhID09PSAnficgfHwgbWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJyk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG52YXIgX251bGwgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gY2Fub25pY2FsKCkge1xuICAgICAgcmV0dXJuICd+JztcbiAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gbG93ZXJjYXNlKCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gdXBwZXJjYXNlKCkge1xuICAgICAgcmV0dXJuICdOVUxMJztcbiAgICB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gY2FtZWxjYXNlKCkge1xuICAgICAgcmV0dXJuICdOdWxsJztcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG4gIHJldHVybiBtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSB8fCBtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBCb29sZWFuXSc7XG59XG5cbnZhciBib29sID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIGxvd2VyY2FzZShvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiB1cHBlcmNhc2Uob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJztcbiAgICB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gY2FtZWxjYXNlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxuZnVuY3Rpb24gaXNIZXhDb2RlKGMpIHtcbiAgcmV0dXJuIDB4MzBcbiAgLyogMCAqL1xuICA8PSBjICYmIGMgPD0gMHgzOVxuICAvKiA5ICovXG4gIHx8IDB4NDFcbiAgLyogQSAqL1xuICA8PSBjICYmIGMgPD0gMHg0NlxuICAvKiBGICovXG4gIHx8IDB4NjFcbiAgLyogYSAqL1xuICA8PSBjICYmIGMgPD0gMHg2NlxuICAvKiBmICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuIDB4MzBcbiAgLyogMCAqL1xuICA8PSBjICYmIGMgPD0gMHgzN1xuICAvKiA3ICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuIDB4MzBcbiAgLyogMCAqL1xuICA8PSBjICYmIGMgPD0gMHgzOVxuICAvKiA5ICovXG4gIDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaGFzRGlnaXRzID0gZmFsc2UsXG4gICAgICBjaDtcbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcbiAgY2ggPSBkYXRhW2luZGV4XTsgLy8gc2lnblxuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTsgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfSAvLyBiYXNlIDhcblxuXG4gICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgaWYgKCFpc09jdENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICB9IC8vIGJhc2UgMTAgKGV4Y2VwdCAwKSBvciBiYXNlIDYwXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG5cblxuICBpZiAoY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmIChjaCA9PT0gJzonKSBicmVhaztcblxuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgfSAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG5cblxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7IC8vIGlmICFiYXNlNjAgLSBkb25lO1xuXG4gIGlmIChjaCAhPT0gJzonKSByZXR1cm4gdHJ1ZTsgLy8gYmFzZTYwIGFsbW9zdCBub3QgdXNlZCwgbm8gbmVlZHMgdG8gb3B0aW1pemVcblxuICByZXR1cm4gL14oOlswLTVdP1swLTldKSskLy50ZXN0KGRhdGEuc2xpY2UoaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLFxuICAgICAgc2lnbiA9IDEsXG4gICAgICBjaCxcbiAgICAgIGJhc2UsXG4gICAgICBkaWdpdHMgPSBbXTtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgc2lnbiA9IC0xO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgY2ggPSB2YWx1ZVswXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJzAnKSByZXR1cm4gMDtcblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ2InKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICd4JykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDgpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfSk7XG4gICAgdmFsdWUgPSAwO1xuICAgIGJhc2UgPSAxO1xuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSBkICogYmFzZTtcbiAgICAgIGJhc2UgKj0gNjA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpO1xufVxuXG52YXIgaW50ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogZnVuY3Rpb24gYmluYXJ5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA+PSAwID8gJzBiJyArIG9iai50b1N0cmluZygyKSA6ICctMGInICsgb2JqLnRvU3RyaW5nKDIpLnNsaWNlKDEpO1xuICAgIH0sXG4gICAgb2N0YWw6IGZ1bmN0aW9uIG9jdGFsKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA+PSAwID8gJzAnICsgb2JqLnRvU3RyaW5nKDgpIDogJy0wJyArIG9iai50b1N0cmluZyg4KS5zbGljZSgxKTtcbiAgICB9LFxuICAgIGRlY2ltYWw6IGZ1bmN0aW9uIGRlY2ltYWwob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKDEwKTtcbiAgICB9LFxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiBoZXhhZGVjaW1hbChvYmopIHtcbiAgICAgIHJldHVybiBvYmogPj0gMCA/ICcweCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgOiAnLTB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5zbGljZSgxKTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2RlY2ltYWwnLFxuICBzdHlsZUFsaWFzZXM6IHtcbiAgICBiaW5hcnk6IFsyLCAnYmluJ10sXG4gICAgb2N0YWw6IFs4LCAnb2N0J10sXG4gICAgZGVjaW1hbDogWzEwLCAnZGVjJ10sXG4gICAgaGV4YWRlY2ltYWw6IFsxNiwgJ2hleCddXG4gIH1cbn0pO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cCggLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbideKD86Wy0rXT8oPzowfFsxLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArIC8vIC4yZTQsIC4yXG4vLyBzcGVjaWFsIGNhc2UsIHNlZW1zIG5vdCBmcm9tIHNwZWNcbid8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICsgLy8gMjA6NTlcbid8Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKicgKyAvLyAuaW5mXG4nfFstK10/XFxcXC4oPzppbmZ8SW5mfElORiknICsgLy8gLm5hblxuJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHwgLy8gUXVpY2sgaGFjayB0byBub3QgYWxsb3cgaW50ZWdlcnMgZW5kIHdpdGggYF9gXG4gIC8vIFByb2JhYmx5IHNob3VsZCB1cGRhdGUgcmVnZXhwICYgY2hlY2sgc3BlZWRcbiAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG4gIHZhbHVlID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcbiAgZGlnaXRzID0gW107XG5cbiAgaWYgKCcrLScuaW5kZXhPZih2YWx1ZVswXSkgPj0gMCkge1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcuaW5mJykge1xuICAgIHJldHVybiBzaWduID09PSAxID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzonKSA+PSAwKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUZsb2F0KHYsIDEwKSk7XG4gICAgfSk7XG4gICAgdmFsdWUgPSAwLjA7XG4gICAgYmFzZSA9IDE7XG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcbiAgICByZXR1cm4gc2lnbiAqIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XG59XG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgICAgcmV0dXJuICcubmFuJztcblxuICAgICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgICAgcmV0dXJuICcuTkFOJztcblxuICAgICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgICAgcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgICByZXR1cm4gJy5pbmYnO1xuXG4gICAgICBjYXNlICd1cHBlcmNhc2UnOlxuICAgICAgICByZXR1cm4gJy5JTkYnO1xuXG4gICAgICBjYXNlICdjYW1lbGNhc2UnOlxuICAgICAgICByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICAgIHJldHVybiAnLS5pbmYnO1xuXG4gICAgICBjYXNlICd1cHBlcmNhc2UnOlxuICAgICAgICByZXR1cm4gJy0uSU5GJztcblxuICAgICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgICAgcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7IC8vIEpTIHN0cmluZ2lmaWVyIGNhbiBidWlsZCBzY2llbnRpZmljIGZvcm1hdCB3aXRob3V0IGRvdHM6IDVlLTEwMCxcbiAgLy8gd2hpbGUgWUFNTCByZXF1cmVzIGRvdDogNS5lLTEwMC4gRml4IGl0IHdpdGggc2ltcGxlIGhhY2tcblxuICByZXR1cm4gU0NJRU5USUZJQ19XSVRIT1VUX0RPVC50ZXN0KHJlcykgPyByZXMucmVwbGFjZSgnZScsICcuZScpIDogcmVzO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIChvYmplY3QgJSAxICE9PSAwIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxudmFyIGZsb2F0ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxGbG9hdCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sRmxvYXQsXG4gIHByZWRpY2F0ZTogaXNGbG9hdCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sRmxvYXQsXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG52YXIganNvbiA9IG5ldyBzY2hlbWEoe1xuICBpbmNsdWRlOiBbZmFpbHNhZmVdLFxuICBpbXBsaWNpdDogW19udWxsLCBib29sLCBpbnQsIGZsb2F0XVxufSk7XG5cbnZhciBjb3JlID0gbmV3IHNjaGVtYSh7XG4gIGluY2x1ZGU6IFtqc29uXVxufSk7XG5cbnZhciBZQU1MX0RBVEVfUkVHRVhQID0gbmV3IFJlZ0V4cCgnXihbMC05XVswLTldWzAtOV1bMC05XSknICsgLy8gWzFdIHllYXJcbictKFswLTldWzAtOV0pJyArIC8vIFsyXSBtb250aFxuJy0oWzAtOV1bMC05XSkkJyk7IC8vIFszXSBkYXlcblxudmFyIFlBTUxfVElNRVNUQU1QX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyArIC8vIFsxXSB5ZWFyXG4nLShbMC05XVswLTldPyknICsgLy8gWzJdIG1vbnRoXG4nLShbMC05XVswLTldPyknICsgLy8gWzNdIGRheVxuJyg/OltUdF18WyBcXFxcdF0rKScgKyAvLyAuLi5cbicoWzAtOV1bMC05XT8pJyArIC8vIFs0XSBob3VyXG4nOihbMC05XVswLTldKScgKyAvLyBbNV0gbWludXRlXG4nOihbMC05XVswLTldKScgKyAvLyBbNl0gc2Vjb25kXG4nKD86XFxcXC4oWzAtOV0qKSk/JyArIC8vIFs3XSBmcmFjdGlvblxuJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuJyg/OjooWzAtOV1bMC05XSkpPykpPyQnKTsgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLFxuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5LFxuICAgICAgaG91cixcbiAgICAgIG1pbnV0ZSxcbiAgICAgIHNlY29uZCxcbiAgICAgIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCxcbiAgICAgIHR6X2hvdXIsXG4gICAgICB0el9taW51dGUsXG4gICAgICBkYXRlO1xuICBtYXRjaCA9IFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7IC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArbWF0Y2hbMV07XG4gIG1vbnRoID0gK21hdGNoWzJdIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuXG4gIGRheSA9ICttYXRjaFszXTtcblxuICBpZiAoIW1hdGNoWzRdKSB7XG4gICAgLy8gbm8gaG91clxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gIH0gLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuXG4gIGhvdXIgPSArbWF0Y2hbNF07XG4gIG1pbnV0ZSA9ICttYXRjaFs1XTtcbiAgc2Vjb25kID0gK21hdGNoWzZdO1xuXG4gIGlmIChtYXRjaFs3XSkge1xuICAgIGZyYWN0aW9uID0gbWF0Y2hbN10uc2xpY2UoMCwgMyk7XG5cbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykge1xuICAgICAgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgIH1cblxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9IC8vIG1hdGNoOiBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyIFsxMV0gdHpfbWludXRlXG5cblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gK21hdGNoWzEwXTtcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcbiAgICBkZWx0YSA9ICh0el9ob3VyICogNjAgKyB0el9taW51dGUpICogNjAwMDA7IC8vIGRlbHRhIGluIG1pbGktc2Vjb25kc1xuXG4gICAgaWYgKG1hdGNoWzldID09PSAnLScpIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuICBpZiAoZGVsdGEpIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0XG4vKiwgc3R5bGUqL1xuKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxudmFyIHRpbWVzdGFtcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFRpbWVzdGFtcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wLFxuICBpbnN0YW5jZU9mOiBEYXRlLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE1lcmdlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICc8PCcgfHwgZGF0YSA9PT0gbnVsbDtcbn1cblxudmFyIG1lcmdlID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG5cbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAodGFyZ2V0KSB7XG5cdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGR5bmFtaWNhbGx5IHJlcXVpcmUgXCInICsgdGFyZ2V0ICsgJ1wiLiBQbGVhc2UgY29uZmlndXJlIHRoZSBkeW5hbWljUmVxdWlyZVRhcmdldHMgb3B0aW9uIG9mIEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzIGFwcHJvcHJpYXRlbHkgZm9yIHRoaXMgcmVxdWlyZSBjYWxsIHRvIGJlaGF2ZSBwcm9wZXJseS4nKTtcbn1cblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuXG52YXIgTm9kZUJ1ZmZlcjtcblxudHJ5IHtcbiAgLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24sIHRvIG5vdCBpbmNsdWRlIGBCdWZmZXJgIHNoaW1cbiAgdmFyIF9yZXF1aXJlID0gY29tbW9uanNSZXF1aXJlO1xuICBOb2RlQnVmZmVyID0gX3JlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbn0gY2F0Y2ggKF9fKSB7fSAvLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG5cblxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjb2RlLFxuICAgICAgaWR4LFxuICAgICAgYml0bGVuID0gMCxcbiAgICAgIG1heCA9IGRhdGEubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUDsgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTsgLy8gU2tpcCBDUi9MRlxuXG4gICAgaWYgKGNvZGUgPiA2NCkgY29udGludWU7IC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG5cbiAgICBpZiAoY29kZSA8IDApIHJldHVybiBmYWxzZTtcbiAgICBiaXRsZW4gKz0gNjtcbiAgfSAvLyBJZiB0aGVyZSBhcmUgYW55IGJpdHMgbGVmdCwgc291cmNlIHdhcyBjb3JydXB0ZWRcblxuXG4gIHJldHVybiBiaXRsZW4gJSA4ID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCxcbiAgICAgIHRhaWxiaXRzLFxuICAgICAgaW5wdXQgPSBkYXRhLnJlcGxhY2UoL1tcXHJcXG49XS9nLCAnJyksXG4gICAgICAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgbWF4ID0gaW5wdXQubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUCxcbiAgICAgIGJpdHMgPSAwLFxuICAgICAgcmVzdWx0ID0gW107IC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKGlkeCAlIDQgPT09IDAgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaChiaXRzID4+IDE2ICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzID4+IDggJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gYml0cyA8PCA2IHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9IC8vIER1bXAgdGFpbFxuXG5cbiAgdGFpbGJpdHMgPSBtYXggJSA0ICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICByZXN1bHQucHVzaChiaXRzID4+IDE2ICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyA+PiA4ICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgPj4gMTAgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzID4+IDIgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaChiaXRzID4+IDQgJiAweEZGKTtcbiAgfSAvLyBXcmFwIGludG8gQnVmZmVyIGZvciBOb2RlSlMgYW5kIGxlYXZlIEFycmF5IGZvciBicm93c2VyXG5cblxuICBpZiAoTm9kZUJ1ZmZlcikge1xuICAgIC8vIFN1cHBvcnQgbm9kZSA2LisgQnVmZmVyIEFQSSB3aGVuIGF2YWlsYWJsZVxuICAgIHJldHVybiBOb2RlQnVmZmVyLmZyb20gPyBOb2RlQnVmZmVyLmZyb20ocmVzdWx0KSA6IG5ldyBOb2RlQnVmZmVyKHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sQmluYXJ5KG9iamVjdFxuLyosIHN0eWxlKi9cbikge1xuICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIGlkeCxcbiAgICAgIHRhaWwsXG4gICAgICBtYXggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUDsgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKGlkeCAlIDMgPT09IDAgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTggJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyA+PiAxMiAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzID4+IDYgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9IC8vIER1bXAgdGFpbFxuXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTggJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTIgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gNiAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTAgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gNCAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyA8PCAyICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyA+PiAyICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzIDw8IDQgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iamVjdCkge1xuICByZXR1cm4gTm9kZUJ1ZmZlciAmJiBOb2RlQnVmZmVyLmlzQnVmZmVyKG9iamVjdCk7XG59XG5cbnZhciBiaW5hcnkgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCaW5hcnksXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJpbmFyeSxcbiAgcHJlZGljYXRlOiBpc0JpbmFyeSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sQmluYXJ5XG59KTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICB2YXIgb2JqZWN0S2V5cyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBwYWlyLFxuICAgICAgcGFpcktleSxcbiAgICAgIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhaXIsIHBhaXJLZXkpKSB7XG4gICAgICAgIGlmICghcGFpckhhc0tleSkgcGFpckhhc0tleSA9IHRydWU7ZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG9iamVjdEtleXMuaW5kZXhPZihwYWlyS2V5KSA9PT0gLTEpIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdO1xufVxuXG52YXIgb21hcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuXG52YXIgX3RvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICB2YXIgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBwYWlyLFxuICAgICAga2V5cyxcbiAgICAgIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBpZiAoX3RvU3RyaW5nJDEuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgcmVzdWx0W2luZGV4XSA9IFtrZXlzWzBdLCBwYWlyW2tleXNbMF1dXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuICB2YXIgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBwYWlyLFxuICAgICAga2V5cyxcbiAgICAgIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG4gICAgcmVzdWx0W2luZGV4XSA9IFtrZXlzWzBdLCBwYWlyW2tleXNbMF1dXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBwYWlycyA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuXG52YXIgX2hhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIGtleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xufVxuXG52YXIgc2V0ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcblxudmFyIGRlZmF1bHRfc2FmZSA9IG5ldyBzY2hlbWEoe1xuICBpbmNsdWRlOiBbY29yZV0sXG4gIGltcGxpY2l0OiBbdGltZXN0YW1wLCBtZXJnZV0sXG4gIGV4cGxpY2l0OiBbYmluYXJ5LCBvbWFwLCBwYWlycywgc2V0XVxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbnZhciBfdW5kZWZpbmVkID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3VuZGVmaW5lZCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQsXG4gIHByZWRpY2F0ZTogaXNVbmRlZmluZWQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZFxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJzsgLy8gaWYgcmVnZXhwIHN0YXJ0cyB3aXRoICcvJyBpdCBjYW4gaGF2ZSBtb2RpZmllcnMgYW5kIG11c3QgYmUgcHJvcGVybHkgY2xvc2VkXG4gIC8vIGAvZm9vL2dpbWAgLSBtb2RpZmllcnMgdGFpbCBjYW4gYmUgbWF4aW11bSAzIGNoYXJzXG5cbiAgaWYgKHJlZ2V4cFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHRhaWwpIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAzKSByZXR1cm4gZmFsc2U7IC8vIGlmIGV4cHJlc3Npb24gc3RhcnRzIHdpdGggLywgaXMgc2hvdWxkIGJlIHByb3Blcmx5IHRlcm1pbmF0ZWRcblxuICAgIGlmIChyZWdleHBbcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxXSAhPT0gJy8nKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJzsgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xuXG4gIGlmIChyZWdleHBbMF0gPT09ICcvJykge1xuICAgIGlmICh0YWlsKSBtb2RpZmllcnMgPSB0YWlsWzFdO1xuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwKG9iamVjdFxuLyosIHN0eWxlKi9cbikge1xuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcbiAgaWYgKG9iamVjdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmIChvYmplY3QubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG52YXIgcmVnZXhwID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG5cbnZhciBlc3ByaW1hOyAvLyBCcm93c2VyaWZpZWQgdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGVzcHJpbWFcbi8vXG4vLyAxLiBGb3Igbm9kZS5qcyBqdXN0IHJlcXVpcmUgbW9kdWxlIGFzIGRlcHNcbi8vIDIuIEZvciBicm93c2VyIHRyeSB0byByZXF1aXJlIG11ZHVsZSB2aWEgZXh0ZXJuYWwgQU1EIHN5c3RlbS5cbi8vICAgIElmIG5vdCBmb3VuZCAtIHRyeSB0byBmYWxsYmFjayB0byB3aW5kb3cuZXNwcmltYS4gSWYgbm90XG4vLyAgICBmb3VuZCB0b28gLSB0aGVuIGZhaWwgdG8gcGFyc2UuXG4vL1xuXG50cnkge1xuICAvLyB3b3JrYXJvdW5kIHRvIGV4Y2x1ZGUgcGFja2FnZSBmcm9tIGJyb3dzZXJpZnkgbGlzdC5cbiAgdmFyIF9yZXF1aXJlJDEgPSBjb21tb25qc1JlcXVpcmU7XG4gIGVzcHJpbWEgPSBfcmVxdWlyZSQxKCdlc3ByaW1hJyk7XG59IGNhdGNoIChfKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG4gIC8qIGdsb2JhbCB3aW5kb3cgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBlc3ByaW1hID0gd2luZG93LmVzcHJpbWE7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICAgIGFzdCA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7XG4gICAgICByYW5nZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGFzdC50eXBlICE9PSAnUHJvZ3JhbScgfHwgYXN0LmJvZHkubGVuZ3RoICE9PSAxIHx8IGFzdC5ib2R5WzBdLnR5cGUgIT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyB8fCBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicgJiYgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cbiAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICBhc3QgPSBlc3ByaW1hLnBhcnNlKHNvdXJjZSwge1xuICAgIHJhbmdlOiB0cnVlXG4gIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmIChhc3QudHlwZSAhPT0gJ1Byb2dyYW0nIHx8IGFzdC5ib2R5Lmxlbmd0aCAhPT0gMSB8fCBhc3QuYm9keVswXS50eXBlICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHwgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nICYmIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBhc3QuYm9keVswXS5leHByZXNzaW9uLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHBhcmFtcy5wdXNoKHBhcmFtLm5hbWUpO1xuICB9KTtcbiAgYm9keSA9IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS5yYW5nZTsgLy8gRXNwcmltYSdzIHJhbmdlcyBpbmNsdWRlIHRoZSBmaXJzdCAneycgYW5kIHRoZSBsYXN0ICd9JyBjaGFyYWN0ZXJzIG9uXG4gIC8vIGZ1bmN0aW9uIGV4cHJlc3Npb25zLiBTbyBjdXQgdGhlbSBvdXQuXG5cbiAgaWYgKGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihwYXJhbXMsIHNvdXJjZS5zbGljZShib2R5WzBdICsgMSwgYm9keVsxXSAtIDEpKTtcbiAgfSAvLyBFUzYgYXJyb3cgZnVuY3Rpb25zIGNhbiBvbWl0IHRoZSBCbG9ja1N0YXRlbWVudC4gSW4gdGhhdCBjYXNlLCBqdXN0IHJldHVyblxuICAvLyB0aGUgYm9keS5cblxuICAvKmVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jKi9cblxuXG4gIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCAncmV0dXJuICcgKyBzb3VyY2Uuc2xpY2UoYm9keVswXSwgYm9keVsxXSkpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24ob2JqZWN0XG4vKiwgc3R5bGUqL1xuKSB7XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG52YXIgX2Z1bmN0aW9uID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIHByZWRpY2F0ZTogaXNGdW5jdGlvbixcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb25cbn0pO1xuXG52YXIgZGVmYXVsdF9mdWxsID0gc2NoZW1hLkRFRkFVTFQgPSBuZXcgc2NoZW1hKHtcbiAgaW5jbHVkZTogW2RlZmF1bHRfc2FmZV0sXG4gIGV4cGxpY2l0OiBbX3VuZGVmaW5lZCwgcmVnZXhwLCBfZnVuY3Rpb25dXG59KTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxuXG52YXIgX2hhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIENPTlRFWFRfRkxPV19JTiA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiA9IDM7XG52YXIgQ09OVEVYVF9CTE9DS19PVVQgPSA0O1xudmFyIENIT01QSU5HX0NMSVAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQID0gMztcbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgPSAvW1xceDAwLVxceDA4XFx4MEJcXHgwQ1xceDBFLVxceDFGXFx4N0YtXFx4ODRcXHg4Ni1cXHg5RlxcdUZGRkVcXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS87XG52YXIgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MgPSAvW1xceDg1XFx1MjAyOFxcdTIwMjldLztcbnZhciBQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyA9IC9bLFxcW1xcXVxce1xcfV0vO1xudmFyIFBBVFRFUk5fVEFHX0hBTkRMRSA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuZnVuY3Rpb24gX2NsYXNzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiBjID09PSAweDBBXG4gIC8qIExGICovXG4gIHx8IGMgPT09IDB4MERcbiAgLyogQ1IgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBpc19XSElURV9TUEFDRShjKSB7XG4gIHJldHVybiBjID09PSAweDA5XG4gIC8qIFRhYiAqL1xuICB8fCBjID09PSAweDIwXG4gIC8qIFNwYWNlICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIGMgPT09IDB4MDlcbiAgLyogVGFiICovXG4gIHx8IGMgPT09IDB4MjBcbiAgLyogU3BhY2UgKi9cbiAgfHwgYyA9PT0gMHgwQVxuICAvKiBMRiAqL1xuICB8fCBjID09PSAweDBEXG4gIC8qIENSICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQ1xuICAvKiAsICovXG4gIHx8IGMgPT09IDB4NUJcbiAgLyogWyAqL1xuICB8fCBjID09PSAweDVEXG4gIC8qIF0gKi9cbiAgfHwgYyA9PT0gMHg3QlxuICAvKiB7ICovXG4gIHx8IGMgPT09IDB4N0RcbiAgLyogfSAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgweDMwXG4gIC8qIDAgKi9cbiAgPD0gYyAmJiBjIDw9IDB4MzlcbiAgLyogOSAqL1xuICApIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKDB4NjFcbiAgLyogYSAqL1xuICA8PSBsYyAmJiBsYyA8PSAweDY2XG4gIC8qIGYgKi9cbiAgKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzhcbiAgLyogeCAqL1xuICApIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cblxuICBpZiAoYyA9PT0gMHg3NVxuICAvKiB1ICovXG4gICkge1xuICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuXG4gIGlmIChjID09PSAweDU1XG4gIC8qIFUgKi9cbiAgKSB7XG4gICAgICByZXR1cm4gODtcbiAgICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgweDMwXG4gIC8qIDAgKi9cbiAgPD0gYyAmJiBjIDw9IDB4MzlcbiAgLyogOSAqL1xuICApIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVzY2FwZVNlcXVlbmNlKGMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4gIHJldHVybiBjID09PSAweDMwXG4gIC8qIDAgKi9cbiAgPyAnXFx4MDAnIDogYyA9PT0gMHg2MVxuICAvKiBhICovXG4gID8gJ1xceDA3JyA6IGMgPT09IDB4NjJcbiAgLyogYiAqL1xuICA/ICdcXHgwOCcgOiBjID09PSAweDc0XG4gIC8qIHQgKi9cbiAgPyAnXFx4MDknIDogYyA9PT0gMHgwOVxuICAvKiBUYWIgKi9cbiAgPyAnXFx4MDknIDogYyA9PT0gMHg2RVxuICAvKiBuICovXG4gID8gJ1xceDBBJyA6IGMgPT09IDB4NzZcbiAgLyogdiAqL1xuICA/ICdcXHgwQicgOiBjID09PSAweDY2XG4gIC8qIGYgKi9cbiAgPyAnXFx4MEMnIDogYyA9PT0gMHg3MlxuICAvKiByICovXG4gID8gJ1xceDBEJyA6IGMgPT09IDB4NjVcbiAgLyogZSAqL1xuICA/ICdcXHgxQicgOiBjID09PSAweDIwXG4gIC8qIFNwYWNlICovXG4gID8gJyAnIDogYyA9PT0gMHgyMlxuICAvKiBcIiAqL1xuICA/ICdcXHgyMicgOiBjID09PSAweDJGXG4gIC8qIC8gKi9cbiAgPyAnLycgOiBjID09PSAweDVDXG4gIC8qIFxcICovXG4gID8gJ1xceDVDJyA6IGMgPT09IDB4NEVcbiAgLyogTiAqL1xuICA/ICdcXHg4NScgOiBjID09PSAweDVGXG4gIC8qIF8gKi9cbiAgPyAnXFx4QTAnIDogYyA9PT0gMHg0Q1xuICAvKiBMICovXG4gID8gXCJcXHUyMDI4XCIgOiBjID09PSAweDUwXG4gIC8qIFAgKi9cbiAgPyBcIlxcdTIwMjlcIiA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9IC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuXG5cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgLSAweDAxMDAwMCA+PiAxMCkgKyAweEQ4MDAsIChjIC0gMHgwMTAwMDAgJiAweDAzRkYpICsgMHhEQzAwKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xuXG52YXIgc2ltcGxlRXNjYXBlTWFwID0gbmV3IEFycmF5KDI1Nik7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuZnVuY3Rpb24gU3RhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB0aGlzLmZpbGVuYW1lID0gb3B0aW9uc1snZmlsZW5hbWUnXSB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IGRlZmF1bHRfZnVsbDtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICB0aGlzLmxlZ2FjeSA9IG9wdGlvbnNbJ2xlZ2FjeSddIHx8IGZhbHNlO1xuICB0aGlzLmpzb24gPSBvcHRpb25zWydqc29uJ10gfHwgZmFsc2U7XG4gIHRoaXMubGlzdGVuZXIgPSBvcHRpb25zWydsaXN0ZW5lciddIHx8IG51bGw7XG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMudHlwZU1hcCA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkVHlwZU1hcDtcbiAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIHRoaXMucG9zaXRpb24gPSAwO1xuICB0aGlzLmxpbmUgPSAwO1xuICB0aGlzLmxpbmVTdGFydCA9IDA7XG4gIHRoaXMubGluZUluZGVudCA9IDA7XG4gIHRoaXMuZG9jdW1lbnRzID0gW107XG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBleGNlcHRpb24obWVzc2FnZSwgbmV3IG1hcmsoc3RhdGUuZmlsZW5hbWUsIHN0YXRlLmlucHV0LCBzdGF0ZS5wb3NpdGlvbiwgc3RhdGUubGluZSwgc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge1xuICBZQU1MOiBmdW5jdGlvbiBoYW5kbGVZYW1sRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IG1pbm9yIDwgMjtcblxuICAgIGlmIChtaW5vciAhPT0gMSAmJiBtaW5vciAhPT0gMikge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cbiAgfSxcbiAgVEFHOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5JDIuY2FsbChzdGF0ZS50YWdNYXAsIGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGVyZSBpcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgc3VmZml4IGZvciBcIicgKyBoYW5kbGUgKyAnXCIgdGFnIGhhbmRsZScpO1xuICAgIH1cblxuICAgIGlmICghUEFUVEVSTl9UQUdfVVJJLnRlc3QocHJlZml4KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnRhZ01hcFtoYW5kbGVdID0gcHJlZml4O1xuICB9XG59O1xuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7IF9wb3NpdGlvbiA8IF9sZW5ndGg7IF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgICAgICBpZiAoIShfY2hhcmFjdGVyID09PSAweDA5IHx8IDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChfcmVzdWx0KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgc3RhdGUucmVzdWx0ICs9IF9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgZGVzdGluYXRpb24sIHNvdXJjZSwgb3ZlcnJpZGFibGVLZXlzKSB7XG4gIHZhciBzb3VyY2VLZXlzLCBrZXksIGluZGV4LCBxdWFudGl0eTtcblxuICBpZiAoIWNvbW1vbi5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlJyk7XG4gIH1cblxuICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuXG4gICAgaWYgKCFfaGFzT3duUHJvcGVydHkkMi5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgICBvdmVycmlkYWJsZUtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIHN0YXJ0TGluZSwgc3RhcnRQb3MpIHtcbiAgdmFyIGluZGV4LCBxdWFudGl0eTsgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGUpKSB7XG4gICAga2V5Tm9kZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGtleU5vZGUpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0ga2V5Tm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGVbaW5kZXhdKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmVzdGVkIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUga2V5cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlW2luZGV4XSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIGtleU5vZGVbaW5kZXhdID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG5cblxuICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBrZXlOb2RlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICBrZXlOb2RlID0gU3RyaW5nKGtleU5vZGUpO1xuXG4gIGlmIChfcmVzdWx0ID09PSBudWxsKSB7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9XG5cbiAgaWYgKGtleVRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlTm9kZSkpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHZhbHVlTm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlW2luZGV4XSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlLCBvdmVycmlkYWJsZUtleXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIXN0YXRlLmpzb24gJiYgIV9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwob3ZlcnJpZGFibGVLZXlzLCBrZXlOb2RlKSAmJiBfaGFzT3duUHJvcGVydHkkMi5jYWxsKF9yZXN1bHQsIGtleU5vZGUpKSB7XG4gICAgICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lIHx8IHN0YXRlLmxpbmU7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXJ0UG9zIHx8IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0ZWQgbWFwcGluZyBrZXknKTtcbiAgICB9XG5cbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICAgIGRlbGV0ZSBvdmVycmlkYWJsZUtleXNba2V5Tm9kZV07XG4gIH1cblxuICByZXR1cm4gX3Jlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZExpbmVCcmVhayhzdGF0ZSkge1xuICB2YXIgY2g7XG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDBBXG4gIC8qIExGICovXG4gICkge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDBEXG4gIC8qIENSICovXG4gICkge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDBBXG4gICAgICAvKiBMRiAqL1xuICAgICAgKSB7XG4gICAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjNcbiAgICAvKiAjICovXG4gICAgKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBXG4gICAgICAgIC8qIExGICovXG4gICAgICAgICYmIGNoICE9PSAweDBEXG4gICAgICAgIC8qIENSICovXG4gICAgICAgICYmIGNoICE9PSAwKTtcbiAgICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKGNoID09PSAweDIwXG4gICAgICAvKiBTcGFjZSAqL1xuICAgICAgKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTsgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG5cbiAgaWYgKChjaCA9PT0gMHgyRFxuICAvKiAtICovXG4gIHx8IGNoID09PSAweDJFXG4gIC8qIC4gKi9cbiAgKSAmJiBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJiBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAyKSkge1xuICAgIF9wb3NpdGlvbiArPSAzO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAwIHx8IGlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgY291bnQpIHtcbiAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgfSBlbHNlIGlmIChjb3VudCA+IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgY291bnQgLSAxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpIHx8IGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSB8fCBjaCA9PT0gMHgyM1xuICAvKiAjICovXG4gIHx8IGNoID09PSAweDI2XG4gIC8qICYgKi9cbiAgfHwgY2ggPT09IDB4MkFcbiAgLyogKiAqL1xuICB8fCBjaCA9PT0gMHgyMVxuICAvKiAhICovXG4gIHx8IGNoID09PSAweDdDXG4gIC8qIHwgKi9cbiAgfHwgY2ggPT09IDB4M0VcbiAgLyogPiAqL1xuICB8fCBjaCA9PT0gMHgyN1xuICAvKiAnICovXG4gIHx8IGNoID09PSAweDIyXG4gIC8qIFwiICovXG4gIHx8IGNoID09PSAweDI1XG4gIC8qICUgKi9cbiAgfHwgY2ggPT09IDB4NDBcbiAgLyogQCAqL1xuICB8fCBjaCA9PT0gMHg2MFxuICAvKiBgICovXG4gICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICBpZiAoY2ggPT09IDB4M0ZcbiAgLyogPyAqL1xuICB8fCBjaCA9PT0gMHgyRFxuICAvKiAtICovXG4gICkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHwgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4M0FcbiAgICAvKiA6ICovXG4gICAgKSB7XG4gICAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHwgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAweDIzXG4gICAgLyogIyAqL1xuICAgICkge1xuICAgICAgICBwcmVjZWRpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uIC0gMSk7XG5cbiAgICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHx8IHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2xpbmVJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIC0xKTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPj0gbm9kZUluZGVudCkge1xuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBjYXB0dXJlRW5kO1xuICAgICAgICBzdGF0ZS5saW5lID0gX2xpbmU7XG4gICAgICAgIHN0YXRlLmxpbmVTdGFydCA9IF9saW5lU3RhcnQ7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSBfbGluZUluZGVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdDb250ZW50KSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBzdGF0ZS5saW5lIC0gX2xpbmUpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG5cbiAgaWYgKHN0YXRlLnJlc3VsdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9IF9raW5kO1xuICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNoLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQ7XG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI3XG4gIC8qICcgKi9cbiAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDI3XG4gICAgLyogJyAqL1xuICAgICkge1xuICAgICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4MjdcbiAgICAgICAgLyogJyAqL1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgaGV4TGVuZ3RoLCBoZXhSZXN1bHQsIHRtcCwgY2g7XG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIyXG4gIC8qIFwiICovXG4gICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyMlxuICAgIC8qIFwiICovXG4gICAgKSB7XG4gICAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDXG4gICAgLyogXFwgKi9cbiAgICApIHtcbiAgICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7IC8vIFRPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9IHNpbXBsZUVzY2FwZU1hcFtjaF07XG4gICAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgICBoZXhSZXN1bHQgPSAwO1xuXG4gICAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmICgodG1wID0gZnJvbUhleENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biBlc2NhcGUgc2VxdWVuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciByZWFkTmV4dCA9IHRydWUsXG4gICAgICBfbGluZSxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCXG4gIC8qIFsgKi9cbiAgKSB7XG4gICAgICB0ZXJtaW5hdG9yID0gMHg1RDtcbiAgICAgIC8qIF0gKi9cblxuICAgICAgaXNNYXBwaW5nID0gZmFsc2U7XG4gICAgICBfcmVzdWx0ID0gW107XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg3QlxuICAvKiB7ICovXG4gICkge1xuICAgICAgdGVybWluYXRvciA9IDB4N0Q7XG4gICAgICAvKiB9ICovXG5cbiAgICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgICBfcmVzdWx0ID0ge307XG4gICAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGXG4gICAgLyogPyAqL1xuICAgICkge1xuICAgICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIGNoID09PSAweDNBXG4gICAgLyogOiAqL1xuICAgICkge1xuICAgICAgICBpc1BhaXIgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0LnB1c2goa2V5Tm9kZSk7XG4gICAgfVxuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQ1xuICAgIC8qICwgKi9cbiAgICApIHtcbiAgICAgICAgcmVhZE5leHQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCxcbiAgICAgIGVtcHR5TGluZXMgPSAwLFxuICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZSxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg3Q1xuICAvKiB8ICovXG4gICkge1xuICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4M0VcbiAgLyogPiAqL1xuICApIHtcbiAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkJcbiAgICAvKiArICovXG4gICAgfHwgY2ggPT09IDB4MkRcbiAgICAvKiAtICovXG4gICAgKSB7XG4gICAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICAgIGNob21waW5nID0gY2ggPT09IDB4MkJcbiAgICAgICAgICAvKiArICovXG4gICAgICAgICAgPyBDSE9NUElOR19LRUVQIDogQ0hPTVBJTkdfU1RSSVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBmcm9tRGVjaW1hbENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgZXhwbGljaXQgaW5kZW50YXRpb24gd2lkdGggb2YgYSBibG9jayBzY2FsYXI7IGl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gb25lJyk7XG4gICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xuICAgICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCArIHRtcCAtIDE7XG4gICAgICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8ge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjNcbiAgICAvKiAjICovXG4gICAgKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH0gd2hpbGUgKCFpc19FT0woY2gpICYmIGNoICE9PSAwKTtcbiAgICAgIH1cbiAgfVxuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoKCFkZXRlY3RlZEluZGVudCB8fCBzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkgJiYgY2ggPT09IDB4MjBcbiAgICAvKiBTcGFjZSAqL1xuICAgICkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIEVuZCBvZiB0aGUgc2NhbGFyLlxuXG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcbiAgICAgIC8vIFBlcmZvcm0gdGhlIGNob21waW5nLlxuICAgICAgaWYgKGNob21waW5nID09PSBDSE9NUElOR19LRUVQKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKGNob21waW5nID09PSBDSE9NUElOR19DTElQKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkge1xuICAgICAgICAgIC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cblxuXG4gICAgICBicmVhaztcbiAgICB9IC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cblxuXG4gICAgaWYgKGZvbGRpbmcpIHtcbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTsgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY29udGVudCBsaW5lIChjZi4gRXhhbXBsZSA4LjEpXG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTsgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7IC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmIChlbXB0eUxpbmVzID09PSAwKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkge1xuICAgICAgICAgIC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH0gLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfSAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgY2ggIT09IDApIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmIChjaCAhPT0gMHgyRFxuICAgIC8qIC0gKi9cbiAgICApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoIWlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDw9IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xuXG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuXG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIGNoICE9PSAwKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSB7fSxcbiAgICAgIGtleVRhZyA9IG51bGwsXG4gICAgICBrZXlOb2RlID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSA9IG51bGwsXG4gICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZCA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuXG4gICAgX3BvcyA9IHN0YXRlLnBvc2l0aW9uOyAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cblxuICAgIGlmICgoY2ggPT09IDB4M0ZcbiAgICAvKiA/ICovXG4gICAgfHwgY2ggPT09IDB4M0FcbiAgICAvKiA6ICovXG4gICAgKSAmJiBpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgaWYgKGNoID09PSAweDNGXG4gICAgICAvKiA/ICovXG4gICAgICApIHtcbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAvLyBpLmUuIDB4M0EvKiA6ICovID09PSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGV4cGxpY2l0IGtleS5cbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nOyAvL1xuICAgICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQVxuICAgICAgICAvKiA6ICovXG4gICAgICAgICkge1xuICAgICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxvd0NvbXBhY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhIGJsb2NrIG1hcHBpbmcgZW50cnk7IGEgbXVsdGlsaW5lIGtleSBtYXkgbm90IGJlIGFuIGltcGxpY2l0IGtleScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrOyAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICAgIH0gLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cblxuXG4gICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSB7XG4gICAgICBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfT1VULCB0cnVlLCBhbGxvd0NvbXBhY3QpKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9saW5lLCBfcG9zKTtcbiAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50ICYmIGNoICE9PSAwKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cbiAgLy8gU3BlY2lhbCBjYXNlOiBsYXN0IG1hcHBpbmcncyBub2RlIGNvbnRhaW5zIG9ubHkgdGhlIGtleSBpbiBleHBsaWNpdCBub3RhdGlvbi5cblxuXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICB9IC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG5cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdtYXBwaW5nJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGRldGVjdGVkO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGlzVmVyYmF0aW0gPSBmYWxzZSxcbiAgICAgIGlzTmFtZWQgPSBmYWxzZSxcbiAgICAgIHRhZ0hhbmRsZSxcbiAgICAgIHRhZ05hbWUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICBpZiAoY2ggIT09IDB4MjFcbiAgLyogISAqL1xuICApIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUudGFnICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGEgdGFnIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDNDXG4gIC8qIDwgKi9cbiAgKSB7XG4gICAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIxXG4gIC8qICEgKi9cbiAgKSB7XG4gICAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICAgIHRhZ0hhbmRsZSA9ICchISc7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IHdoaWxlIChjaCAhPT0gMCAmJiBjaCAhPT0gMHgzRVxuICAgIC8qID4gKi9cbiAgICApO1xuXG4gICAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHZlcmJhdGltIHRhZycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgyMVxuICAgICAgLyogISAqL1xuICAgICAgKSB7XG4gICAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgICB0YWdIYW5kbGUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24gLSAxLCBzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTLnRlc3QodGFnTmFtZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnTmFtZSAmJiAhUEFUVEVSTl9UQUdfVVJJLnRlc3QodGFnTmFtZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIHN0YXRlLnRhZyA9IHRhZ05hbWU7XG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDIuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnIScpIHtcbiAgICBzdGF0ZS50YWcgPSAnIScgKyB0YWdOYW1lO1xuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICBpZiAoY2ggIT09IDB4MjZcbiAgLyogJiAqL1xuICApIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLCBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICBpZiAoY2ggIT09IDB4MkFcbiAgLyogKiAqL1xuICApIHJldHVybiBmYWxzZTtcbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIV9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwoc3RhdGUuYW5jaG9yTWFwLCBhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSxcbiAgICAgIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gIGF0TmV3TGluZSA9IGZhbHNlLFxuICAgICAgaGFzQ29udGVudCA9IGZhbHNlLFxuICAgICAgdHlwZUluZGV4LFxuICAgICAgdHlwZVF1YW50aXR5LFxuICAgICAgdHlwZSxcbiAgICAgIGZsb3dJbmRlbnQsXG4gICAgICBibG9ja0luZGVudDtcblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignb3BlbicsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmFuY2hvciA9IG51bGw7XG4gIHN0YXRlLmtpbmQgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuICBhbGxvd0Jsb2NrU3R5bGVzID0gYWxsb3dCbG9ja1NjYWxhcnMgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9CTE9DS19JTiA9PT0gbm9kZUNvbnRleHQ7XG5cbiAgaWYgKGFsbG93VG9TZWVrKSB7XG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMpIHtcbiAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhdE5ld0xpbmUgfHwgYWxsb3dDb21wYWN0O1xuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSB8fCBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICBpZiAoQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCB8fCBDT05URVhUX0ZMT1dfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudCArIDE7XG4gICAgfVxuXG4gICAgYmxvY2tJbmRlbnQgPSBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydDtcblxuICAgIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHwgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fCByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkgfHwgcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkgfHwgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkQWxpYXMoc3RhdGUpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsIHx8IHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2FsaWFzIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGFueSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGVudFN0YXR1cyA9PT0gMCkge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBibG9jayBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgdG8gaGF2ZSBzYW1lIGluZGVudGF0aW9uIGxldmVsIGFzIHRoZSBwYXJlbnQuXG4gICAgICAvLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3OTk3ODRcbiAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJyEnKSB7XG4gICAgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgICAvLyBJbXBsaWNpdCByZXNvbHZpbmcgaXMgbm90IGFsbG93ZWQgZm9yIG5vbi1zY2FsYXIgdHlwZXMsIGFuZCAnPydcbiAgICAgIC8vIG5vbi1zcGVjaWZpYyB0YWcgaXMgb25seSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvIHBsYWluIHNjYWxhcnMuXG4gICAgICAvL1xuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGNoZWNrIGtpbmQgY29uZm9ybWl0eSBpbiBjYXNlIHVzZXIgZXhwbGljaXRseSBhc3NpZ25zICc/J1xuICAgICAgLy8gdGFnLCBmb3IgZXhhbXBsZSBsaWtlIHRoaXM6IFwiITw/PiBbMF1cIlxuICAgICAgLy9cbiAgICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgc3RhdGUua2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8Pz4gdGFnOyBpdCBzaG91bGQgYmUgXCJzY2FsYXJcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xuXG4gICAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkge1xuICAgICAgICAgIC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDIuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcblxuICAgICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkge1xuICAgICAgICAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcblxuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gdGFnICE8JyArIHN0YXRlLnRhZyArICc+Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLnRhZyAhPT0gbnVsbCB8fCBzdGF0ZS5hbmNob3IgIT09IG51bGwgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IHt9O1xuICBzdGF0ZS5hbmNob3JNYXAgPSB7fTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IDAgfHwgY2ggIT09IDB4MjVcbiAgICAvKiAlICovXG4gICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09IDB4MjNcbiAgICAgIC8qICMgKi9cbiAgICAgICkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgICB9IHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfRU9MKGNoKSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkgYnJlYWs7XG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiYgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkRcbiAgLyogLSAqL1xuICAmJiBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSkgPT09IDB4MkRcbiAgLyogLSAqL1xuICAmJiBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMikgPT09IDB4MkRcbiAgLyogLSAqL1xuICApIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfSBlbHNlIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZXMgZW5kIG1hcmsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGNvbXBvc2VOb2RlKHN0YXRlLCBzdGF0ZS5saW5lSW5kZW50IC0gMSwgQ09OVEVYVF9CTE9DS19PVVQsIGZhbHNlLCB0cnVlKTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5jaGVja0xpbmVCcmVha3MgJiYgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkVcbiAgICAvKiAuICovXG4gICAgKSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCAtIDEpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEFcbiAgICAvKiBMRiAqL1xuICAgICYmIGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MERcbiAgICAvKiBDUiAqL1xuICAgICkge1xuICAgICAgICBpbnB1dCArPSAnXFxuJztcbiAgICAgIH0gLy8gU3RyaXAgQk9NXG5cblxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKGlucHV0LCBvcHRpb25zKTtcbiAgdmFyIG51bGxwb3MgPSBpbnB1dC5pbmRleE9mKCdcXDAnKTtcblxuICBpZiAobnVsbHBvcyAhPT0gLTEpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiA9IG51bGxwb3M7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ251bGwgYnl0ZSBpcyBub3QgYWxsb3dlZCBpbiBpbnB1dCcpO1xuICB9IC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG5cblxuICBzdGF0ZS5pbnB1dCArPSAnXFwwJztcblxuICB3aGlsZSAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MjBcbiAgLyogU3BhY2UgKi9cbiAgKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGggLSAxKSB7XG4gICAgcmVhZERvY3VtZW50KHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5kb2N1bWVudHM7XG59XG5cbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmIChpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9hZChpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuXG4gIHRocm93IG5ldyBleGNlcHRpb24oJ2V4cGVjdGVkIGEgc2luZ2xlIGRvY3VtZW50IGluIHRoZSBzdHJlYW0sIGJ1dCBmb3VuZCBtb3JlJyk7XG59XG5cbmZ1bmN0aW9uIHNhZmVMb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yID09PSAnb2JqZWN0JyAmJiBpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gaXRlcmF0b3I7XG4gICAgaXRlcmF0b3IgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBjb21tb24uZXh0ZW5kKHtcbiAgICBzY2hlbWE6IGRlZmF1bHRfc2FmZVxuICB9LCBvcHRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIHNhZmVMb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBsb2FkKGlucHV0LCBjb21tb24uZXh0ZW5kKHtcbiAgICBzY2hlbWE6IGRlZmF1bHRfc2FmZVxuICB9LCBvcHRpb25zKSk7XG59XG5cbnZhciBsb2FkQWxsXzEgPSBsb2FkQWxsO1xudmFyIGxvYWRfMSA9IGxvYWQ7XG52YXIgc2FmZUxvYWRBbGxfMSA9IHNhZmVMb2FkQWxsO1xudmFyIHNhZmVMb2FkXzEgPSBzYWZlTG9hZDtcbnZhciBsb2FkZXIgPSB7XG4gIGxvYWRBbGw6IGxvYWRBbGxfMSxcbiAgbG9hZDogbG9hZF8xLFxuICBzYWZlTG9hZEFsbDogc2FmZUxvYWRBbGxfMSxcbiAgc2FmZUxvYWQ6IHNhZmVMb2FkXzFcbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG5cbnZhciBfdG9TdHJpbmckMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5JDMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIENIQVJfVEFCID0gMHgwOTtcbi8qIFRhYiAqL1xuXG52YXIgQ0hBUl9MSU5FX0ZFRUQgPSAweDBBO1xuLyogTEYgKi9cblxudmFyIENIQVJfQ0FSUklBR0VfUkVUVVJOID0gMHgwRDtcbi8qIENSICovXG5cbnZhciBDSEFSX1NQQUNFID0gMHgyMDtcbi8qIFNwYWNlICovXG5cbnZhciBDSEFSX0VYQ0xBTUFUSU9OID0gMHgyMTtcbi8qICEgKi9cblxudmFyIENIQVJfRE9VQkxFX1FVT1RFID0gMHgyMjtcbi8qIFwiICovXG5cbnZhciBDSEFSX1NIQVJQID0gMHgyMztcbi8qICMgKi9cblxudmFyIENIQVJfUEVSQ0VOVCA9IDB4MjU7XG4vKiAlICovXG5cbnZhciBDSEFSX0FNUEVSU0FORCA9IDB4MjY7XG4vKiAmICovXG5cbnZhciBDSEFSX1NJTkdMRV9RVU9URSA9IDB4Mjc7XG4vKiAnICovXG5cbnZhciBDSEFSX0FTVEVSSVNLID0gMHgyQTtcbi8qICogKi9cblxudmFyIENIQVJfQ09NTUEgPSAweDJDO1xuLyogLCAqL1xuXG52YXIgQ0hBUl9NSU5VUyA9IDB4MkQ7XG4vKiAtICovXG5cbnZhciBDSEFSX0NPTE9OID0gMHgzQTtcbi8qIDogKi9cblxudmFyIENIQVJfRVFVQUxTID0gMHgzRDtcbi8qID0gKi9cblxudmFyIENIQVJfR1JFQVRFUl9USEFOID0gMHgzRTtcbi8qID4gKi9cblxudmFyIENIQVJfUVVFU1RJT04gPSAweDNGO1xuLyogPyAqL1xuXG52YXIgQ0hBUl9DT01NRVJDSUFMX0FUID0gMHg0MDtcbi8qIEAgKi9cblxudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUI7XG4vKiBbICovXG5cbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDtcbi8qIF0gKi9cblxudmFyIENIQVJfR1JBVkVfQUNDRU5UID0gMHg2MDtcbi8qIGAgKi9cblxudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUID0gMHg3Qjtcbi8qIHsgKi9cblxudmFyIENIQVJfVkVSVElDQUxfTElORSA9IDB4N0M7XG4vKiB8ICovXG5cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgPSAweDdEO1xuLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuRVNDQVBFX1NFUVVFTkNFU1sweDAwXSA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gPSAnXFxcXGInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA5XSA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gPSAnXFxcXHYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBDXSA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gPSAnXFxcXGUnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIyXSA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdID0gJ1xcXFxOJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHhBMF0gPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbJ3knLCAnWScsICd5ZXMnLCAnWWVzJywgJ1lFUycsICdvbicsICdPbicsICdPTicsICduJywgJ04nLCAnbm8nLCAnTm8nLCAnTk8nLCAnb2ZmJywgJ09mZicsICdPRkYnXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG4gIGlmIChtYXAgPT09IG51bGwpIHJldHVybiB7fTtcbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG5cbiAgICB0eXBlID0gc2NoZW1hLmNvbXBpbGVkVHlwZU1hcFsnZmFsbGJhY2snXVt0YWddO1xuXG4gICAgaWYgKHR5cGUgJiYgX2hhc093blByb3BlcnR5JDMuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlJDEob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IGRlZmF1bHRfZnVsbDtcbiAgdGhpcy5pbmRlbnQgPSBNYXRoLm1heCgxLCBvcHRpb25zWydpbmRlbnQnXSB8fCAyKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgPSBjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ107XG4gIHRoaXMuc3R5bGVNYXAgPSBjb21waWxlU3R5bGVNYXAodGhpcy5zY2hlbWEsIG9wdGlvbnNbJ3N0eWxlcyddIHx8IG51bGwpO1xuICB0aGlzLnNvcnRLZXlzID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggPSBvcHRpb25zWydsaW5lV2lkdGgnXSB8fCA4MDtcbiAgdGhpcy5ub1JlZnMgPSBvcHRpb25zWydub1JlZnMnXSB8fCBmYWxzZTtcbiAgdGhpcy5ub0NvbXBhdE1vZGUgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgPSBvcHRpb25zWydjb25kZW5zZUZsb3cnXSB8fCBmYWxzZTtcbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcbiAgdGhpcy50YWcgPSBudWxsO1xuICB0aGlzLnJlc3VsdCA9ICcnO1xuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59IC8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuXG5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuXG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gWzMzXSBzLXdoaXRlIDo6PSBzLXNwYWNlIHwgcy10YWJcblxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICByZXR1cm4gYyA9PT0gQ0hBUl9TUEFDRSB8fCBjID09PSBDSEFSX1RBQjtcbn0gLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgY2FuIGJlIHByaW50ZWQgd2l0aG91dCBlc2NhcGluZy5cbi8vIEZyb20gWUFNTCAxLjI6IFwiYW55IGFsbG93ZWQgY2hhcmFjdGVycyBrbm93biB0byBiZSBub24tcHJpbnRhYmxlXG4vLyBzaG91bGQgYWxzbyBiZSBlc2NhcGVkLiBbSG93ZXZlcixdIFRoaXMgaXNu4oCZdCBtYW5kYXRvcnlcIlxuLy8gRGVyaXZlZCBmcm9tIG5iLWNoYXIgLSBcXHQgLSAjeDg1IC0gI3hBMCAtICN4MjAyOCAtICN4MjAyOS5cblxuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAweDAwMDIwIDw9IGMgJiYgYyA8PSAweDAwMDA3RSB8fCAweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRiAmJiBjICE9PSAweDIwMjggJiYgYyAhPT0gMHgyMDI5IHx8IDB4MEUwMDAgPD0gYyAmJiBjIDw9IDB4MDBGRkZEICYmIGMgIT09IDB4RkVGRlxuICAvKiBCT00gKi9cbiAgfHwgMHgxMDAwMCA8PSBjICYmIGMgPD0gMHgxMEZGRkY7XG59IC8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBbMjRdIGItbGluZS1mZWVkICAgICAgIDo6PSAgICAgI3hBICAgIC8qIExGICovXG4vLyBbMjVdIGItY2FycmlhZ2UtcmV0dXJuIDo6PSAgICAgI3hEICAgIC8qIENSICovXG4vLyBbM10gIGMtYnl0ZS1vcmRlci1tYXJrIDo6PSAgICAgI3hGRUZGXG5cblxuZnVuY3Rpb24gaXNOc0NoYXIoYykge1xuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgIWlzV2hpdGVzcGFjZShjKSAvLyBieXRlLW9yZGVyLW1hcmtcbiAgJiYgYyAhPT0gMHhGRUZGIC8vIGItY2hhclxuICAmJiBjICE9PSBDSEFSX0NBUlJJQUdFX1JFVFVSTiAmJiBjICE9PSBDSEFSX0xJTkVfRkVFRDtcbn0gLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhZnRlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuXG5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlKGMsIHByZXYpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBuYi1jaGFyIC0gYy1mbG93LWluZGljYXRvciAtIFwiOlwiIC0gXCIjXCJcbiAgLy8gd2hlcmUgbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFyay5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRiAvLyAtIGMtZmxvdy1pbmRpY2F0b3JcbiAgJiYgYyAhPT0gQ0hBUl9DT01NQSAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgLy8gLSBcIjpcIiAtIFwiI1wiXG4gIC8vIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIFwiI1wiXG4gICYmIGMgIT09IENIQVJfQ09MT04gJiYgKGMgIT09IENIQVJfU0hBUlAgfHwgcHJldiAmJiBpc05zQ2hhcihwcmV2KSk7XG59IC8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cblxuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUZpcnN0KGMpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBucy1jaGFyIC0gYy1pbmRpY2F0b3JcbiAgLy8gd2hlcmUgbnMtY2hhciA9IG5iLWNoYXIgLSBzLXdoaXRlLlxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gMHhGRUZGICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gIC8vIC0gKGMtaW5kaWNhdG9yIDo6PVxuICAvLyDigJwt4oCdIHwg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJws4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ0gfCDigJx74oCdIHwg4oCcfeKAnVxuICAmJiBjICE9PSBDSEFSX01JTlVTICYmIGMgIT09IENIQVJfUVVFU1RJT04gJiYgYyAhPT0gQ0hBUl9DT0xPTiAmJiBjICE9PSBDSEFSX0NPTU1BICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAvLyB8IOKAnCPigJ0gfCDigJwm4oCdIHwg4oCcKuKAnSB8IOKAnCHigJ0gfCDigJx84oCdIHwg4oCcPeKAnSB8IOKAnD7igJ0gfCDigJwn4oCdIHwg4oCcXCLigJ1cbiAgJiYgYyAhPT0gQ0hBUl9TSEFSUCAmJiBjICE9PSBDSEFSX0FNUEVSU0FORCAmJiBjICE9PSBDSEFSX0FTVEVSSVNLICYmIGMgIT09IENIQVJfRVhDTEFNQVRJT04gJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FICYmIGMgIT09IENIQVJfRVFVQUxTICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOICYmIGMgIT09IENIQVJfU0lOR0xFX1FVT1RFICYmIGMgIT09IENIQVJfRE9VQkxFX1FVT1RFIC8vIHwg4oCcJeKAnSB8IOKAnEDigJ0gfCDigJxg4oCdKVxuICAmJiBjICE9PSBDSEFSX1BFUkNFTlQgJiYgYyAhPT0gQ0hBUl9DT01NRVJDSUFMX0FUICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufSAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGlzIHJlcXVpcmVkLlxuXG5cbmZ1bmN0aW9uIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSB7XG4gIHZhciBsZWFkaW5nU3BhY2VSZSA9IC9eXFxuKiAvO1xuICByZXR1cm4gbGVhZGluZ1NwYWNlUmUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgU1RZTEVfUExBSU4gPSAxLFxuICAgIFNUWUxFX1NJTkdMRSA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgPSA1OyAvLyBEZXRlcm1pbmVzIHdoaWNoIHNjYWxhciBzdHlsZXMgYXJlIHBvc3NpYmxlIGFuZCByZXR1cm5zIHRoZSBwcmVmZXJyZWQgc3R5bGUuXG4vLyBsaW5lV2lkdGggPSAtMSA9PiBubyBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBzdHIubGVuZ3RoID4gMC5cbi8vIFBvc3QtY29uZGl0aW9uczpcbi8vICAgIFNUWUxFX1BMQUlOIG9yIFNUWUxFX1NJTkdMRSA9PiBubyBcXG4gYXJlIGluIHRoZSBzdHJpbmcuXG4vLyAgICBTVFlMRV9MSVRFUkFMID0+IG5vIGxpbmVzIGFyZSBzdWl0YWJsZSBmb3IgZm9sZGluZyAob3IgbGluZVdpZHRoIGlzIC0xKS5cbi8vICAgIFNUWUxFX0ZPTERFRCA9PiBhIGxpbmUgPiBsaW5lV2lkdGggYW5kIGNhbiBiZSBmb2xkZWQgKGFuZCBsaW5lV2lkdGggIT0gLTEpLlxuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1b3VzVHlwZSkge1xuICB2YXIgaTtcbiAgdmFyIGNoYXIsIHByZXZfY2hhcjtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG5cbiAgdmFyIHNob3VsZFRyYWNrV2lkdGggPSBsaW5lV2lkdGggIT09IC0xO1xuICB2YXIgcHJldmlvdXNMaW5lQnJlYWsgPSAtMTsgLy8gY291bnQgdGhlIGZpcnN0IGxpbmUgY29ycmVjdGx5XG5cbiAgdmFyIHBsYWluID0gaXNQbGFpblNhZmVGaXJzdChzdHJpbmcuY2hhckNvZGVBdCgwKSkgJiYgIWlzV2hpdGVzcGFjZShzdHJpbmcuY2hhckNvZGVBdChzdHJpbmcubGVuZ3RoIC0gMSkpO1xuXG4gIGlmIChzaW5nbGVMaW5lT25seSkge1xuICAgIC8vIENhc2U6IG5vIGJsb2NrIHN0eWxlcy5cbiAgICAvLyBDaGVjayBmb3IgZGlzYWxsb3dlZCBjaGFyYWN0ZXJzIHRvIHJ1bGUgb3V0IHBsYWluIGFuZCBzaW5nbGUuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG5cbiAgICAgIHByZXZfY2hhciA9IGkgPiAwID8gc3RyaW5nLmNoYXJDb2RlQXQoaSAtIDEpIDogbnVsbDtcbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldl9jaGFyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZTogYmxvY2sgc3R5bGVzIHBlcm1pdHRlZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlOyAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuXG4gICAgICAgIGlmIChzaG91bGRUcmFja1dpZHRoKSB7XG4gICAgICAgICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8IC8vIEZvbGRhYmxlIGxpbmUgPSB0b28gbG9uZywgYW5kIG5vdCBtb3JlLWluZGVudGVkLlxuICAgICAgICAgIGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiYgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJztcbiAgICAgICAgICBwcmV2aW91c0xpbmVCcmVhayA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG5cbiAgICAgIHByZXZfY2hhciA9IGkgPiAwID8gc3RyaW5nLmNoYXJDb2RlQXQoaSAtIDEpIDogbnVsbDtcbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldl9jaGFyKTtcbiAgICB9IC8vIGluIGNhc2UgdGhlIGVuZCBpcyBtaXNzaW5nIGEgXFxuXG5cblxuICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fCBzaG91bGRUcmFja1dpZHRoICYmIGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiYgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJztcbiAgfSAvLyBBbHRob3VnaCBldmVyeSBzdHlsZSBjYW4gcmVwcmVzZW50IFxcbiB3aXRob3V0IGVzY2FwaW5nLCBwcmVmZXIgYmxvY2sgc3R5bGVzXG4gIC8vIGZvciBtdWx0aWxpbmUsIHNpbmNlIHRoZXkncmUgbW9yZSByZWFkYWJsZSBhbmQgdGhleSBkb24ndCBhZGQgZW1wdHkgbGluZXMuXG4gIC8vIEFsc28gcHJlZmVyIGZvbGRpbmcgYSBzdXBlci1sb25nIGxpbmUuXG5cblxuICBpZiAoIWhhc0xpbmVCcmVhayAmJiAhaGFzRm9sZGFibGVMaW5lKSB7XG4gICAgLy8gU3RyaW5ncyBpbnRlcnByZXRhYmxlIGFzIGFub3RoZXIgdHlwZSBoYXZlIHRvIGJlIHF1b3RlZDtcbiAgICAvLyBlLmcuIHRoZSBzdHJpbmcgJ3RydWUnIHZzLiB0aGUgYm9vbGVhbiB0cnVlLlxuICAgIHJldHVybiBwbGFpbiAmJiAhdGVzdEFtYmlndW91c1R5cGUoc3RyaW5nKSA/IFNUWUxFX1BMQUlOIDogU1RZTEVfU0lOR0xFO1xuICB9IC8vIEVkZ2UgY2FzZTogYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGNhbiBvbmx5IGhhdmUgb25lIGRpZ2l0LlxuXG5cbiAgaWYgKGluZGVudFBlckxldmVsID4gOSAmJiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9IC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuXG5cbiAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG59IC8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAg4oCiIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICDigKIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5cblxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIHN0cmluZywgbGV2ZWwsIGlza2V5KSB7XG4gIHN0YXRlLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIicnXCI7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5ub0NvbXBhdE1vZGUgJiYgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nICsgXCInXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIOKJpCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cblxuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGggPT09IC0xID8gLTEgOiBNYXRoLm1heChNYXRoLm1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKSwgc3RhdGUubGluZVdpZHRoIC0gaW5kZW50KTsgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cblxuICAgIHZhciBzaW5nbGVMaW5lT25seSA9IGlza2V5IC8vIE5vIGJsb2NrIHN0eWxlcyBpbiBmbG93IG1vZGUuXG4gICAgfHwgc3RhdGUuZmxvd0xldmVsID4gLTEgJiYgbGV2ZWwgPj0gc3RhdGUuZmxvd0xldmVsO1xuXG4gICAgZnVuY3Rpb24gdGVzdEFtYmlndWl0eShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cmluZyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBzdGF0ZS5pbmRlbnQsIGxpbmVXaWR0aCwgdGVzdEFtYmlndWl0eSkpIHtcbiAgICAgIGNhc2UgU1RZTEVfUExBSU46XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG5cbiAgICAgIGNhc2UgU1RZTEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG5cbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KSArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhzdHJpbmcsIGluZGVudCkpO1xuXG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KSArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhmb2xkU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSwgaW5kZW50KSk7XG5cbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcpICsgJ1wiJztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignaW1wb3NzaWJsZSBlcnJvcjogaW52YWxpZCBzY2FsYXIgc3R5bGUnKTtcbiAgICB9XG4gIH0oKTtcbn0gLy8gUHJlLWNvbmRpdGlvbnM6IHN0cmluZyBpcyB2YWxpZCBmb3IgYSBibG9jayBzY2FsYXIsIDEgPD0gaW5kZW50UGVyTGV2ZWwgPD0gOS5cblxuXG5mdW5jdGlvbiBibG9ja0hlYWRlcihzdHJpbmcsIGluZGVudFBlckxldmVsKSB7XG4gIHZhciBpbmRlbnRJbmRpY2F0b3IgPSBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykgPyBTdHJpbmcoaW5kZW50UGVyTGV2ZWwpIDogJyc7IC8vIG5vdGUgdGhlIHNwZWNpYWwgY2FzZTogdGhlIHN0cmluZyAnXFxuJyBjb3VudHMgYXMgYSBcInRyYWlsaW5nXCIgZW1wdHkgbGluZS5cblxuICB2YXIgY2xpcCA9IHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICB2YXIga2VlcCA9IGNsaXAgJiYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMl0gPT09ICdcXG4nIHx8IHN0cmluZyA9PT0gJ1xcbicpO1xuICB2YXIgY2hvbXAgPSBrZWVwID8gJysnIDogY2xpcCA/ICcnIDogJy0nO1xuICByZXR1cm4gaW5kZW50SW5kaWNhdG9yICsgY2hvbXAgKyAnXFxuJztcbn0gLy8gKFNlZSB0aGUgbm90ZSBmb3Igd3JpdGVTY2FsYXIuKVxuXG5cbmZ1bmN0aW9uIGRyb3BFbmRpbmdOZXdsaW5lKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufSAvLyBOb3RlOiBhIGxvbmcgbGluZSB3aXRob3V0IGEgc3VpdGFibGUgYnJlYWsgcG9pbnQgd2lsbCBleGNlZWQgdGhlIHdpZHRoIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IGV2ZXJ5IGNoYXIgaW4gc3RyIGlzUHJpbnRhYmxlLCBzdHIubGVuZ3RoID4gMCwgd2lkdGggPiAwLlxuXG5cbmZ1bmN0aW9uIGZvbGRTdHJpbmcoc3RyaW5nLCB3aWR0aCkge1xuICAvLyBJbiBmb2xkZWQgc3R5bGUsICRrJCBjb25zZWN1dGl2ZSBuZXdsaW5lcyBvdXRwdXQgYXMgJGsrMSQgbmV3bGluZXPigJRcbiAgLy8gdW5sZXNzIHRoZXkncmUgYmVmb3JlIG9yIGFmdGVyIGEgbW9yZS1pbmRlbnRlZCBsaW5lLCBvciBhdCB0aGUgdmVyeVxuICAvLyBiZWdpbm5pbmcgb3IgZW5kLCBpbiB3aGljaCBjYXNlICRrJCBtYXBzIHRvICRrJC5cbiAgLy8gVGhlcmVmb3JlLCBwYXJzZSBlYWNoIGNodW5rIGFzIG5ld2xpbmUocykgZm9sbG93ZWQgYnkgYSBjb250ZW50IGxpbmUuXG4gIHZhciBsaW5lUmUgPSAvKFxcbispKFteXFxuXSopL2c7IC8vIGZpcnN0IGxpbmUgKHBvc3NpYmx5IGFuIGVtcHR5IGxpbmUpXG5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dExGID0gc3RyaW5nLmluZGV4T2YoJ1xcbicpO1xuICAgIG5leHRMRiA9IG5leHRMRiAhPT0gLTEgPyBuZXh0TEYgOiBzdHJpbmcubGVuZ3RoO1xuICAgIGxpbmVSZS5sYXN0SW5kZXggPSBuZXh0TEY7XG4gICAgcmV0dXJuIGZvbGRMaW5lKHN0cmluZy5zbGljZSgwLCBuZXh0TEYpLCB3aWR0aCk7XG4gIH0oKTsgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgeWV0LCBkb24ndCBhZGQgYW4gZXh0cmEgXFxuLlxuXG5cbiAgdmFyIHByZXZNb3JlSW5kZW50ZWQgPSBzdHJpbmdbMF0gPT09ICdcXG4nIHx8IHN0cmluZ1swXSA9PT0gJyAnO1xuICB2YXIgbW9yZUluZGVudGVkOyAvLyByZXN0IG9mIHRoZSBsaW5lc1xuXG4gIHZhciBtYXRjaDtcblxuICB3aGlsZSAobWF0Y2ggPSBsaW5lUmUuZXhlYyhzdHJpbmcpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdLFxuICAgICAgICBsaW5lID0gbWF0Y2hbMl07XG4gICAgbW9yZUluZGVudGVkID0gbGluZVswXSA9PT0gJyAnO1xuICAgIHJlc3VsdCArPSBwcmVmaXggKyAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIW1vcmVJbmRlbnRlZCAmJiBsaW5lICE9PSAnJyA/ICdcXG4nIDogJycpICsgZm9sZExpbmUobGluZSwgd2lkdGgpO1xuICAgIHByZXZNb3JlSW5kZW50ZWQgPSBtb3JlSW5kZW50ZWQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSAvLyBHcmVlZHkgbGluZSBicmVha2luZy5cbi8vIFBpY2tzIHRoZSBsb25nZXN0IGxpbmUgdW5kZXIgdGhlIGxpbWl0IGVhY2ggdGltZSxcbi8vIG90aGVyd2lzZSBzZXR0bGVzIGZvciB0aGUgc2hvcnRlc3QgbGluZSBvdmVyIHRoZSBsaW1pdC5cbi8vIE5CLiBNb3JlLWluZGVudGVkIGxpbmVzICpjYW5ub3QqIGJlIGZvbGRlZCwgYXMgdGhhdCB3b3VsZCBhZGQgYW4gZXh0cmEgXFxuLlxuXG5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIHdpZHRoKSB7XG4gIGlmIChsaW5lID09PSAnJyB8fCBsaW5lWzBdID09PSAnICcpIHJldHVybiBsaW5lOyAvLyBTaW5jZSBhIG1vcmUtaW5kZW50ZWQgbGluZSBhZGRzIGEgXFxuLCBicmVha3MgY2FuJ3QgYmUgZm9sbG93ZWQgYnkgYSBzcGFjZS5cblxuICB2YXIgYnJlYWtSZSA9IC8gW14gXS9nOyAvLyBub3RlOiB0aGUgbWF0Y2ggaW5kZXggd2lsbCBhbHdheXMgYmUgPD0gbGVuZ3RoLTIuXG5cbiAgdmFyIG1hdGNoOyAvLyBzdGFydCBpcyBhbiBpbmNsdXNpdmUgaW5kZXguIGVuZCwgY3VyciwgYW5kIG5leHQgYXJlIGV4Y2x1c2l2ZS5cblxuICB2YXIgc3RhcnQgPSAwLFxuICAgICAgZW5kLFxuICAgICAgY3VyciA9IDAsXG4gICAgICBuZXh0ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnOyAvLyBJbnZhcmlhbnRzOiAwIDw9IHN0YXJ0IDw9IGxlbmd0aC0xLlxuICAvLyAgIDAgPD0gY3VyciA8PSBuZXh0IDw9IG1heCgwLCBsZW5ndGgtMikuIGN1cnIgLSBzdGFydCA8PSB3aWR0aC5cbiAgLy8gSW5zaWRlIHRoZSBsb29wOlxuICAvLyAgIEEgbWF0Y2ggaW1wbGllcyBsZW5ndGggPj0gMiwgc28gY3VyciBhbmQgbmV4dCBhcmUgPD0gbGVuZ3RoLTIuXG5cbiAgd2hpbGUgKG1hdGNoID0gYnJlYWtSZS5leGVjKGxpbmUpKSB7XG4gICAgbmV4dCA9IG1hdGNoLmluZGV4OyAvLyBtYWludGFpbiBpbnZhcmlhbnQ6IGN1cnIgLSBzdGFydCA8PSB3aWR0aFxuXG4gICAgaWYgKG5leHQgLSBzdGFydCA+IHdpZHRoKSB7XG4gICAgICBlbmQgPSBjdXJyID4gc3RhcnQgPyBjdXJyIDogbmV4dDsgLy8gZGVyaXZlIGVuZCA8PSBsZW5ndGgtMlxuXG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpOyAvLyBza2lwIHRoZSBzcGFjZSB0aGF0IHdhcyBvdXRwdXQgYXMgXFxuXG5cbiAgICAgIHN0YXJ0ID0gZW5kICsgMTsgLy8gZGVyaXZlIHN0YXJ0IDw9IGxlbmd0aC0xXG4gICAgfVxuXG4gICAgY3VyciA9IG5leHQ7XG4gIH0gLy8gQnkgdGhlIGludmFyaWFudHMsIHN0YXJ0IDw9IGxlbmd0aC0xLCBzbyB0aGVyZSBpcyBzb21ldGhpbmcgbGVmdCBvdmVyLlxuICAvLyBJdCBpcyBlaXRoZXIgdGhlIHdob2xlIHN0cmluZyBvciBhIHBhcnQgc3RhcnRpbmcgZnJvbSBub24td2hpdGVzcGFjZS5cblxuXG4gIHJlc3VsdCArPSAnXFxuJzsgLy8gSW5zZXJ0IGEgYnJlYWsgaWYgdGhlIHJlbWFpbmRlciBpcyB0b28gbG9uZyBhbmQgdGhlcmUgaXMgYSBicmVhayBhdmFpbGFibGUuXG5cbiAgaWYgKGxpbmUubGVuZ3RoIC0gc3RhcnQgPiB3aWR0aCAmJiBjdXJyID4gc3RhcnQpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCwgY3VycikgKyAnXFxuJyArIGxpbmUuc2xpY2UoY3VyciArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2xpY2UoMSk7IC8vIGRyb3AgZXh0cmEgXFxuIGpvaW5lclxufSAvLyBFc2NhcGVzIGEgZG91YmxlLXF1b3RlZCBzdHJpbmcuXG5cblxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjaGFyLCBuZXh0Q2hhcjtcbiAgdmFyIGVzY2FwZVNlcTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTsgLy8gQ2hlY2sgZm9yIHN1cnJvZ2F0ZSBwYWlycyAocmVmZXJlbmNlIFVuaWNvZGUgMy4wIHNlY3Rpb24gXCIzLjcgU3Vycm9nYXRlc1wiKS5cblxuICAgIGlmIChjaGFyID49IDB4RDgwMCAmJiBjaGFyIDw9IDB4REJGRlxuICAgIC8qIGhpZ2ggc3Vycm9nYXRlICovXG4gICAgKSB7XG4gICAgICAgIG5leHRDaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuXG4gICAgICAgIGlmIChuZXh0Q2hhciA+PSAweERDMDAgJiYgbmV4dENoYXIgPD0gMHhERkZGXG4gICAgICAgIC8qIGxvdyBzdXJyb2dhdGUgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBDb21iaW5lIHRoZSBzdXJyb2dhdGUgcGFpciBhbmQgc3RvcmUgaXQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVIZXgoKGNoYXIgLSAweEQ4MDApICogMHg0MDAgKyBuZXh0Q2hhciAtIDB4REMwMCArIDB4MTAwMDApOyAvLyBBZHZhbmNlIGluZGV4IG9uZSBleHRyYSBzaW5jZSB3ZSBhbHJlYWR5IHVzZWQgdGhhdCBjaGFyIGhlcmUuXG5cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgIGVzY2FwZVNlcSA9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcl07XG4gICAgcmVzdWx0ICs9ICFlc2NhcGVTZXEgJiYgaXNQcmludGFibGUoY2hhcikgPyBzdHJpbmdbaV0gOiBlc2NhcGVTZXEgfHwgZW5jb2RlSGV4KGNoYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoaW5kZXggIT09IDApIF9yZXN1bHQgKz0gJywnICsgKCFzdGF0ZS5jb25kZW5zZUZsb3cgPyAnICcgOiAnJyk7XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RbaW5kZXhdLCB0cnVlLCB0cnVlKSkge1xuICAgICAgaWYgKCFjb21wYWN0IHx8IGluZGV4ICE9PSAwKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSAnO1xuICAgICAgfVxuXG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuICAgIGlmIChpbmRleCAhPT0gMCkgcGFpckJ1ZmZlciArPSAnLCAnO1xuICAgIGlmIChzdGF0ZS5jb25kZW5zZUZsb3cpIHBhaXJCdWZmZXIgKz0gJ1wiJztcbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RLZXksIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpIHBhaXJCdWZmZXIgKz0gJz8gJztcbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDsgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cblxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAneycgKyBfcmVzdWx0ICsgJ30nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIGV4cGxpY2l0UGFpcixcbiAgICAgIHBhaXJCdWZmZXI7IC8vIEFsbG93IHNvcnRpbmcga2V5cyBzbyB0aGF0IHRoZSBvdXRwdXQgZmlsZSBpcyBkZXRlcm1pbmlzdGljXG5cbiAgaWYgKHN0YXRlLnNvcnRLZXlzID09PSB0cnVlKSB7XG4gICAgLy8gRGVmYXVsdCBzb3J0aW5nXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlLnNvcnRLZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ3VzdG9tIHNvcnQgZnVuY3Rpb25cbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoc3RhdGUuc29ydEtleXMpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNvcnRLZXlzKSB7XG4gICAgLy8gU29tZXRoaW5nIGlzIHdyb25nXG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignc29ydEtleXMgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSAnJztcblxuICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JyB8fCBzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7IC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mIHx8IHR5cGUucHJlZGljYXRlKSAmJiAoIXR5cGUuaW5zdGFuY2VPZiB8fCB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgaW5zdGFuY2VvZiB0eXBlLmluc3RhbmNlT2YpICYmICghdHlwZS5wcmVkaWNhdGUgfHwgdHlwZS5wcmVkaWNhdGUob2JqZWN0KSkpIHtcbiAgICAgIHN0YXRlLnRhZyA9IGV4cGxpY2l0ID8gdHlwZS50YWcgOiAnPyc7XG5cbiAgICAgIGlmICh0eXBlLnJlcHJlc2VudCkge1xuICAgICAgICBzdHlsZSA9IHN0YXRlLnN0eWxlTWFwW3R5cGUudGFnXSB8fCB0eXBlLmRlZmF1bHRTdHlsZTtcblxuICAgICAgICBpZiAoX3RvU3RyaW5nJDIuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDMuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCchPCcgKyB0eXBlLnRhZyArICc+IHRhZyByZXNvbHZlciBhY2NlcHRzIG5vdCBcIicgKyBzdHlsZSArICdcIiBzdHlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZHVtcCA9IF9yZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cbi8vIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBvciBmYWxzZSBvbiBpbnZhbGlkIG9iamVjdC5cbi8vXG5cblxuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXkpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nJDIuY2FsbChzdGF0ZS5kdW1wKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9IHN0YXRlLmZsb3dMZXZlbCA8IDAgfHwgc3RhdGUuZmxvd0xldmVsID4gbGV2ZWw7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JyB8fCBkdXBsaWNhdGUgfHwgc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkge1xuICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIGlmIChibG9jayAmJiBPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcblxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcblxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBhcnJheUxldmVsID0gc3RhdGUubm9BcnJheUluZGVudCAmJiBsZXZlbCA+IDAgPyBsZXZlbCAtIDEgOiBsZXZlbDtcblxuICAgICAgaWYgKGJsb2NrICYmIHN0YXRlLmR1bXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYXJyYXlMZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG5cbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgYXJyYXlMZXZlbCwgc3RhdGUuZHVtcCk7XG5cbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wLCBsZXZlbCwgaXNrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuc2tpcEludmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ3VuYWNjZXB0YWJsZSBraW5kIG9mIGFuIG9iamVjdCB0byBkdW1wICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICBzdGF0ZS5kdW1wID0gJyE8JyArIHN0YXRlLnRhZyArICc+ICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuXG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIG9iamVjdEtleUxpc3QsIGluZGV4LCBsZW5ndGg7XG5cbiAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlJDEob3B0aW9ucyk7XG4gIGlmICghc3RhdGUubm9SZWZzKSBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIGlucHV0LCB0cnVlLCB0cnVlKSkgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBzYWZlRHVtcChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gZHVtcChpbnB1dCwgY29tbW9uLmV4dGVuZCh7XG4gICAgc2NoZW1hOiBkZWZhdWx0X3NhZmVcbiAgfSwgb3B0aW9ucykpO1xufVxuXG52YXIgZHVtcF8xID0gZHVtcDtcbnZhciBzYWZlRHVtcF8xID0gc2FmZUR1bXA7XG52YXIgZHVtcGVyID0ge1xuICBkdW1wOiBkdW1wXzEsXG4gIHNhZmVEdW1wOiBzYWZlRHVtcF8xXG59O1xuXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uICcgKyBuYW1lICsgJyBpcyBkZXByZWNhdGVkIGFuZCBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgfTtcbn1cblxudmFyIFR5cGUkMSA9IHR5cGU7XG52YXIgU2NoZW1hJDEgPSBzY2hlbWE7XG52YXIgRkFJTFNBRkVfU0NIRU1BID0gZmFpbHNhZmU7XG52YXIgSlNPTl9TQ0hFTUEgPSBqc29uO1xudmFyIENPUkVfU0NIRU1BID0gY29yZTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gZGVmYXVsdF9zYWZlO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSBkZWZhdWx0X2Z1bGw7XG52YXIgbG9hZCQxID0gbG9hZGVyLmxvYWQ7XG52YXIgbG9hZEFsbCQxID0gbG9hZGVyLmxvYWRBbGw7XG52YXIgc2FmZUxvYWQkMSA9IGxvYWRlci5zYWZlTG9hZDtcbnZhciBzYWZlTG9hZEFsbCQxID0gbG9hZGVyLnNhZmVMb2FkQWxsO1xudmFyIGR1bXAkMSA9IGR1bXBlci5kdW1wO1xudmFyIHNhZmVEdW1wJDEgPSBkdW1wZXIuc2FmZUR1bXA7XG52YXIgWUFNTEV4Y2VwdGlvbiQxID0gZXhjZXB0aW9uOyAvLyBEZXByZWNhdGVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcblxudmFyIE1JTklNQUxfU0NIRU1BID0gZmFpbHNhZmU7XG52YXIgU0FGRV9TQ0hFTUEgPSBkZWZhdWx0X3NhZmU7XG52YXIgREVGQVVMVF9TQ0hFTUEgPSBkZWZhdWx0X2Z1bGw7IC8vIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAxLngueFxuXG52YXIgc2NhbiA9IGRlcHJlY2F0ZWQoJ3NjYW4nKTtcbnZhciBwYXJzZSA9IGRlcHJlY2F0ZWQoJ3BhcnNlJyk7XG52YXIgY29tcG9zZSA9IGRlcHJlY2F0ZWQoJ2NvbXBvc2UnKTtcbnZhciBhZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG52YXIganNZYW1sID0ge1xuICBUeXBlOiBUeXBlJDEsXG4gIFNjaGVtYTogU2NoZW1hJDEsXG4gIEZBSUxTQUZFX1NDSEVNQTogRkFJTFNBRkVfU0NIRU1BLFxuICBKU09OX1NDSEVNQTogSlNPTl9TQ0hFTUEsXG4gIENPUkVfU0NIRU1BOiBDT1JFX1NDSEVNQSxcbiAgREVGQVVMVF9TQUZFX1NDSEVNQTogREVGQVVMVF9TQUZFX1NDSEVNQSxcbiAgREVGQVVMVF9GVUxMX1NDSEVNQTogREVGQVVMVF9GVUxMX1NDSEVNQSxcbiAgbG9hZDogbG9hZCQxLFxuICBsb2FkQWxsOiBsb2FkQWxsJDEsXG4gIHNhZmVMb2FkOiBzYWZlTG9hZCQxLFxuICBzYWZlTG9hZEFsbDogc2FmZUxvYWRBbGwkMSxcbiAgZHVtcDogZHVtcCQxLFxuICBzYWZlRHVtcDogc2FmZUR1bXAkMSxcbiAgWUFNTEV4Y2VwdGlvbjogWUFNTEV4Y2VwdGlvbiQxLFxuICBNSU5JTUFMX1NDSEVNQTogTUlOSU1BTF9TQ0hFTUEsXG4gIFNBRkVfU0NIRU1BOiBTQUZFX1NDSEVNQSxcbiAgREVGQVVMVF9TQ0hFTUE6IERFRkFVTFRfU0NIRU1BLFxuICBzY2FuOiBzY2FuLFxuICBwYXJzZTogcGFyc2UsXG4gIGNvbXBvc2U6IGNvbXBvc2UsXG4gIGFkZENvbnN0cnVjdG9yOiBhZGRDb25zdHJ1Y3RvclxufTtcblxudmFyIGpzWWFtbCQxID0ganNZYW1sO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXG4gKiBSZWRpcmVjdCAtIG9iamVjdCB1c2VkIHRvIHJlZGlyZWN0IHNvbWUgcmVxdWVzdHNcbiAqIGUuZy5cbiAqIHtcbiAqICAgICAgdGl0bGU6IDF4MS10cmFuc3BhcmVudC5naWZcbiAqICAgICAgY29tbWVudDogaHR0cDovL3Byb2JhYmx5cHJvZ3JhbW1pbmcuY29tLzIwMDkvMDMvMTUvdGhlLXRpbmllc3QtZ2lmLWV2ZXJcbiAqICAgICAgY29udGVudFR5cGU6IGltYWdlL2dpZjtiYXNlNjRcbiAqICAgICAgY29udGVudDogUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVxuICogfVxuICogQHR5cGVkZWYge09iamVjdH0gUmVkaXJlY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aXRsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbW1lbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGVudFR5cGVcbiAqL1xuXG52YXIgUmVkaXJlY3RzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHJhd1lhbWwgaW50byBKUyBvYmplY3Qgd2l0aCBzb3VyY2VzIHRpdGxlcyB1c2VkIGFzIGtleXNcbiAgICogQHBhcmFtIHJhd1lhbWxcbiAgICogQHJldHVybnMge09iamVjdDxSZWRpcmVjdD59IC0gcmV0dXJuIG9iamVjdCB3aXRoIHRpdGxlcyBpbiB0aGUga2V5cyBhbmQgUmVkaXJlY3RTb3VyY2VzXG4gICAqIGluIHRoZSB2YWx1ZXNcbiAgICovXG4gIGZ1bmN0aW9uIFJlZGlyZWN0cyhyYXdZYW1sKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVkaXJlY3RzKTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgYXJyT2ZSZWRpcmVjdHMgPSBqc1lhbWwkMS5zYWZlTG9hZChyYXdZYW1sKTtcbiAgICAgIHRoaXMucmVkaXJlY3RzID0gYXJyT2ZSZWRpcmVjdHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlZGlyZWN0KSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFjYyksIHt9LCBkZWZpbmVQcm9wZXJ0eSh7fSwgcmVkaXJlY3QudGl0bGUsIHJlZGlyZWN0KSk7XG4gICAgICB9LCB7fSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FzIHVuYWJsZSB0byBsb2FkIFlBTUwgaW50byBKUyBkdWUgdG86IFwiLmNvbmNhdChlLm1lc3NhZ2UpKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlZGlyZWN0IHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gICAqIEByZXR1cm4ge1JlZGlyZWN0fVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFJlZGlyZWN0cywgW3tcbiAgICBrZXk6IFwiZ2V0UmVkaXJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVkaXJlY3QodGl0bGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5yZWRpcmVjdHMsIHRpdGxlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdHNbdGl0bGVdO1xuICAgICAgfSAvLyBsb29rIHRpdGxlIGFtb25nIGFsaWFzZXNcblxuXG4gICAgICB2YXIgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5yZWRpcmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZWRpcmVjdHNba2V5XTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHZhbHVlcy5maW5kKGZ1bmN0aW9uIChyZWRpcmVjdCkge1xuICAgICAgICB2YXIgYWxpYXNlcyA9IHJlZGlyZWN0LmFsaWFzZXM7XG5cbiAgICAgICAgaWYgKCFhbGlhc2VzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsaWFzZXMuaW5kZXhPZih0aXRsZSkgPiAtMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWRpcmVjdHM7XG59KCk7XG5cbi8qKlxuICogRmluZHMgcmVkaXJlY3QgcmVzb3VyY2UgYnkgaXQncyBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHJlZGlyZWN0IG5hbWVcbiAqL1xuXG52YXIgZ2V0UmVkaXJlY3RCeU5hbWUgPSBmdW5jdGlvbiBnZXRSZWRpcmVjdEJ5TmFtZShuYW1lKSB7XG4gIHZhciByZWRpcmVjdHMgPSBPYmplY3Qua2V5cyhyZWRpcmVjdHNMaXN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiByZWRpcmVjdHNMaXN0W2tleV07XG4gIH0pO1xuICByZXR1cm4gcmVkaXJlY3RzLmZpbmQoZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gci5uYW1lcyAmJiByLm5hbWVzLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgfSk7XG59O1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTb3VyY2UgLSByZWRpcmVjdCBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSByZWRpcmVjdCBuYW1lXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IGFyZ3MgQXJndW1lbnRzIGZvciByZWRpcmVjdCBmdW5jdGlvblxuICogQHByb3BlcnR5IHsnZXh0ZW5zaW9uJ3wndGVzdCd9IFtlbmdpbmVdIC1cbiAqIERlZmluZXMgdGhlIGZpbmFsIGZvcm0gb2YgcmVkaXJlY3Qgc3RyaW5nIHByZXNlbnRhdGlvblxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmVyYm9zZV0gZmxhZyB0byBlbmFibGUgcHJpbnRpbmcgdG8gY29uc29sZSBkZWJ1ZyBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogUmV0dXJucyByZWRpcmVjdCBjb2RlIGJ5IHBhcmFtXG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZWRpcmVjdCBjb2RlXG4gKi9cblxuXG52YXIgZ2V0UmVkaXJlY3RDb2RlID0gZnVuY3Rpb24gZ2V0UmVkaXJlY3RDb2RlKHNvdXJjZSkge1xuICB2YXIgcmVkaXJlY3QgPSBnZXRSZWRpcmVjdEJ5TmFtZShzb3VyY2UubmFtZSk7XG4gIHZhciByZXN1bHQgPSBhdHRhY2hEZXBlbmRlbmNpZXMocmVkaXJlY3QpO1xuICByZXN1bHQgPSBhZGRDYWxsKHJlZGlyZWN0LCByZXN1bHQpOyAvLyByZWRpcmVjdCBjb2RlIGZvciBkaWZmZXJlbnQgc291cmNlcyBpcyBjaGVja2VkIGluIHRlc3RzXG4gIC8vIHNvIGl0IHNob3VsZCBiZSBqdXN0IGEgY29kZSB3aXRob3V0IGFueSBzb3VyY2UgYW5kIHByb3BzIHBhc3NlZFxuXG4gIHJlc3VsdCA9IHNvdXJjZS5lbmdpbmUgPT09ICd0ZXN0JyA/IHdyYXBJbk5vbmFtZUZ1bmMocmVzdWx0KSA6IHBhc3NTb3VyY2VBbmRQcm9wcyhzb3VyY2UsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcmVkaXJlY3RzQ2pzID0ge1xuICBSZWRpcmVjdHM6IFJlZGlyZWN0cyxcbiAgZ2V0Q29kZTogZ2V0UmVkaXJlY3RDb2RlLFxuICBpc0FkZ1JlZGlyZWN0UnVsZTogdmFsaWRhdG9yLmlzQWRnUmVkaXJlY3RSdWxlLFxuICBpc1ZhbGlkQWRnUmVkaXJlY3RSdWxlOiB2YWxpZGF0b3IuaXNWYWxpZEFkZ1JlZGlyZWN0UnVsZSxcbiAgaXNBZGdSZWRpcmVjdENvbXBhdGlibGVXaXRoVWJvOiB2YWxpZGF0b3IuaXNBZGdSZWRpcmVjdENvbXBhdGlibGVXaXRoVWJvLFxuICBpc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGc6IHZhbGlkYXRvci5pc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcsXG4gIGlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZzogdmFsaWRhdG9yLmlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyxcbiAgY29udmVydFVib1JlZGlyZWN0VG9BZGc6IGNvbnZlcnRVYm9SZWRpcmVjdFRvQWRnLFxuICBjb252ZXJ0QWJwUmVkaXJlY3RUb0FkZzogY29udmVydEFicFJlZGlyZWN0VG9BZGcsXG4gIGNvbnZlcnRSZWRpcmVjdFRvQWRnOiBjb252ZXJ0UmVkaXJlY3RUb0FkZyxcbiAgY29udmVydEFkZ1JlZGlyZWN0VG9VYm86IGNvbnZlcnRBZGdSZWRpcmVjdFRvVWJvXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNvdXJjZSAtIHNjcmlwdGxldCBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTY3JpcHRsZXQgbmFtZVxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBhcmdzIEFyZ3VtZW50cyBmb3Igc2NyaXB0bGV0IGZ1bmN0aW9uXG4gKiBAcHJvcGVydHkgeydleHRlbnNpb24nfCdjb3JlbGlicyd8J3Rlc3QnfSBlbmdpbmUgLVxuICogRGVmaW5lcyB0aGUgZmluYWwgZm9ybSBvZiBzY3JpcHRsZXQgc3RyaW5nIHByZXNlbnRhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt2ZXJzaW9uXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmVyYm9zZV0gZmxhZyB0byBlbmFibGUgcHJpbnRpbmcgdG8gY29uc29sZSBkZWJ1ZyBpbmZvcm1hdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtydWxlVGV4dF0gU291cmNlIHJ1bGUgdGV4dCBpcyB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZG9tYWluTmFtZV0gZG9tYWluIG5hbWUgd2hlcmUgc2NyaXB0bGV0IGlzIGFwcGxpZWQ7IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgc2NyaXB0bGV0IGNvZGUgYnkgcGFyYW1cbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHNjcmlwdGxldCBjb2RlXG4gKi9cblxuZnVuY3Rpb24gZ2V0U2NyaXB0bGV0Q29kZShzb3VyY2UpIHtcbiAgaWYgKCF2YWxpZGF0b3IuaXNWYWxpZFNjcmlwdGxldE5hbWUoc291cmNlLm5hbWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2NyaXB0bGV0ID0gdmFsaWRhdG9yLmdldFNjcmlwdGxldEJ5TmFtZShzb3VyY2UubmFtZSk7XG4gIHZhciByZXN1bHQgPSBhdHRhY2hEZXBlbmRlbmNpZXMoc2NyaXB0bGV0KTtcbiAgcmVzdWx0ID0gYWRkQ2FsbChzY3JpcHRsZXQsIHJlc3VsdCk7XG4gIHJlc3VsdCA9IHNvdXJjZS5lbmdpbmUgPT09ICdjb3JlbGlicycgfHwgc291cmNlLmVuZ2luZSA9PT0gJ3Rlc3QnID8gd3JhcEluTm9uYW1lRnVuYyhyZXN1bHQpIDogcGFzc1NvdXJjZUFuZFByb3BzKHNvdXJjZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogU2NyaXB0bGV0cyB2YXJpYWJsZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIG1ldGhvZHM6XG4gKiBgaW52b2tlYCBtZXRob2QgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IHdpdGggYFNvdXJjZWAgdHlwZVxuICogYHZhbGlkYXRlYCBtZXRob2QgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IHdpdGggYFN0cmluZ2AgdHlwZVxuICovXG5cblxudmFyIHNjcmlwdGxldHNPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgaW52b2tlOiBnZXRTY3JpcHRsZXRDb2RlLFxuICAgIGlzVmFsaWRTY3JpcHRsZXROYW1lOiB2YWxpZGF0b3IuaXNWYWxpZFNjcmlwdGxldE5hbWUsXG4gICAgaXNWYWxpZFNjcmlwdGxldFJ1bGU6IGlzVmFsaWRTY3JpcHRsZXRSdWxlLFxuICAgIGlzQWRnU2NyaXB0bGV0UnVsZTogdmFsaWRhdG9yLmlzQWRnU2NyaXB0bGV0UnVsZSxcbiAgICBpc1Vib1NjcmlwdGxldFJ1bGU6IHZhbGlkYXRvci5pc1Vib1NjcmlwdGxldFJ1bGUsXG4gICAgaXNBYnBTbmlwcGV0UnVsZTogdmFsaWRhdG9yLmlzQWJwU25pcHBldFJ1bGUsXG4gICAgY29udmVydFVib1RvQWRnOiBjb252ZXJ0VWJvU2NyaXB0bGV0VG9BZGcsXG4gICAgY29udmVydEFicFRvQWRnOiBjb252ZXJ0QWJwU25pcHBldFRvQWRnLFxuICAgIGNvbnZlcnRTY3JpcHRsZXRUb0FkZzogY29udmVydFNjcmlwdGxldFRvQWRnLFxuICAgIGNvbnZlcnRBZGdUb1VibzogY29udmVydEFkZ1NjcmlwdGxldFRvVWJvLFxuICAgIHJlZGlyZWN0czogcmVkaXJlY3RzQ2pzXG4gIH07XG59KCk7XG5cbi8qKlxuICogQWRkIG1vZHVsZSBleHBvcnRzIHRvIGJlIHVzZWQgYXMgbm9kZSBwYWNrYWdlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBzY3JpcHRsZXRzT2JqZWN0O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIElmIHlvdSB3YW50IHRvIGFkZCB5b3VyIG93biBzY3JpcHRsZXQgIHxcbiAqIHwgIHBsZWFzZSBwdXQgeW91ciBjb2RlIGJlbG93ICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmV4cG9ydHMuYnJvd3NlciA9IHJlcXVpcmUoXCJ3ZWJleHRlbnNpb24tcG9seWZpbGxcIik7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoXCJ3ZWJleHRlbnNpb24tcG9seWZpbGxcIiwgW1wibW9kdWxlXCJdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGZhY3RvcnkobW9kdWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbW9kID0ge1xuICAgICAgZXhwb3J0czoge31cbiAgICB9O1xuICAgIGZhY3RvcnkobW9kKTtcbiAgICBnbG9iYWwuYnJvd3NlciA9IG1vZC5leHBvcnRzO1xuICB9XG59KSh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gIC8qIHdlYmV4dGVuc2lvbi1wb2x5ZmlsbCAtIHYwLjcuMCAtIFR1ZSBOb3YgMTAgMjAyMCAyMDoyNDowNCAqL1xuXG4gIC8qIC0qLSBNb2RlOiBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGpzLWluZGVudC1sZXZlbDogMiAtKi0gKi9cblxuICAvKiB2aW06IHNldCBzdHM9MiBzdz0yIGV0IHR3PTgwOiAqL1xuXG4gIC8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAgICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICAgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZiAodHlwZW9mIGJyb3dzZXIgPT09IFwidW5kZWZpbmVkXCIgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGJyb3dzZXIpICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgY29uc3QgQ0hST01FX1NFTkRfTUVTU0FHRV9DQUxMQkFDS19OT19SRVNQT05TRV9NRVNTQUdFID0gXCJUaGUgbWVzc2FnZSBwb3J0IGNsb3NlZCBiZWZvcmUgYSByZXNwb25zZSB3YXMgcmVjZWl2ZWQuXCI7XG4gICAgY29uc3QgU0VORF9SRVNQT05TRV9ERVBSRUNBVElPTl9XQVJOSU5HID0gXCJSZXR1cm5pbmcgYSBQcm9taXNlIGlzIHRoZSBwcmVmZXJyZWQgd2F5IHRvIHNlbmQgYSByZXBseSBmcm9tIGFuIG9uTWVzc2FnZS9vbk1lc3NhZ2VFeHRlcm5hbCBsaXN0ZW5lciwgYXMgdGhlIHNlbmRSZXNwb25zZSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgc3BlY3MgKFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL01vemlsbGEvQWRkLW9ucy9XZWJFeHRlbnNpb25zL0FQSS9ydW50aW1lL29uTWVzc2FnZSlcIjsgLy8gV3JhcHBpbmcgdGhlIGJ1bGsgb2YgdGhpcyBwb2x5ZmlsbCBpbiBhIG9uZS10aW1lLXVzZSBmdW5jdGlvbiBpcyBhIG1pbm9yXG4gICAgLy8gb3B0aW1pemF0aW9uIGZvciBGaXJlZm94LiBTaW5jZSBTcGlkZXJtb25rZXkgZG9lcyBub3QgZnVsbHkgcGFyc2UgdGhlXG4gICAgLy8gY29udGVudHMgb2YgYSBmdW5jdGlvbiB1bnRpbCB0aGUgZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHNpbmNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBhY3R1YWxseSBuZWVkIHRvIGJlIGNhbGxlZCwgdGhpcyBhbGxvd3MgdGhlIHBvbHlmaWxsIHRvIGJlIGluY2x1ZGVkXG4gICAgLy8gaW4gRmlyZWZveCBuZWFybHkgZm9yIGZyZWUuXG5cbiAgICBjb25zdCB3cmFwQVBJcyA9IGV4dGVuc2lvbkFQSXMgPT4ge1xuICAgICAgLy8gTk9URTogYXBpTWV0YWRhdGEgaXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGVudCBvZiB0aGUgYXBpLW1ldGFkYXRhLmpzb24gZmlsZVxuICAgICAgLy8gYXQgYnVpbGQgdGltZSBieSByZXBsYWNpbmcgdGhlIGZvbGxvd2luZyBcImluY2x1ZGVcIiB3aXRoIHRoZSBjb250ZW50IG9mIHRoZVxuICAgICAgLy8gSlNPTiBmaWxlLlxuICAgICAgY29uc3QgYXBpTWV0YWRhdGEgPSB7XG4gICAgICAgIFwiYWxhcm1zXCI6IHtcbiAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY2xlYXJBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJib29rbWFya3NcIjoge1xuICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Q2hpbGRyZW5cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRSZWNlbnRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRTdWJUcmVlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VHJlZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVUcmVlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VhcmNoXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnJvd3NlckFjdGlvblwiOiB7XG4gICAgICAgICAgXCJkaXNhYmxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZW5hYmxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3JcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRCYWRnZVRleHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3BlblBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3JcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRCYWRnZVRleHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJyb3dzaW5nRGF0YVwiOiB7XG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDYWNoZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNvb2tpZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVEb3dubG9hZHNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVGb3JtRGF0YVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUhpc3RvcnlcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVMb2NhbFN0b3JhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVQYXNzd29yZHNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVQbHVnaW5EYXRhXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjb21tYW5kc1wiOiB7XG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjb250ZXh0TWVudXNcIjoge1xuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY29va2llc1wiOiB7XG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxDb29raWVTdG9yZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJkZXZ0b29sc1wiOiB7XG4gICAgICAgICAgXCJpbnNwZWN0ZWRXaW5kb3dcIjoge1xuICAgICAgICAgICAgXCJldmFsXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyLFxuICAgICAgICAgICAgICBcInNpbmdsZUNhbGxiYWNrQXJnXCI6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInBhbmVsc1wiOiB7XG4gICAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAzLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMyxcbiAgICAgICAgICAgICAgXCJzaW5nbGVDYWxsYmFja0FyZ1wiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJlbGVtZW50c1wiOiB7XG4gICAgICAgICAgICAgIFwiY3JlYXRlU2lkZWJhclBhbmVcIjoge1xuICAgICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZG93bmxvYWRzXCI6IHtcbiAgICAgICAgICBcImNhbmNlbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRvd25sb2FkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZXJhc2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRGaWxlSWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwYXVzZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUZpbGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXN1bWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaG93XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0ZW5zaW9uXCI6IHtcbiAgICAgICAgICBcImlzQWxsb3dlZEZpbGVTY2hlbWVBY2Nlc3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpc0FsbG93ZWRJbmNvZ25pdG9BY2Nlc3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJoaXN0b3J5XCI6IHtcbiAgICAgICAgICBcImFkZFVybFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlbGV0ZUFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlbGV0ZVJhbmdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlVXJsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VmlzaXRzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VhcmNoXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaTE4blwiOiB7XG4gICAgICAgICAgXCJkZXRlY3RMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFjY2VwdExhbmd1YWdlc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImlkZW50aXR5XCI6IHtcbiAgICAgICAgICBcImxhdW5jaFdlYkF1dGhGbG93XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRsZVwiOiB7XG4gICAgICAgICAgXCJxdWVyeVN0YXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibWFuYWdlbWVudFwiOiB7XG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRTZWxmXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0RW5hYmxlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVuaW5zdGFsbFNlbGZcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJub3RpZmljYXRpb25zXCI6IHtcbiAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UGVybWlzc2lvbkxldmVsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGFnZUFjdGlvblwiOiB7XG4gICAgICAgICAgXCJnZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaGlkZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2hvd1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBlcm1pc3Npb25zXCI6IHtcbiAgICAgICAgICBcImNvbnRhaW5zXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVxdWVzdFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInJ1bnRpbWVcIjoge1xuICAgICAgICAgIFwiZ2V0QmFja2dyb3VuZFBhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRQbGF0Zm9ybUluZm9cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuT3B0aW9uc1BhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXF1ZXN0VXBkYXRlQ2hlY2tcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmROYXRpdmVNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VW5pbnN0YWxsVVJMXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic2Vzc2lvbnNcIjoge1xuICAgICAgICAgIFwiZ2V0RGV2aWNlc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFJlY2VudGx5Q2xvc2VkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVzdG9yZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInN0b3JhZ2VcIjoge1xuICAgICAgICAgIFwibG9jYWxcIjoge1xuICAgICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRCeXRlc0luVXNlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtYW5hZ2VkXCI6IHtcbiAgICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRCeXRlc0luVXNlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInN5bmNcIjoge1xuICAgICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRCeXRlc0luVXNlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0YWJzXCI6IHtcbiAgICAgICAgICBcImNhcHR1cmVWaXNpYmxlVGFiXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGV0ZWN0TGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkaXNjYXJkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZHVwbGljYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZXhlY3V0ZVNjcmlwdFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEN1cnJlbnRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRab29tXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Wm9vbVNldHRpbmdzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ29CYWNrXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ29Gb3J3YXJkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaGlnaGxpZ2h0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaW5zZXJ0Q1NTXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInF1ZXJ5XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVsb2FkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ1NTXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogM1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRab29tXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0Wm9vbVNldHRpbmdzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidG9wU2l0ZXNcIjoge1xuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2ViTmF2aWdhdGlvblwiOiB7XG4gICAgICAgICAgXCJnZXRBbGxGcmFtZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRGcmFtZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIndlYlJlcXVlc3RcIjoge1xuICAgICAgICAgIFwiaGFuZGxlckJlaGF2aW9yQ2hhbmdlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIndpbmRvd3NcIjoge1xuICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Q3VycmVudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldExhc3RGb2N1c2VkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhhcGlNZXRhZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFwaS1tZXRhZGF0YS5qc29uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCBpbiBicm93c2VyLXBvbHlmaWxsXCIpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBIFdlYWtNYXAgc3ViY2xhc3Mgd2hpY2ggY3JlYXRlcyBhbmQgc3RvcmVzIGEgdmFsdWUgZm9yIGFueSBrZXkgd2hpY2ggZG9lc1xuICAgICAgICogbm90IGV4aXN0IHdoZW4gYWNjZXNzZWQsIGJ1dCBiZWhhdmVzIGV4YWN0bHkgYXMgYW4gb3JkaW5hcnkgV2Vha01hcFxuICAgICAgICogb3RoZXJ3aXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNyZWF0ZUl0ZW1cbiAgICAgICAqICAgICAgICBBIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGluIG9yZGVyIHRvIGNyZWF0ZSB0aGUgdmFsdWUgZm9yIGFueVxuICAgICAgICogICAgICAgIGtleSB3aGljaCBkb2VzIG5vdCBleGlzdCwgdGhlIGZpcnN0IHRpbWUgaXQgaXMgYWNjZXNzZWQuIFRoZVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVzLCBhcyBpdHMgb25seSBhcmd1bWVudCwgdGhlIGtleSBiZWluZyBjcmVhdGVkLlxuICAgICAgICovXG5cblxuICAgICAgY2xhc3MgRGVmYXVsdFdlYWtNYXAgZXh0ZW5kcyBXZWFrTWFwIHtcbiAgICAgICAgY29uc3RydWN0b3IoY3JlYXRlSXRlbSwgaXRlbXMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdXBlcihpdGVtcyk7XG4gICAgICAgICAgdGhpcy5jcmVhdGVJdGVtID0gY3JlYXRlSXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdGhpcy5jcmVhdGVJdGVtKGtleSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIG9iamVjdCB3aXRoIGEgYHRoZW5gIG1ldGhvZCwgYW5kIGNhblxuICAgICAgICogdGhlcmVmb3JlIGJlIGFzc3VtZWQgdG8gYmVoYXZlIGFzIGEgUHJvbWlzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHRoZW5hYmxlLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgaXNUaGVuYWJsZSA9IHZhbHVlID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoLCB3aGVuIGNhbGxlZCwgd2lsbCByZXNvbHZlIG9yIHJlamVjdFxuICAgICAgICogdGhlIGdpdmVuIHByb21pc2UgYmFzZWQgb24gaG93IGl0IGlzIGNhbGxlZDpcbiAgICAgICAqXG4gICAgICAgKiAtIElmLCB3aGVuIGNhbGxlZCwgYGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcmAgY29udGFpbnMgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgKiAgIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIHdpdGggdGhhdCB2YWx1ZS5cbiAgICAgICAqIC0gSWYgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGV4YWN0bHkgb25lIGFyZ3VtZW50LCB0aGUgcHJvbWlzZSBpc1xuICAgICAgICogICByZXNvbHZlZCB0byB0aGF0IHZhbHVlLlxuICAgICAgICogLSBPdGhlcndpc2UsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG9mIHRoZVxuICAgICAgICogICBmdW5jdGlvbidzIGFyZ3VtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvbWlzZVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXNvbHV0aW9uIGFuZCByZWplY3Rpb24gZnVuY3Rpb25zIG9mIGFcbiAgICAgICAqICAgICAgICBwcm9taXNlLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvbWlzZS5yZXNvbHZlXG4gICAgICAgKiAgICAgICAgVGhlIHByb21pc2UncyByZXNvbHV0aW9uIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvbWlzZS5yZWplY3Rpb25cbiAgICAgICAqICAgICAgICBUaGUgcHJvbWlzZSdzIHJlamVjdGlvbiBmdW5jdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YVxuICAgICAgICogICAgICAgIE1ldGFkYXRhIGFib3V0IHRoZSB3cmFwcGVkIG1ldGhvZCB3aGljaCBoYXMgY3JlYXRlZCB0aGUgY2FsbGJhY2suXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heFJlc29sdmVkQXJnc1xuICAgICAgICogICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBjYWxsYmFjayBjcmVhdGVkIGJ5IHRoZSB3cmFwcGVkIGFzeW5jIGZ1bmN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICAgICAqICAgICAgICBUaGUgZ2VuZXJhdGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgbWFrZUNhbGxiYWNrID0gKHByb21pc2UsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uY2FsbGJhY2tBcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmcgfHwgY2FsbGJhY2tBcmdzLmxlbmd0aCA8PSAxICYmIG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrQXJnc1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShjYWxsYmFja0FyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBsdXJhbGl6ZUFyZ3VtZW50cyA9IG51bUFyZ3MgPT4gbnVtQXJncyA9PSAxID8gXCJhcmd1bWVudFwiIDogXCJhcmd1bWVudHNcIjtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB3aGljaCBpcyBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBtZXRhZGF0YS5taW5BcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbi4gSWYgY2FsbGVkIHdpdGggZmV3ZXIgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heEFyZ3NcbiAgICAgICAqICAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHdoaWNoIG1heSBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24uIElmIGNhbGxlZCB3aXRoIG1vcmUgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heFJlc29sdmVkQXJnc1xuICAgICAgICogICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBjYWxsYmFjayBjcmVhdGVkIGJ5IHRoZSB3cmFwcGVkIGFzeW5jIGZ1bmN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihvYmplY3QsIC4uLiopfVxuICAgICAgICogICAgICAgVGhlIGdlbmVyYXRlZCB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3Qgd3JhcEFzeW5jRnVuY3Rpb24gPSAobmFtZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFzeW5jRnVuY3Rpb25XcmFwcGVyKHRhcmdldCwgLi4uYXJncykge1xuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IG1ldGFkYXRhLm1pbkFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgJHttZXRhZGF0YS5taW5BcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5taW5BcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gbWV0YWRhdGEubWF4QXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBtb3N0ICR7bWV0YWRhdGEubWF4QXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWF4QXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEuZmFsbGJhY2tUb05vQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBBUEkgbWV0aG9kIGhhcyBjdXJyZW50bHkgbm8gY2FsbGJhY2sgb24gQ2hyb21lLCBidXQgaXQgcmV0dXJuIGEgcHJvbWlzZSBvbiBGaXJlZm94LFxuICAgICAgICAgICAgICAvLyBhbmQgc28gdGhlIHBvbHlmaWxsIHdpbGwgdHJ5IHRvIGNhbGwgaXQgd2l0aCBhIGNhbGxiYWNrIGZpcnN0LCBhbmQgaXQgd2lsbCBmYWxsYmFja1xuICAgICAgICAgICAgICAvLyB0byBub3QgcGFzc2luZyB0aGUgY2FsbGJhY2sgaWYgdGhlIGZpcnN0IGNhbGwgZmFpbHMuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MsIG1ha2VDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgfSwgbWV0YWRhdGEpKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoY2JFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtuYW1lfSBBUEkgbWV0aG9kIGRvZXNuJ3Qgc2VlbSB0byBzdXBwb3J0IHRoZSBjYWxsYmFjayBwYXJhbWV0ZXIsIGAgKyBcImZhbGxpbmcgYmFjayB0byBjYWxsIGl0IHdpdGhvdXQgYSBjYWxsYmFjazogXCIsIGNiRXJyb3IpO1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzKTsgLy8gVXBkYXRlIHRoZSBBUEkgbWV0aG9kIG1ldGFkYXRhLCBzbyB0aGF0IHRoZSBuZXh0IEFQSSBjYWxscyB3aWxsIG5vdCB0cnkgdG9cbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHVuc3VwcG9ydGVkIGNhbGxiYWNrIGFueW1vcmUuXG5cbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5mYWxsYmFja1RvTm9DYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLm5vQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRhZGF0YS5ub0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MsIG1ha2VDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgfSwgbWV0YWRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIGFuIGV4aXN0aW5nIG1ldGhvZCBvZiB0aGUgdGFyZ2V0IG9iamVjdCwgc28gdGhhdCBjYWxscyB0byBpdCBhcmVcbiAgICAgICAqIGludGVyY2VwdGVkIGJ5IHRoZSBnaXZlbiB3cmFwcGVyIGZ1bmN0aW9uLiBUaGUgd3JhcHBlciBmdW5jdGlvbiByZWNlaXZlcyxcbiAgICAgICAqIGFzIGl0cyBmaXJzdCBhcmd1bWVudCwgdGhlIG9yaWdpbmFsIGB0YXJnZXRgIG9iamVjdCwgZm9sbG93ZWQgYnkgZWFjaCBvZlxuICAgICAgICogdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0XG4gICAgICAgKiAgICAgICAgVGhlIG9yaWdpbmFsIHRhcmdldCBvYmplY3QgdGhhdCB0aGUgd3JhcHBlZCBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZFxuICAgICAgICogICAgICAgIFRoZSBtZXRob2QgYmVpbmcgd3JhcHBlZC4gVGhpcyBpcyB1c2VkIGFzIHRoZSB0YXJnZXQgb2YgdGhlIFByb3h5XG4gICAgICAgKiAgICAgICAgb2JqZWN0IHdoaWNoIGlzIGNyZWF0ZWQgdG8gd3JhcCB0aGUgbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gd3JhcHBlclxuICAgICAgICogICAgICAgIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBpbiBwbGFjZSBvZiBhIGRpcmVjdCBpbnZvY2F0aW9uXG4gICAgICAgKiAgICAgICAgb2YgdGhlIHdyYXBwZWQgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtQcm94eTxmdW5jdGlvbj59XG4gICAgICAgKiAgICAgICAgQSBQcm94eSBvYmplY3QgZm9yIHRoZSBnaXZlbiBtZXRob2QsIHdoaWNoIGludm9rZXMgdGhlIGdpdmVuIHdyYXBwZXJcbiAgICAgICAqICAgICAgICBtZXRob2QgaW4gaXRzIHBsYWNlLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3Qgd3JhcE1ldGhvZCA9ICh0YXJnZXQsIG1ldGhvZCwgd3JhcHBlcikgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KG1ldGhvZCwge1xuICAgICAgICAgIGFwcGx5KHRhcmdldE1ldGhvZCwgdGhpc09iaiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2FsbCh0aGlzT2JqLCB0YXJnZXQsIC4uLmFyZ3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGxldCBoYXNPd25Qcm9wZXJ0eSA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgYW4gb2JqZWN0IGluIGEgUHJveHkgd2hpY2ggaW50ZXJjZXB0cyBhbmQgd3JhcHMgY2VydGFpbiBtZXRob2RzXG4gICAgICAgKiBiYXNlZCBvbiB0aGUgZ2l2ZW4gYHdyYXBwZXJzYCBhbmQgYG1ldGFkYXRhYCBvYmplY3RzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAgICAgICAqICAgICAgICBUaGUgdGFyZ2V0IG9iamVjdCB0byB3cmFwLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbd3JhcHBlcnMgPSB7fV1cbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgdHJlZSBjb250YWluaW5nIHdyYXBwZXIgZnVuY3Rpb25zIGZvciBzcGVjaWFsIGNhc2VzLiBBbnlcbiAgICAgICAqICAgICAgICBmdW5jdGlvbiBwcmVzZW50IGluIHRoaXMgb2JqZWN0IHRyZWUgaXMgY2FsbGVkIGluIHBsYWNlIG9mIHRoZVxuICAgICAgICogICAgICAgIG1ldGhvZCBpbiB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgYHRhcmdldGAgb2JqZWN0IHRyZWUuIFRoZXNlXG4gICAgICAgKiAgICAgICAgd3JhcHBlciBtZXRob2RzIGFyZSBpbnZva2VkIGFzIGRlc2NyaWJlZCBpbiB7QHNlZSB3cmFwTWV0aG9kfS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW21ldGFkYXRhID0ge31dXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IHRyZWUgY29udGFpbmluZyBtZXRhZGF0YSB1c2VkIHRvIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVcbiAgICAgICAqICAgICAgICBQcm9taXNlLWJhc2VkIHdyYXBwZXIgZnVuY3Rpb25zIGZvciBhc3luY2hyb25vdXMuIEFueSBmdW5jdGlvbiBpblxuICAgICAgICogICAgICAgIHRoZSBgdGFyZ2V0YCBvYmplY3QgdHJlZSB3aGljaCBoYXMgYSBjb3JyZXNwb25kaW5nIG1ldGFkYXRhIG9iamVjdFxuICAgICAgICogICAgICAgIGluIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBgbWV0YWRhdGFgIHRyZWUgaXMgcmVwbGFjZWQgd2l0aCBhblxuICAgICAgICogICAgICAgIGF1dG9tYXRpY2FsbHktZ2VuZXJhdGVkIHdyYXBwZXIgZnVuY3Rpb24sIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICogICAgICAgIHtAc2VlIHdyYXBBc3luY0Z1bmN0aW9ufVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtQcm94eTxvYmplY3Q+fVxuICAgICAgICovXG5cbiAgICAgIGNvbnN0IHdyYXBPYmplY3QgPSAodGFyZ2V0LCB3cmFwcGVycyA9IHt9LCBtZXRhZGF0YSA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IHtcbiAgICAgICAgICBoYXMocHJveHlUYXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldCB8fCBwcm9wIGluIGNhY2hlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXQocHJveHlUYXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBjYWNoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbcHJvcF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKHByb3AgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWV0aG9kIG9uIHRoZSB1bmRlcmx5aW5nIG9iamVjdC4gQ2hlY2sgaWYgd2UgbmVlZCB0byBkb1xuICAgICAgICAgICAgICAvLyBhbnkgd3JhcHBpbmcuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlcnNbcHJvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzcGVjaWFsLWNhc2Ugd3JhcHBlciBmb3IgdGhpcyBtZXRob2QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwTWV0aG9kKHRhcmdldCwgdGFyZ2V0W3Byb3BdLCB3cmFwcGVyc1twcm9wXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyBtZXRob2QgdGhhdCB3ZSBoYXZlIG1ldGFkYXRhIGZvci4gQ3JlYXRlIGFcbiAgICAgICAgICAgICAgICAvLyBQcm9taXNlIHdyYXBwZXIgZm9yIGl0LlxuICAgICAgICAgICAgICAgIGxldCB3cmFwcGVyID0gd3JhcEFzeW5jRnVuY3Rpb24ocHJvcCwgbWV0YWRhdGFbcHJvcF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcE1ldGhvZCh0YXJnZXQsIHRhcmdldFtwcm9wXSwgd3JhcHBlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1ldGhvZCB0aGF0IHdlIGRvbid0IGtub3cgb3IgY2FyZSBhYm91dC4gUmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIG1ldGhvZCwgYm91bmQgdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuYmluZCh0YXJnZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAoaGFzT3duUHJvcGVydHkod3JhcHBlcnMsIHByb3ApIHx8IGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBwcm9wKSkpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBvYmplY3QgdGhhdCB3ZSBuZWVkIHRvIGRvIHNvbWUgd3JhcHBpbmcgZm9yIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAvLyBvZi4gQ3JlYXRlIGEgc3ViLW9iamVjdCB3cmFwcGVyIGZvciBpdCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjaGlsZFxuICAgICAgICAgICAgICAvLyBtZXRhZGF0YS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwT2JqZWN0KHZhbHVlLCB3cmFwcGVyc1twcm9wXSwgbWV0YWRhdGFbcHJvcF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgXCIqXCIpKSB7XG4gICAgICAgICAgICAgIC8vIFdyYXAgYWxsIHByb3BlcnRpZXMgaW4gKiBuYW1lc3BhY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gd3JhcE9iamVjdCh2YWx1ZSwgd3JhcHBlcnNbcHJvcF0sIG1ldGFkYXRhW1wiKlwiXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGRvIGFueSB3cmFwcGluZyBmb3IgdGhpcyBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgLy8gc28ganVzdCBmb3J3YXJkIGFsbCBhY2Nlc3MgdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FjaGUsIHByb3AsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNldChwcm94eVRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBjYWNoZSkge1xuICAgICAgICAgICAgICBjYWNoZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShwcm94eVRhcmdldCwgcHJvcCwgZGVzYykge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoY2FjaGUsIHByb3AsIGRlc2MpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBkZWxldGVQcm9wZXJ0eShwcm94eVRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkoY2FjaGUsIHByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICB9OyAvLyBQZXIgY29udHJhY3Qgb2YgdGhlIFByb3h5IEFQSSwgdGhlIFwiZ2V0XCIgcHJveHkgaGFuZGxlciBtdXN0IHJldHVybiB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHRhcmdldCBpZiB0aGF0IHZhbHVlIGlzIGRlY2xhcmVkIHJlYWQtb25seSBhbmRcbiAgICAgICAgLy8gbm9uLWNvbmZpZ3VyYWJsZS4gRm9yIHRoaXMgcmVhc29uLCB3ZSBjcmVhdGUgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICAgIC8vIHByb3RvdHlwZSBzZXQgdG8gYHRhcmdldGAgaW5zdGVhZCBvZiB1c2luZyBgdGFyZ2V0YCBkaXJlY3RseS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbm5vdCByZXR1cm4gYSBjdXN0b20gb2JqZWN0IGZvciBBUElzIHRoYXRcbiAgICAgICAgLy8gYXJlIGRlY2xhcmVkIHJlYWQtb25seSBhbmQgbm9uLWNvbmZpZ3VyYWJsZSwgc3VjaCBhcyBgY2hyb21lLmRldnRvb2xzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIHByb3h5IGhhbmRsZXJzIHRoZW1zZWx2ZXMgd2lsbCBzdGlsbCB1c2UgdGhlIG9yaWdpbmFsIGB0YXJnZXRgXG4gICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIGBwcm94eVRhcmdldGAsIHNvIHRoYXQgdGhlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXJlXG4gICAgICAgIC8vIGRlcmVmZXJlbmNlZCB2aWEgdGhlIG9yaWdpbmFsIHRhcmdldHMuXG5cbiAgICAgICAgbGV0IHByb3h5VGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZSh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHByb3h5VGFyZ2V0LCBoYW5kbGVycyk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc2V0IG9mIHdyYXBwZXIgZnVuY3Rpb25zIGZvciBhbiBldmVudCBvYmplY3QsIHdoaWNoIGhhbmRsZXNcbiAgICAgICAqIHdyYXBwaW5nIG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0aGF0IHRob3NlIG1lc3NhZ2VzIGFyZSBwYXNzZWQuXG4gICAgICAgKlxuICAgICAgICogQSBzaW5nbGUgd3JhcHBlciBpcyBjcmVhdGVkIGZvciBlYWNoIGxpc3RlbmVyIGZ1bmN0aW9uLCBhbmQgc3RvcmVkIGluIGFcbiAgICAgICAqIG1hcC4gU3Vic2VxdWVudCBjYWxscyB0byBgYWRkTGlzdGVuZXJgLCBgaGFzTGlzdGVuZXJgLCBvciBgcmVtb3ZlTGlzdGVuZXJgXG4gICAgICAgKiByZXRyaWV2ZSB0aGUgb3JpZ2luYWwgd3JhcHBlciwgc28gdGhhdCAgYXR0ZW1wdHMgdG8gcmVtb3ZlIGFcbiAgICAgICAqIHByZXZpb3VzbHktYWRkZWQgbGlzdGVuZXIgd29yayBhcyBleHBlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0RlZmF1bHRXZWFrTWFwPGZ1bmN0aW9uLCBmdW5jdGlvbj59IHdyYXBwZXJNYXBcbiAgICAgICAqICAgICAgICBBIERlZmF1bHRXZWFrTWFwIG9iamVjdCB3aGljaCB3aWxsIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgd3JhcHBlclxuICAgICAgICogICAgICAgIGZvciBhIGdpdmVuIGxpc3RlbmVyIGZ1bmN0aW9uIHdoZW4gb25lIGRvZXMgbm90IGV4aXN0LCBhbmQgcmV0cmlldmVcbiAgICAgICAqICAgICAgICBhbiBleGlzdGluZyBvbmUgd2hlbiBpdCBkb2VzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwRXZlbnQgPSB3cmFwcGVyTWFwID0+ICh7XG4gICAgICAgIGFkZExpc3RlbmVyKHRhcmdldCwgbGlzdGVuZXIsIC4uLmFyZ3MpIHtcbiAgICAgICAgICB0YXJnZXQuYWRkTGlzdGVuZXIod3JhcHBlck1hcC5nZXQobGlzdGVuZXIpLCAuLi5hcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNMaXN0ZW5lcih0YXJnZXQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5oYXNMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lcikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlTGlzdGVuZXIod3JhcHBlck1hcC5nZXQobGlzdGVuZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTsgLy8gS2VlcCB0cmFjayBpZiB0aGUgZGVwcmVjYXRpb24gd2FybmluZyBoYXMgYmVlbiBsb2dnZWQgYXQgbGVhc3Qgb25jZS5cblxuXG4gICAgICBsZXQgbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBvbk1lc3NhZ2VXcmFwcGVycyA9IG5ldyBEZWZhdWx0V2Vha01hcChsaXN0ZW5lciA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHMgYSBtZXNzYWdlIGxpc3RlbmVyIGZ1bmN0aW9uIHNvIHRoYXQgaXQgbWF5IHNlbmQgcmVzcG9uc2VzIGJhc2VkIG9uXG4gICAgICAgICAqIGl0cyByZXR1cm4gdmFsdWUsIHJhdGhlciB0aGFuIGJ5IHJldHVybmluZyBhIHNlbnRpbmVsIHZhbHVlIGFuZCBjYWxsaW5nIGFcbiAgICAgICAgICogY2FsbGJhY2suIElmIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZSwgdGhlIHJlc3BvbnNlIGlzXG4gICAgICAgICAqIHNlbnQgd2hlbiB0aGUgcHJvbWlzZSBlaXRoZXIgcmVzb2x2ZXMgb3IgcmVqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSBtZXNzYWdlXG4gICAgICAgICAqICAgICAgICBUaGUgbWVzc2FnZSBzZW50IGJ5IHRoZSBvdGhlciBlbmQgb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZW5kZXJcbiAgICAgICAgICogICAgICAgIERldGFpbHMgYWJvdXQgdGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqKX0gc2VuZFJlc3BvbnNlXG4gICAgICAgICAqICAgICAgICBBIGNhbGxiYWNrIHdoaWNoLCB3aGVuIGNhbGxlZCB3aXRoIGFuIGFyYml0cmFyeSBhcmd1bWVudCwgc2VuZHNcbiAgICAgICAgICogICAgICAgIHRoYXQgdmFsdWUgYXMgYSByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqICAgICAgICBUcnVlIGlmIHRoZSB3cmFwcGVkIGxpc3RlbmVyIHJldHVybmVkIGEgUHJvbWlzZSwgd2hpY2ggd2lsbCBsYXRlclxuICAgICAgICAgKiAgICAgICAgeWllbGQgYSByZXNwb25zZS4gRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBvbk1lc3NhZ2UobWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICBsZXQgZGlkQ2FsbFNlbmRSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgIGxldCB3cmFwcGVkU2VuZFJlc3BvbnNlO1xuICAgICAgICAgIGxldCBzZW5kUmVzcG9uc2VQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkU2VuZFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGlmICghbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFNFTkRfUkVTUE9OU0VfREVQUkVDQVRJT05fV0FSTklORywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaWRDYWxsU2VuZFJlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIobWVzc2FnZSwgc2VuZGVyLCB3cmFwcGVkU2VuZFJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNSZXN1bHRUaGVuYWJsZSA9IHJlc3VsdCAhPT0gdHJ1ZSAmJiBpc1RoZW5hYmxlKHJlc3VsdCk7IC8vIElmIHRoZSBsaXN0ZW5lciBkaWRuJ3QgcmV0dXJuZWQgdHJ1ZSBvciBhIFByb21pc2UsIG9yIGNhbGxlZFxuICAgICAgICAgIC8vIHdyYXBwZWRTZW5kUmVzcG9uc2Ugc3luY2hyb25vdXNseSwgd2UgY2FuIGV4aXQgZWFybGllclxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSBubyByZXNwb25zZSBzZW50IGZyb20gdGhpcyBsaXN0ZW5lci5cblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUgJiYgIWlzUmVzdWx0VGhlbmFibGUgJiYgIWRpZENhbGxTZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIEEgc21hbGwgaGVscGVyIHRvIHNlbmQgdGhlIG1lc3NhZ2UgaWYgdGhlIHByb21pc2UgcmVzb2x2ZXNcbiAgICAgICAgICAvLyBhbmQgYW4gZXJyb3IgaWYgdGhlIHByb21pc2UgcmVqZWN0cyAoYSB3cmFwcGVkIHNlbmRNZXNzYWdlIGhhc1xuICAgICAgICAgIC8vIHRvIHRyYW5zbGF0ZSB0aGUgbWVzc2FnZSBpbnRvIGEgcmVzb2x2ZWQgcHJvbWlzZSBvciBhIHJlamVjdGVkXG4gICAgICAgICAgLy8gcHJvbWlzZSkuXG5cblxuICAgICAgICAgIGNvbnN0IHNlbmRQcm9taXNlZFJlc3VsdCA9IHByb21pc2UgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKG1zZyA9PiB7XG4gICAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1lc3NhZ2UgdmFsdWUuXG4gICAgICAgICAgICAgIHNlbmRSZXNwb25zZShtc2cpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAvLyBTZW5kIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaWYgdGhlIHJlamVjdGVkIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGlzIGFuIGluc3RhbmNlIG9mIGVycm9yLCBvciB0aGUgb2JqZWN0IGl0c2VsZiBvdGhlcndpc2UuXG4gICAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuXG4gICAgICAgICAgICAgIGlmIChlcnJvciAmJiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIF9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgLy8gUHJpbnQgYW4gZXJyb3Igb24gdGhlIGNvbnNvbGUgaWYgdW5hYmxlIHRvIHNlbmQgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgb25NZXNzYWdlIHJlamVjdGVkIHJlcGx5XCIsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJuZWQgYSBQcm9taXNlLCBzZW5kIHRoZSByZXNvbHZlZCB2YWx1ZSBhcyBhXG4gICAgICAgICAgLy8gcmVzdWx0LCBvdGhlcndpc2Ugd2FpdCB0aGUgcHJvbWlzZSByZWxhdGVkIHRvIHRoZSB3cmFwcGVkU2VuZFJlc3BvbnNlXG4gICAgICAgICAgLy8gY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbmQgc2VuZCBpdCBhcyBhIHJlc3BvbnNlLlxuXG5cbiAgICAgICAgICBpZiAoaXNSZXN1bHRUaGVuYWJsZSkge1xuICAgICAgICAgICAgc2VuZFByb21pc2VkUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRQcm9taXNlZFJlc3VsdChzZW5kUmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICB9IC8vIExldCBDaHJvbWUga25vdyB0aGF0IHRoZSBsaXN0ZW5lciBpcyByZXBseWluZy5cblxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgd3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2sgPSAoe1xuICAgICAgICByZWplY3QsXG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0sIHJlcGx5KSA9PiB7XG4gICAgICAgIGlmIChleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IHdoZW4gbm9uZSBvZiB0aGUgbGlzdGVuZXJzIHJlcGxpZWQgdG8gdGhlIHNlbmRNZXNzYWdlIGNhbGwgYW5kIHJlc29sdmVcbiAgICAgICAgICAvLyB0aGUgcHJvbWlzZSB0byB1bmRlZmluZWQgYXMgaW4gRmlyZWZveC5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsL2lzc3Vlcy8xMzBcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlID09PSBDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXBseSAmJiByZXBseS5fX21veldlYkV4dGVuc2lvblBvbHlmaWxsUmVqZWN0X18pIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yIGludG9cbiAgICAgICAgICAvLyBhbiBFcnJvciBpbnN0YW5jZS5cbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKHJlcGx5Lm1lc3NhZ2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHJlcGx5KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgd3JhcHBlZFNlbmRNZXNzYWdlID0gKG5hbWUsIG1ldGFkYXRhLCBhcGlOYW1lc3BhY2VPYmosIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgbWV0YWRhdGEubWluQXJncykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgJHttZXRhZGF0YS5taW5BcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5taW5BcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBtZXRhZGF0YS5tYXhBcmdzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBtb3N0ICR7bWV0YWRhdGEubWF4QXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWF4QXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVkQ2IgPSB3cmFwcGVkU2VuZE1lc3NhZ2VDYWxsYmFjay5iaW5kKG51bGwsIHtcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICByZWplY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcmdzLnB1c2god3JhcHBlZENiKTtcbiAgICAgICAgICBhcGlOYW1lc3BhY2VPYmouc2VuZE1lc3NhZ2UoLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RhdGljV3JhcHBlcnMgPSB7XG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICBvbk1lc3NhZ2U6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgb25NZXNzYWdlRXh0ZXJuYWw6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB0YWJzOiB7XG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMixcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0dGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjbGVhcjoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhcGlNZXRhZGF0YS5wcml2YWN5ID0ge1xuICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgd2Vic2l0ZXM6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gd3JhcE9iamVjdChleHRlbnNpb25BUElzLCBzdGF0aWNXcmFwcGVycywgYXBpTWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNocm9tZSAhPSBcIm9iamVjdFwiIHx8ICFjaHJvbWUgfHwgIWNocm9tZS5ydW50aW1lIHx8ICFjaHJvbWUucnVudGltZS5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzY3JpcHQgc2hvdWxkIG9ubHkgYmUgbG9hZGVkIGluIGEgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgIH0gLy8gVGhlIGJ1aWxkIHByb2Nlc3MgYWRkcyBhIFVNRCB3cmFwcGVyIGFyb3VuZCB0aGlzIGZpbGUsIHdoaWNoIG1ha2VzIHRoZVxuICAgIC8vIGBtb2R1bGVgIHZhcmlhYmxlIGF2YWlsYWJsZS5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3cmFwQVBJcyhjaHJvbWUpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gYnJvd3NlcjtcbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLXBvbHlmaWxsLmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCB7IGNvbnRlbnQgfSBmcm9tICcuLi8uLi9wYWdlcy9jb250ZW50JztcbmNvbnNvbGUubG9nKGBUaW1lIGZyb20gY29udGVudCBzY3JpcHQ6ICR7RGF0ZS5ub3coKX1gKTtcbmNvbnRlbnQuaW5pdCgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==