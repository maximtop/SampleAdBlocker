/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _asyncToGenerator)\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanM/MWRhMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzP2EzNGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0hBQStDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./src/common/constants.ts":
/*!*********************************!*\
  !*** ./src/common/constants.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Messages\": () => (/* binding */ Messages)\n/* harmony export */ });\nvar Messages;\n\n(function (Messages) {\n  Messages[\"GetSelectorsAndScripts\"] = \"get_selectors_and_scripts\";\n})(Messages || (Messages = {}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vc3JjL2NvbW1vbi9jb25zdGFudHMudHM/MmZjMiJdLCJuYW1lcyI6WyJNZXNzYWdlcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFPLElBQUtBLFFBQVo7O1dBQVlBLFE7QUFBQUEsVTtHQUFBQSxRLEtBQUFBLFEiLCJmaWxlIjoiLi9zcmMvY29tbW9uL2NvbnN0YW50cy50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBlbnVtIE1lc3NhZ2VzIHtcbiAgICBHZXRTZWxlY3RvcnNBbmRTY3JpcHRzID0gJ2dldF9zZWxlY3RvcnNfYW5kX3NjcmlwdHMnLFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/common/constants.ts\n");

/***/ }),

/***/ "./src/content.ts":
/*!************************!*\
  !*** ./src/content.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var webextension_polyfill_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! webextension-polyfill-ts */ \"./node_modules/webextension-polyfill-ts/lib/index.js\");\n/* harmony import */ var scriptlets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scriptlets */ \"./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js\");\n/* harmony import */ var scriptlets__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(scriptlets__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var extended_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! extended-css */ \"./node_modules/extended-css/dist/extended-css.esm.js\");\n/* harmony import */ var _common_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./common/constants */ \"./src/common/constants.ts\");\n\n\n\n/* eslint-disable no-console */\n\n\n\n\n/**\n * Logs a message if verbose is true\n *\n * @param verbose\n * @param message\n */\n\nvar logMessage = function logMessage(verbose, message) {\n  if (verbose) {\n    console.log(\"(AG) \".concat(message));\n  }\n};\n\nvar getSelectorsAndScripts = /*#__PURE__*/function () {\n  var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee() {\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", webextension_polyfill_ts__WEBPACK_IMPORTED_MODULE_2__.browser.runtime.sendMessage({\n              type: _common_constants__WEBPACK_IMPORTED_MODULE_5__.Messages.GetSelectorsAndScripts,\n              data: {\n                url: window.location.href\n              }\n            }));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getSelectorsAndScripts() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Execute scripts in a page context and cleanup itself when execution completes\n * @param scripts Scripts array to execute\n */\n\n\nvar executeScripts = function executeScripts(scripts) {\n  // Wrap with try catch\n  scripts.unshift('( function () { try {');\n  scripts.push(\"} catch (ex) { console.error('Error executing AG js: ' + ex); } })();\");\n  var scriptTag = document.createElement('script');\n  scriptTag.setAttribute('type', 'text/javascript');\n  scriptTag.textContent = scripts.join('\\r\\n');\n  var parent = document.head || document.documentElement;\n  parent.appendChild(scriptTag);\n\n  if (scriptTag.parentNode) {\n    scriptTag.parentNode.removeChild(scriptTag);\n  }\n};\n/**\n * Applies JS injections.\n * @param scripts Array with JS scripts\n * @param verbose logging\n */\n\n\nvar applyScripts = function applyScripts(scripts, verbose) {\n  if (!scripts || scripts.length === 0) {\n    return;\n  }\n\n  logMessage(verbose, \"scripts length: \".concat(scripts.length));\n  executeScripts(scripts.reverse());\n};\n/**\n * Protects specified style element from changes to the current document\n * Add a mutation observer, which is adds our rules again if it was removed\n *\n * @param protectStyleEl protected style element\n */\n\n\nvar protectStyleElementContent = function protectStyleElementContent(protectStyleEl) {\n  // @ts-ignore\n  var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n  if (!MutationObserver) {\n    return;\n  }\n  /* observer, which observe protectStyleEl inner changes, without deleting styleEl */\n\n\n  var innerObserver = new MutationObserver(function (mutations) {\n    for (var i = 0; i < mutations.length; i += 1) {\n      var m = mutations[i]; // @ts-ignore\n\n      if (protectStyleEl.hasAttribute('mod') && protectStyleEl.getAttribute('mod') === 'inner') {\n        // @ts-ignore\n        protectStyleEl.removeAttribute('mod');\n        break;\n      } // @ts-ignore\n\n\n      protectStyleEl.setAttribute('mod', 'inner');\n      var isProtectStyleElModified = false;\n      /**\n       * further, there are two mutually exclusive situations: either there were changes\n       * the text of protectStyleEl, either there was removes a whole child \"text\"\n       * element of protectStyleEl we'll process both of them\n       */\n\n      if (m.removedNodes.length > 0) {\n        for (var j = 0; j < m.removedNodes.length; j += 1) {\n          isProtectStyleElModified = true;\n          protectStyleEl.appendChild(m.removedNodes[j]);\n        }\n      } else if (m.oldValue) {\n        isProtectStyleElModified = true; // eslint-disable-next-line no-param-reassign\n\n        protectStyleEl.textContent = m.oldValue;\n      }\n\n      if (!isProtectStyleElModified) {\n        // @ts-ignore\n        protectStyleEl.removeAttribute('mod');\n      }\n    }\n  });\n  innerObserver.observe(protectStyleEl, {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    characterDataOldValue: true\n  });\n};\n/**\n * Applies css stylesheet\n * @param styleSelectors Array of stylesheets or selectors\n * @param verbose logging\n */\n\n\nvar applyCss = function applyCss(styleSelectors, verbose) {\n  if (!styleSelectors || !styleSelectors.length) {\n    return;\n  }\n\n  logMessage(verbose, \"css length: \".concat(styleSelectors.length));\n  var styleElement = document.createElement('style');\n  styleElement.setAttribute('type', 'text/css');\n  (document.head || document.documentElement).appendChild(styleElement);\n  var selectors = styleSelectors.map(function (s) {\n    return s.trim();\n  });\n  selectors.forEach(function (selector) {\n    styleElement.sheet.insertRule(selector);\n  });\n  protectStyleElementContent(styleElement);\n};\n/**\n * Applies Extended Css stylesheet\n *\n * @param extendedCss Array with ExtendedCss stylesheets\n * @param verbose logging\n */\n\n\nvar applyExtendedCss = function applyExtendedCss(extendedCss, verbose) {\n  if (!extendedCss || !extendedCss.length) {\n    return;\n  }\n\n  logMessage(verbose, \"extended css length: \".concat(extendedCss.length));\n  var extcss = new extended_css__WEBPACK_IMPORTED_MODULE_4__.default({\n    styleSheet: extendedCss.filter(function (s) {\n      return s.length > 0;\n    }).map(function (s) {\n      return s.trim();\n    }).map(function (s) {\n      return s[s.length - 1] !== '}' ? \"\".concat(s, \" {display:none!important;}\") : s;\n    }).join('\\n')\n  });\n  extcss.apply();\n};\n/**\n * Applies scriptlets\n *\n * @param scriptletsData Array with scriptlets data\n * @param verbose logging\n */\n\n\nvar applyScriptlets = function applyScriptlets(scriptletsData, verbose) {\n  if (!scriptletsData || !scriptletsData.length) {\n    return;\n  }\n\n  logMessage(verbose, \"scriptlets length: \".concat(scriptletsData.length));\n  var scriptletExecutableScripts = scriptletsData.map(function (s) {\n    var param = JSON.parse(s);\n    param.engine = 'safari-extension';\n\n    if (verbose) {\n      param.verbose = true;\n    }\n\n    var code = (scriptlets__WEBPACK_IMPORTED_MODULE_3___default()) && scriptlets__WEBPACK_IMPORTED_MODULE_3___default().invoke(param);\n    return code || '';\n  });\n  console.log(scriptletExecutableScripts);\n  executeScripts(scriptletExecutableScripts); // @ts-ignore\n\n  console.log(window.adg);\n};\n\n/**\n * Applies injected script and css\n *\n * @param selectorsAndScripts\n * @param verbose\n */\nvar applyAdvancedBlockingData = function applyAdvancedBlockingData(selectorsAndScripts) {\n  var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  logMessage(verbose, 'Applying scripts and css..');\n  logMessage(verbose, \"Frame url: \".concat(window.location.href));\n  applyScripts(selectorsAndScripts.scripts, verbose);\n  applyCss(selectorsAndScripts.cssInject, verbose);\n  applyExtendedCss(selectorsAndScripts.cssExtended, verbose);\n  applyScriptlets(selectorsAndScripts.scriptlets, verbose);\n  logMessage(verbose, 'Applying scripts and css - done');\n};\n\nvar main = /*#__PURE__*/function () {\n  var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2() {\n    var selectorsAndScripts;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(document instanceof HTMLDocument)) {\n              _context2.next = 6;\n              break;\n            }\n\n            if (!(window.location.href && window.location.href.indexOf('http') === 0)) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 4;\n            return getSelectorsAndScripts();\n\n          case 4:\n            selectorsAndScripts = _context2.sent;\n            applyAdvancedBlockingData(selectorsAndScripts);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function main() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmain();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vc3JjL2NvbnRlbnQudHM/MTA1ZCJdLCJuYW1lcyI6WyJsb2dNZXNzYWdlIiwidmVyYm9zZSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwibG9nIiwiZ2V0U2VsZWN0b3JzQW5kU2NyaXB0cyIsImJyb3dzZXIiLCJ0eXBlIiwiTWVzc2FnZXMiLCJkYXRhIiwidXJsIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiZXhlY3V0ZVNjcmlwdHMiLCJzY3JpcHRzIiwidW5zaGlmdCIsInB1c2giLCJzY3JpcHRUYWciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJ0ZXh0Q29udGVudCIsImpvaW4iLCJwYXJlbnQiLCJoZWFkIiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBseVNjcmlwdHMiLCJsZW5ndGgiLCJyZXZlcnNlIiwicHJvdGVjdFN0eWxlRWxlbWVudENvbnRlbnQiLCJwcm90ZWN0U3R5bGVFbCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiaW5uZXJPYnNlcnZlciIsIm11dGF0aW9ucyIsImkiLCJtIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiaXNQcm90ZWN0U3R5bGVFbE1vZGlmaWVkIiwicmVtb3ZlZE5vZGVzIiwiaiIsIm9sZFZhbHVlIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiYXBwbHlDc3MiLCJzdHlsZVNlbGVjdG9ycyIsInN0eWxlRWxlbWVudCIsInNlbGVjdG9ycyIsIm1hcCIsInMiLCJ0cmltIiwiZm9yRWFjaCIsInNlbGVjdG9yIiwic2hlZXQiLCJpbnNlcnRSdWxlIiwiYXBwbHlFeHRlbmRlZENzcyIsImV4dGVuZGVkQ3NzIiwiZXh0Y3NzIiwiRXh0ZW5kZWRDc3MiLCJzdHlsZVNoZWV0IiwiZmlsdGVyIiwiYXBwbHkiLCJhcHBseVNjcmlwdGxldHMiLCJzY3JpcHRsZXRzRGF0YSIsInNjcmlwdGxldEV4ZWN1dGFibGVTY3JpcHRzIiwicGFyYW0iLCJKU09OIiwicGFyc2UiLCJlbmdpbmUiLCJjb2RlIiwic2NyaXB0bGV0cyIsImFkZyIsImFwcGx5QWR2YW5jZWRCbG9ja2luZ0RhdGEiLCJzZWxlY3RvcnNBbmRTY3JpcHRzIiwiY3NzSW5qZWN0IiwiY3NzRXh0ZW5kZWQiLCJtYWluIiwiSFRNTERvY3VtZW50IiwiaW5kZXhPZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFNQSxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFDQyxPQUFELEVBQW1CQyxPQUFuQixFQUF1QztBQUN0RCxNQUFJRCxPQUFKLEVBQWE7QUFDVEUsV0FBTyxDQUFDQyxHQUFSLGdCQUFvQkYsT0FBcEI7QUFDSDtBQUNKLENBSkQ7O0FBTUEsSUFBTUcsc0JBQXNCO0FBQUEsbUxBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZDQUNwQkMsaUZBQUEsQ0FBNEI7QUFDL0JDLGtCQUFJLEVBQUVDLDhFQUR5QjtBQUUvQkMsa0JBQUksRUFBRTtBQUNGQyxtQkFBRyxFQUFFQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDO0FBRG5CO0FBRnlCLGFBQTVCLENBRG9COztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUg7O0FBQUEsa0JBQXRCUixzQkFBc0I7QUFBQTtBQUFBO0FBQUEsR0FBNUI7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsSUFBTVMsY0FBYyxHQUFHLFNBQWpCQSxjQUFpQixDQUFDQyxPQUFELEVBQXVCO0FBQzFDO0FBQ0FBLFNBQU8sQ0FBQ0MsT0FBUixDQUFnQix1QkFBaEI7QUFDQUQsU0FBTyxDQUFD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QTtBQUFBLGtCQU9MbEUsUUFBUSxZQUFZbUUsWUFQZjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFRRDNFLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsSUFBaEIsSUFBd0JGLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsSUFBaEIsQ0FBcUIwRSxPQUFyQixDQUE2QixNQUE3QixNQUF5QyxDQVJoRTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQVNpQ2xGLHNCQUFzQixFQVR2RDs7QUFBQTtBQVNLNkUsK0JBVEw7QUFVREQscUNBQXlCLENBQUNDLG1CQUFELENBQXpCOztBQVZDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBQUg7O0FBQUEsa0JBQUpHLElBQUk7QUFBQTtBQUFBO0FBQUEsR0FBVjs7QUFlQUEsSUFBSSIsImZpbGUiOiIuL3NyYy9jb250ZW50LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuaW1wb3J0IHsgYnJvd3NlciB9IGZyb20gJ3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC10cyc7XG5pbXBvcnQgc2NyaXB0bGV0cyBmcm9tICdzY3JpcHRsZXRzJztcbmltcG9ydCBFeHRlbmRlZENzcyBmcm9tICdleHRlbmRlZC1jc3MnO1xuXG5pbXBvcnQgeyBNZXNzYWdlcyB9IGZyb20gJy4vY29tbW9uL2NvbnN0YW50cyc7XG5cbi8qKlxuICogTG9ncyBhIG1lc3NhZ2UgaWYgdmVyYm9zZSBpcyB0cnVlXG4gKlxuICogQHBhcmFtIHZlcmJvc2VcbiAqIEBwYXJhbSBtZXNzYWdlXG4gKi9cbmNvbnN0IGxvZ01lc3NhZ2UgPSAodmVyYm9zZTogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coYChBRykgJHttZXNzYWdlfWApO1xuICAgIH1cbn07XG5cbmNvbnN0IGdldFNlbGVjdG9yc0FuZFNjcmlwdHMgPSBhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIGJyb3dzZXIucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IE1lc3NhZ2VzLkdldFNlbGVjdG9yc0FuZFNjcmlwdHMsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHVybDogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgc2NyaXB0cyBpbiBhIHBhZ2UgY29udGV4dCBhbmQgY2xlYW51cCBpdHNlbGYgd2hlbiBleGVjdXRpb24gY29tcGxldGVzXG4gKiBAcGFyYW0gc2NyaXB0cyBTY3JpcHRzIGFycmF5IHRvIGV4ZWN1dGVcbiAqL1xuY29uc3QgZXhlY3V0ZVNjcmlwdHMgPSAoc2NyaXB0czogc3RyaW5nW10pID0+IHtcbiAgICAvLyBXcmFwIHdpdGggdHJ5IGNhdGNoXG4gICAgc2NyaXB0cy51bnNoaWZ0KCcoIGZ1bmN0aW9uICgpIHsgdHJ5IHsnKTtcbiAgICBzY3JpcHRzLnB1c2goXCJ9IGNhdGNoIChleCkgeyBjb25zb2xlLmVycm9yKCdFcnJvciBleGVjdXRpbmcgQUcganM6ICcgKyBleCk7IH0gfSkoKTtcIik7XG5cbiAgICBjb25zdCBzY3JpcHRUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzY3JpcHRUYWcuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvamF2YXNjcmlwdCcpO1xuICAgIHNjcmlwdFRhZy50ZXh0Q29udGVudCA9IHNjcmlwdHMuam9pbignXFxyXFxuJyk7XG5cbiAgICBjb25zdCBwYXJlbnQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoc2NyaXB0VGFnKTtcbiAgICBpZiAoc2NyaXB0VGFnLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc2NyaXB0VGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0VGFnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgSlMgaW5qZWN0aW9ucy5cbiAqIEBwYXJhbSBzY3JpcHRzIEFycmF5IHdpdGggSlMgc2NyaXB0c1xuICogQHBhcmFtIHZlcmJvc2UgbG9nZ2luZ1xuICovXG5jb25zdCBhcHBseVNjcmlwdHMgPSAoc2NyaXB0czogc3RyaW5nW10sIHZlcmJvc2U6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAoIXNjcmlwdHMgfHwgc2NyaXB0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ01lc3NhZ2UodmVyYm9zZSwgYHNjcmlwdHMgbGVuZ3RoOiAke3NjcmlwdHMubGVuZ3RofWApO1xuICAgIGV4ZWN1dGVTY3JpcHRzKHNjcmlwdHMucmV2ZXJzZSgpKTtcbn07XG5cbi8qKlxuICogUHJvdGVjdHMgc3BlY2lmaWVkIHN0eWxlIGVsZW1lbnQgZnJvbSBjaGFuZ2VzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBBZGQgYSBtdXRhdGlvbiBvYnNlcnZlciwgd2hpY2ggaXMgYWRkcyBvdXIgcnVsZXMgYWdhaW4gaWYgaXQgd2FzIHJlbW92ZWRcbiAqXG4gKiBAcGFyYW0gcHJvdGVjdFN0eWxlRWwgcHJvdGVjdGVkIHN0eWxlIGVsZW1lbnRcbiAqL1xuY29uc3QgcHJvdGVjdFN0eWxlRWxlbWVudENvbnRlbnQgPSAocHJvdGVjdFN0eWxlRWw6IE5vZGUpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIG9ic2VydmVyLCB3aGljaCBvYnNlcnZlIHByb3RlY3RTdHlsZUVsIGlubmVyIGNoYW5nZXMsIHdpdGhvdXQgZGVsZXRpbmcgc3R5bGVFbCAqL1xuICAgIGNvbnN0IGlubmVyT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgbSA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChwcm90ZWN0U3R5bGVFbC5oYXNBdHRyaWJ1dGUoJ21vZCcpICYmIHByb3RlY3RTdHlsZUVsLmdldEF0dHJpYnV0ZSgnbW9kJykgPT09ICdpbm5lcicpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcHJvdGVjdFN0eWxlRWwucmVtb3ZlQXR0cmlidXRlKCdtb2QnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcHJvdGVjdFN0eWxlRWwuc2V0QXR0cmlidXRlKCdtb2QnLCAnaW5uZXInKTtcbiAgICAgICAgICAgIGxldCBpc1Byb3RlY3RTdHlsZUVsTW9kaWZpZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBmdXJ0aGVyLCB0aGVyZSBhcmUgdHdvIG11dHVhbGx5IGV4Y2x1c2l2ZSBzaXR1YXRpb25zOiBlaXRoZXIgdGhlcmUgd2VyZSBjaGFuZ2VzXG4gICAgICAgICAgICAgKiB0aGUgdGV4dCBvZiBwcm90ZWN0U3R5bGVFbCwgZWl0aGVyIHRoZXJlIHdhcyByZW1vdmVzIGEgd2hvbGUgY2hpbGQgXCJ0ZXh0XCJcbiAgICAgICAgICAgICAqIGVsZW1lbnQgb2YgcHJvdGVjdFN0eWxlRWwgd2UnbGwgcHJvY2VzcyBib3RoIG9mIHRoZW1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG0ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJvdGVjdFN0eWxlRWxNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHByb3RlY3RTdHlsZUVsLmFwcGVuZENoaWxkKG0ucmVtb3ZlZE5vZGVzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpc1Byb3RlY3RTdHlsZUVsTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIHByb3RlY3RTdHlsZUVsLnRleHRDb250ZW50ID0gbS5vbGRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1Byb3RlY3RTdHlsZUVsTW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgcHJvdGVjdFN0eWxlRWwucmVtb3ZlQXR0cmlidXRlKCdtb2QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIGlubmVyT2JzZXJ2ZXIub2JzZXJ2ZShwcm90ZWN0U3R5bGVFbCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQXBwbGllcyBjc3Mgc3R5bGVzaGVldFxuICogQHBhcmFtIHN0eWxlU2VsZWN0b3JzIEFycmF5IG9mIHN0eWxlc2hlZXRzIG9yIHNlbGVjdG9yc1xuICogQHBhcmFtIHZlcmJvc2UgbG9nZ2luZ1xuICovXG5jb25zdCBhcHBseUNzcyA9IChzdHlsZVNlbGVjdG9yczogc3RyaW5nW10sIHZlcmJvc2U6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAoIXN0eWxlU2VsZWN0b3JzIHx8ICFzdHlsZVNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ01lc3NhZ2UodmVyYm9zZSwgYGNzcyBsZW5ndGg6ICR7c3R5bGVTZWxlY3RvcnMubGVuZ3RofWApO1xuXG4gICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXG4gICAgY29uc3Qgc2VsZWN0b3JzID0gc3R5bGVTZWxlY3RvcnMubWFwKChzKSA9PiBzLnRyaW0oKSk7XG4gICAgc2VsZWN0b3JzLmZvckVhY2goKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5zaGVldCEuaW5zZXJ0UnVsZShzZWxlY3Rvcik7XG4gICAgfSk7XG5cbiAgICBwcm90ZWN0U3R5bGVFbGVtZW50Q29udGVudChzdHlsZUVsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIEV4dGVuZGVkIENzcyBzdHlsZXNoZWV0XG4gKlxuICogQHBhcmFtIGV4dGVuZGVkQ3NzIEFycmF5IHdpdGggRXh0ZW5kZWRDc3Mgc3R5bGVzaGVldHNcbiAqIEBwYXJhbSB2ZXJib3NlIGxvZ2dpbmdcbiAqL1xuY29uc3QgYXBwbHlFeHRlbmRlZENzcyA9IChleHRlbmRlZENzczogc3RyaW5nW10sIHZlcmJvc2U6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAoIWV4dGVuZGVkQ3NzIHx8ICFleHRlbmRlZENzcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ01lc3NhZ2UodmVyYm9zZSwgYGV4dGVuZGVkIGNzcyBsZW5ndGg6ICR7ZXh0ZW5kZWRDc3MubGVuZ3RofWApO1xuICAgIGNvbnN0IGV4dGNzcyA9IG5ldyBFeHRlbmRlZENzcyh7XG4gICAgICAgIHN0eWxlU2hlZXQ6IGV4dGVuZGVkQ3NzXG4gICAgICAgICAgICAuZmlsdGVyKChzKSA9PiBzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAubWFwKChzKSA9PiBzLnRyaW0oKSlcbiAgICAgICAgICAgIC5tYXAoKHMpID0+IChzW3MubGVuZ3RoIC0gMV0gIT09ICd9JyA/IGAke3N9IHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50O31gIDogcykpXG4gICAgICAgICAgICAuam9pbignXFxuJyksXG4gICAgfSk7XG4gICAgZXh0Y3NzLmFwcGx5KCk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgc2NyaXB0bGV0c1xuICpcbiAqIEBwYXJhbSBzY3JpcHRsZXRzRGF0YSBBcnJheSB3aXRoIHNjcmlwdGxldHMgZGF0YVxuICogQHBhcmFtIHZlcmJvc2UgbG9nZ2luZ1xuICovXG5jb25zdCBhcHBseVNjcmlwdGxldHMgPSAoc2NyaXB0bGV0c0RhdGE6IHN0cmluZ1tdLCB2ZXJib3NlOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFzY3JpcHRsZXRzRGF0YSB8fCAhc2NyaXB0bGV0c0RhdGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dNZXNzYWdlKHZlcmJvc2UsIGBzY3JpcHRsZXRzIGxlbmd0aDogJHtzY3JpcHRsZXRzRGF0YS5sZW5ndGh9YCk7XG4gICAgY29uc3Qgc2NyaXB0bGV0RXhlY3V0YWJsZVNjcmlwdHMgPSBzY3JpcHRsZXRzRGF0YVxuICAgICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICBwYXJhbS5lbmdpbmUgPSAnc2FmYXJpLWV4dGVuc2lvbic7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLnZlcmJvc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gc2NyaXB0bGV0cyAmJiBzY3JpcHRsZXRzLmludm9rZShwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gY29kZSB8fCAnJztcbiAgICAgICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZyhzY3JpcHRsZXRFeGVjdXRhYmxlU2NyaXB0cyk7XG4gICAgZXhlY3V0ZVNjcmlwdHMoc2NyaXB0bGV0RXhlY3V0YWJsZVNjcmlwdHMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zb2xlLmxvZyh3aW5kb3cuYWRnKTtcbn07XG5cbmludGVyZmFjZSBTZWxlY3RvcnNBbmRTY3JpcHRzIHtcbiAgICBzY3JpcHRzOiBzdHJpbmdbXSxcbiAgICBjc3NJbmplY3Q6IHN0cmluZ1tdLFxuICAgIGNzc0V4dGVuZGVkOiBzdHJpbmdbXSxcbiAgICBzY3JpcHRsZXRzOiBzdHJpbmdbXSxcbn1cbi8qKlxuICogQXBwbGllcyBpbmplY3RlZCBzY3JpcHQgYW5kIGNzc1xuICpcbiAqIEBwYXJhbSBzZWxlY3RvcnNBbmRTY3JpcHRzXG4gKiBAcGFyYW0gdmVyYm9zZVxuICovXG5jb25zdCBhcHBseUFkdmFuY2VkQmxvY2tpbmdEYXRhID0gKHNlbGVjdG9yc0FuZFNjcmlwdHM6IFNlbGVjdG9yc0FuZFNjcmlwdHMsIHZlcmJvc2UgPSB0cnVlKSA9PiB7XG4gICAgbG9nTWVzc2FnZSh2ZXJib3NlLCAnQXBwbHlpbmcgc2NyaXB0cyBhbmQgY3NzLi4nKTtcbiAgICBsb2dNZXNzYWdlKHZlcmJvc2UsIGBGcmFtZSB1cmw6ICR7d2luZG93LmxvY2F0aW9uLmhyZWZ9YCk7XG5cbiAgICBhcHBseVNjcmlwdHMoc2VsZWN0b3JzQW5kU2NyaXB0cy5zY3JpcHRzLCB2ZXJib3NlKTtcbiAgICBhcHBseUNzcyhzZWxlY3RvcnNBbmRTY3JpcHRzLmNzc0luamVjdCwgdmVyYm9zZSk7XG4gICAgYXBwbHlFeHRlbmRlZENzcyhzZWxlY3RvcnNBbmRTY3JpcHRzLmNzc0V4dGVuZGVkLCB2ZXJib3NlKTtcbiAgICBhcHBseVNjcmlwdGxldHMoc2VsZWN0b3JzQW5kU2NyaXB0cy5zY3JpcHRsZXRzLCB2ZXJib3NlKTtcblxuICAgIGxvZ01lc3NhZ2UodmVyYm9zZSwgJ0FwcGx5aW5nIHNjcmlwdHMgYW5kIGNzcyAtIGRvbmUnKTtcbn07XG5cbmNvbnN0IG1haW4gPSBhc3luYyAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogV2l0aCB0aGUgZm9sbG93aW5nIGxpbWl0YXRpb24gd2UgZml4IHNvbWUgdHJvdWJsZXMgd2l0aCBHbWFpbCBhbmQgc2Nyb2xsaW5nXG4gICAgICogb24gdmFyaW91cyB3ZWJzaXRlc1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9BZEd1YXJkRm9yU2FmYXJpL2lzc3Vlcy80MzNcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vQWRHdWFyZEZvclNhZmFyaS9pc3N1ZXMvNDQxXG4gICAgICovXG4gICAgaWYgKGRvY3VtZW50IGluc3RhbmNlb2YgSFRNTERvY3VtZW50KSB7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaHJlZiAmJiB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCdodHRwJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yc0FuZFNjcmlwdHMgPSBhd2FpdCBnZXRTZWxlY3RvcnNBbmRTY3JpcHRzKCk7XG4gICAgICAgICAgICBhcHBseUFkdmFuY2VkQmxvY2tpbmdEYXRhKHNlbGVjdG9yc0FuZFNjcmlwdHMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubWFpbigpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/content.ts\n");

/***/ }),

/***/ "./node_modules/extended-css/dist/extended-css.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/extended-css/dist/extended-css.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*! extended-css - v1.3.12 - Mon May 31 2021\n* https://github.com/AdguardTeam/ExtendedCss\n* Copyright (c) 2021 AdGuard. Licensed LGPL-3.0\n*/\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable no-console */\nvar utils = {};\nutils.MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n/**\n * Stores native Node textContent getter to be used for contains pseudo-class\n * because elements' 'textContent' and 'innerText' properties might be mocked\n * https://github.com/AdguardTeam/ExtendedCss/issues/127\n */\n\nutils.nodeTextContentGetter = function () {\n  var nativeNode = window.Node || Node;\n  return Object.getOwnPropertyDescriptor(nativeNode.prototype, 'textContent').get;\n}();\n\nutils.isSafariBrowser = function () {\n  var isChrome = navigator.userAgent.indexOf('Chrome') > -1;\n  var isSafari = navigator.userAgent.indexOf('Safari') > -1;\n\n  if (isSafari) {\n    if (isChrome) {\n      // Chrome seems to have both Chrome and Safari userAgents\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n}();\n/**\n * Converts regular expressions passed as pseudo class arguments into RegExp instances.\n * Have to unescape doublequote \" as well, because we escape them while enclosing such\n * arguments with doublequotes, and sizzle does not automatically unescapes them.\n */\n\n\nutils.pseudoArgToRegex = function (regexSrc, flag) {\n  flag = flag || 'i';\n  regexSrc = regexSrc.trim().replace(/\\\\([\"\\\\])/g, '$1');\n  return new RegExp(regexSrc, flag);\n};\n/**\n * Converts string to the regexp\n * @param {string} str\n * @returns {RegExp}\n */\n\n\nutils.toRegExp = function (str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n\nutils.startsWith = function (str, prefix) {\n  // if str === '', (str && false) will return ''\n  // that's why it has to be !!str\n  return !!str && str.indexOf(prefix) === 0;\n};\n\nutils.endsWith = function (str, postfix) {\n  if (!str || !postfix) {\n    return false;\n  }\n\n  if (str.endsWith) {\n    return str.endsWith(postfix);\n  }\n\n  var t = String(postfix);\n  var index = str.lastIndexOf(t);\n  return index >= 0 && index === str.length - t.length;\n};\n/**\n * Helper function for creating regular expression from a url filter rule syntax.\n */\n\n\nutils.createURLRegex = function () {\n  // Constants\n  var regexConfiguration = {\n    maskStartUrl: '||',\n    maskPipe: '|',\n    maskSeparator: '^',\n    maskAnySymbol: '*',\n    regexAnySymbol: '.*',\n    regexSeparator: '([^ a-zA-Z0-9.%_-]|$)',\n    regexStartUrl: '^(http|https|ws|wss)://([a-z0-9-_.]+\\\\.)?',\n    regexStartString: '^',\n    regexEndString: '$'\n  }; // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp\n  // should be escaped . * + ? ^ $ { } ( ) | [ ] / \\\n  // except of * | ^\n\n  var specials = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '\\\\', '/'];\n  var specialsRegex = new RegExp(\"[\".concat(specials.join('\\\\'), \"]\"), 'g');\n  /**\n   * Escapes regular expression string\n   */\n\n  var escapeRegExp = function escapeRegExp(str) {\n    return str.replace(specialsRegex, '\\\\$&');\n  };\n\n  var replaceAll = function replaceAll(str, find, replace) {\n    if (!str) {\n      return str;\n    }\n\n    return str.split(find).join(replace);\n  };\n  /**\n   * Main function that converts a url filter rule string to a regex.\n   * @param {string} str\n   * @return {RegExp}\n   */\n\n\n  var createRegexText = function createRegexText(str) {\n    var regex = escapeRegExp(str);\n\n    if (utils.startsWith(regex, regexConfiguration.maskStartUrl)) {\n      regex = regex.substring(0, regexConfiguration.maskStartUrl.length) + replaceAll(regex.substring(regexConfiguration.maskStartUrl.length, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } else if (utils.startsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regex.substring(0, regexConfiguration.maskPipe.length) + replaceAll(regex.substring(regexConfiguration.maskPipe.length, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } else {\n      regex = replaceAll(regex.substring(0, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } // Replacing special url masks\n\n\n    regex = replaceAll(regex, regexConfiguration.maskAnySymbol, regexConfiguration.regexAnySymbol);\n    regex = replaceAll(regex, regexConfiguration.maskSeparator, regexConfiguration.regexSeparator);\n\n    if (utils.startsWith(regex, regexConfiguration.maskStartUrl)) {\n      regex = regexConfiguration.regexStartUrl + regex.substring(regexConfiguration.maskStartUrl.length);\n    } else if (utils.startsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regexConfiguration.regexStartString + regex.substring(regexConfiguration.maskPipe.length);\n    }\n\n    if (utils.endsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regex.substring(0, regex.length - 1) + regexConfiguration.regexEndString;\n    }\n\n    return new RegExp(regex, 'i');\n  };\n\n  return createRegexText;\n}();\n/**\n * Creates an object implementing Location interface from a url.\n * An alternative to URL.\n * https://github.com/AdguardTeam/FingerprintingBlocker/blob/master/src/shared/url.ts#L64\n */\n\n\nutils.createLocation = function (href) {\n  var anchor = document.createElement('a');\n  anchor.href = href;\n\n  if (anchor.host === '') {\n    anchor.href = anchor.href; // eslint-disable-line no-self-assign\n  }\n\n  return anchor;\n};\n/**\n * Checks whether A has the same origin as B.\n * @param {string} urlA location.href of A.\n * @param {Location} locationB location of B.\n * @param {string} domainB document.domain of B.\n * @return {boolean}\n */\n\n\nutils.isSameOrigin = function (urlA, locationB, domainB) {\n  var locationA = utils.createLocation(urlA); // eslint-disable-next-line no-script-url\n\n  if (locationA.protocol === 'javascript:' || locationA.href === 'about:blank') {\n    return true;\n  }\n\n  if (locationA.protocol === 'data:' || locationA.protocol === 'file:') {\n    return false;\n  }\n\n  return locationA.hostname === domainB && locationA.port === locationB.port && locationA.protocol === locationB.protocol;\n};\n/**\n * A helper class to throttle function calls with setTimeout and requestAnimationFrame.\n */\n\n\nutils.AsyncWrapper = function () {\n  /**\n   * PhantomJS passes a wrong timestamp to the requestAnimationFrame callback and that breaks the AsyncWrapper logic\n   * https://github.com/ariya/phantomjs/issues/14832\n   */\n  var supported = typeof window.requestAnimationFrame !== 'undefined' && !/phantom/i.test(navigator.userAgent);\n  var rAF = supported ? requestAnimationFrame : setTimeout;\n  var cAF = supported ? cancelAnimationFrame : clearTimeout;\n  var perf = supported ? performance : Date;\n  /**\n   * @param {Function} callback\n   * @param {number} throttle number, the provided callback should be executed twice\n   * in this time frame.\n   * @constructor\n   */\n\n  function AsyncWrapper(callback, throttle) {\n    this.callback = callback;\n    this.throttle = throttle;\n    this.wrappedCallback = this.wrappedCallback.bind(this);\n\n    if (this.wrappedAsapCallback) {\n      this.wrappedAsapCallback = this.wrappedAsapCallback.bind(this);\n    }\n  }\n  /** @private */\n\n\n  AsyncWrapper.prototype.wrappedCallback = function (ts) {\n    this.lastRun = isNumber(ts) ? ts : perf.now();\n    delete this.rAFid;\n    delete this.timerId;\n    delete this.asapScheduled;\n    this.callback();\n  };\n  /** @private Indicates whether there is a scheduled callback. */\n\n\n  AsyncWrapper.prototype.hasPendingCallback = function () {\n    return isNumber(this.rAFid) || isNumber(this.timerId);\n  };\n  /**\n   * Schedules a function call before the next animation frame.\n   */\n\n\n  AsyncWrapper.prototype.run = function () {\n    if (this.hasPendingCallback()) {\n      // There is a pending execution scheduled.\n      return;\n    }\n\n    if (typeof this.lastRun !== 'undefined') {\n      var elapsed = perf.now() - this.lastRun;\n\n      if (elapsed < this.throttle) {\n        this.timerId = setTimeout(this.wrappedCallback, this.throttle - elapsed);\n        return;\n      }\n    }\n\n    this.rAFid = rAF(this.wrappedCallback);\n  };\n  /**\n   * Schedules a function call in the most immenent microtask.\n   * This cannot be canceled.\n   */\n\n\n  AsyncWrapper.prototype.runAsap = function () {\n    if (this.asapScheduled) {\n      return;\n    }\n\n    this.asapScheduled = true;\n    cAF(this.rAFid);\n    clearTimeout(this.timerId);\n\n    if (utils.MutationObserver) {\n      /**\n       * Using MutationObservers to access microtask queue is a standard technique,\n       * used in ASAP library\n       * {@link https://github.com/kriskowal/asap/blob/master/browser-raw.js#L140}\n       */\n      if (!this.mo) {\n        this.mo = new utils.MutationObserver(this.wrappedCallback);\n        this.node = document.createTextNode(1);\n        this.mo.observe(this.node, {\n          characterData: true\n        });\n      }\n\n      this.node.nodeValue = -this.node.nodeValue;\n    } else {\n      setTimeout(this.wrappedCallback);\n    }\n  };\n  /**\n   * Runs scheduled execution immediately, if there were any.\n   */\n\n\n  AsyncWrapper.prototype.runImmediately = function () {\n    if (this.hasPendingCallback()) {\n      cAF(this.rAFid);\n      clearTimeout(this.timerId);\n      delete this.rAFid;\n      delete this.timerId;\n      this.wrappedCallback();\n    }\n  };\n\n  AsyncWrapper.now = function () {\n    return perf.now();\n  };\n\n  return AsyncWrapper;\n}();\n/**\n * Stores native OdP to be used in WeakMap and Set polyfills.\n */\n\n\nutils.defineProperty = Object.defineProperty;\nutils.WeakMap = typeof WeakMap !== 'undefined' ? WeakMap : function () {\n  /** Originally based on {@link https://github.com/Polymer/WeakMap} */\n  var counter = Date.now() % 1e9;\n\n  var WeakMap = function WeakMap() {\n    this.name = \"__st\".concat(Math.random() * 1e9 >>> 0).concat(counter++, \"__\");\n  };\n\n  WeakMap.prototype = {\n    set: function set(key, value) {\n      var entry = key[this.name];\n\n      if (entry && entry[0] === key) {\n        entry[1] = value;\n      } else {\n        utils.defineProperty(key, this.name, {\n          value: [key, value],\n          writable: true\n        });\n      }\n\n      return this;\n    },\n    get: function get(key) {\n      var entry = key[this.name];\n      return entry && entry[0] === key ? entry[1] : undefined;\n    },\n    delete: function _delete(key) {\n      var entry = key[this.name];\n\n      if (!entry) {\n        return false;\n      }\n\n      var hasValue = entry[0] === key;\n      delete entry[0];\n      delete entry[1];\n      return hasValue;\n    },\n    has: function has(key) {\n      var entry = key[this.name];\n\n      if (!entry) {\n        return false;\n      }\n\n      return entry[0] === key;\n    }\n  };\n  return WeakMap;\n}();\nutils.Set = typeof Set !== 'undefined' ? Set : function () {\n  var counter = Date.now() % 1e9;\n  /**\n   * A polyfill which covers only the basic usage.\n   * Only supports methods that are supported in IE11.\n   * {@link https://docs.microsoft.com/en-us/scripting/javascript/reference/set-object-javascript}\n   * Assumes that 'key's are all objects, not primitives such as a number.\n   *\n   * @param {Array} items Initial items in this set\n   */\n\n  var Set = function Set(items) {\n    this.name = \"__st\".concat(Math.random() * 1e9 >>> 0).concat(counter++, \"__\");\n    this.keys = [];\n\n    if (items && items.length) {\n      var iItems = items.length;\n\n      while (iItems--) {\n        this.add(items[iItems]);\n      }\n    }\n  };\n\n  Set.prototype = {\n    add: function add(key) {\n      if (!isNumber(key[this.name])) {\n        var index = this.keys.push(key) - 1;\n        utils.defineProperty(key, this.name, {\n          value: index,\n          writable: true\n        });\n      }\n    },\n    delete: function _delete(key) {\n      if (isNumber(key[this.name])) {\n        var index = key[this.name];\n        delete this.keys[index];\n        key[this.name] = undefined;\n      }\n    },\n    has: function has(key) {\n      return isNumber(key[this.name]);\n    },\n    clear: function clear() {\n      this.keys.forEach(function (key) {\n        key[this.name] = undefined;\n      });\n      this.keys.length = 0;\n    },\n    forEach: function forEach(cb) {\n      var that = this;\n      this.keys.forEach(function (value) {\n        cb(value, value, that);\n      });\n    }\n  };\n  utils.defineProperty(Set.prototype, 'size', {\n    get: function get() {\n      // Skips holes.\n      return this.keys.reduce(function (acc) {\n        return acc + 1;\n      }, 0);\n    }\n  });\n  return Set;\n}();\n/**\n * Vendor-specific Element.prototype.matches\n */\n\nutils.matchesPropertyName = function () {\n  var props = ['matches', 'matchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector', 'webkitMatchesSelector'];\n\n  for (var i = 0; i < 6; i++) {\n    if (Element.prototype.hasOwnProperty(props[i])) {\n      return props[i];\n    }\n  }\n}();\n/**\n * Provides stats information\n */\n\n\nutils.Stats = function () {\n  /** @member {Array<number>} */\n  this.array = [];\n  /** @member {number} */\n\n  this.length = 0;\n  var zeroDescriptor = {\n    value: 0,\n    writable: true\n  };\n  /** @member {number} @private */\n\n  Object.defineProperty(this, 'sum', zeroDescriptor);\n  /** @member {number} @private */\n\n  Object.defineProperty(this, 'squaredSum', zeroDescriptor);\n};\n/**\n * @param {number} dataPoint data point\n */\n\n\nutils.Stats.prototype.push = function (dataPoint) {\n  this.array.push(dataPoint);\n  this.length++;\n  this.sum += dataPoint;\n  this.squaredSum += dataPoint * dataPoint;\n  /** @member {number} */\n\n  this.mean = this.sum / this.length;\n  /** @member {number} */\n  // eslint-disable-next-line no-restricted-properties\n\n  this.stddev = Math.sqrt(this.squaredSum / this.length - Math.pow(this.mean, 2));\n};\n/** Safe console.error version */\n\n\nutils.logError = typeof console !== 'undefined' && console.error && Function.prototype.bind && console.error.bind ? console.error.bind(window.console) : console.error;\n/** Safe console.info version */\n\nutils.logInfo = typeof console !== 'undefined' && console.info && Function.prototype.bind && console.info.bind ? console.info.bind(window.console) : console.info;\n\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n/**\n * Returns path to element we will use as element identifier\n * @param {Element} inputEl\n * @returns {string} - path to the element\n */\n\n\nutils.getNodeSelector = function (inputEl) {\n  if (!(inputEl instanceof Element)) {\n    throw new Error('Function received argument with wrong type');\n  }\n\n  var el = inputEl;\n  var path = []; // we need to check '!!el' first because it is possible\n  // that some ancestor of the inputEl was removed before it\n\n  while (!!el && el.nodeType === Node.ELEMENT_NODE) {\n    var selector = el.nodeName.toLowerCase();\n\n    if (el.id && typeof el.id === 'string') {\n      selector += \"#\".concat(el.id);\n      path.unshift(selector);\n      break;\n    } else {\n      var sibling = el;\n      var nth = 1;\n\n      while (sibling.previousSibling) {\n        sibling = sibling.previousSibling;\n\n        if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName.toLowerCase() === selector) {\n          nth++;\n        }\n      }\n\n      if (nth !== 1) {\n        selector += \":nth-of-type(\".concat(nth, \")\");\n      }\n    }\n\n    path.unshift(selector);\n    el = el.parentNode;\n  }\n\n  return path.join(' > ');\n};\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Helper class css utils\n *\n * @type {{normalize}}\n */\nvar cssUtils = function () {\n  /**\n   * Regex that matches AdGuard's backward compatible syntaxes.\n   */\n  var reAttrFallback = /\\[-(?:ext|abp)-([a-z-_]+)=([\"'])((?:(?=(\\\\?))\\4.)*?)\\2\\]/g;\n  /**\n   * Complex replacement function.\n   * Unescapes quote characters inside of an extended selector.\n   *\n   * @param match     Whole matched string\n   * @param name      Group 1\n   * @param quoteChar Group 2\n   * @param value     Group 3\n   */\n\n  var evaluateMatch = function evaluateMatch(match, name, quoteChar, value) {\n    // Unescape quotes\n    var re = new RegExp(\"([^\\\\\\\\]|^)\\\\\\\\\".concat(quoteChar), 'g');\n    value = value.replace(re, \"$1\".concat(quoteChar));\n    return \":\".concat(name, \"(\").concat(value, \")\");\n  }; // Sizzle's parsing of pseudo class arguments is buggy on certain circumstances\n  // We support following form of arguments:\n  // 1. for :matches-css, those of a form {propertyName}: /.*/\n  // 2. for :contains, those of a form /.*/\n  // We transform such cases in a way that Sizzle has no ambiguity in parsing arguments.\n\n\n  var reMatchesCss = /\\:(matches-css(?:-after|-before)?)\\(([a-z-\\s]*\\:\\s*\\/(?:\\\\.|[^\\/])*?\\/\\s*)\\)/g;\n  var reContains = /:(?:-abp-)?(contains|has-text)\\((\\s*\\/(?:\\\\.|[^\\/])*?\\/\\s*)\\)/g;\n  var reScope = /\\(\\:scope >/g; // Note that we require `/` character in regular expressions to be escaped.\n\n  /**\n   * Used for pre-processing pseudo-classes values with above two regexes.\n   */\n\n  var addQuotes = function addQuotes(_, c1, c2) {\n    return \":\".concat(c1, \"(\\\"\").concat(c2.replace(/[\"\\\\]/g, '\\\\$&'), \"\\\")\");\n  };\n\n  var SCOPE_REPLACER = '(>';\n  /**\n   * Normalizes specified css text in a form that can be parsed by the\n   * Sizzle engine.\n   * Normalization means\n   *  1. transforming [-ext-*=\"\"] attributes to pseudo classes\n   *  2. enclosing possibly ambiguous arguments of `:contains`,\n   *     `:matches-css` pseudo classes with quotes.\n   * @param {string} cssText\n   * @return {string}\n   */\n\n  var normalize = function normalize(cssText) {\n    var normalizedCssText = cssText.replace(reAttrFallback, evaluateMatch).replace(reMatchesCss, addQuotes).replace(reContains, addQuotes).replace(reScope, SCOPE_REPLACER);\n    return normalizedCssText;\n  };\n\n  var isSimpleSelectorValid = function isSimpleSelectorValid(selector) {\n    try {\n      document.querySelectorAll(selector);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return {\n    normalize: normalize,\n    isSimpleSelectorValid: isSimpleSelectorValid\n  };\n}();\n\n/*!\n * Sizzle CSS Selector Engine v2.3.4-pre-adguard\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2020-08-04\n */\n\n/**\n * Version of Sizzle patched by AdGuard in order to be used in the ExtendedCss module.\n * https://github.com/AdguardTeam/sizzle-extcss\n *\n * Look for [AdGuard Patch] and ADGUARD_EXTCSS markers to find out what exactly was changed by us.\n *\n * Global changes:\n * 1. Added additional parameters to the \"Sizzle.tokenize\" method so that it can be used for stylesheets parsing and validation.\n * 2. Added tokens re-sorting mechanism forcing slow pseudos to be matched last  (see sortTokenGroups).\n * 3. Fix the nonnativeSelectorCache caching -- there was no value corresponding to a key.\n * 4. Added Sizzle.compile call to the `:has` pseudo definition.\n *\n * Changes that are applied to the ADGUARD_EXTCSS build only:\n * 1. Do not expose Sizzle to the global scope. Initialize it lazily via initializeSizzle().\n * 2. Removed :contains pseudo declaration -- its syntax is changed and declared outside of Sizzle.\n * 3. Removed declarations for the following non-standard pseudo classes:\n * :parent, :header, :input, :button, :text, :first, :last, :eq,\n * :even, :odd, :lt, :gt, :nth, :radio, :checkbox, :file,\n * :password, :image, :submit, :reset\n * 4. Added es6 module export\n */\nvar Sizzle;\n/**\n * Initializes Sizzle object.\n * In the case of AdGuard ExtendedCss we want to avoid initializing Sizzle right away\n * and exposing it to the global scope.\n */\n\nvar initializeSizzle = function initializeSizzle() {\n  // jshint ignore:line\n  if (!Sizzle) {\n    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n    Sizzle = function (window) {\n      var support,\n          Expr,\n          getText,\n          isXML,\n          tokenize,\n          compile,\n          select,\n          outermostContext,\n          sortInput,\n          hasDuplicate,\n          // Local document vars\n      setDocument,\n          document,\n          docElem,\n          documentIsHTML,\n          rbuggyQSA,\n          rbuggyMatches,\n          matches,\n          contains,\n          // Instance-specific data\n      expando = \"sizzle\" + 1 * new Date(),\n          preferredDoc = window.document,\n          dirruns = 0,\n          done = 0,\n          classCache = createCache(),\n          tokenCache = createCache(),\n          compilerCache = createCache(),\n          nonnativeSelectorCache = createCache(),\n          sortOrder = function sortOrder(a, b) {\n        if (a === b) {\n          hasDuplicate = true;\n        }\n\n        return 0;\n      },\n          // Instance methods\n      hasOwn = {}.hasOwnProperty,\n          arr = [],\n          pop = arr.pop,\n          push_native = arr.push,\n          push = arr.push,\n          slice = arr.slice,\n          // Use a stripped-down indexOf as it's faster than native\n      // https://jsperf.com/thor-indexof-vs-for/5\n      indexOf = function indexOf(list, elem) {\n        var i = 0,\n            len = list.length;\n\n        for (; i < len; i++) {\n          if (list[i] === elem) {\n            return i;\n          }\n        }\n\n        return -1;\n      },\n          booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n          // Regular expressions\n      // http://www.w3.org/TR/css3-selectors/#whitespace\n      whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n          // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n      identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n          // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n      attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n      \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n      \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n          pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n      // 1. quoted (capture 3; capture 4 or capture 5)\n      \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n      \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n      \".*\" + \")\\\\)|)\",\n          // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n      rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n          rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n          rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n          rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n          rpseudo = new RegExp(pseudos),\n          ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n          matchExpr = {\n        \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n        \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n        \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n        \"ATTR\": new RegExp(\"^\" + attributes),\n        \"PSEUDO\": new RegExp(\"^\" + pseudos),\n        \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n        \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n        // For use in libraries implementing .is()\n        // We use this for POS matching in `select`\n        \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n      },\n          rnative = /^[^{]+\\{\\s*\\[native \\w/,\n          // Easily-parseable/retrievable ID or TAG or CLASS selectors\n      rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n          rsibling = /[+~]/,\n          // CSS escapes\n      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n      runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n          funescape = function funescape(_, escaped, escapedWhitespace) {\n        var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n        // Support: Firefox<24\n        // Workaround erroneous numeric interpretation of +\"0x\"\n\n        return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n        String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n      },\n          // CSS string/identifier serialization\n      // https://drafts.csswg.org/cssom/#common-serializing-idioms\n      rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n          fcssescape = function fcssescape(ch, asCodePoint) {\n        if (asCodePoint) {\n          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n          if (ch === \"\\0\") {\n            return \"\\uFFFD\";\n          } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n          return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n        } // Other potentially-special ASCII characters get backslash-escaped\n\n\n        return \"\\\\\" + ch;\n      },\n          // Used for iframes\n      // See setDocument()\n      // Removing the function wrapper causes a \"Permission Denied\"\n      // error in IE\n      unloadHandler = function unloadHandler() {\n        setDocument();\n      },\n          inDisabledFieldset = addCombinator(function (elem) {\n        return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n      }, {\n        dir: \"parentNode\",\n        next: \"legend\"\n      }); // Optimize for push.apply( _, NodeList )\n\n\n      try {\n        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n        // Detect silently failing push.apply\n\n        arr[preferredDoc.childNodes.length].nodeType;\n      } catch (e) {\n        push = {\n          apply: arr.length ? // Leverage slice if possible\n          function (target, els) {\n            push_native.apply(target, slice.call(els));\n          } : // Support: IE<9\n          // Otherwise append directly\n          function (target, els) {\n            var j = target.length,\n                i = 0; // Can't trust NodeList.length\n\n            while (target[j++] = els[i++]) {}\n\n            target.length = j - 1;\n          }\n        };\n      }\n\n      function Sizzle(selector, context, results, seed) {\n        var m,\n            i,\n            elem,\n            nid,\n            match,\n            groups,\n            newSelector,\n            newContext = context && context.ownerDocument,\n            // nodeType defaults to 9, since context defaults to document\n        nodeType = context ? context.nodeType : 9;\n        results = results || []; // Return early from calls with invalid selector or context\n\n        if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n          return results;\n        } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n        if (!seed) {\n          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n            setDocument(context);\n          }\n\n          context = context || document;\n\n          if (documentIsHTML) {\n            // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n            // (excepting DocumentFragment context, where the methods don't exist)\n            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n              // ID selector\n              if (m = match[1]) {\n                // Document context\n                if (nodeType === 9) {\n                  if (elem = context.getElementById(m)) {\n                    // Support: IE, Opera, Webkit\n                    // TODO: identify versions\n                    // getElementById can match elements by name instead of ID\n                    if (elem.id === m) {\n                      results.push(elem);\n                      return results;\n                    }\n                  } else {\n                    return results;\n                  } // Element context\n\n                } else {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } // Type selector\n\n              } else if (match[2]) {\n                push.apply(results, context.getElementsByTagName(selector));\n                return results; // Class selector\n              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n                push.apply(results, context.getElementsByClassName(m));\n                return results;\n              }\n            } // Take advantage of querySelectorAll\n\n\n            if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n              if (nodeType !== 1) {\n                newContext = context;\n                newSelector = selector; // qSA looks outside Element context, which is not what we want\n                // Thanks to Andrew Dupont for this workaround technique\n                // Support: IE <=8\n                // Exclude object elements\n              } else if (context.nodeName.toLowerCase() !== \"object\") {\n                // Capture the context ID, setting it first if necessary\n                if (nid = context.getAttribute(\"id\")) {\n                  nid = nid.replace(rcssescape, fcssescape);\n                } else {\n                  context.setAttribute(\"id\", nid = expando);\n                } // Prefix every selector in the list\n\n\n                groups = tokenize(selector);\n                i = groups.length;\n\n                while (i--) {\n                  groups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\n                }\n\n                newSelector = groups.join(\",\"); // Expand context for sibling selectors\n\n                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n              }\n\n              if (newSelector) {\n                try {\n                  push.apply(results, newContext.querySelectorAll(newSelector));\n                  return results;\n                } catch (qsaError) {\n                  // [AdGuard Path]: Fix the cache value\n                  nonnativeSelectorCache(selector, true);\n                } finally {\n                  if (nid === expando) {\n                    context.removeAttribute(\"id\");\n                  }\n                }\n              }\n            }\n          }\n        } // All others\n\n\n        return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n      }\n      /**\n       * Create key-value caches of limited size\n       * @returns {function(string, object)} Returns the Object data after storing it on itself with\n       *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n       *\tdeleting the oldest entry\n       */\n\n\n      function createCache() {\n        var keys = [];\n\n        function cache(key, value) {\n          // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n          if (keys.push(key + \" \") > Expr.cacheLength) {\n            // Only keep the most recent entries\n            delete cache[keys.shift()];\n          }\n\n          return cache[key + \" \"] = value;\n        }\n\n        return cache;\n      }\n      /**\n       * Mark a function for special use by Sizzle\n       * @param {Function} fn The function to mark\n       */\n\n\n      function markFunction(fn) {\n        fn[expando] = true;\n        return fn;\n      }\n      /**\n       * Support testing using an element\n       * @param {Function} fn Passed the created element and returns a boolean result\n       */\n\n\n      function assert(fn) {\n        var el = document.createElement(\"fieldset\");\n\n        try {\n          return !!fn(el);\n        } catch (e) {\n          return false;\n        } finally {\n          // Remove from its parent by default\n          if (el.parentNode) {\n            el.parentNode.removeChild(el);\n          } // release memory in IE\n\n\n          el = null;\n        }\n      }\n      /**\n       * Adds the same handler for all of the specified attrs\n       * @param {String} attrs Pipe-separated list of attributes\n       * @param {Function} handler The method that will be applied\n       */\n\n\n      function addHandle(attrs, handler) {\n        var arr = attrs.split(\"|\"),\n            i = arr.length;\n\n        while (i--) {\n          Expr.attrHandle[arr[i]] = handler;\n        }\n      }\n      /**\n       * Checks document order of two siblings\n       * @param {Element} a\n       * @param {Element} b\n       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n       */\n\n\n      function siblingCheck(a, b) {\n        var cur = b && a,\n            diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n        if (diff) {\n          return diff;\n        } // Check if b follows a\n\n\n        if (cur) {\n          while (cur = cur.nextSibling) {\n            if (cur === b) {\n              return -1;\n            }\n          }\n        }\n\n        return a ? 1 : -1;\n      }\n      /**\n       * Returns a function to use in pseudos for :enabled/:disabled\n       * @param {Boolean} disabled true for :disabled; false for :enabled\n       */\n\n\n      function createDisabledPseudo(disabled) {\n        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n        return function (elem) {\n          // Only certain elements can match :enabled or :disabled\n          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n          if (\"form\" in elem) {\n            // Check for inherited disabledness on relevant non-disabled elements:\n            // * listed form-associated elements in a disabled fieldset\n            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n            // * option elements in a disabled optgroup\n            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n            // All such elements have a \"form\" property.\n            if (elem.parentNode && elem.disabled === false) {\n              // Option elements defer to a parent optgroup if present\n              if (\"label\" in elem) {\n                if (\"label\" in elem.parentNode) {\n                  return elem.parentNode.disabled === disabled;\n                } else {\n                  return elem.disabled === disabled;\n                }\n              } // Support: IE 6 - 11\n              // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n              /* jshint -W018 */\n              elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n            }\n\n            return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n            // even exist on them, let alone have a boolean value.\n          } else if (\"label\" in elem) {\n            return elem.disabled === disabled;\n          } // Remaining elements are neither :enabled nor :disabled\n\n\n          return false;\n        };\n      }\n      /**\n       * Checks a node for validity as a Sizzle context\n       * @param {Element|Object=} context\n       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n       */\n\n\n      function testContext(context) {\n        return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n      } // Expose support vars for convenience\n\n\n      support = Sizzle.support = {};\n      /**\n       * Detects XML nodes\n       * @param {Element|Object} elem An element or a document\n       * @returns {Boolean} True iff elem is a non-HTML XML node\n       */\n\n      isXML = Sizzle.isXML = function (elem) {\n        // documentElement is verified for cases where it doesn't yet exist\n        // (such as loading iframes in IE - #4833)\n        var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n        return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n      };\n      /**\n       * Sets document-related variables once based on the current document\n       * @param {Element|Object} [doc] An element or document object to use to set the document\n       * @returns {Object} Returns the current document\n       */\n\n\n      setDocument = Sizzle.setDocument = function (node) {\n        var hasCompare,\n            subWindow,\n            doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n\n        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n          return document;\n        } // Update global variables\n\n\n        document = doc;\n        docElem = document.documentElement;\n        documentIsHTML = !isXML(document); // Support: IE 9-11, Edge\n        // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\n        if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n          // Support: IE 11, Edge\n          if (subWindow.addEventListener) {\n            subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n          } else if (subWindow.attachEvent) {\n            subWindow.attachEvent(\"onunload\", unloadHandler);\n          }\n        }\n        /* Attributes\n        ---------------------------------------------------------------------- */\n        // Support: IE<8\n        // Verify that getAttribute really returns attributes and not properties\n        // (excepting IE8 booleans)\n\n\n        support.attributes = assert(function (el) {\n          el.className = \"i\";\n          return !el.getAttribute(\"className\");\n        });\n        /* getElement(s)By*\n        ---------------------------------------------------------------------- */\n        // Check if getElementsByTagName(\"*\") returns only elements\n\n        support.getElementsByTagName = assert(function (el) {\n          el.appendChild(document.createComment(\"\"));\n          return !el.getElementsByTagName(\"*\").length;\n        }); // Support: IE<9\n\n        support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n        // Check if getElementById returns elements by name\n        // The broken getElementById methods don't pick up programmatically-set names,\n        // so use a roundabout getElementsByName test\n\n        support.getById = assert(function (el) {\n          docElem.appendChild(el).id = expando;\n          return !document.getElementsByName || !document.getElementsByName(expando).length;\n        }); // ID filter and find\n\n        if (support.getById) {\n          Expr.filter[\"ID\"] = function (id) {\n            var attrId = id.replace(runescape, funescape);\n            return function (elem) {\n              return elem.getAttribute(\"id\") === attrId;\n            };\n          };\n\n          Expr.find[\"ID\"] = function (id, context) {\n            if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n              var elem = context.getElementById(id);\n              return elem ? [elem] : [];\n            }\n          };\n        } else {\n          Expr.filter[\"ID\"] = function (id) {\n            var attrId = id.replace(runescape, funescape);\n            return function (elem) {\n              var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n              return node && node.value === attrId;\n            };\n          }; // Support: IE 6 - 7 only\n          // getElementById is not reliable as a find shortcut\n\n\n          Expr.find[\"ID\"] = function (id, context) {\n            if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n              var node,\n                  i,\n                  elems,\n                  elem = context.getElementById(id);\n\n              if (elem) {\n                // Verify the id attribute\n                node = elem.getAttributeNode(\"id\");\n\n                if (node && node.value === id) {\n                  return [elem];\n                } // Fall back on getElementsByName\n\n\n                elems = context.getElementsByName(id);\n                i = 0;\n\n                while (elem = elems[i++]) {\n                  node = elem.getAttributeNode(\"id\");\n\n                  if (node && node.value === id) {\n                    return [elem];\n                  }\n                }\n              }\n\n              return [];\n            }\n          };\n        } // Tag\n\n\n        Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n          if (typeof context.getElementsByTagName !== \"undefined\") {\n            return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n          } else if (support.qsa) {\n            return context.querySelectorAll(tag);\n          }\n        } : function (tag, context) {\n          var elem,\n              tmp = [],\n              i = 0,\n              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n          results = context.getElementsByTagName(tag); // Filter out possible comments\n\n          if (tag === \"*\") {\n            while (elem = results[i++]) {\n              if (elem.nodeType === 1) {\n                tmp.push(elem);\n              }\n            }\n\n            return tmp;\n          }\n\n          return results;\n        }; // Class\n\n        Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n          if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n            return context.getElementsByClassName(className);\n          }\n        };\n        /* QSA/matchesSelector\n        ---------------------------------------------------------------------- */\n        // QSA and matchesSelector support\n        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n        rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n        // We allow this because of a bug in IE8/9 that throws an error\n        // whenever `document.activeElement` is accessed on an iframe\n        // So, we allow :focus to pass through QSA all the time to avoid the IE error\n        // See https://bugs.jquery.com/ticket/13378\n\n        rbuggyQSA = [];\n\n        if (support.qsa = rnative.test(document.querySelectorAll)) {\n          // Build QSA regex\n          // Regex strategy adopted from Diego Perini\n          assert(function (el) {\n            // Select is set to empty string on purpose\n            // This is to test IE's treatment of not explicitly\n            // setting a boolean content attribute,\n            // since its presence should be enough\n            // https://bugs.jquery.com/ticket/12359\n            docElem.appendChild(el).innerHTML = AGPolicy.createHTML(\"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"); // Support: IE8, Opera 11-12.16\n            // Nothing should be selected when empty strings follow ^= or $= or *=\n            // The test attribute must be unknown in Opera but \"safe\" for WinRT\n            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n            if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n              rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n            } // Support: IE8\n            // Boolean attributes and \"value\" are not treated correctly\n\n\n            if (!el.querySelectorAll(\"[selected]\").length) {\n              rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n            } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n            if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n              rbuggyQSA.push(\"~=\");\n            } // Webkit/Opera - :checked should return selected option elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            // IE8 throws error here and will not see later tests\n\n\n            if (!el.querySelectorAll(\":checked\").length) {\n              rbuggyQSA.push(\":checked\");\n            } // Support: Safari 8+, iOS 8+\n            // https://bugs.webkit.org/show_bug.cgi?id=136851\n            // In-page `selector#id sibling-combinator selector` fails\n\n\n            if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n              rbuggyQSA.push(\".#.+[+~]\");\n            }\n          });\n          assert(function (el) {\n            el.innerHTML = AGPolicy.createHTML(\"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"); // Support: Windows 8 Native Apps\n            // The type and name attributes are restricted during .innerHTML assignment\n\n            var input = document.createElement(\"input\");\n            input.setAttribute(\"type\", \"hidden\");\n            el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n            // Enforce case-sensitivity of name attribute\n\n            if (el.querySelectorAll(\"[name=d]\").length) {\n              rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n            } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n            // IE8 throws error here and will not see later tests\n\n\n            if (el.querySelectorAll(\":enabled\").length !== 2) {\n              rbuggyQSA.push(\":enabled\", \":disabled\");\n            } // Support: IE9-11+\n            // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n            docElem.appendChild(el).disabled = true;\n\n            if (el.querySelectorAll(\":disabled\").length !== 2) {\n              rbuggyQSA.push(\":enabled\", \":disabled\");\n            } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n            el.querySelectorAll(\"*,:x\");\n            rbuggyQSA.push(\",.*:\");\n          });\n        }\n\n        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n          assert(function (el) {\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node (IE 9)\n            support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n            // Gecko does not error, returns false instead\n\n            matches.call(el, \"[s!='']:x\");\n            rbuggyMatches.push(\"!=\", pseudos);\n          });\n        }\n\n        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n        /* Contains\n        ---------------------------------------------------------------------- */\n\n        hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n        // Purposefully self-exclusive\n        // As in, an element does not contain itself\n\n        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n          var adown = a.nodeType === 9 ? a.documentElement : a,\n              bup = b && b.parentNode;\n          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n        } : function (a, b) {\n          if (b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        };\n        /* Sorting\n        ---------------------------------------------------------------------- */\n        // Document order sorting\n\n        sortOrder = hasCompare ? function (a, b) {\n          // Flag for duplicate removal\n          if (a === b) {\n            hasDuplicate = true;\n            return 0;\n          } // Sort on method existence if only one input has compareDocumentPosition\n\n\n          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n          if (compare) {\n            return compare;\n          } // Calculate position if both inputs belong to the same document\n\n\n          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n          1; // Disconnected nodes\n\n          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n            // Choose the first element that is related to our preferred document\n            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n              return -1;\n            }\n\n            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n              return 1;\n            } // Maintain original order\n\n\n            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n          }\n\n          return compare & 4 ? -1 : 1;\n        } : function (a, b) {\n          // Exit early if the nodes are identical\n          if (a === b) {\n            hasDuplicate = true;\n            return 0;\n          }\n\n          var cur,\n              i = 0,\n              aup = a.parentNode,\n              bup = b.parentNode,\n              ap = [a],\n              bp = [b]; // Parentless nodes are either documents or disconnected\n\n          if (!aup || !bup) {\n            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n          } else if (aup === bup) {\n            return siblingCheck(a, b);\n          } // Otherwise we need full lists of their ancestors for comparison\n\n\n          cur = a;\n\n          while (cur = cur.parentNode) {\n            ap.unshift(cur);\n          }\n\n          cur = b;\n\n          while (cur = cur.parentNode) {\n            bp.unshift(cur);\n          } // Walk down the tree looking for a discrepancy\n\n\n          while (ap[i] === bp[i]) {\n            i++;\n          }\n\n          return i ? // Do a sibling check if the nodes have a common ancestor\n          siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n          ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n        };\n        return document;\n      };\n\n      Sizzle.matches = function (expr, elements) {\n        return Sizzle(expr, null, null, elements);\n      };\n\n      Sizzle.matchesSelector = function (elem, expr) {\n        // Set document vars if needed\n        if ((elem.ownerDocument || elem) !== document) {\n          setDocument(elem);\n        }\n\n        if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n          try {\n            var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n            // fragment in IE 9\n            elem.document && elem.document.nodeType !== 11) {\n              return ret;\n            }\n          } catch (e) {\n            // [AdGuard Path]: Fix the cache value\n            nonnativeSelectorCache(expr, true);\n          }\n        }\n\n        return Sizzle(expr, document, null, [elem]).length > 0;\n      };\n\n      Sizzle.contains = function (context, elem) {\n        // Set document vars if needed\n        if ((context.ownerDocument || context) !== document) {\n          setDocument(context);\n        }\n\n        return contains(context, elem);\n      };\n\n      Sizzle.attr = function (elem, name) {\n        // Set document vars if needed\n        if ((elem.ownerDocument || elem) !== document) {\n          setDocument(elem);\n        }\n\n        var fn = Expr.attrHandle[name.toLowerCase()],\n            // Don't get fooled by Object.prototype properties (jQuery #13807)\n        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n      };\n\n      Sizzle.escape = function (sel) {\n        return (sel + \"\").replace(rcssescape, fcssescape);\n      };\n\n      Sizzle.error = function (msg) {\n        throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n      };\n      /**\n       * Document sorting and removing duplicates\n       * @param {ArrayLike} results\n       */\n\n\n      Sizzle.uniqueSort = function (results) {\n        var elem,\n            duplicates = [],\n            j = 0,\n            i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n        hasDuplicate = !support.detectDuplicates;\n        sortInput = !support.sortStable && results.slice(0);\n        results.sort(sortOrder);\n\n        if (hasDuplicate) {\n          while (elem = results[i++]) {\n            if (elem === results[i]) {\n              j = duplicates.push(i);\n            }\n          }\n\n          while (j--) {\n            results.splice(duplicates[j], 1);\n          }\n        } // Clear input after sorting to release objects\n        // See https://github.com/jquery/sizzle/pull/225\n\n\n        sortInput = null;\n        return results;\n      };\n      /**\n       * Utility function for retrieving the text value of an array of DOM nodes\n       * @param {Array|Element} elem\n       */\n\n\n      getText = Sizzle.getText = function (elem) {\n        var node,\n            ret = \"\",\n            i = 0,\n            nodeType = elem.nodeType;\n\n        if (!nodeType) {\n          // If no nodeType, this is expected to be an array\n          while (node = elem[i++]) {\n            // Do not traverse comment nodes\n            ret += getText(node);\n          }\n        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n          // Use textContent for elements\n          // innerText usage removed for consistency of new lines (jQuery #11153)\n          if (typeof elem.textContent === \"string\") {\n            return elem.textContent;\n          } else {\n            // Traverse its children\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n              ret += getText(elem);\n            }\n          }\n        } else if (nodeType === 3 || nodeType === 4) {\n          return elem.nodeValue;\n        } // Do not include comment or processing instruction nodes\n\n\n        return ret;\n      };\n\n      Expr = Sizzle.selectors = {\n        // Can be adjusted by the user\n        cacheLength: 50,\n        createPseudo: markFunction,\n        match: matchExpr,\n        attrHandle: {},\n        find: {},\n        relative: {\n          \">\": {\n            dir: \"parentNode\",\n            first: true\n          },\n          \" \": {\n            dir: \"parentNode\"\n          },\n          \"+\": {\n            dir: \"previousSibling\",\n            first: true\n          },\n          \"~\": {\n            dir: \"previousSibling\"\n          }\n        },\n        preFilter: {\n          \"ATTR\": function ATTR(match) {\n            match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n            match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n            if (match[2] === \"~=\") {\n              match[3] = \" \" + match[3] + \" \";\n            }\n\n            return match.slice(0, 4);\n          },\n          \"CHILD\": function CHILD(match) {\n            /* matches from matchExpr[\"CHILD\"]\n            \t1 type (only|nth|...)\n            \t2 what (child|of-type)\n            \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n            \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n            \t5 sign of xn-component\n            \t6 x of xn-component\n            \t7 sign of y-component\n            \t8 y of y-component\n            */\n            match[1] = match[1].toLowerCase();\n\n            if (match[1].slice(0, 3) === \"nth\") {\n              // nth-* requires argument\n              if (!match[3]) {\n                Sizzle.error(match[0]);\n              } // numeric x and y parameters for Expr.filter.CHILD\n              // remember that false/true cast respectively to 0/1\n\n\n              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n              match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n            } else if (match[3]) {\n              Sizzle.error(match[0]);\n            }\n\n            return match;\n          },\n          \"PSEUDO\": function PSEUDO(match) {\n            var excess,\n                unquoted = !match[6] && match[2];\n\n            if (matchExpr[\"CHILD\"].test(match[0])) {\n              return null;\n            } // Accept quoted arguments as-is\n\n\n            if (match[3]) {\n              match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n            } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n            excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n              // excess is a negative index\n              match[0] = match[0].slice(0, excess);\n              match[2] = unquoted.slice(0, excess);\n            } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n            return match.slice(0, 3);\n          }\n        },\n        filter: {\n          \"TAG\": function TAG(nodeNameSelector) {\n            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n            return nodeNameSelector === \"*\" ? function () {\n              return true;\n            } : function (elem) {\n              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n            };\n          },\n          \"CLASS\": function CLASS(className) {\n            var pattern = classCache[className + \" \"];\n            return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n              return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n            });\n          },\n          \"ATTR\": function ATTR(name, operator, check) {\n            return function (elem) {\n              var result = Sizzle.attr(elem, name);\n\n              if (result == null) {\n                return operator === \"!=\";\n              }\n\n              if (!operator) {\n                return true;\n              }\n\n              result += \"\";\n              return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n            };\n          },\n          \"CHILD\": function CHILD(type, what, argument, first, last) {\n            var simple = type.slice(0, 3) !== \"nth\",\n                forward = type.slice(-4) !== \"last\",\n                ofType = what === \"of-type\";\n            return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n            function (elem) {\n              return !!elem.parentNode;\n            } : function (elem, context, xml) {\n              var cache,\n                  uniqueCache,\n                  outerCache,\n                  node,\n                  nodeIndex,\n                  start,\n                  dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                  parent = elem.parentNode,\n                  name = ofType && elem.nodeName.toLowerCase(),\n                  useCache = !xml && !ofType,\n                  diff = false;\n\n              if (parent) {\n                // :(first|last|only)-(child|of-type)\n                if (simple) {\n                  while (dir) {\n                    node = elem;\n\n                    while (node = node[dir]) {\n                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                        return false;\n                      }\n                    } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                    start = dir = type === \"only\" && !start && \"nextSibling\";\n                  }\n\n                  return true;\n                }\n\n                start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n                if (forward && useCache) {\n                  // Seek `elem` from a previously-cached index\n                  // ...in a gzip-friendly way\n                  node = parent;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex && cache[2];\n                  node = nodeIndex && parent.childNodes[nodeIndex];\n\n                  while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                  diff = nodeIndex = 0) || start.pop()) {\n                    // When found, cache indexes on `parent` and break\n                    if (node.nodeType === 1 && ++diff && node === elem) {\n                      uniqueCache[type] = [dirruns, nodeIndex, diff];\n                      break;\n                    }\n                  }\n                } else {\n                  // Use previously-cached element index if available\n                  if (useCache) {\n                    // ...in a gzip-friendly way\n                    node = elem;\n                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                    // Defend against cloned attroperties (jQuery gh-1709)\n\n                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                    cache = uniqueCache[type] || [];\n                    nodeIndex = cache[0] === dirruns && cache[1];\n                    diff = nodeIndex;\n                  } // xml :nth-child(...)\n                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                  if (diff === false) {\n                    // Use the same loop as above to seek `elem` from the start\n                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                        // Cache the index of each encountered element\n                        if (useCache) {\n                          outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                          // Defend against cloned attroperties (jQuery gh-1709)\n\n                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                          uniqueCache[type] = [dirruns, diff];\n                        }\n\n                        if (node === elem) {\n                          break;\n                        }\n                      }\n                    }\n                  }\n                } // Incorporate the offset, then check against cycle size\n\n\n                diff -= last;\n                return diff === first || diff % first === 0 && diff / first >= 0;\n              }\n            };\n          },\n          \"PSEUDO\": function PSEUDO(pseudo, argument) {\n            // pseudo-class names are case-insensitive\n            // http://www.w3.org/TR/selectors/#pseudo-classes\n            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n            // Remember that setFilters inherits from pseudos\n            var args,\n                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n            // arguments are needed to create the filter function\n            // just as Sizzle does\n\n            if (fn[expando]) {\n              return fn(argument);\n            } // But maintain support for old signatures\n\n\n            if (fn.length > 1) {\n              args = [pseudo, pseudo, \"\", argument];\n              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n                var idx,\n                    matched = fn(seed, argument),\n                    i = matched.length;\n\n                while (i--) {\n                  idx = indexOf(seed, matched[i]);\n                  seed[idx] = !(matches[idx] = matched[i]);\n                }\n              }) : function (elem) {\n                return fn(elem, 0, args);\n              };\n            }\n\n            return fn;\n          }\n        },\n        pseudos: {\n          // Potentially complex pseudos\n          \"not\": markFunction(function (selector) {\n            // Trim the selector passed to compile\n            // to avoid treating leading and trailing\n            // spaces as combinators\n            var input = [],\n                results = [],\n                matcher = compile(selector.replace(rtrim, \"$1\"));\n            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n              var elem,\n                  unmatched = matcher(seed, null, xml, []),\n                  i = seed.length; // Match elements unmatched by `matcher`\n\n              while (i--) {\n                if (elem = unmatched[i]) {\n                  seed[i] = !(matches[i] = elem);\n                }\n              }\n            }) : function (elem, context, xml) {\n              input[0] = elem;\n              matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n              input[0] = null;\n              return !results.pop();\n            };\n          }),\n          \"has\": markFunction(function (selector) {\n            if (typeof selector === \"string\") {\n              Sizzle.compile(selector);\n            }\n\n            return function (elem) {\n              return Sizzle(selector, elem).length > 0;\n            };\n          }),\n          // Removed :contains pseudo-class declaration\n          // \"Whether an element is represented by a :lang() selector\n          // is based solely on the element's language value\n          // being equal to the identifier C,\n          // or beginning with the identifier C immediately followed by \"-\".\n          // The matching of C against the element's language value is performed case-insensitively.\n          // The identifier C does not have to be a valid language name.\"\n          // http://www.w3.org/TR/selectors/#lang-pseudo\n          \"lang\": markFunction(function (lang) {\n            // lang value must be a valid identifier\n            if (!ridentifier.test(lang || \"\")) {\n              Sizzle.error(\"unsupported lang: \" + lang);\n            }\n\n            lang = lang.replace(runescape, funescape).toLowerCase();\n            return function (elem) {\n              var elemLang;\n\n              do {\n                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                  elemLang = elemLang.toLowerCase();\n                  return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n                }\n              } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n              return false;\n            };\n          }),\n          // Miscellaneous\n          \"target\": function target(elem) {\n            var hash = window.location && window.location.hash;\n            return hash && hash.slice(1) === elem.id;\n          },\n          \"root\": function root(elem) {\n            return elem === docElem;\n          },\n          \"focus\": function focus(elem) {\n            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n          },\n          // Boolean properties\n          \"enabled\": createDisabledPseudo(false),\n          \"disabled\": createDisabledPseudo(true),\n          \"checked\": function checked(elem) {\n            // In CSS3, :checked should return both checked and selected elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            var nodeName = elem.nodeName.toLowerCase();\n            return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n          },\n          \"selected\": function selected(elem) {\n            // Accessing this property makes selected-by-default\n            // options in Safari work properly\n            if (elem.parentNode) {\n              elem.parentNode.selectedIndex;\n            }\n\n            return elem.selected === true;\n          },\n          // Contents\n          \"empty\": function empty(elem) {\n            // http://www.w3.org/TR/selectors/#empty-pseudo\n            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n            //   but not by others (comment: 8; processing instruction: 7; etc.)\n            // nodeType < 6 works because attributes (2) do not appear as children\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n              if (elem.nodeType < 6) {\n                return false;\n              }\n            }\n\n            return true;\n          } // Removed custom pseudo-classes\n\n        }\n      }; // Removed custom pseudo-classes\n      // Easy API for creating new setFilters\n\n      function setFilters() {}\n\n      setFilters.prototype = Expr.filters = Expr.pseudos;\n      Expr.setFilters = new setFilters();\n      /**\n       * [AdGuard Patch]:\n       * Sorts the tokens in order to mitigate the performance issues caused by matching slow pseudos first:\n       * https://github.com/AdguardTeam/ExtendedCss/issues/55#issuecomment-364058745\n       */\n\n      var sortTokenGroups = function () {\n        /**\n         * Splits compound selector into a list of simple selectors\n         *\n         * @param {*} tokens Tokens to split into groups\n         * @returns an array consisting of token groups (arrays) and relation tokens.\n         */\n        var splitCompoundSelector = function splitCompoundSelector(tokens) {\n          var groups = [];\n          var currentTokensGroup = [];\n          var maxIdx = tokens.length - 1;\n\n          for (var i = 0; i <= maxIdx; i++) {\n            var token = tokens[i];\n            var relative = Sizzle.selectors.relative[token.type];\n\n            if (relative) {\n              groups.push(currentTokensGroup);\n              groups.push(token);\n              currentTokensGroup = [];\n            } else {\n              currentTokensGroup.push(token);\n            }\n\n            if (i === maxIdx) {\n              groups.push(currentTokensGroup);\n            }\n          }\n\n          return groups;\n        };\n\n        var TOKEN_TYPES_VALUES = {\n          // nth-child, etc, always go last\n          \"CHILD\": 100,\n          \"ID\": 90,\n          \"CLASS\": 80,\n          \"TAG\": 70,\n          \"ATTR\": 70,\n          \"PSEUDO\": 60\n        };\n        var POSITIONAL_PSEUDOS = [\"nth\", \"first\", \"last\", \"eq\", \"even\", \"odd\", \"lt\", \"gt\", \"not\"];\n        /**\n         * A function that defines the sort order.\n         * Returns a value lesser than 0 if \"left\" is less than \"right\".\n         */\n\n        var compareFunction = function compareFunction(left, right) {\n          var leftValue = TOKEN_TYPES_VALUES[left.type];\n          var rightValue = TOKEN_TYPES_VALUES[right.type];\n          return leftValue - rightValue;\n        };\n        /**\n         * Checks if the specified tokens group is sortable.\n         * We do not re-sort tokens in case of any positional or child pseudos in the group\n         */\n\n\n        var isSortable = function isSortable(tokens) {\n          var iTokens = tokens.length;\n\n          while (iTokens--) {\n            var token = tokens[iTokens];\n\n            if (token.type === \"PSEUDO\" && POSITIONAL_PSEUDOS.indexOf(token.matches[0]) !== -1) {\n              return false;\n            }\n\n            if (token.type === \"CHILD\") {\n              return false;\n            }\n          }\n\n          return true;\n        };\n        /**\n         * Sorts the tokens in order to mitigate the issues caused by the left-to-right matching.\n         * The idea is change the tokens order so that Sizzle was matching fast selectors first (id, class),\n         * and slow selectors after that (and here I mean our slow custom pseudo classes).\n         *\n         * @param {Array} tokens An array of tokens to sort\n         * @returns {Array} A new re-sorted array\n         */\n\n\n        var sortTokens = function sortTokens(tokens) {\n          if (!tokens || tokens.length === 1) {\n            return tokens;\n          }\n\n          var sortedTokens = [];\n          var groups = splitCompoundSelector(tokens);\n\n          for (var i = 0; i < groups.length; i++) {\n            var group = groups[i];\n\n            if (group instanceof Array) {\n              if (isSortable(group)) {\n                group.sort(compareFunction);\n              }\n\n              sortedTokens = sortedTokens.concat(group);\n            } else {\n              sortedTokens.push(group);\n            }\n          }\n\n          return sortedTokens;\n        };\n        /**\n         * Sorts every tokens array inside of the specified \"groups\" array.\n         * See \"sortTokens\" methods for more information on how tokens are sorted.\n         *\n         * @param {Array} groups An array of tokens arrays.\n         * @returns {Array} A new array that consists of the same tokens arrays after sorting\n         */\n\n\n        var sortTokenGroups = function sortTokenGroups(groups) {\n          var sortedGroups = [];\n          var len = groups.length;\n          var i = 0;\n\n          for (; i < len; i++) {\n            sortedGroups.push(sortTokens(groups[i]));\n          }\n\n          return sortedGroups;\n        }; // Expose\n\n\n        return sortTokenGroups;\n      }();\n      /**\n       * Creates custom policy to use TrustedTypes CSP policy\n       * https://w3c.github.io/webappsec-trusted-types/dist/spec/\n       */\n\n\n      var AGPolicy = function createPolicy() {\n        var defaultPolicy = {\n          createHTML: function createHTML(input) {\n            return input;\n          },\n          createScript: function createScript(input) {\n            return input;\n          },\n          createScriptURL: function createScriptURL(input) {\n            return input;\n          }\n        };\n\n        if (window.trustedTypes && window.trustedTypes.createPolicy) {\n          return window.trustedTypes.createPolicy(\"AGPolicy\", defaultPolicy);\n        }\n\n        return defaultPolicy;\n      }();\n      /**\n       * [AdGuard Patch]:\n       * Removes trailing spaces from the tokens list\n       *\n       * @param {*} tokens An array of Sizzle tokens to post-process\n       */\n\n\n      function removeTrailingSpaces(tokens) {\n        var iTokens = tokens.length;\n\n        while (iTokens--) {\n          var token = tokens[iTokens];\n\n          if (token.type === \" \") {\n            tokens.length = iTokens;\n          } else {\n            break;\n          }\n        }\n      }\n      /**\n       * [AdGuard Patch]:\n       * An object with the information about selectors and their token representation\n       * @typedef {{selectorText: string, groups: Array}} SelectorData\n       * @property {string} selectorText A CSS selector text\n       * @property {Array} groups An array of token groups corresponding to that selector\n       */\n\n      /**\n       * [AdGuard Patch]:\n       * This method processes parsed token groups, divides them into a number of selectors\n       * and makes sure that each selector's tokens are cached properly in Sizzle.\n       *\n       * @param {*} groups Token groups (see {@link Sizzle.tokenize})\n       * @returns {Array.<SelectorData>} An array of selectors data we got from the groups\n       */\n\n\n      function tokenGroupsToSelectors(groups) {\n        // Remove trailing spaces which we can encounter in tolerant mode\n        // We're doing it in tolerant mode only as this is the only case when\n        // encountering trailing spaces is expected\n        removeTrailingSpaces(groups[groups.length - 1]); // We need sorted tokens to make cache work properly\n\n        var sortedGroups = sortTokenGroups(groups);\n        var selectors = [];\n\n        for (var i = 0; i < groups.length; i++) {\n          var tokenGroups = groups[i];\n          var selectorText = toSelector(tokenGroups);\n          selectors.push({\n            // Sizzle expects an array of token groups when compiling a selector\n            groups: [tokenGroups],\n            selectorText: selectorText\n          }); // Now make sure that selector tokens are cached\n\n          var tokensCacheItem = {\n            groups: tokenGroups,\n            sortedGroups: [sortedGroups[i]]\n          };\n          tokenCache(selectorText, tokensCacheItem);\n        }\n\n        return selectors;\n      }\n      /**\n       * [AdGuard Patch]:\n       * Add an additional argument for Sizzle.tokenize which indicates that it\n       * should not throw on invalid tokens, and instead should return tokens\n       * that it has produced so far.\n       *\n       * One more additional argument that allow to choose if you want to receive sorted or unsorted tokens\n       * The problem is that the re-sorted selectors are valid for Sizzle, but not for the browser.\n       * options.returnUnsorted -- return unsorted tokens if true.\n       * options.cacheOnly -- return cached result only. Required for unit-tests.\n       *\n       * @param {*} options Optional configuration object with two additional flags\n       * (options.tolerant, options.returnUnsorted, options.cacheOnly) -- see patches #5 and #6 notes\n       */\n\n\n      tokenize = Sizzle.tokenize = function (selector, parseOnly, options) {\n        var matched,\n            match,\n            tokens,\n            type,\n            soFar,\n            groups,\n            preFilters,\n            cached = tokenCache[selector + \" \"];\n        var tolerant = options && options.tolerant;\n        var returnUnsorted = options && options.returnUnsorted;\n        var cacheOnly = options && options.cacheOnly;\n\n        if (cached) {\n          if (parseOnly) {\n            return 0;\n          } else {\n            return (returnUnsorted ? cached.groups : cached.sortedGroups).slice(0);\n          }\n        }\n\n        if (cacheOnly) {\n          return null;\n        }\n\n        soFar = selector;\n        groups = [];\n        preFilters = Expr.preFilter;\n\n        while (soFar) {\n          // Comma and first run\n          if (!matched || (match = rcomma.exec(soFar))) {\n            if (match) {\n              // Don't consume trailing commas as valid\n              soFar = soFar.slice(match[0].length) || soFar;\n            }\n\n            groups.push(tokens = []);\n          }\n\n          matched = false; // Combinators\n\n          if (match = rcombinators.exec(soFar)) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              // Cast descendant combinators to space\n              type: match[0].replace(rtrim, \" \")\n            });\n            soFar = soFar.slice(matched.length);\n          } // Filters\n\n\n          for (type in Expr.filter) {\n            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n              matched = match.shift();\n              tokens.push({\n                value: matched,\n                type: type,\n                matches: match\n              });\n              soFar = soFar.slice(matched.length);\n            }\n          }\n\n          if (!matched) {\n            break;\n          }\n        } // Return the length of the invalid excess\n        // if we're just parsing\n        // Otherwise, throw an error or return tokens\n\n\n        var invalidLen = soFar.length;\n\n        if (parseOnly) {\n          return invalidLen;\n        }\n\n        if (invalidLen !== 0 && !tolerant) {\n          Sizzle.error(selector); // Throws an error.\n        }\n\n        if (tolerant) {\n          /**\n           * [AdGuard Patch]:\n           * In tolerant mode we return a special object that constists of\n           * an array of parsed selectors (and their tokens) and a \"nextIndex\" field\n           * that points to an index after which we're not able to parse selectors farther.\n           */\n          var nextIndex = selector.length - invalidLen;\n          var selectors = tokenGroupsToSelectors(groups);\n          return {\n            selectors: selectors,\n            nextIndex: nextIndex\n          };\n        }\n        /** [AdGuard Patch]: Sorting tokens */\n\n\n        var sortedGroups = sortTokenGroups(groups);\n        /** [AdGuard Patch]: Change the way tokens are cached */\n\n        var tokensCacheItem = {\n          groups: groups,\n          sortedGroups: sortedGroups\n        };\n        tokensCacheItem = tokenCache(selector, tokensCacheItem);\n        return (returnUnsorted ? tokensCacheItem.groups : tokensCacheItem.sortedGroups).slice(0);\n      };\n\n      function toSelector(tokens) {\n        var i = 0,\n            len = tokens.length,\n            selector = \"\";\n\n        for (; i < len; i++) {\n          selector += tokens[i].value;\n        }\n\n        return selector;\n      }\n\n      function addCombinator(matcher, combinator, base) {\n        var dir = combinator.dir,\n            skip = combinator.next,\n            key = skip || dir,\n            checkNonElements = base && key === \"parentNode\",\n            doneName = done++;\n        return combinator.first ? // Check against closest ancestor/preceding element\n        function (elem, context, xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              return matcher(elem, context, xml);\n            }\n          }\n\n          return false;\n        } : // Check against all ancestor/preceding elements\n        function (elem, context, xml) {\n          var oldCache,\n              uniqueCache,\n              outerCache,\n              newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n          if (xml) {\n            while (elem = elem[dir]) {\n              if (elem.nodeType === 1 || checkNonElements) {\n                if (matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            while (elem = elem[dir]) {\n              if (elem.nodeType === 1 || checkNonElements) {\n                outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n                if (skip && skip === elem.nodeName.toLowerCase()) {\n                  elem = elem[dir] || elem;\n                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                  // Assign to newCache so results back-propagate to previous elements\n                  return newCache[2] = oldCache[2];\n                } else {\n                  // Reuse newcache so results back-propagate to previous elements\n                  uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                  if (newCache[2] = matcher(elem, context, xml)) {\n                    return true;\n                  }\n                }\n              }\n            }\n          }\n\n          return false;\n        };\n      }\n\n      function elementMatcher(matchers) {\n        return matchers.length > 1 ? function (elem, context, xml) {\n          var i = matchers.length;\n\n          while (i--) {\n            if (!matchers[i](elem, context, xml)) {\n              return false;\n            }\n          }\n\n          return true;\n        } : matchers[0];\n      }\n\n      function multipleContexts(selector, contexts, results) {\n        var i = 0,\n            len = contexts.length;\n\n        for (; i < len; i++) {\n          Sizzle(selector, contexts[i], results);\n        }\n\n        return results;\n      }\n\n      function condense(unmatched, map, filter, context, xml) {\n        var elem,\n            newUnmatched = [],\n            i = 0,\n            len = unmatched.length,\n            mapped = map != null;\n\n        for (; i < len; i++) {\n          if (elem = unmatched[i]) {\n            if (!filter || filter(elem, context, xml)) {\n              newUnmatched.push(elem);\n\n              if (mapped) {\n                map.push(i);\n              }\n            }\n          }\n        }\n\n        return newUnmatched;\n      }\n\n      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n        if (postFilter && !postFilter[expando]) {\n          postFilter = setMatcher(postFilter);\n        }\n\n        if (postFinder && !postFinder[expando]) {\n          postFinder = setMatcher(postFinder, postSelector);\n        }\n\n        return markFunction(function (seed, results, context, xml) {\n          var temp,\n              i,\n              elem,\n              preMap = [],\n              postMap = [],\n              preexisting = results.length,\n              // Get initial elements from seed or context\n          elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n              // Prefilter to get matcher input, preserving a map for seed-results synchronization\n          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n              matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n          [] : // ...otherwise use results directly\n          results : matcherIn; // Find primary matches\n\n          if (matcher) {\n            matcher(matcherIn, matcherOut, context, xml);\n          } // Apply postFilter\n\n\n          if (postFilter) {\n            temp = condense(matcherOut, postMap);\n            postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n            i = temp.length;\n\n            while (i--) {\n              if (elem = temp[i]) {\n                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n              }\n            }\n          }\n\n          if (seed) {\n            if (postFinder || preFilter) {\n              if (postFinder) {\n                // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                temp = [];\n                i = matcherOut.length;\n\n                while (i--) {\n                  if (elem = matcherOut[i]) {\n                    // Restore matcherIn since elem is not yet a final match\n                    temp.push(matcherIn[i] = elem);\n                  }\n                }\n\n                postFinder(null, matcherOut = [], temp, xml);\n              } // Move matched elements from seed to results to keep them synchronized\n\n\n              i = matcherOut.length;\n\n              while (i--) {\n                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                  seed[temp] = !(results[temp] = elem);\n                }\n              }\n            } // Add elements to results, through postFinder if defined\n\n          } else {\n            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n            if (postFinder) {\n              postFinder(null, results, matcherOut, xml);\n            } else {\n              push.apply(results, matcherOut);\n            }\n          }\n        });\n      }\n\n      function matcherFromTokens(tokens) {\n        var checkContext,\n            matcher,\n            j,\n            len = tokens.length,\n            leadingRelative = Expr.relative[tokens[0].type],\n            implicitRelative = leadingRelative || Expr.relative[\" \"],\n            i = leadingRelative ? 1 : 0,\n            // The foundational matcher ensures that elements are reachable from top-level context(s)\n        matchContext = addCombinator(function (elem) {\n          return elem === checkContext;\n        }, implicitRelative, true),\n            matchAnyContext = addCombinator(function (elem) {\n          return indexOf(checkContext, elem) > -1;\n        }, implicitRelative, true),\n            matchers = [function (elem, context, xml) {\n          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n          checkContext = null;\n          return ret;\n        }];\n\n        for (; i < len; i++) {\n          if (matcher = Expr.relative[tokens[i].type]) {\n            matchers = [addCombinator(elementMatcher(matchers), matcher)];\n          } else {\n            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n            if (matcher[expando]) {\n              // Find the next relative operator (if any) for proper handling\n              j = ++i;\n\n              for (; j < len; j++) {\n                if (Expr.relative[tokens[j].type]) {\n                  break;\n                }\n              }\n\n              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n              tokens.slice(0, i - 1).concat({\n                value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n              })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n            }\n\n            matchers.push(matcher);\n          }\n        }\n\n        return elementMatcher(matchers);\n      }\n\n      function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n        var bySet = setMatchers.length > 0,\n            byElement = elementMatchers.length > 0,\n            superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n          var elem,\n              j,\n              matcher,\n              matchedCount = 0,\n              i = \"0\",\n              unmatched = seed && [],\n              setMatched = [],\n              contextBackup = outermostContext,\n              // We must always have either seed elements or outermost context\n          elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n              // Use integer dirruns iff this is the outermost matcher\n          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n              len = elems.length;\n\n          if (outermost) {\n            outermostContext = context === document || context || outermost;\n          } // Add elements passing elementMatchers directly to results\n          // Support: IE<9, Safari\n          // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n          for (; i !== len && (elem = elems[i]) != null; i++) {\n            if (byElement && elem) {\n              j = 0;\n\n              if (!context && elem.ownerDocument !== document) {\n                setDocument(elem);\n                xml = !documentIsHTML;\n              }\n\n              while (matcher = elementMatchers[j++]) {\n                if (matcher(elem, context || document, xml)) {\n                  results.push(elem);\n                  break;\n                }\n              }\n\n              if (outermost) {\n                dirruns = dirrunsUnique;\n              }\n            } // Track unmatched elements for set filters\n\n\n            if (bySet) {\n              // They will have gone through all possible matchers\n              if (elem = !matcher && elem) {\n                matchedCount--;\n              } // Lengthen the array for every element, matched or not\n\n\n              if (seed) {\n                unmatched.push(elem);\n              }\n            }\n          } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n          // makes the latter nonnegative.\n\n\n          matchedCount += i; // Apply set filters to unmatched elements\n          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n          // no element matchers and no seed.\n          // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n          // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n          // numerically zero.\n\n          if (bySet && i !== matchedCount) {\n            j = 0;\n\n            while (matcher = setMatchers[j++]) {\n              matcher(unmatched, setMatched, context, xml);\n            }\n\n            if (seed) {\n              // Reintegrate element matches to eliminate the need for sorting\n              if (matchedCount > 0) {\n                while (i--) {\n                  if (!(unmatched[i] || setMatched[i])) {\n                    setMatched[i] = pop.call(results);\n                  }\n                }\n              } // Discard index placeholder values to get only actual matches\n\n\n              setMatched = condense(setMatched);\n            } // Add matches to results\n\n\n            push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n              Sizzle.uniqueSort(results);\n            }\n          } // Override manipulation of globals by nested matchers\n\n\n          if (outermost) {\n            dirruns = dirrunsUnique;\n            outermostContext = contextBackup;\n          }\n\n          return unmatched;\n        };\n\n        return bySet ? markFunction(superMatcher) : superMatcher;\n      }\n\n      compile = Sizzle.compile = function (selector, match\n      /* Internal Use Only */\n      ) {\n        var i,\n            setMatchers = [],\n            elementMatchers = [],\n            cached = compilerCache[selector + \" \"];\n\n        if (!cached) {\n          // Generate a function of recursive functions that can be used to check each element\n          if (!match) {\n            match = tokenize(selector);\n          }\n\n          i = match.length;\n\n          while (i--) {\n            cached = matcherFromTokens(match[i]);\n\n            if (cached[expando]) {\n              setMatchers.push(cached);\n            } else {\n              elementMatchers.push(cached);\n            }\n          } // Cache the compiled function\n\n\n          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n          cached.selector = selector;\n        }\n\n        return cached;\n      };\n      /**\n       * A low-level selection function that works with Sizzle's compiled\n       *  selector functions\n       * @param {String|Function} selector A selector or a pre-compiled\n       *  selector function built with Sizzle.compile\n       * @param {Element} context\n       * @param {Array} [results]\n       * @param {Array} [seed] A set of elements to match against\n       */\n\n\n      select = Sizzle.select = function (selector, context, results, seed) {\n        var i,\n            tokens,\n            token,\n            type,\n            find,\n            compiled = typeof selector === \"function\" && selector,\n            match = !seed && tokenize(selector = compiled.selector || selector);\n        results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n        // (the latter of which guarantees us context)\n\n        if (match.length === 1) {\n          // Reduce context if the leading compound selector is an ID\n          tokens = match[0] = match[0].slice(0);\n\n          if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n            context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n            if (!context) {\n              return results; // Precompiled matchers will still verify ancestry, so step up a level\n            } else if (compiled) {\n              context = context.parentNode;\n            }\n\n            selector = selector.slice(tokens.shift().value.length);\n          } // Fetch a seed set for right-to-left matching\n\n\n          i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n          while (i--) {\n            token = tokens[i]; // Abort if we hit a combinator\n\n            if (Expr.relative[type = token.type]) {\n              break;\n            }\n\n            if (find = Expr.find[type]) {\n              // Search, expanding context for leading sibling combinators\n              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n                // If seed is empty or no tokens remain, we can return early\n                tokens.splice(i, 1);\n                selector = seed.length && toSelector(tokens);\n\n                if (!selector) {\n                  push.apply(results, seed);\n                  return results;\n                }\n\n                break;\n              }\n            }\n          }\n        } // Compile and execute a filtering function if one is not provided\n        // Provide `match` to avoid retokenization if we modified the selector above\n\n\n        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n        return results;\n      }; // One-time assignments\n      // Sort stability\n\n\n      support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n      // Always assume duplicates if they aren't passed to the comparison function\n\n      support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n      setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n      // Detached nodes confoundingly follow *each other*\n\n      support.sortDetached = assert(function (el) {\n        // Should return 1, but returns 4 (following)\n        return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n      }); // Support: IE<8\n      // Prevent attribute/property \"interpolation\"\n      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n      if (!assert(function (el) {\n        el.innerHTML = AGPolicy.createHTML(\"<a href='#'></a>\");\n        return el.firstChild.getAttribute(\"href\") === \"#\";\n      })) {\n        addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n          if (!isXML) {\n            return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n          }\n        });\n      } // Support: IE<9\n      // Use defaultValue in place of getAttribute(\"value\")\n\n\n      if (!support.attributes || !assert(function (el) {\n        el.innerHTML = AGPolicy.createHTML(\"<input/>\");\n        el.firstChild.setAttribute(\"value\", \"\");\n        return el.firstChild.getAttribute(\"value\") === \"\";\n      })) {\n        addHandle(\"value\", function (elem, name, isXML) {\n          if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n            return elem.defaultValue;\n          }\n        });\n      } // Support: IE<9\n      // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n      if (!assert(function (el) {\n        return el.getAttribute(\"disabled\") == null;\n      })) {\n        addHandle(booleans, function (elem, name, isXML) {\n          var val;\n\n          if (!isXML) {\n            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n          }\n        });\n      } // EXPOSE\n      // Do not expose Sizzle to the global scope in the case of AdGuard ExtendedCss build\n\n\n      return Sizzle; // EXPOSE\n    }(window); //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n  }\n\n  return Sizzle;\n};\n\n/* jshint ignore:end */\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class that extends Sizzle and adds support for \"matches-css\" pseudo element.\n */\n\nvar StylePropertyMatcher = function (window) {\n  var isPhantom = !!window._phantom;\n  var useFallback = isPhantom && !!window.getMatchedCSSRules;\n  /**\n   * Unquotes specified value\n   * Webkit-based browsers singlequotes <string> content property values\n   * Other browsers doublequotes content property values.\n   */\n\n  var removeContentQuotes = function removeContentQuotes(value) {\n    if (typeof value === 'string') {\n      return value.replace(/^([\"'])([\\s\\S]*)\\1$/, '$2');\n    }\n\n    return value;\n  };\n\n  var getComputedStyle = window.getComputedStyle.bind(window);\n  var getMatchedCSSRules = useFallback ? window.getMatchedCSSRules.bind(window) : null;\n  /**\n   * There is an issue in browsers based on old webkit:\n   * getComputedStyle(el, \":before\") is empty if element is not visible.\n   *\n   * To circumvent this issue we use getMatchedCSSRules instead.\n   *\n   * It appears that getMatchedCSSRules sorts the CSS rules\n   * in increasing order of specifities of corresponding selectors.\n   * We pick the css rule that is being applied to an element based on this assumption.\n   *\n   * @param element       DOM node\n   * @param pseudoElement Optional pseudoElement name\n   * @param propertyName  CSS property name\n   */\n\n  var getComputedStylePropertyValue = function getComputedStylePropertyValue(element, pseudoElement, propertyName) {\n    var value = '';\n\n    if (useFallback && pseudoElement) {\n      var cssRules = getMatchedCSSRules(element, pseudoElement) || [];\n      var i = cssRules.length;\n\n      while (i-- > 0 && !value) {\n        value = cssRules[i].style.getPropertyValue(propertyName);\n      }\n    } else {\n      var style = getComputedStyle(element, pseudoElement);\n\n      if (style) {\n        value = style.getPropertyValue(propertyName); // https://bugs.webkit.org/show_bug.cgi?id=93445\n\n        if (propertyName === 'opacity' && utils.isSafariBrowser) {\n          value = (Math.round(parseFloat(value) * 100) / 100).toString();\n        }\n      }\n    }\n\n    if (propertyName === 'content') {\n      value = removeContentQuotes(value);\n    }\n\n    return value;\n  };\n  /**\n   * Adds url parameter quotes for non-regex pattern\n   * @param {string} pattern\n   */\n\n\n  var addUrlQuotes = function addUrlQuotes(pattern) {\n    // for regex patterns\n    if (pattern[0] === '/' && pattern[pattern.length - 1] === '/' && pattern.indexOf('\\\\\"') < 10) {\n      // e.g. /^url\\\\([a-z]{4}:[a-z]{5}/\n      // or /^url\\\\(data\\\\:\\\\image\\\\/gif;base64.+/\n      var re = /(\\^)?url(\\\\)?\\\\\\((\\w|\\[\\w)/g;\n      return pattern.replace(re, '$1url$2\\\\\\(\\\\\"?$3');\n    } // for non-regex patterns\n\n\n    if (pattern.indexOf('url(\"') === -1) {\n      var _re = /url\\((.*?)\\)/g;\n      return pattern.replace(_re, 'url(\"$1\")');\n    }\n\n    return pattern;\n  };\n  /**\n   * Class that matches element style against the specified expression\n   * @member {string} propertyName\n   * @member {string} pseudoElement\n   * @member {RegExp} regex\n   */\n\n\n  var Matcher = function Matcher(propertyFilter, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n\n    try {\n      var index = propertyFilter.indexOf(':');\n      this.propertyName = propertyFilter.substring(0, index).trim();\n      var pattern = propertyFilter.substring(index + 1).trim();\n      pattern = addUrlQuotes(pattern); // Unescaping pattern\n      // For non-regex patterns, (,),[,] should be unescaped, because we require escaping them in filter rules.\n      // For regex patterns, \",\\ should be escaped, because we manually escape those in extended-css-selector.js.\n\n      if (/^\\/.*\\/$/.test(pattern)) {\n        pattern = pattern.slice(1, -1);\n        this.regex = utils.pseudoArgToRegex(pattern);\n      } else {\n        pattern = pattern.replace(/\\\\([\\\\()[\\]\"])/g, '$1');\n        this.regex = utils.createURLRegex(pattern);\n      }\n    } catch (ex) {\n      utils.logError(\"StylePropertyMatcher: invalid match string \".concat(propertyFilter));\n    }\n  };\n  /**\n   * Function to check if element CSS property matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  Matcher.prototype.matches = function (element) {\n    if (!this.regex || !this.propertyName) {\n      return false;\n    }\n\n    var value = getComputedStylePropertyValue(element, this.pseudoElement, this.propertyName);\n    return value && this.regex.test(value);\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-css'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n    sizzle.selectors.pseudos['matches-css-before'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter, ':before');\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n    sizzle.selectors.pseudos['matches-css-after'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter, ':after');\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}(window);\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar matcherUtils = {};\nmatcherUtils.MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n/**\n * Parses argument of matcher pseudo (for matches-attr and matches-property)\n * @param {string} matcherFilter argument of pseudo class\n * @returns {Array}\n */\n\nmatcherUtils.parseMatcherFilter = function (matcherFilter) {\n  var FULL_MATCH_MARKER = '\"=\"';\n  var rawArgs = [];\n\n  if (matcherFilter.indexOf(FULL_MATCH_MARKER) === -1) {\n    // if there is only one pseudo arg\n    // e.g. :matches-attr(\"data-name\") or :matches-property(\"inner.prop\")\n    // Sizzle will parse it and get rid of quotes\n    // so it might be valid arg already without them\n    rawArgs.push(matcherFilter);\n  } else {\n    matcherFilter.split('=').forEach(function (arg) {\n      if (arg[0] === '\"' && arg[arg.length - 1] === '\"') {\n        rawArgs.push(arg.slice(1, -1));\n      }\n    });\n  }\n\n  return rawArgs;\n};\n/**\n * @typedef {Object} ArgData\n * @property {string} arg\n * @property {boolean} isRegexp\n */\n\n/**\n * Parses raw matcher arg\n * @param {string} rawArg\n * @returns {ArgData}\n */\n\n\nmatcherUtils.parseRawMatcherArg = function (rawArg) {\n  var arg = rawArg;\n  var isRegexp = !!rawArg && rawArg[0] === '/' && rawArg[rawArg.length - 1] === '/';\n\n  if (isRegexp) {\n    // to avoid at least such case  :matches-property(\"//\")\n    if (rawArg.length > 2) {\n      arg = utils.toRegExp(rawArg);\n    } else {\n      throw new Error(\"Invalid regexp: \".concat(rawArg));\n    }\n  }\n\n  return {\n    arg: arg,\n    isRegexp: isRegexp\n  };\n};\n/**\n * @typedef Chain\n * @property {Object} base\n * @property {string} prop\n * @property {string} value\n */\n\n/**\n * Checks if the property exists in the base object (recursively).\n * @param {Object} base\n * @param {ArgData[]} chain array of objects - parsed string property chain\n * @param {Array} [output=[]] result acc\n * @returns {Chain[]} array of objects\n */\n\n\nmatcherUtils.filterRootsByRegexpChain = function (base, chain) {\n  var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var tempProp = chain[0];\n\n  if (chain.length === 1) {\n    // eslint-disable-next-line no-restricted-syntax\n    for (var key in base) {\n      if (tempProp.isRegexp) {\n        if (tempProp.arg.test(key)) {\n          output.push({\n            base: base,\n            prop: key,\n            value: base[key]\n          });\n        }\n      } else if (tempProp.arg === key) {\n        output.push({\n          base: base,\n          prop: tempProp.arg,\n          value: base[key]\n        });\n      }\n    }\n\n    return output;\n  } // if there is a regexp prop in input chain\n  // e.g. 'unit./^ad.+/.src' for 'unit.ad-1gf2.src unit.ad-fgd34.src'),\n  // every base keys should be tested by regexp and it can be more that one results\n\n\n  if (tempProp.isRegexp) {\n    var nextProp = chain.slice(1);\n    var baseKeys = []; // eslint-disable-next-line no-restricted-syntax\n\n    for (var _key in base) {\n      if (tempProp.arg.test(_key)) {\n        baseKeys.push(_key);\n      }\n    }\n\n    baseKeys.forEach(function (key) {\n      var item = base[key];\n      matcherUtils.filterRootsByRegexpChain(item, nextProp, output);\n    });\n  } // avoid TypeError while accessing to null-prop's child\n\n\n  if (base === null) {\n    return;\n  }\n\n  var nextBase = base[tempProp.arg];\n  chain = chain.slice(1);\n\n  if (nextBase !== undefined) {\n    matcherUtils.filterRootsByRegexpChain(nextBase, chain, output);\n  }\n\n  return output;\n};\n/**\n * Validates parsed args of matches-property pseudo\n * @param {...ArgData} args\n */\n\n\nmatcherUtils.validatePropMatcherArgs = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  for (var i = 0; i < args.length; i += 1) {\n    if (args[i].isRegexp) {\n      if (!utils.startsWith(args[i].arg.toString(), '/') || !utils.endsWith(args[i].arg.toString(), '/')) {\n        return false;\n      } // simple arg check if it is not a regexp\n\n    } else if (!/^[\\w-]+$/.test(args[i].arg)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Class that extends Sizzle and adds support for \"matches-attr\" pseudo element.\n */\n\nvar AttributesMatcher = function () {\n  /**\n   * Class that matches element attributes against the specified expressions\n   * @param {ArgData} nameArg - parsed name argument\n   * @param {ArgData} valueArg - parsed value argument\n   * @param {string} pseudoElement\n   * @constructor\n   *\n   * @member {string|RegExp} attrName\n   * @member {boolean} isRegexpName\n   * @member {string|RegExp} attrValue\n   * @member {boolean} isRegexpValue\n   */\n  var AttrMatcher = function AttrMatcher(nameArg, valueArg, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n    this.attrName = nameArg.arg;\n    this.isRegexpName = nameArg.isRegexp;\n    this.attrValue = valueArg.arg;\n    this.isRegexpValue = valueArg.isRegexp;\n  };\n  /**\n   * Function to check if element attributes matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  AttrMatcher.prototype.matches = function (element) {\n    var elAttrs = element.attributes;\n\n    if (elAttrs.length === 0 || !this.attrName) {\n      return false;\n    }\n\n    var i = 0;\n\n    while (i < elAttrs.length) {\n      var attr = elAttrs[i];\n      var matched = false;\n      var attrNameMatched = this.isRegexpName ? this.attrName.test(attr.name) : this.attrName === attr.name;\n\n      if (!this.attrValue) {\n        // for :matches-attr(\"/regex/\") or :matches-attr(\"attr-name\")\n        matched = attrNameMatched;\n      } else {\n        var attrValueMatched = this.isRegexpValue ? this.attrValue.test(attr.value) : this.attrValue === attr.value;\n        matched = attrNameMatched && attrValueMatched;\n      }\n\n      if (matched) {\n        return true;\n      }\n\n      i += 1;\n    }\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-attr'] = sizzle.selectors.createPseudo(function (attrFilter) {\n      var _matcherUtils$parseMa = matcherUtils.parseMatcherFilter(attrFilter),\n          _matcherUtils$parseMa2 = _slicedToArray(_matcherUtils$parseMa, 2),\n          rawName = _matcherUtils$parseMa2[0],\n          rawValue = _matcherUtils$parseMa2[1];\n\n      var nameArg = matcherUtils.parseRawMatcherArg(rawName);\n      var valueArg = matcherUtils.parseRawMatcherArg(rawValue);\n\n      if (!attrFilter || !matcherUtils.validatePropMatcherArgs(nameArg, valueArg)) {\n        throw new Error(\"Invalid argument of :matches-attr pseudo class: \".concat(attrFilter));\n      }\n\n      var matcher = new AttrMatcher(nameArg, valueArg);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Parses raw property arg\n * @param {string} input\n * @returns {ArgData[]} array of objects\n */\n\nvar parseRawPropChain = function parseRawPropChain(input) {\n  var PROPS_DIVIDER = '.';\n  var REGEXP_MARKER = '/';\n  var propsArr = [];\n  var str = input;\n\n  while (str.length > 0) {\n    if (utils.startsWith(str, PROPS_DIVIDER)) {\n      // for cases like '.prop.id' and 'nested..test'\n      throw new Error(\"Invalid chain property: \".concat(input));\n    }\n\n    if (!utils.startsWith(str, REGEXP_MARKER)) {\n      var isRegexp = false;\n      var dividerIndex = str.indexOf(PROPS_DIVIDER);\n\n      if (str.indexOf(PROPS_DIVIDER) === -1) {\n        // if there is no '.' left in str\n        // take the rest of str as prop\n        propsArr.push({\n          arg: str,\n          isRegexp: isRegexp\n        });\n        return propsArr;\n      } // else take prop from str\n\n\n      var prop = str.slice(0, dividerIndex); // for cases like 'asadf.?+/.test'\n\n      if (prop.indexOf(REGEXP_MARKER) > -1) {\n        // prop is '?+/'\n        throw new Error(\"Invalid chain property: \".concat(prop));\n      }\n\n      propsArr.push({\n        arg: prop,\n        isRegexp: isRegexp\n      }); // delete prop from str\n\n      str = str.slice(dividerIndex);\n    } else {\n      // deal with regexp\n      var propChunks = [];\n      propChunks.push(str.slice(0, 1)); // if str starts with '/', delete it from str and find closing regexp slash.\n      // note that chained property name can not include '/' or '.'\n      // so there is no checking for escaped characters\n\n      str = str.slice(1);\n      var regexEndIndex = str.indexOf(REGEXP_MARKER);\n\n      if (regexEndIndex < 1) {\n        // regexp should be at least === '/./'\n        // so we should avoid args like '/id' and 'test.//.id'\n        throw new Error(\"Invalid regexp: \".concat(REGEXP_MARKER).concat(str));\n      }\n\n      var _isRegexp = true; // take the rest regexp part\n\n      propChunks.push(str.slice(0, regexEndIndex + 1));\n\n      var _prop = utils.toRegExp(propChunks.join(''));\n\n      propsArr.push({\n        arg: _prop,\n        isRegexp: _isRegexp\n      }); // delete prop from str\n\n      str = str.slice(regexEndIndex + 1);\n    }\n\n    if (!str) {\n      return propsArr;\n    } // str should be like '.nextProp' now\n    // so 'zx.prop' or '.' is invalid\n\n\n    if (!utils.startsWith(str, PROPS_DIVIDER) || utils.startsWith(str, PROPS_DIVIDER) && str.length === 1) {\n      throw new Error(\"Invalid chain property: \".concat(input));\n    }\n\n    str = str.slice(1);\n  }\n};\n\nvar convertTypeFromStr = function convertTypeFromStr(value) {\n  var numValue = Number(value);\n  var output;\n\n  if (!Number.isNaN(numValue)) {\n    output = numValue;\n  } else {\n    switch (value) {\n      case 'undefined':\n        output = undefined;\n        break;\n\n      case 'null':\n        output = null;\n        break;\n\n      case 'true':\n        output = true;\n        break;\n\n      case 'false':\n        output = false;\n        break;\n\n      default:\n        output = value;\n    }\n  }\n\n  return output;\n};\n\nvar convertTypeIntoStr = function convertTypeIntoStr(value) {\n  var output;\n\n  switch (value) {\n    case undefined:\n      output = 'undefined';\n      break;\n\n    case null:\n      output = 'null';\n      break;\n\n    default:\n      output = value.toString();\n  }\n\n  return output;\n};\n/**\n * Class that extends Sizzle and adds support for \"matches-property\" pseudo element.\n */\n\n\nvar ElementPropertyMatcher = function () {\n  /**\n   * Class that matches element properties against the specified expressions\n   * @param {ArgData[]} propsChainArg - array of parsed props chain objects\n   * @param {ArgData} valueArg - parsed value argument\n   * @param {string} pseudoElement\n   * @constructor\n   *\n   * @member {Array} chainedProps\n   * @member {boolean} isRegexpName\n   * @member {string|RegExp} propValue\n   * @member {boolean} isRegexpValue\n   */\n  var PropMatcher = function PropMatcher(propsChainArg, valueArg, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n    this.chainedProps = propsChainArg;\n    this.propValue = valueArg.arg;\n    this.isRegexpValue = valueArg.isRegexp;\n  };\n  /**\n   * Function to check if element properties matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  PropMatcher.prototype.matches = function (element) {\n    var ownerObjArr = matcherUtils.filterRootsByRegexpChain(element, this.chainedProps);\n\n    if (ownerObjArr.length === 0) {\n      return false;\n    }\n\n    var matched = true;\n\n    if (this.propValue) {\n      for (var i = 0; i < ownerObjArr.length; i += 1) {\n        var realValue = ownerObjArr[i].value;\n\n        if (this.isRegexpValue) {\n          matched = this.propValue.test(convertTypeIntoStr(realValue));\n        } else {\n          // handle 'null' and 'undefined' property values set as string\n          if (realValue === 'null' || realValue === 'undefined') {\n            matched = this.propValue === realValue;\n            break;\n          }\n\n          matched = convertTypeFromStr(this.propValue) === realValue;\n        }\n\n        if (matched) {\n          break;\n        }\n      }\n    }\n\n    return matched;\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-property'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      if (!propertyFilter) {\n        throw new Error('No argument is given for :matches-property pseudo class');\n      }\n\n      var _matcherUtils$parseMa = matcherUtils.parseMatcherFilter(propertyFilter),\n          _matcherUtils$parseMa2 = _slicedToArray(_matcherUtils$parseMa, 2),\n          rawProp = _matcherUtils$parseMa2[0],\n          rawValue = _matcherUtils$parseMa2[1]; // chained property name can not include '/' or '.'\n      // so regex prop names with such escaped characters are invalid\n\n\n      if (rawProp.indexOf('\\\\/') > -1 || rawProp.indexOf('\\\\.') > -1) {\n        throw new Error(\"Invalid property name: \".concat(rawProp));\n      }\n\n      var propsChainArg = parseRawPropChain(rawProp);\n      var valueArg = matcherUtils.parseRawMatcherArg(rawValue);\n      var propsToValidate = [].concat(_toConsumableArray(propsChainArg), [valueArg]);\n\n      if (!matcherUtils.validatePropMatcherArgs(propsToValidate)) {\n        throw new Error(\"Invalid argument of :matches-property pseudo class: \".concat(propertyFilter));\n      }\n\n      var matcher = new PropMatcher(propsChainArg, valueArg);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Copyright 2020 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class that extends Sizzle and adds support for :is() pseudo element.\n */\n\nvar IsAnyMatcher = function () {\n  /**\n   * Class that matches element by one of the selectors\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/:is\n   * @param {Array} selectors\n   * @param {string} pseudoElement\n   * @constructor\n   */\n  var IsMatcher = function IsMatcher(selectors, pseudoElement) {\n    this.selectors = selectors;\n    this.pseudoElement = pseudoElement;\n  };\n  /**\n   * Function to check if element can be matched by any passed selector\n   * @param {Element} element to check\n   */\n\n\n  IsMatcher.prototype.matches = function (element) {\n    var isMatched = !!this.selectors.find(function (selector) {\n      var nodes = document.querySelectorAll(selector);\n      return Array.from(nodes).find(function (node) {\n        return node === element;\n      });\n    });\n    return isMatched;\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['is'] = sizzle.selectors.createPseudo(function (input) {\n      if (input === '') {\n        throw new Error(\"Invalid argument of :is pseudo-class: \".concat(input));\n      }\n\n      var selectors = input.split(',').map(function (s) {\n        return s.trim();\n      }); // collect valid selectors and log about invalid ones\n\n      var validSelectors = selectors.reduce(function (acc, selector) {\n        if (cssUtils.isSimpleSelectorValid(selector)) {\n          acc.push(selector);\n        } else {\n          utils.logInfo(\"Invalid selector passed to :is() pseudo-class: '\".concat(selector, \"'\"));\n        }\n\n        return acc;\n      }, []);\n      var matcher = new IsMatcher(validSelectors);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  };\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Copyright 2021 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Extended selector factory module, for creating extended selector classes.\n *\n * Extended selection capabilities description:\n * https://github.com/AdguardTeam/ExtendedCss/blob/master/README.md\n */\n\nvar ExtendedSelectorFactory = function () {\n  // while adding new markers, constants in other AdGuard repos should be corrected\n  // AdGuard browser extension : CssFilterRule.SUPPORTED_PSEUDO_CLASSES and CssFilterRule.EXTENDED_CSS_MARKERS\n  // tsurlfilter, SafariConverterLib : EXT_CSS_PSEUDO_INDICATORS\n  var PSEUDO_EXTENSIONS_MARKERS = [':has', ':contains', ':has-text', ':matches-css', ':-abp-has', ':-abp-has-text', ':if', ':if-not', ':xpath', ':nth-ancestor', ':upward', ':remove', ':matches-attr', ':matches-property', ':-abp-contains', ':is'];\n  var initialized = false;\n  var Sizzle;\n  /**\n   * Lazy initialization of the ExtendedSelectorFactory and objects that might be necessary for creating and applying styles.\n   * This method extends Sizzle engine that we use under the hood with our custom pseudo-classes.\n   */\n\n  function initialize() {\n    if (initialized) {\n      return;\n    }\n\n    initialized = true; // Our version of Sizzle is initialized lazily as well\n\n    Sizzle = initializeSizzle(); // Add :matches-css-*() support\n\n    StylePropertyMatcher.extendSizzle(Sizzle); // Add :matches-attr() support\n\n    AttributesMatcher.extendSizzle(Sizzle); // Add :matches-property() support\n\n    ElementPropertyMatcher.extendSizzle(Sizzle); // Add :is() support\n\n    IsAnyMatcher.extendSizzle(Sizzle); // Add :contains, :has-text, :-abp-contains support\n\n    var containsPseudo = Sizzle.selectors.createPseudo(function (text) {\n      if (/^\\s*\\/.*\\/[gmisuy]*\\s*$/.test(text)) {\n        text = text.trim();\n        var flagsIndex = text.lastIndexOf('/');\n        var flags = text.substring(flagsIndex + 1);\n        text = text.substr(0, flagsIndex + 1).slice(1, -1).replace(/\\\\([\\\\\"])/g, '$1');\n        var regex;\n\n        try {\n          regex = new RegExp(text, flags);\n        } catch (e) {\n          throw new Error(\"Invalid argument of :contains pseudo class: \".concat(text));\n        }\n\n        return function (elem) {\n          var elemTextContent = utils.nodeTextContentGetter.apply(elem);\n          return regex.test(elemTextContent);\n        };\n      }\n\n      text = text.replace(/\\\\([\\\\()[\\]\"])/g, '$1');\n      return function (elem) {\n        var elemTextContent = utils.nodeTextContentGetter.apply(elem);\n        return elemTextContent.indexOf(text) > -1;\n      };\n    });\n    Sizzle.selectors.pseudos['contains'] = containsPseudo;\n    Sizzle.selectors.pseudos['has-text'] = containsPseudo;\n    Sizzle.selectors.pseudos['-abp-contains'] = containsPseudo; // Add :if, :-abp-has support\n\n    Sizzle.selectors.pseudos['if'] = Sizzle.selectors.pseudos['has'];\n    Sizzle.selectors.pseudos['-abp-has'] = Sizzle.selectors.pseudos['has']; // Add :if-not support\n\n    Sizzle.selectors.pseudos['if-not'] = Sizzle.selectors.createPseudo(function (selector) {\n      if (typeof selector === 'string') {\n        Sizzle.compile(selector);\n      }\n\n      return function (elem) {\n        return Sizzle(selector, elem).length === 0;\n      };\n    });\n    registerParserOnlyTokens();\n  }\n  /**\n   * Registrate custom tokens for parser.\n   * Needed for proper work of pseudos:\n   * for checking if the token is last and pseudo-class arguments validation\n   */\n\n\n  function registerParserOnlyTokens() {\n    Sizzle.selectors.pseudos['xpath'] = Sizzle.selectors.createPseudo(function (selector) {\n      try {\n        document.createExpression(selector, null);\n      } catch (e) {\n        throw new Error(\"Invalid argument of :xpath pseudo class: \".concat(selector));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['nth-ancestor'] = Sizzle.selectors.createPseudo(function (selector) {\n      var deep = Number(selector);\n\n      if (Number.isNaN(deep) || deep < 1 || deep >= 256) {\n        throw new Error(\"Invalid argument of :nth-ancestor pseudo class: \".concat(selector));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['upward'] = Sizzle.selectors.createPseudo(function (input) {\n      if (input === '') {\n        throw new Error(\"Invalid argument of :upward pseudo class: \".concat(input));\n      } else if (Number.isInteger(+input) && (+input < 1 || +input >= 256)) {\n        throw new Error(\"Invalid argument of :upward pseudo class: \".concat(input));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['remove'] = Sizzle.selectors.createPseudo(function (input) {\n      if (input !== '') {\n        throw new Error(\"Invalid argument of :remove pseudo class: \".concat(input));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n  }\n  /**\n   * Checks if specified token can be used by document.querySelectorAll.\n   */\n\n\n  function isSimpleToken(token) {\n    var type = token.type;\n\n    if (type === 'ID' || type === 'CLASS' || type === 'ATTR' || type === 'TAG' || type === 'CHILD') {\n      // known simple tokens\n      return true;\n    }\n\n    if (type === 'PSEUDO') {\n      // check if value contains any of extended pseudo classes\n      var i = PSEUDO_EXTENSIONS_MARKERS.length;\n\n      while (i--) {\n        if (token.value.indexOf(PSEUDO_EXTENSIONS_MARKERS[i]) >= 0) {\n          return false;\n        }\n      }\n\n      return true;\n    } // all others aren't simple\n\n\n    return false;\n  }\n  /**\n   * Checks if specified token is a combinator\n   */\n\n\n  function isRelationToken(token) {\n    var type = token.type;\n    return type === ' ' || type === '>' || type === '+' || type === '~';\n  }\n  /**\n   * ExtendedSelectorParser is a helper class for creating various selector instances which\n   * all shares a method `querySelectorAll()` and `matches()` implementing different search strategies\n   * depending on a type of selector.\n   *\n   * Currently, there are 3 types:\n   *  A trait-less extended selector\n   *    - we directly feed selector strings to Sizzle.\n   *  A splitted extended selector\n   *    - such as #container #feedItem:has(.ads), where it is splitted to `#container` and `#feedItem:has(.ads)`.\n   */\n\n\n  function ExtendedSelectorParser(selectorText, tokens, debug) {\n    initialize();\n\n    if (typeof tokens === 'undefined') {\n      this.selectorText = cssUtils.normalize(selectorText); // Passing `returnUnsorted` in order to receive tokens in the order that's valid for the browser\n      // In Sizzle internally, the tokens are re-sorted: https://github.com/AdguardTeam/ExtendedCss/issues/55\n\n      this.tokens = Sizzle.tokenize(this.selectorText, false, {\n        returnUnsorted: true\n      });\n    } else {\n      this.selectorText = selectorText;\n      this.tokens = tokens;\n    }\n\n    if (debug === true) {\n      this.debug = true;\n    }\n  }\n\n  ExtendedSelectorParser.prototype = {\n    /**\n     * The main method, creates a selector instance depending on the type of a selector.\n     * @public\n     */\n    createSelector: function createSelector() {\n      var debug = this.debug;\n      var tokens = this.tokens;\n      var selectorText = this.selectorText;\n\n      if (tokens.length !== 1) {\n        // Comma-separate selector - can't optimize further\n        return new TraitLessSelector(selectorText, debug);\n      }\n\n      var xpathPart = this.getXpathPart();\n\n      if (typeof xpathPart !== 'undefined') {\n        return new XpathSelector(selectorText, xpathPart, debug);\n      }\n\n      var upwardPart = this.getUpwardPart();\n\n      if (typeof upwardPart !== 'undefined') {\n        var output;\n        var upwardDeep = parseInt(upwardPart, 10); // if upward parameter is not a number, we consider it as a selector\n\n        if (Number.isNaN(upwardDeep)) {\n          output = new UpwardSelector(selectorText, upwardPart, debug);\n        } else {\n          // upward works like nth-ancestor\n          var xpath = this.convertNthAncestorToken(upwardDeep);\n          output = new XpathSelector(selectorText, xpath, debug);\n        }\n\n        return output;\n      } // argument of pseudo-class remove;\n      // it's defined only if remove is parsed as last token\n      // and it's valid only if remove arg is empty string\n\n\n      var removePart = this.getRemovePart();\n\n      if (typeof removePart !== 'undefined') {\n        var hasValidRemovePart = removePart === '';\n        return new RemoveSelector(selectorText, hasValidRemovePart, debug);\n      }\n\n      tokens = tokens[0];\n      var l = tokens.length;\n      var lastRelTokenInd = this.getSplitPoint();\n\n      if (typeof lastRelTokenInd === 'undefined') {\n        try {\n          document.querySelector(selectorText);\n        } catch (e) {\n          return new TraitLessSelector(selectorText, debug);\n        }\n\n        return new NotAnExtendedSelector(selectorText, debug);\n      }\n\n      var simple = '';\n      var relation = null;\n      var complex = '';\n      var i = 0;\n\n      for (; i < lastRelTokenInd; i++) {\n        // build simple part\n        simple += tokens[i].value;\n      }\n\n      if (i > 0) {\n        // build relation part\n        relation = tokens[i++].type;\n      } // i is pointing to the start of a complex part.\n\n\n      for (; i < l; i++) {\n        complex += tokens[i].value;\n      }\n\n      return lastRelTokenInd === -1 ? new TraitLessSelector(selectorText, debug) : new SplittedSelector(selectorText, simple, relation, complex, debug);\n    },\n\n    /**\n     * @private\n     * @return {number|undefined} An index of a token that is split point.\n     * returns undefined if the selector does not contain any complex tokens\n     * or it is not eligible for splitting.\n     * Otherwise returns an integer indicating the index of the last relation token.\n     */\n    getSplitPoint: function getSplitPoint() {\n      var tokens = this.tokens[0]; // We split selector only when the last compound selector\n      // is the only extended selector.\n\n      var latestRelationTokenIndex = -1;\n      var haveMetComplexToken = false;\n\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (isRelationToken(token)) {\n          if (haveMetComplexToken) {\n            return;\n          }\n\n          latestRelationTokenIndex = i;\n        } else if (!isSimpleToken(token)) {\n          haveMetComplexToken = true;\n        }\n      }\n\n      if (!haveMetComplexToken) {\n        return;\n      }\n\n      return latestRelationTokenIndex;\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} xpath selector part if exists\n     * returns undefined if the selector does not contain xpath tokens\n     */\n    getXpathPart: function getXpathPart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'xpath') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':xpath\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n\n            if (matches[0] === 'nth-ancestor') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':nth-ancestor\\' should be at the end of the selector');\n              }\n\n              var deep = matches[1];\n\n              if (deep > 0 && deep < 256) {\n                return this.convertNthAncestorToken(deep);\n              }\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * converts nth-ancestor/upward deep value to xpath equivalent\n     * @param {number} deep\n     * @return {string}\n     */\n    convertNthAncestorToken: function convertNthAncestorToken(deep) {\n      var result = '..';\n\n      while (deep > 1) {\n        result += '/..';\n        deep--;\n      }\n\n      return result;\n    },\n\n    /**\n     * Checks if the token is last,\n     * except of remove pseudo-class\n     * @param {Array} tokens\n     * @param {number} i index of token\n     * @returns {boolean}\n     */\n    isLastToken: function isLastToken(tokens, i) {\n      // check id the next parsed token is remove pseudo\n      var isNextRemoveToken = tokens[i + 1] && tokens[i + 1].type === 'PSEUDO' && tokens[i + 1].matches && tokens[i + 1].matches[0] === 'remove'; // check if the token is last\n      // and if it is not check if it is remove one\n      // which should be skipped\n\n      return i + 1 !== tokens.length && !isNextRemoveToken;\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} upward parameter\n     * or undefined if the input does not contain upward tokens\n     */\n    getUpwardPart: function getUpwardPart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'upward') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':upward\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} remove parameter\n     * or undefined if the input does not contain remove tokens\n     */\n    getRemovePart: function getRemovePart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'remove') {\n              if (i + 1 !== tokensLength) {\n                throw new Error('Invalid pseudo: \\':remove\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n          }\n        }\n      }\n    }\n  };\n  var globalDebuggingFlag = false;\n\n  function isDebugging() {\n    return globalDebuggingFlag || this.debug;\n  }\n  /**\n   * This class represents a selector which is not an extended selector.\n   * @param {string} selectorText\n   * @param {boolean=} debug\n   * @final\n   */\n\n\n  function NotAnExtendedSelector(selectorText, debug) {\n    this.selectorText = selectorText;\n    this.debug = debug;\n  }\n\n  NotAnExtendedSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      return document.querySelectorAll(this.selectorText);\n    },\n    matches: function matches(element) {\n      return element[utils.matchesPropertyName](this.selectorText);\n    },\n    isDebugging: isDebugging\n  };\n  /**\n   * A trait-less extended selector class.\n   * @param {string} selectorText\n   * @param {boolean=} debug\n   * @constructor\n   */\n\n  function TraitLessSelector(selectorText, debug) {\n    this.selectorText = selectorText;\n    this.debug = debug;\n    Sizzle.compile(selectorText);\n  }\n\n  TraitLessSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      return Sizzle(this.selectorText);\n    },\n\n    /** @final */\n    matches: function matches(element) {\n      return Sizzle.matchesSelector(element, this.selectorText);\n    },\n\n    /** @final */\n    isDebugging: isDebugging\n  };\n  /**\n   * Parental class for such pseudo-classes as xpath, upward, remove\n   * which are limited to be the last one token in selector\n   *\n   * @param {string} selectorText\n   * @param {string} pseudoClassArg pseudo-class arg\n   * @param {boolean=} debug\n   * @constructor\n   */\n\n  function BaseLastArgumentSelector(selectorText, pseudoClassArg, debug) {\n    this.selectorText = selectorText;\n    this.pseudoClassArg = pseudoClassArg;\n    this.debug = debug;\n    Sizzle.compile(this.selectorText);\n  }\n\n  BaseLastArgumentSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      var _this = this;\n\n      var resultNodes = [];\n      var simpleNodes;\n\n      if (this.selectorText) {\n        simpleNodes = Sizzle(this.selectorText);\n\n        if (!simpleNodes || !simpleNodes.length) {\n          return resultNodes;\n        }\n      } else {\n        simpleNodes = [document];\n      }\n\n      simpleNodes.forEach(function (node) {\n        _this.searchResultNodes(node, _this.pseudoClassArg, resultNodes);\n      });\n      return Sizzle.uniqueSort(resultNodes);\n    },\n\n    /** @final */\n    matches: function matches(element) {\n      var results = this.querySelectorAll();\n      return results.indexOf(element) > -1;\n    },\n\n    /** @final */\n    isDebugging: isDebugging,\n\n    /**\n     * Primitive method that returns all nodes if pseudo-class arg is defined.\n     * That logic works for remove pseudo-class,\n     * but for others it should be overridden.\n     * @param {Object} node context element\n     * @param {string} pseudoClassArg pseudo-class argument\n     * @param {Array} result\n     */\n    searchResultNodes: function searchResultNodes(node, pseudoClassArg, result) {\n      if (pseudoClassArg) {\n        result.push(node);\n      }\n    }\n  };\n  /**\n   * Xpath selector class\n   * Limited to support 'xpath' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {string} xpath value\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n  function XpathSelector(selectorText, xpath, debug) {\n    var NO_SELECTOR_MARKER = ':xpath(//';\n    var BODY_SELECTOR_REPLACER = 'body:xpath(//';\n    var modifiedSelectorText = selectorText; // Normally, a pseudo-class is applied to nodes selected by a selector -- selector:xpath(...).\n    // However, :xpath is special as the selector can be ommited.\n    // For any other pseudo-class that would mean \"apply to ALL DOM nodes\",\n    // but in case of :xpath it just means \"apply me to the document\".\n\n    if (utils.startsWith(selectorText, NO_SELECTOR_MARKER)) {\n      modifiedSelectorText = selectorText.replace(NO_SELECTOR_MARKER, BODY_SELECTOR_REPLACER);\n    }\n\n    BaseLastArgumentSelector.call(this, modifiedSelectorText, xpath, debug);\n  }\n\n  XpathSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  XpathSelector.prototype.constructor = XpathSelector;\n  /**\n   * Applies xpath pseudo-class to provided context node\n   * @param {Object} node context element\n   * @param {string} pseudoClassArg xpath\n   * @param {Array} result\n   * @override\n   */\n\n  XpathSelector.prototype.searchResultNodes = function (node, pseudoClassArg, result) {\n    var xpathResult = document.evaluate(pseudoClassArg, node, null, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n    var iNode; // eslint-disable-next-line no-cond-assign\n\n    while (iNode = xpathResult.iterateNext()) {\n      result.push(iNode);\n    }\n  };\n  /**\n   * Upward selector class\n   * Limited to support 'upward' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {string} upwardSelector value\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n\n  function UpwardSelector(selectorText, upwardSelector, debug) {\n    BaseLastArgumentSelector.call(this, selectorText, upwardSelector, debug);\n  }\n\n  UpwardSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  UpwardSelector.prototype.constructor = UpwardSelector;\n  /**\n   * Applies upward pseudo-class to provided context node\n   * @param {Object} node context element\n   * @param {string} upwardSelector upward selector\n   * @param {Array} result\n   * @override\n   */\n\n  UpwardSelector.prototype.searchResultNodes = function (node, upwardSelector, result) {\n    if (upwardSelector !== '') {\n      var parent = node.parentElement;\n\n      if (parent === null) {\n        return;\n      }\n\n      node = parent.closest(upwardSelector);\n\n      if (node === null) {\n        return;\n      }\n    }\n\n    result.push(node);\n  };\n  /**\n   * Remove selector class\n   * Limited to support 'remove' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {boolean} hasValidRemovePart\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n\n  function RemoveSelector(selectorText, hasValidRemovePart, debug) {\n    var REMOVE_PSEUDO_MARKER = ':remove()';\n    var removeMarkerIndex = selectorText.indexOf(REMOVE_PSEUDO_MARKER); // deleting remove part of rule instead of which\n    // pseudo-property property 'remove' will be added by ExtendedCssParser\n\n    var modifiedSelectorText = selectorText.slice(0, removeMarkerIndex);\n    BaseLastArgumentSelector.call(this, modifiedSelectorText, hasValidRemovePart, debug); // mark extendedSelector as Remove one for ExtendedCssParser\n\n    this.isRemoveSelector = true;\n  }\n\n  RemoveSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  RemoveSelector.prototype.constructor = RemoveSelector;\n  /**\n   * A splitted extended selector class.\n   *\n   * #container #feedItem:has(.ads)\n   * +--------+                     simple\n   *           +                    relation\n   *            +-----------------+ complex\n   * We split selector only when the last selector is complex\n   * @param {string} selectorText\n   * @param {string} simple\n   * @param {string} relation\n   * @param {string} complex\n   * @param {boolean=} debug\n   * @constructor\n   * @extends TraitLessSelector\n   */\n\n  function SplittedSelector(selectorText, simple, relation, complex, debug) {\n    TraitLessSelector.call(this, selectorText, debug);\n    this.simple = simple;\n    this.relation = relation;\n    this.complex = complex;\n    Sizzle.compile(complex);\n  }\n\n  SplittedSelector.prototype = Object.create(TraitLessSelector.prototype);\n  SplittedSelector.prototype.constructor = SplittedSelector;\n  /** @override */\n\n  SplittedSelector.prototype.querySelectorAll = function () {\n    var _this2 = this;\n\n    var resultNodes = [];\n    var simpleNodes;\n    var simple = this.simple;\n    var relation;\n\n    if (simple) {\n      // First we use simple selector to narrow our search\n      simpleNodes = document.querySelectorAll(simple);\n\n      if (!simpleNodes || !simpleNodes.length) {\n        return resultNodes;\n      }\n\n      relation = this.relation;\n    } else {\n      simpleNodes = [document];\n      relation = ' ';\n    }\n\n    switch (relation) {\n      case ' ':\n        simpleNodes.forEach(function (node) {\n          _this2.relativeSearch(node, resultNodes);\n        });\n        break;\n\n      case '>':\n        {\n          simpleNodes.forEach(function (node) {\n            Object.values(node.children).forEach(function (childNode) {\n              if (_this2.matches(childNode)) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n\n      case '+':\n        {\n          simpleNodes.forEach(function (node) {\n            var parentNode = node.parentNode;\n            Object.values(parentNode.children).forEach(function (childNode) {\n              if (_this2.matches(childNode) && childNode.previousElementSibling === node) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n\n      case '~':\n        {\n          simpleNodes.forEach(function (node) {\n            var parentNode = node.parentNode;\n            Object.values(parentNode.children).forEach(function (childNode) {\n              if (_this2.matches(childNode) && node.compareDocumentPosition(childNode) === 4) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n    }\n\n    return Sizzle.uniqueSort(resultNodes);\n  };\n  /**\n   * Performs a search of \"complex\" part relative to results for the \"simple\" part.\n   * @param {Node} node a node matching the \"simple\" part.\n   * @param {Node[]} result an array to append search result.\n   */\n\n\n  SplittedSelector.prototype.relativeSearch = function (node, results) {\n    Sizzle(this.complex, node, results);\n  };\n\n  return {\n    /**\n     * Wraps the inner class so that the instance is not exposed.\n     */\n    createSelector: function createSelector(selector, tokens, debug) {\n      return new ExtendedSelectorParser(selector, tokens, debug).createSelector();\n    },\n\n    /**\n     * Mark every selector as a selector being debugged, so that timing information\n     * for the selector is printed to the console.\n     */\n    enableGlobalDebugging: function enableGlobalDebugging() {\n      globalDebuggingFlag = true;\n    }\n  };\n}();\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A helper class that parses stylesheets containing extended selectors\n * into ExtendedSelector instances and key-value maps of style declarations.\n * Please note, that it does not support any complex things like media queries and such.\n */\n\nvar ExtendedCssParser = function () {\n  var reDeclEnd = /[;}]/g;\n  var reDeclDivider = /[;:}]/g;\n  var reNonWhitespace = /\\S/g;\n  var Sizzle;\n  /**\n   * @param {string} cssText\n   * @constructor\n   */\n\n  function Parser(cssText) {\n    this.cssText = cssText;\n  }\n\n  Parser.prototype = {\n    error: function error(position) {\n      throw new Error(\"CssParser: parse error at position \".concat(this.posOffset + position));\n    },\n\n    /**\n     * Validates that the tokens correspond to a valid selector.\n     * Sizzle is different from browsers and some selectors that it tolerates aren't actually valid.\n     * For instance, \"div >\" won't work in a browser, but it will in Sizzle (it'd be the same as \"div > *\").\n     *\n     * @param {*} selectors An array of SelectorData (selector, groups)\n     * @returns {boolean} false if any of the groups are invalid\n     */\n    validateSelectors: function validateSelectors(selectors) {\n      var iSelectors = selectors.length;\n\n      while (iSelectors--) {\n        var groups = selectors[iSelectors].groups;\n        var iGroups = groups.length;\n\n        while (iGroups--) {\n          var tokens = groups[iGroups];\n          var lastToken = tokens[tokens.length - 1];\n\n          if (Sizzle.selectors.relative[lastToken.type]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Parses a stylesheet and returns a list of pairs of an ExtendedSelector and a styles map.\n     * This method will throw an error in case of an obviously invalid input.\n     * If any of the selectors used in the stylesheet cannot be compiled into an ExtendedSelector,\n     * it will be ignored.\n     *\n     * @typedef {Object} ExtendedStyle\n     * @property {Object} selector An instance of the {@link ExtendedSelector} class\n     * @property {Object} styleMap A map of styles parsed\n     *\n     * @returns {Array.<ExtendedStyle>} An array of the styles parsed\n     */\n    parseCss: function parseCss() {\n      this.posOffset = 0;\n\n      if (!this.cssText) {\n        this.error(0);\n      }\n\n      var results = [];\n\n      while (this.cssText) {\n        // Apply tolerant tokenization.\n        var parseResult = Sizzle.tokenize(this.cssText, false, {\n          tolerant: true,\n          returnUnsorted: true\n        });\n        var selectorData = parseResult.selectors;\n        this.nextIndex = parseResult.nextIndex;\n\n        if (this.cssText.charCodeAt(this.nextIndex) !== 123 ||\n        /* charCode of '{' */\n        !this.validateSelectors(selectorData)) {\n          this.error(this.nextIndex);\n        }\n\n        this.nextIndex++; // Move the pointer to the start of style declaration.\n\n        var styleMap = this.parseNextStyle();\n        var debug = false; // If there is a style property 'debug', mark the selector\n        // as a debuggable selector, and delete the style declaration.\n\n        var debugPropertyValue = styleMap['debug'];\n\n        if (typeof debugPropertyValue !== 'undefined') {\n          if (debugPropertyValue === 'global') {\n            ExtendedSelectorFactory.enableGlobalDebugging();\n          }\n\n          debug = true;\n          delete styleMap['debug'];\n        } // Creating an ExtendedSelector instance for every selector we got from Sizzle.tokenize.\n        // This is quite important as Sizzle does a poor job at executing selectors like \"selector1, selector2\".\n\n\n        for (var i = 0, l = selectorData.length; i < l; i++) {\n          var data = selectorData[i];\n\n          try {\n            var extendedSelector = ExtendedSelectorFactory.createSelector(data.selectorText, data.groups, debug);\n\n            if (extendedSelector.pseudoClassArg && extendedSelector.isRemoveSelector) {\n              // if there is remove pseudo-class in rule,\n              // the element will be removed and no other styles will be applied\n              styleMap['remove'] = 'true';\n            }\n\n            results.push({\n              selector: extendedSelector,\n              style: styleMap\n            });\n          } catch (ex) {\n            utils.logError(\"ExtendedCssParser: ignoring invalid selector \".concat(data.selectorText));\n          }\n        }\n      }\n\n      return results;\n    },\n    parseNextStyle: function parseNextStyle() {\n      var styleMap = Object.create(null);\n      var bracketPos = this.parseUntilClosingBracket(styleMap); // Cut out matched portion from cssText.\n\n      reNonWhitespace.lastIndex = bracketPos + 1;\n      var match = reNonWhitespace.exec(this.cssText);\n\n      if (match === null) {\n        this.cssText = '';\n        return styleMap;\n      }\n\n      var matchPos = match.index;\n      this.cssText = this.cssText.slice(matchPos);\n      this.posOffset += matchPos;\n      return styleMap;\n    },\n\n    /**\n     * @return {number} an index of the next '}' in `this.cssText`.\n     */\n    parseUntilClosingBracket: function parseUntilClosingBracket(styleMap) {\n      // Expects \":\", \";\", and \"}\".\n      reDeclDivider.lastIndex = this.nextIndex;\n      var match = reDeclDivider.exec(this.cssText);\n\n      if (match === null) {\n        this.error(this.nextIndex);\n      }\n\n      var matchPos = match.index;\n      var matched = match[0];\n\n      if (matched === '}') {\n        return matchPos;\n      }\n\n      if (matched === ':') {\n        var colonIndex = matchPos; // Expects \";\" and \"}\".\n\n        reDeclEnd.lastIndex = colonIndex;\n        match = reDeclEnd.exec(this.cssText);\n\n        if (match === null) {\n          this.error(colonIndex);\n        }\n\n        matchPos = match.index;\n        matched = match[0]; // Populates the `styleMap` key-value map.\n\n        var property = this.cssText.slice(this.nextIndex, colonIndex).trim();\n        var value = this.cssText.slice(colonIndex + 1, matchPos).trim();\n        styleMap[property] = value; // If found \"}\", re-run the outer loop.\n\n        if (matched === '}') {\n          return matchPos;\n        }\n      } // matchPos is the position of the next ';'.\n      // Increase 'nextIndex' and re-run the loop.\n\n\n      this.nextIndex = matchPos + 1;\n      return this.parseUntilClosingBracket(styleMap); // Should be a subject of tail-call optimization.\n    }\n  };\n  return {\n    parseCss: function parseCss(cssText) {\n      Sizzle = initializeSizzle();\n      return new Parser(cssUtils.normalize(cssText)).parseCss();\n    }\n  };\n}();\n\n/**\n * This callback is used to get affected node elements and handle style properties\n * before they are applied to them if it is necessary\n * @callback beforeStyleApplied\n * @param {object} affectedElement - Object containing DOM node and rule to be applied\n * @return {object} affectedElement - Same or modified object containing DOM node and rule to be applied\n */\n\n/**\n * Extended css class\n *\n * @param {Object} configuration\n * @param {string} configuration.styleSheet - the CSS stylesheet text\n * @param {beforeStyleApplied} [configuration.beforeStyleApplied] - the callback that handles affected elements\n * @constructor\n */\n\nfunction ExtendedCss(configuration) {\n  if (!configuration) {\n    throw new Error('Configuration is not provided.');\n  }\n\n  var styleSheet = configuration.styleSheet;\n  var beforeStyleApplied = configuration.beforeStyleApplied;\n\n  if (beforeStyleApplied && typeof beforeStyleApplied !== 'function') {\n    // eslint-disable-next-line max-len\n    throw new Error(\"Wrong configuration. Type of 'beforeStyleApplied' field should be a function, received: \".concat(_typeof(beforeStyleApplied)));\n  } // We use EventTracker to track the event that is likely to cause the mutation.\n  // The problem is that we cannot use `window.event` directly from the mutation observer call\n  // as we're not in the event handler context anymore.\n\n\n  var EventTracker = function () {\n    var ignoredEventTypes = ['mouseover', 'mouseleave', 'mouseenter', 'mouseout'];\n    var LAST_EVENT_TIMEOUT_MS = 10;\n    var EVENTS = [// keyboard events\n    'keydown', 'keypress', 'keyup', // mouse events\n    'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel']; // 'wheel' event makes scrolling in Safari twitchy\n    // https://github.com/AdguardTeam/ExtendedCss/issues/120\n\n    var safariProblematicEvents = ['wheel'];\n    var trackedEvents = utils.isSafariBrowser ? EVENTS.filter(function (el) {\n      return !(safariProblematicEvents.indexOf(el) > -1);\n    }) : EVENTS;\n    var lastEventType;\n    var lastEventTime;\n\n    var trackEvent = function trackEvent(e) {\n      lastEventType = e.type;\n      lastEventTime = Date.now();\n    };\n\n    trackedEvents.forEach(function (evName) {\n      document.documentElement.addEventListener(evName, trackEvent, true);\n    });\n\n    var getLastEventType = function getLastEventType() {\n      return lastEventType;\n    };\n\n    var getTimeSinceLastEvent = function getTimeSinceLastEvent() {\n      return Date.now() - lastEventTime;\n    };\n\n    return {\n      isIgnoredEventType: function isIgnoredEventType() {\n        return ignoredEventTypes.indexOf(getLastEventType()) > -1 && getTimeSinceLastEvent() < LAST_EVENT_TIMEOUT_MS;\n      }\n    };\n  }();\n\n  var rules = [];\n  var affectedElements = [];\n  var removalsStatistic = {};\n  var domObserved;\n  var eventListenerSupported = window.addEventListener;\n  var domMutationObserver;\n\n  function observeDocument(callback) {\n    // We are trying to limit the number of callback calls by not calling it on all kind of \"hover\" events.\n    // The rationale behind this is that \"hover\" events often cause attributes modification,\n    // but re-applying extCSS rules will be useless as these attribute changes are usually transient.\n    var isIgnoredMutation = function isIgnoredMutation(mutations) {\n      for (var i = 0; i < mutations.length; i += 1) {\n        if (mutations.type !== 'attributes') {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    if (utils.MutationObserver) {\n      domMutationObserver = new utils.MutationObserver(function (mutations) {\n        if (!mutations || mutations.length === 0) {\n          return;\n        }\n\n        if (EventTracker.isIgnoredEventType() && isIgnoredMutation(mutations)) {\n          return;\n        }\n\n        callback();\n      });\n      domMutationObserver.observe(document, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: ['id', 'class']\n      });\n    } else if (eventListenerSupported) {\n      document.addEventListener('DOMNodeInserted', callback, false);\n      document.addEventListener('DOMNodeRemoved', callback, false);\n      document.addEventListener('DOMAttrModified', callback, false);\n    }\n  }\n\n  function disconnectDocument(callback) {\n    if (domMutationObserver) {\n      domMutationObserver.disconnect();\n    } else if (eventListenerSupported) {\n      document.removeEventListener('DOMNodeInserted', callback, false);\n      document.removeEventListener('DOMNodeRemoved', callback, false);\n      document.removeEventListener('DOMAttrModified', callback, false);\n    }\n  }\n\n  var MAX_STYLE_PROTECTION_COUNT = 50;\n  var protectionObserverOption = {\n    attributes: true,\n    attributeOldValue: true,\n    attributeFilter: ['style']\n  };\n  /**\n   * Creates MutationObserver protection function\n   *\n   * @param styles\n   * @return {protectionFunction}\n   */\n\n  function createProtectionFunction(styles) {\n    function protectionFunction(mutations, observer) {\n      if (!mutations.length) {\n        return;\n      }\n\n      var mutation = mutations[0];\n      var target = mutation.target;\n      observer.disconnect();\n      styles.forEach(function (style) {\n        setStyleToElement(target, style);\n      });\n\n      if (++observer.styleProtectionCount < MAX_STYLE_PROTECTION_COUNT) {\n        observer.observe(target, protectionObserverOption);\n      } else {\n        utils.logError('ExtendedCss: infinite loop protection for style');\n      }\n    }\n\n    return protectionFunction;\n  }\n  /**\n   * Sets up a MutationObserver which protects style attributes from changes\n   * @param node DOM node\n   * @param rules rules\n   * @returns Mutation observer used to protect attribute or null if there's nothing to protect\n   */\n\n\n  function protectStyleAttribute(node, rules) {\n    if (!utils.MutationObserver) {\n      return null;\n    }\n\n    var styles = rules.map(function (r) {\n      return r.style;\n    });\n    var protectionObserver = new utils.MutationObserver(createProtectionFunction(styles));\n    protectionObserver.observe(node, protectionObserverOption); // Adds an expando to the observer to keep 'style fix counts'.\n\n    protectionObserver.styleProtectionCount = 0;\n    return protectionObserver;\n  }\n\n  function removeSuffix(str, suffix) {\n    var index = str.indexOf(suffix, str.length - suffix.length);\n\n    if (index >= 0) {\n      return str.substring(0, index);\n    }\n\n    return str;\n  }\n  /**\n   * Finds affectedElement object for the specified DOM node\n   * @param node  DOM node\n   * @returns     affectedElement found or null\n   */\n\n\n  function findAffectedElement(node) {\n    for (var i = 0; i < affectedElements.length; i += 1) {\n      if (affectedElements[i].node === node) {\n        return affectedElements[i];\n      }\n    }\n\n    return null;\n  }\n\n  function removeElement(affectedElement) {\n    var node = affectedElement.node;\n    affectedElement.removed = true;\n    var elementSelector = utils.getNodeSelector(node); // check if the element has been already removed earlier\n\n    var elementRemovalsCounter = removalsStatistic[elementSelector] || 0; // if removals attempts happened more than specified we do not try to remove node again\n\n    if (elementRemovalsCounter > MAX_STYLE_PROTECTION_COUNT) {\n      utils.logError('ExtendedCss: infinite loop protection for SELECTOR', elementSelector);\n      return;\n    }\n\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n      removalsStatistic[elementSelector] = elementRemovalsCounter + 1;\n    }\n  }\n  /**\n   * Applies style to the specified DOM node\n   * @param affectedElement Object containing DOM node and rule to be applied\n   */\n\n\n  function applyStyle(affectedElement) {\n    if (affectedElement.protectionObserver) {\n      // Style is already applied and protected by the observer\n      return;\n    }\n\n    if (beforeStyleApplied) {\n      affectedElement = beforeStyleApplied(affectedElement);\n\n      if (!affectedElement) {\n        return;\n      }\n    }\n\n    var _affectedElement = affectedElement,\n        node = _affectedElement.node;\n\n    for (var i = 0; i < affectedElement.rules.length; i++) {\n      var style = affectedElement.rules[i].style;\n\n      if (style['remove'] === 'true') {\n        removeElement(affectedElement);\n        return;\n      }\n\n      setStyleToElement(node, style);\n    }\n  }\n  /**\n   * Sets style to the specified DOM node\n   * @param node element\n   * @param style style\n   */\n\n\n  function setStyleToElement(node, style) {\n    Object.keys(style).forEach(function (prop) {\n      // Apply this style only to existing properties\n      // We can't use hasOwnProperty here (does not work in FF)\n      if (typeof node.style.getPropertyValue(prop) !== 'undefined') {\n        var value = style[prop]; // First we should remove !important attribute (or it won't be applied')\n\n        value = removeSuffix(value.trim(), '!important').trim();\n        node.style.setProperty(prop, value, 'important');\n      }\n    });\n  }\n  /**\n   * Reverts style for the affected object\n   */\n\n\n  function revertStyle(affectedElement) {\n    if (affectedElement.protectionObserver) {\n      affectedElement.protectionObserver.disconnect();\n    }\n\n    affectedElement.node.style.cssText = affectedElement.originalStyle;\n  }\n  /**\n   * Applies specified rule and returns list of elements affected\n   * @param rule Rule to apply\n   * @returns List of elements affected by this rule\n   */\n\n\n  function applyRule(rule) {\n    var debug = rule.selector.isDebugging();\n    var start;\n\n    if (debug) {\n      start = utils.AsyncWrapper.now();\n    }\n\n    var selector = rule.selector;\n    var nodes = selector.querySelectorAll();\n    nodes.forEach(function (node) {\n      var affectedElement = findAffectedElement(node);\n\n      if (affectedElement) {\n        affectedElement.rules.push(rule);\n        applyStyle(affectedElement);\n      } else {\n        // Applying style first time\n        var originalStyle = node.style.cssText;\n        affectedElement = {\n          node: node,\n          // affected DOM node\n          rules: [rule],\n          // rules to be applied\n          originalStyle: originalStyle,\n          // original node style\n          protectionObserver: null // style attribute observer\n\n        };\n        applyStyle(affectedElement);\n        affectedElements.push(affectedElement);\n      }\n    });\n\n    if (debug) {\n      var elapsed = utils.AsyncWrapper.now() - start;\n\n      if (!('timingStats' in rule)) {\n        rule.timingStats = new utils.Stats();\n      }\n\n      rule.timingStats.push(elapsed);\n    }\n\n    return nodes;\n  }\n  /**\n   * Applies filtering rules\n   */\n\n\n  function applyRules() {\n    var elementsIndex = []; // some rules could make call - selector.querySelectorAll() temporarily to change node id attribute\n    // this caused MutationObserver to call recursively\n    // https://github.com/AdguardTeam/ExtendedCss/issues/81\n\n    stopObserve();\n    rules.forEach(function (rule) {\n      var nodes = applyRule(rule);\n      Array.prototype.push.apply(elementsIndex, nodes);\n    }); // Now revert styles for elements which are no more affected\n\n    var l = affectedElements.length; // do nothing if there is no elements to process\n\n    if (elementsIndex.length > 0) {\n      while (l--) {\n        var obj = affectedElements[l];\n\n        if (elementsIndex.indexOf(obj.node) === -1) {\n          // Time to revert style\n          revertStyle(obj);\n          affectedElements.splice(l, 1);\n        } else if (!obj.removed) {\n          // Add style protection observer\n          // Protect \"style\" attribute from changes\n          if (!obj.protectionObserver) {\n            obj.protectionObserver = protectStyleAttribute(obj.node, obj.rules);\n          }\n        }\n      }\n    } // After styles are applied we can start observe again\n\n\n    observe();\n    printTimingInfo();\n  }\n\n  var APPLY_RULES_DELAY = 150;\n  var applyRulesScheduler = new utils.AsyncWrapper(applyRules, APPLY_RULES_DELAY);\n  var mainCallback = applyRulesScheduler.run.bind(applyRulesScheduler);\n\n  function observe() {\n    if (domObserved) {\n      return;\n    } // Handle dynamically added elements\n\n\n    domObserved = true;\n    observeDocument(mainCallback);\n  }\n\n  function stopObserve() {\n    if (!domObserved) {\n      return;\n    }\n\n    domObserved = false;\n    disconnectDocument(mainCallback);\n  }\n\n  function apply() {\n    applyRules();\n\n    if (document.readyState !== 'complete') {\n      document.addEventListener('DOMContentLoaded', applyRules);\n    }\n  }\n  /**\n   * Disposes ExtendedCss and removes our styles from matched elements\n   */\n\n\n  function dispose() {\n    stopObserve();\n    affectedElements.forEach(function (obj) {\n      revertStyle(obj);\n    });\n  }\n\n  var timingsPrinted = false;\n  /**\n   * Prints timing information for all selectors marked as \"debug\"\n   */\n\n  function printTimingInfo() {\n    if (timingsPrinted) {\n      return;\n    }\n\n    timingsPrinted = true;\n    var timings = rules.filter(function (rule) {\n      return rule.selector.isDebugging();\n    }).map(function (rule) {\n      return {\n        selectorText: rule.selector.selectorText,\n        timingStats: rule.timingStats\n      };\n    });\n\n    if (timings.length === 0) {\n      return;\n    } // Add location.href to the message to distinguish frames\n\n\n    utils.logInfo('[ExtendedCss] Timings for %o:\\n%o (in milliseconds)', window.location.href, timings);\n  } // First of all parse the stylesheet\n\n\n  rules = ExtendedCssParser.parseCss(styleSheet); // EXPOSE\n\n  this.dispose = dispose;\n  this.apply = apply;\n  /** Exposed for testing purposes only */\n\n  this._getAffectedElements = function () {\n    return affectedElements;\n  };\n}\n/**\n * Expose querySelectorAll for debugging and validating selectors\n *\n * @param {string} selectorText selector text\n * @param {boolean} noTiming if true -- do not print the timing to the console\n * @returns {Array<Node>|NodeList} a list of elements found\n * @throws Will throw an error if the argument is not a valid selector\n */\n\n\nExtendedCss.query = function (selectorText, noTiming) {\n  if (typeof selectorText !== 'string') {\n    throw new Error('Selector text is empty');\n  }\n\n  var now = utils.AsyncWrapper.now;\n  var start = now();\n\n  try {\n    return ExtendedSelectorFactory.createSelector(selectorText).querySelectorAll();\n  } finally {\n    var end = now();\n\n    if (!noTiming) {\n      utils.logInfo(\"[ExtendedCss] Elapsed: \".concat(Math.round((end - start) * 1000), \" \\u03BCs.\"));\n    }\n  }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendedCss);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vbm9kZV9tb2R1bGVzL2V4dGVuZGVkLWNzcy9kaXN0L2V4dGVuZGVkLWNzcy5lc20uanM/MWY5OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsK0JBQStCO0FBQzVFOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUzs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0NBQW9DLEVBQUU7QUFDdEM7O0FBRUEsd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwyQkFBMkIseUNBQXlDO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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QUFDQTs7QUFFQSxpRUFBZSxXQUFXLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXh0ZW5kZWQtY3NzL2Rpc3QvZXh0ZW5kZWQtY3NzLmVzbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBleHRlbmRlZC1jc3MgLSB2MS4zLjEyIC0gTW9uIE1heSAzMSAyMDIxXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9FeHRlbmRlZENzc1xuKiBDb3B5cmlnaHQgKGMpIDIwMjEgQWRHdWFyZC4gTGljZW5zZWQgTEdQTC0zLjBcbiovXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBBZGd1YXJkIFNvZnR3YXJlIEx0ZFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbnZhciB1dGlscyA9IHt9O1xudXRpbHMuTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuLyoqXG4gKiBTdG9yZXMgbmF0aXZlIE5vZGUgdGV4dENvbnRlbnQgZ2V0dGVyIHRvIGJlIHVzZWQgZm9yIGNvbnRhaW5zIHBzZXVkby1jbGFzc1xuICogYmVjYXVzZSBlbGVtZW50cycgJ3RleHRDb250ZW50JyBhbmQgJ2lubmVyVGV4dCcgcHJvcGVydGllcyBtaWdodCBiZSBtb2NrZWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9FeHRlbmRlZENzcy9pc3N1ZXMvMTI3XG4gKi9cblxudXRpbHMubm9kZVRleHRDb250ZW50R2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmF0aXZlTm9kZSA9IHdpbmRvdy5Ob2RlIHx8IE5vZGU7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5hdGl2ZU5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKS5nZXQ7XG59KCk7XG5cbnV0aWxzLmlzU2FmYXJpQnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlzQ2hyb21lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xO1xuICB2YXIgaXNTYWZhcmkgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpID4gLTE7XG5cbiAgaWYgKGlzU2FmYXJpKSB7XG4gICAgaWYgKGlzQ2hyb21lKSB7XG4gICAgICAvLyBDaHJvbWUgc2VlbXMgdG8gaGF2ZSBib3RoIENocm9tZSBhbmQgU2FmYXJpIHVzZXJBZ2VudHNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0oKTtcbi8qKlxuICogQ29udmVydHMgcmVndWxhciBleHByZXNzaW9ucyBwYXNzZWQgYXMgcHNldWRvIGNsYXNzIGFyZ3VtZW50cyBpbnRvIFJlZ0V4cCBpbnN0YW5jZXMuXG4gKiBIYXZlIHRvIHVuZXNjYXBlIGRvdWJsZXF1b3RlIFwiIGFzIHdlbGwsIGJlY2F1c2Ugd2UgZXNjYXBlIHRoZW0gd2hpbGUgZW5jbG9zaW5nIHN1Y2hcbiAqIGFyZ3VtZW50cyB3aXRoIGRvdWJsZXF1b3RlcywgYW5kIHNpenpsZSBkb2VzIG5vdCBhdXRvbWF0aWNhbGx5IHVuZXNjYXBlcyB0aGVtLlxuICovXG5cblxudXRpbHMucHNldWRvQXJnVG9SZWdleCA9IGZ1bmN0aW9uIChyZWdleFNyYywgZmxhZykge1xuICBmbGFnID0gZmxhZyB8fCAnaSc7XG4gIHJlZ2V4U3JjID0gcmVnZXhTcmMudHJpbSgpLnJlcGxhY2UoL1xcXFwoW1wiXFxcXF0pL2csICckMScpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleFNyYywgZmxhZyk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gdGhlIHJlZ2V4cFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge1JlZ0V4cH1cbiAqL1xuXG5cbnV0aWxzLnRvUmVnRXhwID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAoc3RyWzBdID09PSAnLycgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc3RyLnNsaWNlKDEsIC0xKSk7XG4gIH1cblxuICB2YXIgZXNjYXBlZCA9IHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChlc2NhcGVkKTtcbn07XG5cbnV0aWxzLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc3RyLCBwcmVmaXgpIHtcbiAgLy8gaWYgc3RyID09PSAnJywgKHN0ciAmJiBmYWxzZSkgd2lsbCByZXR1cm4gJydcbiAgLy8gdGhhdCdzIHdoeSBpdCBoYXMgdG8gYmUgISFzdHJcbiAgcmV0dXJuICEhc3RyICYmIHN0ci5pbmRleE9mKHByZWZpeCkgPT09IDA7XG59O1xuXG51dGlscy5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzdHIsIHBvc3RmaXgpIHtcbiAgaWYgKCFzdHIgfHwgIXBvc3RmaXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RyLmVuZHNXaXRoKSB7XG4gICAgcmV0dXJuIHN0ci5lbmRzV2l0aChwb3N0Zml4KTtcbiAgfVxuXG4gIHZhciB0ID0gU3RyaW5nKHBvc3RmaXgpO1xuICB2YXIgaW5kZXggPSBzdHIubGFzdEluZGV4T2YodCk7XG4gIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4ID09PSBzdHIubGVuZ3RoIC0gdC5sZW5ndGg7XG59O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIGEgdXJsIGZpbHRlciBydWxlIHN5bnRheC5cbiAqL1xuXG5cbnV0aWxzLmNyZWF0ZVVSTFJlZ2V4ID0gZnVuY3Rpb24gKCkge1xuICAvLyBDb25zdGFudHNcbiAgdmFyIHJlZ2V4Q29uZmlndXJhdGlvbiA9IHtcbiAgICBtYXNrU3RhcnRVcmw6ICd8fCcsXG4gICAgbWFza1BpcGU6ICd8JyxcbiAgICBtYXNrU2VwYXJhdG9yOiAnXicsXG4gICAgbWFza0FueVN5bWJvbDogJyonLFxuICAgIHJlZ2V4QW55U3ltYm9sOiAnLionLFxuICAgIHJlZ2V4U2VwYXJhdG9yOiAnKFteIGEtekEtWjAtOS4lXy1dfCQpJyxcbiAgICByZWdleFN0YXJ0VXJsOiAnXihodHRwfGh0dHBzfHdzfHdzcyk6Ly8oW2EtejAtOS1fLl0rXFxcXC4pPycsXG4gICAgcmVnZXhTdGFydFN0cmluZzogJ14nLFxuICAgIHJlZ2V4RW5kU3RyaW5nOiAnJCdcbiAgfTsgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvcmVnZXhwXG4gIC8vIHNob3VsZCBiZSBlc2NhcGVkIC4gKiArID8gXiAkIHsgfSAoICkgfCBbIF0gLyBcXFxuICAvLyBleGNlcHQgb2YgKiB8IF5cblxuICB2YXIgc3BlY2lhbHMgPSBbJy4nLCAnKycsICc/JywgJyQnLCAneycsICd9JywgJygnLCAnKScsICdbJywgJ10nLCAnXFxcXCcsICcvJ107XG4gIHZhciBzcGVjaWFsc1JlZ2V4ID0gbmV3IFJlZ0V4cChcIltcIi5jb25jYXQoc3BlY2lhbHMuam9pbignXFxcXCcpLCBcIl1cIiksICdnJyk7XG4gIC8qKlxuICAgKiBFc2NhcGVzIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmdcbiAgICovXG5cbiAgdmFyIGVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2Uoc3BlY2lhbHNSZWdleCwgJ1xcXFwkJicpO1xuICB9O1xuXG4gIHZhciByZXBsYWNlQWxsID0gZnVuY3Rpb24gcmVwbGFjZUFsbChzdHIsIGZpbmQsIHJlcGxhY2UpIHtcbiAgICBpZiAoIXN0cikge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnNwbGl0KGZpbmQpLmpvaW4ocmVwbGFjZSk7XG4gIH07XG4gIC8qKlxuICAgKiBNYWluIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgYSB1cmwgZmlsdGVyIHJ1bGUgc3RyaW5nIHRvIGEgcmVnZXguXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7UmVnRXhwfVxuICAgKi9cblxuXG4gIHZhciBjcmVhdGVSZWdleFRleHQgPSBmdW5jdGlvbiBjcmVhdGVSZWdleFRleHQoc3RyKSB7XG4gICAgdmFyIHJlZ2V4ID0gZXNjYXBlUmVnRXhwKHN0cik7XG5cbiAgICBpZiAodXRpbHMuc3RhcnRzV2l0aChyZWdleCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tTdGFydFVybCkpIHtcbiAgICAgIHJlZ2V4ID0gcmVnZXguc3Vic3RyaW5nKDAsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrU3RhcnRVcmwubGVuZ3RoKSArIHJlcGxhY2VBbGwocmVnZXguc3Vic3RyaW5nKHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrU3RhcnRVcmwubGVuZ3RoLCByZWdleC5sZW5ndGggLSAxKSwgJ1xcfCcsICdcXFxcfCcpICsgcmVnZXguc3Vic3RyaW5nKHJlZ2V4Lmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuc3RhcnRzV2l0aChyZWdleCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tQaXBlKSkge1xuICAgICAgcmVnZXggPSByZWdleC5zdWJzdHJpbmcoMCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tQaXBlLmxlbmd0aCkgKyByZXBsYWNlQWxsKHJlZ2V4LnN1YnN0cmluZyhyZWdleENvbmZpZ3VyYXRpb24ubWFza1BpcGUubGVuZ3RoLCByZWdleC5sZW5ndGggLSAxKSwgJ1xcfCcsICdcXFxcfCcpICsgcmVnZXguc3Vic3RyaW5nKHJlZ2V4Lmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWdleCA9IHJlcGxhY2VBbGwocmVnZXguc3Vic3RyaW5nKDAsIHJlZ2V4Lmxlbmd0aCAtIDEpLCAnXFx8JywgJ1xcXFx8JykgKyByZWdleC5zdWJzdHJpbmcocmVnZXgubGVuZ3RoIC0gMSk7XG4gICAgfSAvLyBSZXBsYWNpbmcgc3BlY2lhbCB1cmwgbWFza3NcblxuXG4gICAgcmVnZXggPSByZXBsYWNlQWxsKHJlZ2V4LCByZWdleENvbmZpZ3VyYXRpb24ubWFza0FueVN5bWJvbCwgcmVnZXhDb25maWd1cmF0aW9uLnJlZ2V4QW55U3ltYm9sKTtcbiAgICByZWdleCA9IHJlcGxhY2VBbGwocmVnZXgsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrU2VwYXJhdG9yLCByZWdleENvbmZpZ3VyYXRpb24ucmVnZXhTZXBhcmF0b3IpO1xuXG4gICAgaWYgKHV0aWxzLnN0YXJ0c1dpdGgocmVnZXgsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrU3RhcnRVcmwpKSB7XG4gICAgICByZWdleCA9IHJlZ2V4Q29uZmlndXJhdGlvbi5yZWdleFN0YXJ0VXJsICsgcmVnZXguc3Vic3RyaW5nKHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrU3RhcnRVcmwubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLnN0YXJ0c1dpdGgocmVnZXgsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrUGlwZSkpIHtcbiAgICAgIHJlZ2V4ID0gcmVnZXhDb25maWd1cmF0aW9uLnJlZ2V4U3RhcnRTdHJpbmcgKyByZWdleC5zdWJzdHJpbmcocmVnZXhDb25maWd1cmF0aW9uLm1hc2tQaXBlLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmVuZHNXaXRoKHJlZ2V4LCByZWdleENvbmZpZ3VyYXRpb24ubWFza1BpcGUpKSB7XG4gICAgICByZWdleCA9IHJlZ2V4LnN1YnN0cmluZygwLCByZWdleC5sZW5ndGggLSAxKSArIHJlZ2V4Q29uZmlndXJhdGlvbi5yZWdleEVuZFN0cmluZztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgJ2knKTtcbiAgfTtcblxuICByZXR1cm4gY3JlYXRlUmVnZXhUZXh0O1xufSgpO1xuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBpbXBsZW1lbnRpbmcgTG9jYXRpb24gaW50ZXJmYWNlIGZyb20gYSB1cmwuXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byBVUkwuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vRmluZ2VycHJpbnRpbmdCbG9ja2VyL2Jsb2IvbWFzdGVyL3NyYy9zaGFyZWQvdXJsLnRzI0w2NFxuICovXG5cblxudXRpbHMuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiAoaHJlZikge1xuICB2YXIgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhbmNob3IuaHJlZiA9IGhyZWY7XG5cbiAgaWYgKGFuY2hvci5ob3N0ID09PSAnJykge1xuICAgIGFuY2hvci5ocmVmID0gYW5jaG9yLmhyZWY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgfVxuXG4gIHJldHVybiBhbmNob3I7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBBIGhhcyB0aGUgc2FtZSBvcmlnaW4gYXMgQi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxBIGxvY2F0aW9uLmhyZWYgb2YgQS5cbiAqIEBwYXJhbSB7TG9jYXRpb259IGxvY2F0aW9uQiBsb2NhdGlvbiBvZiBCLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbkIgZG9jdW1lbnQuZG9tYWluIG9mIEIuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxudXRpbHMuaXNTYW1lT3JpZ2luID0gZnVuY3Rpb24gKHVybEEsIGxvY2F0aW9uQiwgZG9tYWluQikge1xuICB2YXIgbG9jYXRpb25BID0gdXRpbHMuY3JlYXRlTG9jYXRpb24odXJsQSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zY3JpcHQtdXJsXG5cbiAgaWYgKGxvY2F0aW9uQS5wcm90b2NvbCA9PT0gJ2phdmFzY3JpcHQ6JyB8fCBsb2NhdGlvbkEuaHJlZiA9PT0gJ2Fib3V0OmJsYW5rJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGxvY2F0aW9uQS5wcm90b2NvbCA9PT0gJ2RhdGE6JyB8fCBsb2NhdGlvbkEucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb25BLmhvc3RuYW1lID09PSBkb21haW5CICYmIGxvY2F0aW9uQS5wb3J0ID09PSBsb2NhdGlvbkIucG9ydCAmJiBsb2NhdGlvbkEucHJvdG9jb2wgPT09IGxvY2F0aW9uQi5wcm90b2NvbDtcbn07XG4vKipcbiAqIEEgaGVscGVyIGNsYXNzIHRvIHRocm90dGxlIGZ1bmN0aW9uIGNhbGxzIHdpdGggc2V0VGltZW91dCBhbmQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuICovXG5cblxudXRpbHMuQXN5bmNXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogUGhhbnRvbUpTIHBhc3NlcyBhIHdyb25nIHRpbWVzdGFtcCB0byB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGxiYWNrIGFuZCB0aGF0IGJyZWFrcyB0aGUgQXN5bmNXcmFwcGVyIGxvZ2ljXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzE0ODMyXG4gICAqL1xuICB2YXIgc3VwcG9ydGVkID0gdHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICd1bmRlZmluZWQnICYmICEvcGhhbnRvbS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciByQUYgPSBzdXBwb3J0ZWQgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0O1xuICB2YXIgY0FGID0gc3VwcG9ydGVkID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhclRpbWVvdXQ7XG4gIHZhciBwZXJmID0gc3VwcG9ydGVkID8gcGVyZm9ybWFuY2UgOiBEYXRlO1xuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRocm90dGxlIG51bWJlciwgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHNob3VsZCBiZSBleGVjdXRlZCB0d2ljZVxuICAgKiBpbiB0aGlzIHRpbWUgZnJhbWUuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBBc3luY1dyYXBwZXIoY2FsbGJhY2ssIHRocm90dGxlKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICB0aGlzLndyYXBwZWRDYWxsYmFjayA9IHRoaXMud3JhcHBlZENhbGxiYWNrLmJpbmQodGhpcyk7XG5cbiAgICBpZiAodGhpcy53cmFwcGVkQXNhcENhbGxiYWNrKSB7XG4gICAgICB0aGlzLndyYXBwZWRBc2FwQ2FsbGJhY2sgPSB0aGlzLndyYXBwZWRBc2FwQ2FsbGJhY2suYmluZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICBBc3luY1dyYXBwZXIucHJvdG90eXBlLndyYXBwZWRDYWxsYmFjayA9IGZ1bmN0aW9uICh0cykge1xuICAgIHRoaXMubGFzdFJ1biA9IGlzTnVtYmVyKHRzKSA/IHRzIDogcGVyZi5ub3coKTtcbiAgICBkZWxldGUgdGhpcy5yQUZpZDtcbiAgICBkZWxldGUgdGhpcy50aW1lcklkO1xuICAgIGRlbGV0ZSB0aGlzLmFzYXBTY2hlZHVsZWQ7XG4gICAgdGhpcy5jYWxsYmFjaygpO1xuICB9O1xuICAvKiogQHByaXZhdGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYSBzY2hlZHVsZWQgY2FsbGJhY2suICovXG5cblxuICBBc3luY1dyYXBwZXIucHJvdG90eXBlLmhhc1BlbmRpbmdDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy5yQUZpZCkgfHwgaXNOdW1iZXIodGhpcy50aW1lcklkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhIGZ1bmN0aW9uIGNhbGwgYmVmb3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICovXG5cblxuICBBc3luY1dyYXBwZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5oYXNQZW5kaW5nQ2FsbGJhY2soKSkge1xuICAgICAgLy8gVGhlcmUgaXMgYSBwZW5kaW5nIGV4ZWN1dGlvbiBzY2hlZHVsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmxhc3RSdW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgZWxhcHNlZCA9IHBlcmYubm93KCkgLSB0aGlzLmxhc3RSdW47XG5cbiAgICAgIGlmIChlbGFwc2VkIDwgdGhpcy50aHJvdHRsZSkge1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KHRoaXMud3JhcHBlZENhbGxiYWNrLCB0aGlzLnRocm90dGxlIC0gZWxhcHNlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJBRmlkID0gckFGKHRoaXMud3JhcHBlZENhbGxiYWNrKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBhIGZ1bmN0aW9uIGNhbGwgaW4gdGhlIG1vc3QgaW1tZW5lbnQgbWljcm90YXNrLlxuICAgKiBUaGlzIGNhbm5vdCBiZSBjYW5jZWxlZC5cbiAgICovXG5cblxuICBBc3luY1dyYXBwZXIucHJvdG90eXBlLnJ1bkFzYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYXNhcFNjaGVkdWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXNhcFNjaGVkdWxlZCA9IHRydWU7XG4gICAgY0FGKHRoaXMuckFGaWQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuXG4gICAgaWYgKHV0aWxzLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIC8qKlxuICAgICAgICogVXNpbmcgTXV0YXRpb25PYnNlcnZlcnMgdG8gYWNjZXNzIG1pY3JvdGFzayBxdWV1ZSBpcyBhIHN0YW5kYXJkIHRlY2huaXF1ZSxcbiAgICAgICAqIHVzZWQgaW4gQVNBUCBsaWJyYXJ5XG4gICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9hc2FwL2Jsb2IvbWFzdGVyL2Jyb3dzZXItcmF3LmpzI0wxNDB9XG4gICAgICAgKi9cbiAgICAgIGlmICghdGhpcy5tbykge1xuICAgICAgICB0aGlzLm1vID0gbmV3IHV0aWxzLk11dGF0aW9uT2JzZXJ2ZXIodGhpcy53cmFwcGVkQ2FsbGJhY2spO1xuICAgICAgICB0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgxKTtcbiAgICAgICAgdGhpcy5tby5vYnNlcnZlKHRoaXMubm9kZSwge1xuICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubm9kZS5ub2RlVmFsdWUgPSAtdGhpcy5ub2RlLm5vZGVWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCh0aGlzLndyYXBwZWRDYWxsYmFjayk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUnVucyBzY2hlZHVsZWQgZXhlY3V0aW9uIGltbWVkaWF0ZWx5LCBpZiB0aGVyZSB3ZXJlIGFueS5cbiAgICovXG5cblxuICBBc3luY1dyYXBwZXIucHJvdG90eXBlLnJ1bkltbWVkaWF0ZWx5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmhhc1BlbmRpbmdDYWxsYmFjaygpKSB7XG4gICAgICBjQUYodGhpcy5yQUZpZCk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJBRmlkO1xuICAgICAgZGVsZXRlIHRoaXMudGltZXJJZDtcbiAgICAgIHRoaXMud3JhcHBlZENhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIEFzeW5jV3JhcHBlci5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmYubm93KCk7XG4gIH07XG5cbiAgcmV0dXJuIEFzeW5jV3JhcHBlcjtcbn0oKTtcbi8qKlxuICogU3RvcmVzIG5hdGl2ZSBPZFAgdG8gYmUgdXNlZCBpbiBXZWFrTWFwIGFuZCBTZXQgcG9seWZpbGxzLlxuICovXG5cblxudXRpbHMuZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG51dGlscy5XZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gV2Vha01hcCA6IGZ1bmN0aW9uICgpIHtcbiAgLyoqIE9yaWdpbmFsbHkgYmFzZWQgb24ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1dlYWtNYXB9ICovXG4gIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcblxuICB2YXIgV2Vha01hcCA9IGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgdGhpcy5uYW1lID0gXCJfX3N0XCIuY29uY2F0KE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApLmNvbmNhdChjb3VudGVyKyssIFwiX19cIik7XG4gIH07XG5cbiAgV2Vha01hcC5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cbiAgICAgIGlmIChlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5KSB7XG4gICAgICAgIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlscy5kZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBba2V5LCB2YWx1ZV0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblxuICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNWYWx1ZSA9IGVudHJ5WzBdID09PSBrZXk7XG4gICAgICBkZWxldGUgZW50cnlbMF07XG4gICAgICBkZWxldGUgZW50cnlbMV07XG4gICAgICByZXR1cm4gaGFzVmFsdWU7XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudHJ5WzBdID09PSBrZXk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gV2Vha01hcDtcbn0oKTtcbnV0aWxzLlNldCA9IHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnID8gU2V0IDogZnVuY3Rpb24gKCkge1xuICB2YXIgY291bnRlciA9IERhdGUubm93KCkgJSAxZTk7XG4gIC8qKlxuICAgKiBBIHBvbHlmaWxsIHdoaWNoIGNvdmVycyBvbmx5IHRoZSBiYXNpYyB1c2FnZS5cbiAgICogT25seSBzdXBwb3J0cyBtZXRob2RzIHRoYXQgYXJlIHN1cHBvcnRlZCBpbiBJRTExLlxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvc2NyaXB0aW5nL2phdmFzY3JpcHQvcmVmZXJlbmNlL3NldC1vYmplY3QtamF2YXNjcmlwdH1cbiAgICogQXNzdW1lcyB0aGF0ICdrZXkncyBhcmUgYWxsIG9iamVjdHMsIG5vdCBwcmltaXRpdmVzIHN1Y2ggYXMgYSBudW1iZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIEluaXRpYWwgaXRlbXMgaW4gdGhpcyBzZXRcbiAgICovXG5cbiAgdmFyIFNldCA9IGZ1bmN0aW9uIFNldChpdGVtcykge1xuICAgIHRoaXMubmFtZSA9IFwiX19zdFwiLmNvbmNhdChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKS5jb25jYXQoY291bnRlcisrLCBcIl9fXCIpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuXG4gICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCkge1xuICAgICAgdmFyIGlJdGVtcyA9IGl0ZW1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGlJdGVtcy0tKSB7XG4gICAgICAgIHRoaXMuYWRkKGl0ZW1zW2lJdGVtc10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTZXQucHJvdG90eXBlID0ge1xuICAgIGFkZDogZnVuY3Rpb24gYWRkKGtleSkge1xuICAgICAgaWYgKCFpc051bWJlcihrZXlbdGhpcy5uYW1lXSkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5rZXlzLnB1c2goa2V5KSAtIDE7XG4gICAgICAgIHV0aWxzLmRlZmluZVByb3BlcnR5KGtleSwgdGhpcy5uYW1lLCB7XG4gICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgaWYgKGlzTnVtYmVyKGtleVt0aGlzLm5hbWVdKSkge1xuICAgICAgICB2YXIgaW5kZXggPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMua2V5c1tpbmRleF07XG4gICAgICAgIGtleVt0aGlzLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaXNOdW1iZXIoa2V5W3RoaXMubmFtZV0pO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBrZXlbdGhpcy5uYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXlzLmxlbmd0aCA9IDA7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNiKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLmtleXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2IodmFsdWUsIHZhbHVlLCB0aGF0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgdXRpbHMuZGVmaW5lUHJvcGVydHkoU2V0LnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyBTa2lwcyBob2xlcy5cbiAgICAgIHJldHVybiB0aGlzLmtleXMucmVkdWNlKGZ1bmN0aW9uIChhY2MpIHtcbiAgICAgICAgcmV0dXJuIGFjYyArIDE7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gU2V0O1xufSgpO1xuLyoqXG4gKiBWZW5kb3Itc3BlY2lmaWMgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1xuICovXG5cbnV0aWxzLm1hdGNoZXNQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm9wcyA9IFsnbWF0Y2hlcycsICdtYXRjaGVzU2VsZWN0b3InLCAnbW96TWF0Y2hlc1NlbGVjdG9yJywgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ29NYXRjaGVzU2VsZWN0b3InLCAnd2Via2l0TWF0Y2hlc1NlbGVjdG9yJ107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICBpZiAoRWxlbWVudC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcHNbaV0pKSB7XG4gICAgICByZXR1cm4gcHJvcHNbaV07XG4gICAgfVxuICB9XG59KCk7XG4vKipcbiAqIFByb3ZpZGVzIHN0YXRzIGluZm9ybWF0aW9uXG4gKi9cblxuXG51dGlscy5TdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqIEBtZW1iZXIge0FycmF5PG51bWJlcj59ICovXG4gIHRoaXMuYXJyYXkgPSBbXTtcbiAgLyoqIEBtZW1iZXIge251bWJlcn0gKi9cblxuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHZhciB6ZXJvRGVzY3JpcHRvciA9IHtcbiAgICB2YWx1ZTogMCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9O1xuICAvKiogQG1lbWJlciB7bnVtYmVyfSBAcHJpdmF0ZSAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3VtJywgemVyb0Rlc2NyaXB0b3IpO1xuICAvKiogQG1lbWJlciB7bnVtYmVyfSBAcHJpdmF0ZSAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3F1YXJlZFN1bScsIHplcm9EZXNjcmlwdG9yKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhUG9pbnQgZGF0YSBwb2ludFxuICovXG5cblxudXRpbHMuU3RhdHMucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YVBvaW50KSB7XG4gIHRoaXMuYXJyYXkucHVzaChkYXRhUG9pbnQpO1xuICB0aGlzLmxlbmd0aCsrO1xuICB0aGlzLnN1bSArPSBkYXRhUG9pbnQ7XG4gIHRoaXMuc3F1YXJlZFN1bSArPSBkYXRhUG9pbnQgKiBkYXRhUG9pbnQ7XG4gIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICovXG5cbiAgdGhpcy5tZWFuID0gdGhpcy5zdW0gLyB0aGlzLmxlbmd0aDtcbiAgLyoqIEBtZW1iZXIge251bWJlcn0gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXG4gIHRoaXMuc3RkZGV2ID0gTWF0aC5zcXJ0KHRoaXMuc3F1YXJlZFN1bSAvIHRoaXMubGVuZ3RoIC0gTWF0aC5wb3codGhpcy5tZWFuLCAyKSk7XG59O1xuLyoqIFNhZmUgY29uc29sZS5lcnJvciB2ZXJzaW9uICovXG5cblxudXRpbHMubG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvciAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAmJiBjb25zb2xlLmVycm9yLmJpbmQgPyBjb25zb2xlLmVycm9yLmJpbmQod2luZG93LmNvbnNvbGUpIDogY29uc29sZS5lcnJvcjtcbi8qKiBTYWZlIGNvbnNvbGUuaW5mbyB2ZXJzaW9uICovXG5cbnV0aWxzLmxvZ0luZm8gPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5pbmZvICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmIGNvbnNvbGUuaW5mby5iaW5kID8gY29uc29sZS5pbmZvLmJpbmQod2luZG93LmNvbnNvbGUpIDogY29uc29sZS5pbmZvO1xuXG5mdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInO1xufVxuLyoqXG4gKiBSZXR1cm5zIHBhdGggdG8gZWxlbWVudCB3ZSB3aWxsIHVzZSBhcyBlbGVtZW50IGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gaW5wdXRFbFxuICogQHJldHVybnMge3N0cmluZ30gLSBwYXRoIHRvIHRoZSBlbGVtZW50XG4gKi9cblxuXG51dGlscy5nZXROb2RlU2VsZWN0b3IgPSBmdW5jdGlvbiAoaW5wdXRFbCkge1xuICBpZiAoIShpbnB1dEVsIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIHJlY2VpdmVkIGFyZ3VtZW50IHdpdGggd3JvbmcgdHlwZScpO1xuICB9XG5cbiAgdmFyIGVsID0gaW5wdXRFbDtcbiAgdmFyIHBhdGggPSBbXTsgLy8gd2UgbmVlZCB0byBjaGVjayAnISFlbCcgZmlyc3QgYmVjYXVzZSBpdCBpcyBwb3NzaWJsZVxuICAvLyB0aGF0IHNvbWUgYW5jZXN0b3Igb2YgdGhlIGlucHV0RWwgd2FzIHJlbW92ZWQgYmVmb3JlIGl0XG5cbiAgd2hpbGUgKCEhZWwgJiYgZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChlbC5pZCAmJiB0eXBlb2YgZWwuaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZWxlY3RvciArPSBcIiNcIi5jb25jYXQoZWwuaWQpO1xuICAgICAgcGF0aC51bnNoaWZ0KHNlbGVjdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2libGluZyA9IGVsO1xuICAgICAgdmFyIG50aCA9IDE7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5wcmV2aW91c1NpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHNpYmxpbmcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICBudGgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnRoICE9PSAxKSB7XG4gICAgICAgIHNlbGVjdG9yICs9IFwiOm50aC1vZi10eXBlKFwiLmNvbmNhdChudGgsIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoLnVuc2hpZnQoc2VsZWN0b3IpO1xuICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBwYXRoLmpvaW4oJyA+ICcpO1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBBZGd1YXJkIFNvZnR3YXJlIEx0ZFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogSGVscGVyIGNsYXNzIGNzcyB1dGlsc1xuICpcbiAqIEB0eXBlIHt7bm9ybWFsaXplfX1cbiAqL1xudmFyIGNzc1V0aWxzID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogUmVnZXggdGhhdCBtYXRjaGVzIEFkR3VhcmQncyBiYWNrd2FyZCBjb21wYXRpYmxlIHN5bnRheGVzLlxuICAgKi9cbiAgdmFyIHJlQXR0ckZhbGxiYWNrID0gL1xcWy0oPzpleHR8YWJwKS0oW2Etei1fXSspPShbXCInXSkoKD86KD89KFxcXFw/KSlcXDQuKSo/KVxcMlxcXS9nO1xuICAvKipcbiAgICogQ29tcGxleCByZXBsYWNlbWVudCBmdW5jdGlvbi5cbiAgICogVW5lc2NhcGVzIHF1b3RlIGNoYXJhY3RlcnMgaW5zaWRlIG9mIGFuIGV4dGVuZGVkIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gbWF0Y2ggICAgIFdob2xlIG1hdGNoZWQgc3RyaW5nXG4gICAqIEBwYXJhbSBuYW1lICAgICAgR3JvdXAgMVxuICAgKiBAcGFyYW0gcXVvdGVDaGFyIEdyb3VwIDJcbiAgICogQHBhcmFtIHZhbHVlICAgICBHcm91cCAzXG4gICAqL1xuXG4gIHZhciBldmFsdWF0ZU1hdGNoID0gZnVuY3Rpb24gZXZhbHVhdGVNYXRjaChtYXRjaCwgbmFtZSwgcXVvdGVDaGFyLCB2YWx1ZSkge1xuICAgIC8vIFVuZXNjYXBlIHF1b3Rlc1xuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCIoW15cXFxcXFxcXF18XilcXFxcXFxcXFwiLmNvbmNhdChxdW90ZUNoYXIpLCAnZycpO1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZSwgXCIkMVwiLmNvbmNhdChxdW90ZUNoYXIpKTtcbiAgICByZXR1cm4gXCI6XCIuY29uY2F0KG5hbWUsIFwiKFwiKS5jb25jYXQodmFsdWUsIFwiKVwiKTtcbiAgfTsgLy8gU2l6emxlJ3MgcGFyc2luZyBvZiBwc2V1ZG8gY2xhc3MgYXJndW1lbnRzIGlzIGJ1Z2d5IG9uIGNlcnRhaW4gY2lyY3Vtc3RhbmNlc1xuICAvLyBXZSBzdXBwb3J0IGZvbGxvd2luZyBmb3JtIG9mIGFyZ3VtZW50czpcbiAgLy8gMS4gZm9yIDptYXRjaGVzLWNzcywgdGhvc2Ugb2YgYSBmb3JtIHtwcm9wZXJ0eU5hbWV9OiAvLiovXG4gIC8vIDIuIGZvciA6Y29udGFpbnMsIHRob3NlIG9mIGEgZm9ybSAvLiovXG4gIC8vIFdlIHRyYW5zZm9ybSBzdWNoIGNhc2VzIGluIGEgd2F5IHRoYXQgU2l6emxlIGhhcyBubyBhbWJpZ3VpdHkgaW4gcGFyc2luZyBhcmd1bWVudHMuXG5cblxuICB2YXIgcmVNYXRjaGVzQ3NzID0gL1xcOihtYXRjaGVzLWNzcyg/Oi1hZnRlcnwtYmVmb3JlKT8pXFwoKFthLXotXFxzXSpcXDpcXHMqXFwvKD86XFxcXC58W15cXC9dKSo/XFwvXFxzKilcXCkvZztcbiAgdmFyIHJlQ29udGFpbnMgPSAvOig/Oi1hYnAtKT8oY29udGFpbnN8aGFzLXRleHQpXFwoKFxccypcXC8oPzpcXFxcLnxbXlxcL10pKj9cXC9cXHMqKVxcKS9nO1xuICB2YXIgcmVTY29wZSA9IC9cXChcXDpzY29wZSA+L2c7IC8vIE5vdGUgdGhhdCB3ZSByZXF1aXJlIGAvYCBjaGFyYWN0ZXIgaW4gcmVndWxhciBleHByZXNzaW9ucyB0byBiZSBlc2NhcGVkLlxuXG4gIC8qKlxuICAgKiBVc2VkIGZvciBwcmUtcHJvY2Vzc2luZyBwc2V1ZG8tY2xhc3NlcyB2YWx1ZXMgd2l0aCBhYm92ZSB0d28gcmVnZXhlcy5cbiAgICovXG5cbiAgdmFyIGFkZFF1b3RlcyA9IGZ1bmN0aW9uIGFkZFF1b3RlcyhfLCBjMSwgYzIpIHtcbiAgICByZXR1cm4gXCI6XCIuY29uY2F0KGMxLCBcIihcXFwiXCIpLmNvbmNhdChjMi5yZXBsYWNlKC9bXCJcXFxcXS9nLCAnXFxcXCQmJyksIFwiXFxcIilcIik7XG4gIH07XG5cbiAgdmFyIFNDT1BFX1JFUExBQ0VSID0gJyg+JztcbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgc3BlY2lmaWVkIGNzcyB0ZXh0IGluIGEgZm9ybSB0aGF0IGNhbiBiZSBwYXJzZWQgYnkgdGhlXG4gICAqIFNpenpsZSBlbmdpbmUuXG4gICAqIE5vcm1hbGl6YXRpb24gbWVhbnNcbiAgICogIDEuIHRyYW5zZm9ybWluZyBbLWV4dC0qPVwiXCJdIGF0dHJpYnV0ZXMgdG8gcHNldWRvIGNsYXNzZXNcbiAgICogIDIuIGVuY2xvc2luZyBwb3NzaWJseSBhbWJpZ3VvdXMgYXJndW1lbnRzIG9mIGA6Y29udGFpbnNgLFxuICAgKiAgICAgYDptYXRjaGVzLWNzc2AgcHNldWRvIGNsYXNzZXMgd2l0aCBxdW90ZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cbiAgdmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShjc3NUZXh0KSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRDc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKHJlQXR0ckZhbGxiYWNrLCBldmFsdWF0ZU1hdGNoKS5yZXBsYWNlKHJlTWF0Y2hlc0NzcywgYWRkUXVvdGVzKS5yZXBsYWNlKHJlQ29udGFpbnMsIGFkZFF1b3RlcykucmVwbGFjZShyZVNjb3BlLCBTQ09QRV9SRVBMQUNFUik7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRDc3NUZXh0O1xuICB9O1xuXG4gIHZhciBpc1NpbXBsZVNlbGVjdG9yVmFsaWQgPSBmdW5jdGlvbiBpc1NpbXBsZVNlbGVjdG9yVmFsaWQoc2VsZWN0b3IpIHtcbiAgICB0cnkge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgaXNTaW1wbGVTZWxlY3RvclZhbGlkOiBpc1NpbXBsZVNlbGVjdG9yVmFsaWRcbiAgfTtcbn0oKTtcblxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjQtcHJlLWFkZ3VhcmRcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMjAtMDgtMDRcbiAqL1xuXG4vKipcbiAqIFZlcnNpb24gb2YgU2l6emxlIHBhdGNoZWQgYnkgQWRHdWFyZCBpbiBvcmRlciB0byBiZSB1c2VkIGluIHRoZSBFeHRlbmRlZENzcyBtb2R1bGUuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vc2l6emxlLWV4dGNzc1xuICpcbiAqIExvb2sgZm9yIFtBZEd1YXJkIFBhdGNoXSBhbmQgQURHVUFSRF9FWFRDU1MgbWFya2VycyB0byBmaW5kIG91dCB3aGF0IGV4YWN0bHkgd2FzIGNoYW5nZWQgYnkgdXMuXG4gKlxuICogR2xvYmFsIGNoYW5nZXM6XG4gKiAxLiBBZGRlZCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gdGhlIFwiU2l6emxlLnRva2VuaXplXCIgbWV0aG9kIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHN0eWxlc2hlZXRzIHBhcnNpbmcgYW5kIHZhbGlkYXRpb24uXG4gKiAyLiBBZGRlZCB0b2tlbnMgcmUtc29ydGluZyBtZWNoYW5pc20gZm9yY2luZyBzbG93IHBzZXVkb3MgdG8gYmUgbWF0Y2hlZCBsYXN0ICAoc2VlIHNvcnRUb2tlbkdyb3VwcykuXG4gKiAzLiBGaXggdGhlIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgY2FjaGluZyAtLSB0aGVyZSB3YXMgbm8gdmFsdWUgY29ycmVzcG9uZGluZyB0byBhIGtleS5cbiAqIDQuIEFkZGVkIFNpenpsZS5jb21waWxlIGNhbGwgdG8gdGhlIGA6aGFzYCBwc2V1ZG8gZGVmaW5pdGlvbi5cbiAqXG4gKiBDaGFuZ2VzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIEFER1VBUkRfRVhUQ1NTIGJ1aWxkIG9ubHk6XG4gKiAxLiBEbyBub3QgZXhwb3NlIFNpenpsZSB0byB0aGUgZ2xvYmFsIHNjb3BlLiBJbml0aWFsaXplIGl0IGxhemlseSB2aWEgaW5pdGlhbGl6ZVNpenpsZSgpLlxuICogMi4gUmVtb3ZlZCA6Y29udGFpbnMgcHNldWRvIGRlY2xhcmF0aW9uIC0tIGl0cyBzeW50YXggaXMgY2hhbmdlZCBhbmQgZGVjbGFyZWQgb3V0c2lkZSBvZiBTaXp6bGUuXG4gKiAzLiBSZW1vdmVkIGRlY2xhcmF0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBub24tc3RhbmRhcmQgcHNldWRvIGNsYXNzZXM6XG4gKiA6cGFyZW50LCA6aGVhZGVyLCA6aW5wdXQsIDpidXR0b24sIDp0ZXh0LCA6Zmlyc3QsIDpsYXN0LCA6ZXEsXG4gKiA6ZXZlbiwgOm9kZCwgOmx0LCA6Z3QsIDpudGgsIDpyYWRpbywgOmNoZWNrYm94LCA6ZmlsZSxcbiAqIDpwYXNzd29yZCwgOmltYWdlLCA6c3VibWl0LCA6cmVzZXRcbiAqIDQuIEFkZGVkIGVzNiBtb2R1bGUgZXhwb3J0XG4gKi9cbnZhciBTaXp6bGU7XG4vKipcbiAqIEluaXRpYWxpemVzIFNpenpsZSBvYmplY3QuXG4gKiBJbiB0aGUgY2FzZSBvZiBBZEd1YXJkIEV4dGVuZGVkQ3NzIHdlIHdhbnQgdG8gYXZvaWQgaW5pdGlhbGl6aW5nIFNpenpsZSByaWdodCBhd2F5XG4gKiBhbmQgZXhwb3NpbmcgaXQgdG8gdGhlIGdsb2JhbCBzY29wZS5cbiAqL1xuXG52YXIgaW5pdGlhbGl6ZVNpenpsZSA9IGZ1bmN0aW9uIGluaXRpYWxpemVTaXp6bGUoKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBpZiAoIVNpenpsZSkge1xuICAgIC8vPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8XG4gICAgU2l6emxlID0gZnVuY3Rpb24gKHdpbmRvdykge1xuICAgICAgdmFyIHN1cHBvcnQsXG4gICAgICAgICAgRXhwcixcbiAgICAgICAgICBnZXRUZXh0LFxuICAgICAgICAgIGlzWE1MLFxuICAgICAgICAgIHRva2VuaXplLFxuICAgICAgICAgIGNvbXBpbGUsXG4gICAgICAgICAgc2VsZWN0LFxuICAgICAgICAgIG91dGVybW9zdENvbnRleHQsXG4gICAgICAgICAgc29ydElucHV0LFxuICAgICAgICAgIGhhc0R1cGxpY2F0ZSxcbiAgICAgICAgICAvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG4gICAgICBzZXREb2N1bWVudCxcbiAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICBkb2NFbGVtLFxuICAgICAgICAgIGRvY3VtZW50SXNIVE1MLFxuICAgICAgICAgIHJidWdneVFTQSxcbiAgICAgICAgICByYnVnZ3lNYXRjaGVzLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgY29udGFpbnMsXG4gICAgICAgICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuICAgICAgZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcbiAgICAgICAgICBwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG4gICAgICAgICAgZGlycnVucyA9IDAsXG4gICAgICAgICAgZG9uZSA9IDAsXG4gICAgICAgICAgY2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgdG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgICAgc29ydE9yZGVyID0gZnVuY3Rpb24gc29ydE9yZGVyKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgICAgIC8vIEluc3RhbmNlIG1ldGhvZHNcbiAgICAgIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgICAgICAgIGFyciA9IFtdLFxuICAgICAgICAgIHBvcCA9IGFyci5wb3AsXG4gICAgICAgICAgcHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcbiAgICAgICAgICBwdXNoID0gYXJyLnB1c2gsXG4gICAgICAgICAgc2xpY2UgPSBhcnIuc2xpY2UsXG4gICAgICAgICAgLy8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG4gICAgICAvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG4gICAgICBpbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihsaXN0LCBlbGVtKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSxcbiAgICAgICAgICBib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcbiAgICAgICAgICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuICAgICAgd2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcbiAgICAgIGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG4gICAgICAgICAgLy8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG4gICAgICBhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgKyAvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuICAgICAgXCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICsgLy8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcbiAgICAgIFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcbiAgICAgICAgICBwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICsgLy8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcbiAgICAgIC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuICAgICAgXCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArIC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuICAgICAgXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgKyAvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG4gICAgICBcIi4qXCIgKyBcIilcXFxcKXwpXCIsXG4gICAgICAgICAgLy8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuICAgICAgcndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIpLFxuICAgICAgICAgIHJ0cmltID0gbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiksXG4gICAgICAgICAgcmNvbW1hID0gbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIpLFxuICAgICAgICAgIHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcbiAgICAgICAgICBycHNldWRvID0gbmV3IFJlZ0V4cChwc2V1ZG9zKSxcbiAgICAgICAgICByaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIpLFxuICAgICAgICAgIG1hdGNoRXhwciA9IHtcbiAgICAgICAgXCJJRFwiOiBuZXcgUmVnRXhwKFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxuICAgICAgICBcIkNMQVNTXCI6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxuICAgICAgICBcIlRBR1wiOiBuZXcgUmVnRXhwKFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIpLFxuICAgICAgICBcIkFUVFJcIjogbmV3IFJlZ0V4cChcIl5cIiArIGF0dHJpYnV0ZXMpLFxuICAgICAgICBcIlBTRVVET1wiOiBuZXcgUmVnRXhwKFwiXlwiICsgcHNldWRvcyksXG4gICAgICAgIFwiQ0hJTERcIjogbmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiKSxcbiAgICAgICAgXCJib29sXCI6IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIpLFxuICAgICAgICAvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcbiAgICAgICAgLy8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuICAgICAgICBcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIpXG4gICAgICB9LFxuICAgICAgICAgIHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuICAgICAgICAgIC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuICAgICAgcnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuICAgICAgICAgIHJzaWJsaW5nID0gL1srfl0vLFxuICAgICAgICAgIC8vIENTUyBlc2NhcGVzXG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG4gICAgICBydW5lc2NhcGUgPSBuZXcgUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiKSxcbiAgICAgICAgICBmdW5lc2NhcGUgPSBmdW5jdGlvbiBmdW5lc2NhcGUoXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UpIHtcbiAgICAgICAgdmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDsgLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcbiAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveDwyNFxuICAgICAgICAvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblxuICAgICAgICByZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/IGVzY2FwZWQgOiBoaWdoIDwgMCA/IC8vIEJNUCBjb2RlcG9pbnRcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShoaWdoICsgMHgxMDAwMCkgOiAvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDApO1xuICAgICAgfSxcbiAgICAgICAgICAvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuICAgICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG4gICAgICByY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG4gICAgICAgICAgZmNzc2VzY2FwZSA9IGZ1bmN0aW9uIGZjc3Nlc2NhcGUoY2gsIGFzQ29kZVBvaW50KSB7XG4gICAgICAgIGlmIChhc0NvZGVQb2ludCkge1xuICAgICAgICAgIC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgICAgIGlmIChjaCA9PT0gXCJcXDBcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFx1RkZGRFwiO1xuICAgICAgICAgIH0gLy8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblxuXG4gICAgICAgICAgcmV0dXJuIGNoLnNsaWNlKDAsIC0xKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdChjaC5sZW5ndGggLSAxKS50b1N0cmluZygxNikgKyBcIiBcIjtcbiAgICAgICAgfSAvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cblxuICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBjaDtcbiAgICAgIH0sXG4gICAgICAgICAgLy8gVXNlZCBmb3IgaWZyYW1lc1xuICAgICAgLy8gU2VlIHNldERvY3VtZW50KClcbiAgICAgIC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuICAgICAgLy8gZXJyb3IgaW4gSUVcbiAgICAgIHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICAgICAgICBzZXREb2N1bWVudCgpO1xuICAgICAgfSxcbiAgICAgICAgICBpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuICAgICAgfSwge1xuICAgICAgICBkaXI6IFwicGFyZW50Tm9kZVwiLFxuICAgICAgICBuZXh0OiBcImxlZ2VuZFwiXG4gICAgICB9KTsgLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcblxuXG4gICAgICB0cnkge1xuICAgICAgICBwdXNoLmFwcGx5KGFyciA9IHNsaWNlLmNhbGwocHJlZmVycmVkRG9jLmNoaWxkTm9kZXMpLCBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcyk7IC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG4gICAgICAgIC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblxuICAgICAgICBhcnJbcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHVzaCA9IHtcbiAgICAgICAgICBhcHBseTogYXJyLmxlbmd0aCA/IC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG4gICAgICAgICAgZnVuY3Rpb24gKHRhcmdldCwgZWxzKSB7XG4gICAgICAgICAgICBwdXNoX25hdGl2ZS5hcHBseSh0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSk7XG4gICAgICAgICAgfSA6IC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG4gICAgICAgICAgZnVuY3Rpb24gKHRhcmdldCwgZWxzKSB7XG4gICAgICAgICAgICB2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaSA9IDA7IC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXG4gICAgICAgICAgICB3aGlsZSAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkge31cblxuICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XG4gICAgICAgIHZhciBtLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICBuaWQsXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIGdyb3VwcyxcbiAgICAgICAgICAgIG5ld1NlbGVjdG9yLFxuICAgICAgICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgLy8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuICAgICAgICBub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107IC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHwgbm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0gLy8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXG5cbiAgICAgICAgaWYgKCFzZWVkKSB7XG4gICAgICAgICAgaWYgKChjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MpICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgc2V0RG9jdW1lbnQoY29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG4gICAgICAgICAgICAvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyhzZWxlY3RvcikpKSB7XG4gICAgICAgICAgICAgIC8vIElEIHNlbGVjdG9yXG4gICAgICAgICAgICAgIGlmIChtID0gbWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBEb2N1bWVudCBjb250ZXh0XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5pZCA9PT0gbSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICB9IC8vIEVsZW1lbnQgY29udGV4dFxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKG0pKSAmJiBjb250YWlucyhjb250ZXh0LCBlbGVtKSAmJiBlbGVtLmlkID09PSBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBUeXBlIHNlbGVjdG9yXG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3RvcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzOyAvLyBDbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXG5cbiAgICAgICAgICAgIGlmIChzdXBwb3J0LnFzYSAmJiAhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVtzZWxlY3RvciArIFwiIFwiXSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IHNlbGVjdG9yOyAvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcbiAgICAgICAgICAgICAgICAvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OFxuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkge1xuICAgICAgICAgICAgICAgICAgbmlkID0gbmlkLnJlcGxhY2UocmNzc2VzY2FwZSwgZmNzc2VzY2FwZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cmlidXRlKFwiaWRcIiwgbmlkID0gZXhwYW5kbyk7XG4gICAgICAgICAgICAgICAgfSAvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3RcblxuXG4gICAgICAgICAgICAgICAgZ3JvdXBzID0gdG9rZW5pemUoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgZ3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTsgLy8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cbiAgICAgICAgICAgICAgICBuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG5ld1NlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgbmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKG5ld1NlbGVjdG9yKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChxc2FFcnJvcikge1xuICAgICAgICAgICAgICAgICAgLy8gW0FkR3VhcmQgUGF0aF06IEZpeCB0aGUgY2FjaGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoc2VsZWN0b3IsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpZiAobmlkID09PSBleHBhbmRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEFsbCBvdGhlcnNcblxuXG4gICAgICAgIHJldHVybiBzZWxlY3Qoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXCIkMVwiKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICAgICAgICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gICAgICAgKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gY2FjaGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG4gICAgICAgICAgaWYgKGtleXMucHVzaChrZXkgKyBcIiBcIikgPiBFeHByLmNhY2hlTGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXlzLnNoaWZ0KCldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjYWNoZVtrZXkgKyBcIiBcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiBtYXJrRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgZm5bZXhwYW5kb10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiBhc3NlcnQoZm4pIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuICEhZm4oZWwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICB9IC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cblxuICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIGFkZEhhbmRsZShhdHRycywgaGFuZGxlcikge1xuICAgICAgICB2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuICAgICAgICAgICAgaSA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIEV4cHIuYXR0ckhhbmRsZVthcnJbaV1dID0gaGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICAgICAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiBzaWJsaW5nQ2hlY2soYSwgYikge1xuICAgICAgICB2YXIgY3VyID0gYiAmJiBhLFxuICAgICAgICAgICAgZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiYgYS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7IC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0gLy8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblxuXG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICB3aGlsZSAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoY3VyID09PSBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKGRpc2FibGVkKSB7XG4gICAgICAgIC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcbiAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuICAgICAgICAgIGlmIChcImZvcm1cIiBpbiBlbGVtKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG4gICAgICAgICAgICAvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcbiAgICAgICAgICAgIC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcbiAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuICAgICAgICAgICAgLy8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuICAgICAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuICAgICAgICAgICAgICBpZiAoXCJsYWJlbFwiIGluIGVsZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gU3VwcG9ydDogSUUgNiAtIDExXG4gICAgICAgICAgICAgIC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cblxuICAgICAgICAgICAgICByZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fCAvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXG4gICAgICAgICAgICAgIC8qIGpzaGludCAtVzAxOCAqL1xuICAgICAgICAgICAgICBlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJiBpbkRpc2FibGVkRmllbGRzZXQoZWxlbSkgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7IC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuICAgICAgICAgICAgLy8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICAgICAgfSBlbHNlIGlmIChcImxhYmVsXCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgIH0gLy8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICAgICAgICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiB0ZXN0Q29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG4gICAgICB9IC8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5cblxuICAgICAgc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG4gICAgICAvKipcbiAgICAgICAqIERldGVjdHMgWE1MIG5vZGVzXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICAgICAgICovXG5cbiAgICAgIGlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgLy8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuICAgICAgICAvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcbiAgICAgICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICAgKi9cblxuXG4gICAgICBzZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBoYXNDb21wYXJlLFxuICAgICAgICAgICAgc3ViV2luZG93LFxuICAgICAgICAgICAgZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jOyAvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXG4gICAgICAgIGlmIChkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfSAvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXG5cbiAgICAgICAgZG9jdW1lbnQgPSBkb2M7XG4gICAgICAgIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKGRvY3VtZW50KTsgLy8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuICAgICAgICAvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cbiAgICAgICAgaWYgKHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiYgKHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cpIHtcbiAgICAgICAgICAvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuICAgICAgICAgIGlmIChzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UpOyAvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3ViV2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBzdWJXaW5kb3cuYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogQXR0cmlidXRlc1xuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXG5cbiAgICAgICAgc3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuICAgICAgICAgIHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyogZ2V0RWxlbWVudChzKUJ5KlxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblxuICAgICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikpO1xuICAgICAgICAgIHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcbiAgICAgICAgfSk7IC8vIFN1cHBvcnQ6IElFPDlcblxuICAgICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSk7IC8vIFN1cHBvcnQ6IElFPDEwXG4gICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuICAgICAgICAvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcbiAgICAgICAgLy8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cbiAgICAgICAgc3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmlkID0gZXhwYW5kbztcbiAgICAgICAgICByZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShleHBhbmRvKS5sZW5ndGg7XG4gICAgICAgIH0pOyAvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblxuICAgICAgICBpZiAoc3VwcG9ydC5nZXRCeUlkKSB7XG4gICAgICAgICAgRXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uIChpZCwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtID8gW2VsZW1dIDogW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07IC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcbiAgICAgICAgICAvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cblxuICAgICAgICAgIEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24gKGlkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgZWxlbXMsXG4gICAgICAgICAgICAgICAgICBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1dO1xuICAgICAgICAgICAgICAgIH0gLy8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cblxuICAgICAgICAgICAgICAgIGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZShpZCk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbSA9IGVsZW1zW2krK10pIHtcbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBUYWdcblxuXG4gICAgICAgIEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBmdW5jdGlvbiAodGFnLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpOyAvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cbiAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQucXNhKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IDogZnVuY3Rpb24gKHRhZywgY29udGV4dCkge1xuICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICB0bXAgPSBbXSxcbiAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgIC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cbiAgICAgICAgICByZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpOyAvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cbiAgICAgICAgICBpZiAodGFnID09PSBcIipcIikge1xuICAgICAgICAgICAgd2hpbGUgKGVsZW0gPSByZXN1bHRzW2krK10pIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0bXAucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9OyAvLyBDbGFzc1xuXG4gICAgICAgIEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uIChjbGFzc05hbWUsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogUVNBL21hdGNoZXNTZWxlY3RvclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcbiAgICAgICAgLy8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblxuXG4gICAgICAgIHJidWdneU1hdGNoZXMgPSBbXTsgLy8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcbiAgICAgICAgLy8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG4gICAgICAgIC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcbiAgICAgICAgLy8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3JcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXG4gICAgICAgIHJidWdneVFTQSA9IFtdO1xuXG4gICAgICAgIGlmIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKSkge1xuICAgICAgICAgIC8vIEJ1aWxkIFFTQSByZWdleFxuICAgICAgICAgIC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcbiAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuICAgICAgICAgICAgLy8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuaW5uZXJIVE1MID0gQUdQb2xpY3kuY3JlYXRlSFRNTChcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICsgXCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArIFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIik7IC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cbiAgICAgICAgICAgIC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIpO1xuICAgICAgICAgICAgfSAvLyBTdXBwb3J0OiBJRThcbiAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblxuXG4gICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiKTtcbiAgICAgICAgICAgIH0gLy8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cblxuICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuICAgICAgICAgICAgfSAvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcbiAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cblxuICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG4gICAgICAgICAgICB9IC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG4gICAgICAgICAgICAvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cblxuICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IEFHUG9saWN5LmNyZWF0ZUhUTUwoXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICsgXCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCIpOyAvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcbiAgICAgICAgICAgIC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoaW5wdXQpLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJEXCIpOyAvLyBTdXBwb3J0OiBJRThcbiAgICAgICAgICAgIC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXG4gICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIpO1xuICAgICAgICAgICAgfSAvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblxuXG4gICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfSAvLyBTdXBwb3J0OiBJRTktMTErXG4gICAgICAgICAgICAvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblxuXG4gICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGVsKS5kaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfSAvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXG5cbiAgICAgICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHwgZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8IGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpKSB7XG4gICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgICAgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbChlbCwgXCIqXCIpOyAvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cbiAgICAgICAgICAgIG1hdGNoZXMuY2FsbChlbCwgXCJbcyE9JyddOnhcIik7XG4gICAgICAgICAgICByYnVnZ3lNYXRjaGVzLnB1c2goXCIhPVwiLCBwc2V1ZG9zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cChyYnVnZ3lRU0Euam9pbihcInxcIikpO1xuICAgICAgICByYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cChyYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpKTtcbiAgICAgICAgLyogQ29udGFpbnNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgIGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbik7IC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuICAgICAgICAvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcbiAgICAgICAgLy8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblxuICAgICAgICBjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KGRvY0VsZW0uY29udGFpbnMpID8gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICB2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYnVwIHx8ICEhKGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKGFkb3duLmNvbnRhaW5zID8gYWRvd24uY29udGFpbnMoYnVwKSA6IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihidXApICYgMTYpKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICAgIHdoaWxlIChiID0gYi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChiID09PSBhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qIFNvcnRpbmdcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICAvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cbiAgICAgICAgc29ydE9yZGVyID0gaGFzQ29tcGFyZSA/IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgLy8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcbiAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0gLy8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXG5cbiAgICAgICAgICB2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cbiAgICAgICAgICBpZiAoY29tcGFyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgICAgfSAvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cblxuICAgICAgICAgIGNvbXBhcmUgPSAoYS5vd25lckRvY3VtZW50IHx8IGEpID09PSAoYi5vd25lckRvY3VtZW50IHx8IGIpID8gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSA6IC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgIDE7IC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXG4gICAgICAgICAgaWYgKGNvbXBhcmUgJiAxIHx8ICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEpID09PSBjb21wYXJlKSB7XG4gICAgICAgICAgICAvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcbiAgICAgICAgICAgIGlmIChhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9IC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cblxuICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnB1dCA/IGluZGV4T2Yoc29ydElucHV0LCBhKSAtIGluZGV4T2Yoc29ydElucHV0LCBiKSA6IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuICAgICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG4gICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3VyLFxuICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgYXVwID0gYS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICBidXAgPSBiLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgIGFwID0gW2FdLFxuICAgICAgICAgICAgICBicCA9IFtiXTsgLy8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblxuICAgICAgICAgIGlmICghYXVwIHx8ICFidXApIHtcbiAgICAgICAgICAgIHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDogYiA9PT0gZG9jdW1lbnQgPyAxIDogYXVwID8gLTEgOiBidXAgPyAxIDogc29ydElucHV0ID8gaW5kZXhPZihzb3J0SW5wdXQsIGEpIC0gaW5kZXhPZihzb3J0SW5wdXQsIGIpIDogMDsgLy8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcbiAgICAgICAgICB9IGVsc2UgaWYgKGF1cCA9PT0gYnVwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2libGluZ0NoZWNrKGEsIGIpO1xuICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblxuXG4gICAgICAgICAgY3VyID0gYTtcblxuICAgICAgICAgIHdoaWxlIChjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgYXAudW5zaGlmdChjdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1ciA9IGI7XG5cbiAgICAgICAgICB3aGlsZSAoY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGJwLnVuc2hpZnQoY3VyKTtcbiAgICAgICAgICB9IC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cblxuICAgICAgICAgIHdoaWxlIChhcFtpXSA9PT0gYnBbaV0pIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaSA/IC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuICAgICAgICAgIHNpYmxpbmdDaGVjayhhcFtpXSwgYnBbaV0pIDogLy8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG4gICAgICAgICAgYXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDogYnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOiAwO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChleHByLCBlbGVtZW50cykge1xuICAgICAgICByZXR1cm4gU2l6emxlKGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAoZWxlbSwgZXhwcikge1xuICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiYgIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbZXhwciArIFwiIFwiXSAmJiAoIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdChleHByKSkgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KGV4cHIpKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKGVsZW0sIGV4cHIpOyAvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cbiAgICAgICAgICAgIGlmIChyZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fCAvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuICAgICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxuICAgICAgICAgICAgZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFtBZEd1YXJkIFBhdGhdOiBGaXggdGhlIGNhY2hlIHZhbHVlXG4gICAgICAgICAgICBub25uYXRpdmVTZWxlY3RvckNhY2hlKGV4cHIsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgZG9jdW1lbnQsIG51bGwsIFtlbGVtXSkubGVuZ3RoID4gMDtcbiAgICAgIH07XG5cbiAgICAgIFNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVtKSB7XG4gICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICBpZiAoKGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0KSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBzZXREb2N1bWVudChjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250YWlucyhjb250ZXh0LCBlbGVtKTtcbiAgICAgIH07XG5cbiAgICAgIFNpenpsZS5hdHRyID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgIGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZuID0gRXhwci5hdHRySGFuZGxlW25hbWUudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcbiAgICAgICAgdmFsID0gZm4gJiYgaGFzT3duLmNhbGwoRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkpID8gZm4oZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/IGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpIDogKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/IHZhbC52YWx1ZSA6IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24gKHNlbCkge1xuICAgICAgICByZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UocmNzc2VzY2FwZSwgZmNzc2VzY2FwZSk7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gICAgICAgKi9cblxuXG4gICAgICBTaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgZHVwbGljYXRlcyA9IFtdLFxuICAgICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgICBpID0gMDsgLy8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXG4gICAgICAgIGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG4gICAgICAgIHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSgwKTtcbiAgICAgICAgcmVzdWx0cy5zb3J0KHNvcnRPcmRlcik7XG5cbiAgICAgICAgaWYgKGhhc0R1cGxpY2F0ZSkge1xuICAgICAgICAgIHdoaWxlIChlbGVtID0gcmVzdWx0c1tpKytdKSB7XG4gICAgICAgICAgICBpZiAoZWxlbSA9PT0gcmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICBqID0gZHVwbGljYXRlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdHMuc3BsaWNlKGR1cGxpY2F0ZXNbal0sIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblxuXG4gICAgICAgIHNvcnRJbnB1dCA9IG51bGw7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICAgICAgICovXG5cblxuICAgICAgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICByZXQgPSBcIlwiLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgICAgaWYgKCFub2RlVHlwZSkge1xuICAgICAgICAgIC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG4gICAgICAgICAgd2hpbGUgKG5vZGUgPSBlbGVtW2krK10pIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICByZXQgKz0gZ2V0VGV4dChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuICAgICAgICAgIC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICBmb3IgKGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcbiAgICAgICAgfSAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuXG4gICAgICBFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcbiAgICAgICAgLy8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIGNhY2hlTGVuZ3RoOiA1MCxcbiAgICAgICAgY3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG4gICAgICAgIG1hdGNoOiBtYXRjaEV4cHIsXG4gICAgICAgIGF0dHJIYW5kbGU6IHt9LFxuICAgICAgICBmaW5kOiB7fSxcbiAgICAgICAgcmVsYXRpdmU6IHtcbiAgICAgICAgICBcIj5cIjoge1xuICAgICAgICAgICAgZGlyOiBcInBhcmVudE5vZGVcIixcbiAgICAgICAgICAgIGZpcnN0OiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIiBcIjoge1xuICAgICAgICAgICAgZGlyOiBcInBhcmVudE5vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCIrXCI6IHtcbiAgICAgICAgICAgIGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIixcbiAgICAgICAgICAgIGZpcnN0OiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIn5cIjoge1xuICAgICAgICAgICAgZGlyOiBcInByZXZpb3VzU2libGluZ1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVGaWx0ZXI6IHtcbiAgICAgICAgICBcIkFUVFJcIjogZnVuY3Rpb24gQVRUUihtYXRjaCkge1xuICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTsgLy8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblxuICAgICAgICAgICAgbWF0Y2hbM10gPSAobWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIikucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFsyXSA9PT0gXCJ+PVwiKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMCwgNCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uIENISUxEKG1hdGNoKSB7XG4gICAgICAgICAgICAvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cbiAgICAgICAgICAgIFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG4gICAgICAgICAgICBcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcbiAgICAgICAgICAgIFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcbiAgICAgICAgICAgIFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG4gICAgICAgICAgICBcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcbiAgICAgICAgICAgIFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuICAgICAgICAgICAgXHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcbiAgICAgICAgICAgIFx0OCB5IG9mIHktY29tcG9uZW50XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0uc2xpY2UoMCwgMykgPT09IFwibnRoXCIpIHtcbiAgICAgICAgICAgICAgLy8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcbiAgICAgICAgICAgICAgaWYgKCFtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvcihtYXRjaFswXSk7XG4gICAgICAgICAgICAgIH0gLy8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG4gICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblxuXG4gICAgICAgICAgICAgIG1hdGNoWzRdID0gKyhtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqIChtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpKTtcbiAgICAgICAgICAgICAgbWF0Y2hbNV0gPSArKG1hdGNoWzddICsgbWF0Y2hbOF0gfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpOyAvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24gUFNFVURPKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgZXhjZXNzLFxuICAgICAgICAgICAgICAgIHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdChtYXRjaFswXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cblxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjsgLy8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KHVucXVvdGVkKSAmJiAoIC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG4gICAgICAgICAgICBleGNlc3MgPSB0b2tlbml6ZSh1bnF1b3RlZCwgdHJ1ZSkpICYmICggLy8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgICBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MpIC0gdW5xdW90ZWQubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuICAgICAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDAsIGV4Y2Vzcyk7XG4gICAgICAgICAgICAgIG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoMCwgZXhjZXNzKTtcbiAgICAgICAgICAgIH0gLy8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgXCJUQUdcIjogZnVuY3Rpb24gVEFHKG5vZGVOYW1lU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNMQVNTXCI6IGZ1bmN0aW9uIENMQVNTKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlW2NsYXNzTmFtZSArIFwiIFwiXTtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuIHx8IChwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIikpICYmIGNsYXNzQ2FjaGUoY2xhc3NOYW1lLCBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBVFRSXCI6IGZ1bmN0aW9uIEFUVFIobmFtZSwgb3BlcmF0b3IsIGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKGVsZW0sIG5hbWUpO1xuXG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiXCI7XG4gICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDogb3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOiBvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoY2hlY2spID09PSAwIDogb3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKGNoZWNrKSA+IC0xIDogb3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSgtY2hlY2subGVuZ3RoKSA9PT0gY2hlY2sgOiBvcGVyYXRvciA9PT0gXCJ+PVwiID8gKFwiIFwiICsgcmVzdWx0LnJlcGxhY2UocndoaXRlc3BhY2UsIFwiIFwiKSArIFwiIFwiKS5pbmRleE9mKGNoZWNrKSA+IC0xIDogb3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKDAsIGNoZWNrLmxlbmd0aCArIDEpID09PSBjaGVjayArIFwiLVwiIDogZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDSElMRFwiOiBmdW5jdGlvbiBDSElMRCh0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QpIHtcbiAgICAgICAgICAgIHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKDAsIDMpICE9PSBcIm50aFwiLFxuICAgICAgICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKC00KSAhPT0gXCJsYXN0XCIsXG4gICAgICAgICAgICAgICAgb2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/IC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgIHZhciBjYWNoZSxcbiAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlLFxuICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSxcbiAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICBub2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgIGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgIHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuICAgICAgICAgICAgICAgICAgZGlmZiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKGRpcikge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGVbZGlyXSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXG5cbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFydCA9IFtmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkXTsgLy8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblxuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkICYmIHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcbiAgICAgICAgICAgICAgICAgIC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcbiAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTsgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cbiAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgIGNhY2hlID0gdW5pcXVlQ2FjaGVbdHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsxXTtcbiAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbMl07XG4gICAgICAgICAgICAgICAgICBub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzW25vZGVJbmRleF07XG5cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0gfHwgKCAvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgbm9kZUluZGV4LCBkaWZmXTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTsgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHwgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gdW5pcXVlQ2FjaGVbdHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuICAgICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgICAgfSAvLyB4bWwgOm50aC1jaGlsZCguLi4pXG4gICAgICAgICAgICAgICAgICAvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cblxuICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0gfHwgKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgob2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSkgJiYgKytkaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbZXhwYW5kb10gfHwgKG5vZGVbZXhwYW5kb10gPSB7fSk7IC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlW25vZGUudW5pcXVlSURdIHx8IChvdXRlckNhY2hlW25vZGUudW5pcXVlSURdID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZVt0eXBlXSA9IFtkaXJydW5zLCBkaWZmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXG5cbiAgICAgICAgICAgICAgICBkaWZmIC09IGxhc3Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8IGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUFNFVURPXCI6IGZ1bmN0aW9uIFBTRVVETyhwc2V1ZG8sIGFyZ3VtZW50KSB7XG4gICAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcbiAgICAgICAgICAgIC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG4gICAgICAgICAgICB2YXIgYXJncyxcbiAgICAgICAgICAgICAgICBmbiA9IEV4cHIucHNldWRvc1twc2V1ZG9dIHx8IEV4cHIuc2V0RmlsdGVyc1twc2V1ZG8udG9Mb3dlckNhc2UoKV0gfHwgU2l6emxlLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyk7IC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcbiAgICAgICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cbiAgICAgICAgICAgIGlmIChmbltleHBhbmRvXSkge1xuICAgICAgICAgICAgICByZXR1cm4gZm4oYXJndW1lbnQpO1xuICAgICAgICAgICAgfSAvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblxuXG4gICAgICAgICAgICBpZiAoZm4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBhcmdzID0gW3BzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudF07XG4gICAgICAgICAgICAgIHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkocHNldWRvLnRvTG93ZXJDYXNlKCkpID8gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZuKHNlZWQsIGFyZ3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZWQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgaWR4ID0gaW5kZXhPZihzZWVkLCBtYXRjaGVkW2ldKTtcbiAgICAgICAgICAgICAgICAgIHNlZWRbaWR4XSA9ICEobWF0Y2hlc1tpZHhdID0gbWF0Y2hlZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVsZW0sIDAsIGFyZ3MpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwc2V1ZG9zOiB7XG4gICAgICAgICAgLy8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG4gICAgICAgICAgXCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG4gICAgICAgICAgICAvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgICAgICBtYXRjaGVyID0gY29tcGlsZShzZWxlY3Rvci5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyW2V4cGFuZG9dID8gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBtYXRjaGVyKHNlZWQsIG51bGwsIHhtbCwgW10pLFxuICAgICAgICAgICAgICAgICAgaSA9IHNlZWQubGVuZ3RoOyAvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtID0gdW5tYXRjaGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgICBzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgaW5wdXRbMF0gPSBlbGVtO1xuICAgICAgICAgICAgICBtYXRjaGVyKGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMpOyAvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXG4gICAgICAgICAgICAgIGlucHV0WzBdID0gbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIFNpenpsZS5jb21waWxlKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTaXp6bGUoc2VsZWN0b3IsIGVsZW0pLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIC8vIFJlbW92ZWQgOmNvbnRhaW5zIHBzZXVkby1jbGFzcyBkZWNsYXJhdGlvblxuICAgICAgICAgIC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuICAgICAgICAgIC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG4gICAgICAgICAgLy8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcbiAgICAgICAgICAvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuICAgICAgICAgIC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICAgIC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG4gICAgICAgICAgXCJsYW5nXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgLy8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuICAgICAgICAgICAgaWYgKCFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikpIHtcbiAgICAgICAgICAgICAgU2l6emxlLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFuZyA9IGxhbmcucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICB2YXIgZWxlbUxhbmc7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID8gZWxlbS5sYW5nIDogZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKGxhbmcgKyBcIi1cIikgPT09IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IHdoaWxlICgoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvLyBNaXNjZWxsYW5lb3VzXG4gICAgICAgICAgXCJ0YXJnZXRcIjogZnVuY3Rpb24gdGFyZ2V0KGVsZW0pIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSgxKSA9PT0gZWxlbS5pZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicm9vdFwiOiBmdW5jdGlvbiByb290KGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmb2N1c1wiOiBmdW5jdGlvbiBmb2N1cyhlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gQm9vbGVhbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgXCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKGZhbHNlKSxcbiAgICAgICAgICBcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKHRydWUpLFxuICAgICAgICAgIFwiY2hlY2tlZFwiOiBmdW5jdGlvbiBjaGVja2VkKGVsZW0pIHtcbiAgICAgICAgICAgIC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkIHx8IG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VsZWN0ZWRcIjogZnVuY3Rpb24gc2VsZWN0ZWQoZWxlbSkge1xuICAgICAgICAgICAgLy8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuICAgICAgICAgICAgLy8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuICAgICAgICAgICAgaWYgKGVsZW0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBDb250ZW50c1xuICAgICAgICAgIFwiZW1wdHlcIjogZnVuY3Rpb24gZW1wdHkoZWxlbSkge1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cbiAgICAgICAgICAgIC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcbiAgICAgICAgICAgIC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG4gICAgICAgICAgICAvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG4gICAgICAgICAgICBmb3IgKGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlIDwgNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IC8vIFJlbW92ZWQgY3VzdG9tIHBzZXVkby1jbGFzc2VzXG5cbiAgICAgICAgfVxuICAgICAgfTsgLy8gUmVtb3ZlZCBjdXN0b20gcHNldWRvLWNsYXNzZXNcbiAgICAgIC8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuXG4gICAgICBmdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cblxuICAgICAgc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG4gICAgICBFeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuICAgICAgLyoqXG4gICAgICAgKiBbQWRHdWFyZCBQYXRjaF06XG4gICAgICAgKiBTb3J0cyB0aGUgdG9rZW5zIGluIG9yZGVyIHRvIG1pdGlnYXRlIHRoZSBwZXJmb3JtYW5jZSBpc3N1ZXMgY2F1c2VkIGJ5IG1hdGNoaW5nIHNsb3cgcHNldWRvcyBmaXJzdDpcbiAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9FeHRlbmRlZENzcy9pc3N1ZXMvNTUjaXNzdWVjb21tZW50LTM2NDA1ODc0NVxuICAgICAgICovXG5cbiAgICAgIHZhciBzb3J0VG9rZW5Hcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGxpdHMgY29tcG91bmQgc2VsZWN0b3IgaW50byBhIGxpc3Qgb2Ygc2ltcGxlIHNlbGVjdG9yc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyp9IHRva2VucyBUb2tlbnMgdG8gc3BsaXQgaW50byBncm91cHNcbiAgICAgICAgICogQHJldHVybnMgYW4gYXJyYXkgY29uc2lzdGluZyBvZiB0b2tlbiBncm91cHMgKGFycmF5cykgYW5kIHJlbGF0aW9uIHRva2Vucy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBzcGxpdENvbXBvdW5kU2VsZWN0b3IgPSBmdW5jdGlvbiBzcGxpdENvbXBvdW5kU2VsZWN0b3IodG9rZW5zKSB7XG4gICAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICAgIHZhciBjdXJyZW50VG9rZW5zR3JvdXAgPSBbXTtcbiAgICAgICAgICB2YXIgbWF4SWR4ID0gdG9rZW5zLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBtYXhJZHg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gU2l6emxlLnNlbGVjdG9ycy5yZWxhdGl2ZVt0b2tlbi50eXBlXTtcblxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGN1cnJlbnRUb2tlbnNHcm91cCk7XG4gICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgY3VycmVudFRva2Vuc0dyb3VwID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyZW50VG9rZW5zR3JvdXAucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpID09PSBtYXhJZHgpIHtcbiAgICAgICAgICAgICAgZ3JvdXBzLnB1c2goY3VycmVudFRva2Vuc0dyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3JvdXBzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBUT0tFTl9UWVBFU19WQUxVRVMgPSB7XG4gICAgICAgICAgLy8gbnRoLWNoaWxkLCBldGMsIGFsd2F5cyBnbyBsYXN0XG4gICAgICAgICAgXCJDSElMRFwiOiAxMDAsXG4gICAgICAgICAgXCJJRFwiOiA5MCxcbiAgICAgICAgICBcIkNMQVNTXCI6IDgwLFxuICAgICAgICAgIFwiVEFHXCI6IDcwLFxuICAgICAgICAgIFwiQVRUUlwiOiA3MCxcbiAgICAgICAgICBcIlBTRVVET1wiOiA2MFxuICAgICAgICB9O1xuICAgICAgICB2YXIgUE9TSVRJT05BTF9QU0VVRE9TID0gW1wibnRoXCIsIFwiZmlyc3RcIiwgXCJsYXN0XCIsIFwiZXFcIiwgXCJldmVuXCIsIFwib2RkXCIsIFwibHRcIiwgXCJndFwiLCBcIm5vdFwiXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIHRoZSBzb3J0IG9yZGVyLlxuICAgICAgICAgKiBSZXR1cm5zIGEgdmFsdWUgbGVzc2VyIHRoYW4gMCBpZiBcImxlZnRcIiBpcyBsZXNzIHRoYW4gXCJyaWdodFwiLlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgY29tcGFyZUZ1bmN0aW9uID0gZnVuY3Rpb24gY29tcGFyZUZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGxlZnRWYWx1ZSA9IFRPS0VOX1RZUEVTX1ZBTFVFU1tsZWZ0LnR5cGVdO1xuICAgICAgICAgIHZhciByaWdodFZhbHVlID0gVE9LRU5fVFlQRVNfVkFMVUVTW3JpZ2h0LnR5cGVdO1xuICAgICAgICAgIHJldHVybiBsZWZ0VmFsdWUgLSByaWdodFZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgdG9rZW5zIGdyb3VwIGlzIHNvcnRhYmxlLlxuICAgICAgICAgKiBXZSBkbyBub3QgcmUtc29ydCB0b2tlbnMgaW4gY2FzZSBvZiBhbnkgcG9zaXRpb25hbCBvciBjaGlsZCBwc2V1ZG9zIGluIHRoZSBncm91cFxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHZhciBpc1NvcnRhYmxlID0gZnVuY3Rpb24gaXNTb3J0YWJsZSh0b2tlbnMpIHtcbiAgICAgICAgICB2YXIgaVRva2VucyA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaVRva2Vucy0tKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaVRva2Vuc107XG5cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcIlBTRVVET1wiICYmIFBPU0lUSU9OQUxfUFNFVURPUy5pbmRleE9mKHRva2VuLm1hdGNoZXNbMF0pICE9PSAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcIkNISUxEXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU29ydHMgdGhlIHRva2VucyBpbiBvcmRlciB0byBtaXRpZ2F0ZSB0aGUgaXNzdWVzIGNhdXNlZCBieSB0aGUgbGVmdC10by1yaWdodCBtYXRjaGluZy5cbiAgICAgICAgICogVGhlIGlkZWEgaXMgY2hhbmdlIHRoZSB0b2tlbnMgb3JkZXIgc28gdGhhdCBTaXp6bGUgd2FzIG1hdGNoaW5nIGZhc3Qgc2VsZWN0b3JzIGZpcnN0IChpZCwgY2xhc3MpLFxuICAgICAgICAgKiBhbmQgc2xvdyBzZWxlY3RvcnMgYWZ0ZXIgdGhhdCAoYW5kIGhlcmUgSSBtZWFuIG91ciBzbG93IGN1c3RvbSBwc2V1ZG8gY2xhc3NlcykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBBbiBhcnJheSBvZiB0b2tlbnMgdG8gc29ydFxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHJlLXNvcnRlZCBhcnJheVxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHZhciBzb3J0VG9rZW5zID0gZnVuY3Rpb24gc29ydFRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgICBpZiAoIXRva2VucyB8fCB0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzb3J0ZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICB2YXIgZ3JvdXBzID0gc3BsaXRDb21wb3VuZFNlbGVjdG9yKHRva2Vucyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICBpZiAoaXNTb3J0YWJsZShncm91cCkpIHtcbiAgICAgICAgICAgICAgICBncm91cC5zb3J0KGNvbXBhcmVGdW5jdGlvbik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzb3J0ZWRUb2tlbnMgPSBzb3J0ZWRUb2tlbnMuY29uY2F0KGdyb3VwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvcnRlZFRva2Vucy5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc29ydGVkVG9rZW5zO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU29ydHMgZXZlcnkgdG9rZW5zIGFycmF5IGluc2lkZSBvZiB0aGUgc3BlY2lmaWVkIFwiZ3JvdXBzXCIgYXJyYXkuXG4gICAgICAgICAqIFNlZSBcInNvcnRUb2tlbnNcIiBtZXRob2RzIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0b2tlbnMgYXJlIHNvcnRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gZ3JvdXBzIEFuIGFycmF5IG9mIHRva2VucyBhcnJheXMuXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgdGhhdCBjb25zaXN0cyBvZiB0aGUgc2FtZSB0b2tlbnMgYXJyYXlzIGFmdGVyIHNvcnRpbmdcbiAgICAgICAgICovXG5cblxuICAgICAgICB2YXIgc29ydFRva2VuR3JvdXBzID0gZnVuY3Rpb24gc29ydFRva2VuR3JvdXBzKGdyb3Vwcykge1xuICAgICAgICAgIHZhciBzb3J0ZWRHcm91cHMgPSBbXTtcbiAgICAgICAgICB2YXIgbGVuID0gZ3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBzb3J0ZWRHcm91cHMucHVzaChzb3J0VG9rZW5zKGdyb3Vwc1tpXSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzb3J0ZWRHcm91cHM7XG4gICAgICAgIH07IC8vIEV4cG9zZVxuXG5cbiAgICAgICAgcmV0dXJuIHNvcnRUb2tlbkdyb3VwcztcbiAgICAgIH0oKTtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBjdXN0b20gcG9saWN5IHRvIHVzZSBUcnVzdGVkVHlwZXMgQ1NQIHBvbGljeVxuICAgICAgICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy10cnVzdGVkLXR5cGVzL2Rpc3Qvc3BlYy9cbiAgICAgICAqL1xuXG5cbiAgICAgIHZhciBBR1BvbGljeSA9IGZ1bmN0aW9uIGNyZWF0ZVBvbGljeSgpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRQb2xpY3kgPSB7XG4gICAgICAgICAgY3JlYXRlSFRNTDogZnVuY3Rpb24gY3JlYXRlSFRNTChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3JlYXRlU2NyaXB0OiBmdW5jdGlvbiBjcmVhdGVTY3JpcHQoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyZWF0ZVNjcmlwdFVSTDogZnVuY3Rpb24gY3JlYXRlU2NyaXB0VVJMKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh3aW5kb3cudHJ1c3RlZFR5cGVzICYmIHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KFwiQUdQb2xpY3lcIiwgZGVmYXVsdFBvbGljeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdFBvbGljeTtcbiAgICAgIH0oKTtcbiAgICAgIC8qKlxuICAgICAgICogW0FkR3VhcmQgUGF0Y2hdOlxuICAgICAgICogUmVtb3ZlcyB0cmFpbGluZyBzcGFjZXMgZnJvbSB0aGUgdG9rZW5zIGxpc3RcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IHRva2VucyBBbiBhcnJheSBvZiBTaXp6bGUgdG9rZW5zIHRvIHBvc3QtcHJvY2Vzc1xuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTcGFjZXModG9rZW5zKSB7XG4gICAgICAgIHZhciBpVG9rZW5zID0gdG9rZW5zLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaVRva2Vucy0tKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2lUb2tlbnNdO1xuXG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0b2tlbnMubGVuZ3RoID0gaVRva2VucztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFtBZEd1YXJkIFBhdGNoXTpcbiAgICAgICAqIEFuIG9iamVjdCB3aXRoIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBzZWxlY3RvcnMgYW5kIHRoZWlyIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gICAgICAgKiBAdHlwZWRlZiB7e3NlbGVjdG9yVGV4dDogc3RyaW5nLCBncm91cHM6IEFycmF5fX0gU2VsZWN0b3JEYXRhXG4gICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0b3JUZXh0IEEgQ1NTIHNlbGVjdG9yIHRleHRcbiAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGdyb3VwcyBBbiBhcnJheSBvZiB0b2tlbiBncm91cHMgY29ycmVzcG9uZGluZyB0byB0aGF0IHNlbGVjdG9yXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBbQWRHdWFyZCBQYXRjaF06XG4gICAgICAgKiBUaGlzIG1ldGhvZCBwcm9jZXNzZXMgcGFyc2VkIHRva2VuIGdyb3VwcywgZGl2aWRlcyB0aGVtIGludG8gYSBudW1iZXIgb2Ygc2VsZWN0b3JzXG4gICAgICAgKiBhbmQgbWFrZXMgc3VyZSB0aGF0IGVhY2ggc2VsZWN0b3IncyB0b2tlbnMgYXJlIGNhY2hlZCBwcm9wZXJseSBpbiBTaXp6bGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBncm91cHMgVG9rZW4gZ3JvdXBzIChzZWUge0BsaW5rIFNpenpsZS50b2tlbml6ZX0pXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFNlbGVjdG9yRGF0YT59IEFuIGFycmF5IG9mIHNlbGVjdG9ycyBkYXRhIHdlIGdvdCBmcm9tIHRoZSBncm91cHNcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIHRva2VuR3JvdXBzVG9TZWxlY3RvcnMoZ3JvdXBzKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBzcGFjZXMgd2hpY2ggd2UgY2FuIGVuY291bnRlciBpbiB0b2xlcmFudCBtb2RlXG4gICAgICAgIC8vIFdlJ3JlIGRvaW5nIGl0IGluIHRvbGVyYW50IG1vZGUgb25seSBhcyB0aGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlblxuICAgICAgICAvLyBlbmNvdW50ZXJpbmcgdHJhaWxpbmcgc3BhY2VzIGlzIGV4cGVjdGVkXG4gICAgICAgIHJlbW92ZVRyYWlsaW5nU3BhY2VzKGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0pOyAvLyBXZSBuZWVkIHNvcnRlZCB0b2tlbnMgdG8gbWFrZSBjYWNoZSB3b3JrIHByb3Blcmx5XG5cbiAgICAgICAgdmFyIHNvcnRlZEdyb3VwcyA9IHNvcnRUb2tlbkdyb3Vwcyhncm91cHMpO1xuICAgICAgICB2YXIgc2VsZWN0b3JzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdG9rZW5Hcm91cHMgPSBncm91cHNbaV07XG4gICAgICAgICAgdmFyIHNlbGVjdG9yVGV4dCA9IHRvU2VsZWN0b3IodG9rZW5Hcm91cHMpO1xuICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHtcbiAgICAgICAgICAgIC8vIFNpenpsZSBleHBlY3RzIGFuIGFycmF5IG9mIHRva2VuIGdyb3VwcyB3aGVuIGNvbXBpbGluZyBhIHNlbGVjdG9yXG4gICAgICAgICAgICBncm91cHM6IFt0b2tlbkdyb3Vwc10sXG4gICAgICAgICAgICBzZWxlY3RvclRleHQ6IHNlbGVjdG9yVGV4dFxuICAgICAgICAgIH0pOyAvLyBOb3cgbWFrZSBzdXJlIHRoYXQgc2VsZWN0b3IgdG9rZW5zIGFyZSBjYWNoZWRcblxuICAgICAgICAgIHZhciB0b2tlbnNDYWNoZUl0ZW0gPSB7XG4gICAgICAgICAgICBncm91cHM6IHRva2VuR3JvdXBzLFxuICAgICAgICAgICAgc29ydGVkR3JvdXBzOiBbc29ydGVkR3JvdXBzW2ldXVxuICAgICAgICAgIH07XG4gICAgICAgICAgdG9rZW5DYWNoZShzZWxlY3RvclRleHQsIHRva2Vuc0NhY2hlSXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0b3JzO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBbQWRHdWFyZCBQYXRjaF06XG4gICAgICAgKiBBZGQgYW4gYWRkaXRpb25hbCBhcmd1bWVudCBmb3IgU2l6emxlLnRva2VuaXplIHdoaWNoIGluZGljYXRlcyB0aGF0IGl0XG4gICAgICAgKiBzaG91bGQgbm90IHRocm93IG9uIGludmFsaWQgdG9rZW5zLCBhbmQgaW5zdGVhZCBzaG91bGQgcmV0dXJuIHRva2Vuc1xuICAgICAgICogdGhhdCBpdCBoYXMgcHJvZHVjZWQgc28gZmFyLlxuICAgICAgICpcbiAgICAgICAqIE9uZSBtb3JlIGFkZGl0aW9uYWwgYXJndW1lbnQgdGhhdCBhbGxvdyB0byBjaG9vc2UgaWYgeW91IHdhbnQgdG8gcmVjZWl2ZSBzb3J0ZWQgb3IgdW5zb3J0ZWQgdG9rZW5zXG4gICAgICAgKiBUaGUgcHJvYmxlbSBpcyB0aGF0IHRoZSByZS1zb3J0ZWQgc2VsZWN0b3JzIGFyZSB2YWxpZCBmb3IgU2l6emxlLCBidXQgbm90IGZvciB0aGUgYnJvd3Nlci5cbiAgICAgICAqIG9wdGlvbnMucmV0dXJuVW5zb3J0ZWQgLS0gcmV0dXJuIHVuc29ydGVkIHRva2VucyBpZiB0cnVlLlxuICAgICAgICogb3B0aW9ucy5jYWNoZU9ubHkgLS0gcmV0dXJuIGNhY2hlZCByZXN1bHQgb25seS4gUmVxdWlyZWQgZm9yIHVuaXQtdGVzdHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBvcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggdHdvIGFkZGl0aW9uYWwgZmxhZ3NcbiAgICAgICAqIChvcHRpb25zLnRvbGVyYW50LCBvcHRpb25zLnJldHVyblVuc29ydGVkLCBvcHRpb25zLmNhY2hlT25seSkgLS0gc2VlIHBhdGNoZXMgIzUgYW5kICM2IG5vdGVzXG4gICAgICAgKi9cblxuXG4gICAgICB0b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcGFyc2VPbmx5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXRjaGVkLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgc29GYXIsXG4gICAgICAgICAgICBncm91cHMsXG4gICAgICAgICAgICBwcmVGaWx0ZXJzLFxuICAgICAgICAgICAgY2FjaGVkID0gdG9rZW5DYWNoZVtzZWxlY3RvciArIFwiIFwiXTtcbiAgICAgICAgdmFyIHRvbGVyYW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRvbGVyYW50O1xuICAgICAgICB2YXIgcmV0dXJuVW5zb3J0ZWQgPSBvcHRpb25zICYmIG9wdGlvbnMucmV0dXJuVW5zb3J0ZWQ7XG4gICAgICAgIHZhciBjYWNoZU9ubHkgPSBvcHRpb25zICYmIG9wdGlvbnMuY2FjaGVPbmx5O1xuXG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICBpZiAocGFyc2VPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChyZXR1cm5VbnNvcnRlZCA/IGNhY2hlZC5ncm91cHMgOiBjYWNoZWQuc29ydGVkR3JvdXBzKS5zbGljZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FjaGVPbmx5KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzb0ZhciA9IHNlbGVjdG9yO1xuICAgICAgICBncm91cHMgPSBbXTtcbiAgICAgICAgcHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG4gICAgICAgIHdoaWxlIChzb0Zhcikge1xuICAgICAgICAgIC8vIENvbW1hIGFuZCBmaXJzdCBydW5cbiAgICAgICAgICBpZiAoIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoc29GYXIpKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG4gICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKSB8fCBzb0ZhcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXBzLnB1c2godG9rZW5zID0gW10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTsgLy8gQ29tYmluYXRvcnNcblxuICAgICAgICAgIGlmIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKHNvRmFyKSkge1xuICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICAvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2VcbiAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMF0ucmVwbGFjZShydHJpbSwgXCIgXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hlZC5sZW5ndGgpO1xuICAgICAgICAgIH0gLy8gRmlsdGVyc1xuXG5cbiAgICAgICAgICBmb3IgKHR5cGUgaW4gRXhwci5maWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaEV4cHJbdHlwZV0uZXhlYyhzb0ZhcikpICYmICghcHJlRmlsdGVyc1t0eXBlXSB8fCAobWF0Y2ggPSBwcmVGaWx0ZXJzW3R5cGVdKG1hdGNoKSkpKSB7XG4gICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiBtYXRjaFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG4gICAgICAgIC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblxuXG4gICAgICAgIHZhciBpbnZhbGlkTGVuID0gc29GYXIubGVuZ3RoO1xuXG4gICAgICAgIGlmIChwYXJzZU9ubHkpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZExlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnZhbGlkTGVuICE9PSAwICYmICF0b2xlcmFudCkge1xuICAgICAgICAgIFNpenpsZS5lcnJvcihzZWxlY3Rvcik7IC8vIFRocm93cyBhbiBlcnJvci5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2xlcmFudCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFtBZEd1YXJkIFBhdGNoXTpcbiAgICAgICAgICAgKiBJbiB0b2xlcmFudCBtb2RlIHdlIHJldHVybiBhIHNwZWNpYWwgb2JqZWN0IHRoYXQgY29uc3Rpc3RzIG9mXG4gICAgICAgICAgICogYW4gYXJyYXkgb2YgcGFyc2VkIHNlbGVjdG9ycyAoYW5kIHRoZWlyIHRva2VucykgYW5kIGEgXCJuZXh0SW5kZXhcIiBmaWVsZFxuICAgICAgICAgICAqIHRoYXQgcG9pbnRzIHRvIGFuIGluZGV4IGFmdGVyIHdoaWNoIHdlJ3JlIG5vdCBhYmxlIHRvIHBhcnNlIHNlbGVjdG9ycyBmYXJ0aGVyLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBuZXh0SW5kZXggPSBzZWxlY3Rvci5sZW5ndGggLSBpbnZhbGlkTGVuO1xuICAgICAgICAgIHZhciBzZWxlY3RvcnMgPSB0b2tlbkdyb3Vwc1RvU2VsZWN0b3JzKGdyb3Vwcyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbGVjdG9yczogc2VsZWN0b3JzLFxuICAgICAgICAgICAgbmV4dEluZGV4OiBuZXh0SW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKiBbQWRHdWFyZCBQYXRjaF06IFNvcnRpbmcgdG9rZW5zICovXG5cblxuICAgICAgICB2YXIgc29ydGVkR3JvdXBzID0gc29ydFRva2VuR3JvdXBzKGdyb3Vwcyk7XG4gICAgICAgIC8qKiBbQWRHdWFyZCBQYXRjaF06IENoYW5nZSB0aGUgd2F5IHRva2VucyBhcmUgY2FjaGVkICovXG5cbiAgICAgICAgdmFyIHRva2Vuc0NhY2hlSXRlbSA9IHtcbiAgICAgICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgICAgICBzb3J0ZWRHcm91cHM6IHNvcnRlZEdyb3Vwc1xuICAgICAgICB9O1xuICAgICAgICB0b2tlbnNDYWNoZUl0ZW0gPSB0b2tlbkNhY2hlKHNlbGVjdG9yLCB0b2tlbnNDYWNoZUl0ZW0pO1xuICAgICAgICByZXR1cm4gKHJldHVyblVuc29ydGVkID8gdG9rZW5zQ2FjaGVJdGVtLmdyb3VwcyA6IHRva2Vuc0NhY2hlSXRlbS5zb3J0ZWRHcm91cHMpLnNsaWNlKDApO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gdG9TZWxlY3Rvcih0b2tlbnMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICAgIHNlbGVjdG9yID0gXCJcIjtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UpIHtcbiAgICAgICAgdmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuICAgICAgICAgICAgc2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcbiAgICAgICAgICAgIGtleSA9IHNraXAgfHwgZGlyLFxuICAgICAgICAgICAgY2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcbiAgICAgICAgICAgIGRvbmVOYW1lID0gZG9uZSsrO1xuICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/IC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuICAgICAgICBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gOiAvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcbiAgICAgICAgZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgIHZhciBvbGRDYWNoZSxcbiAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUsXG4gICAgICAgICAgICAgIG91dGVyQ2FjaGUsXG4gICAgICAgICAgICAgIG5ld0NhY2hlID0gW2RpcnJ1bnMsIGRvbmVOYW1lXTsgLy8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cbiAgICAgICAgICBpZiAoeG1sKSB7XG4gICAgICAgICAgICB3aGlsZSAoZWxlbSA9IGVsZW1bZGlyXSkge1xuICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtID0gZWxlbVtkaXJdKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gZWxlbVtleHBhbmRvXSB8fCAoZWxlbVtleHBhbmRvXSA9IHt9KTsgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXG4gICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlW2VsZW0udW5pcXVlSURdIHx8IChvdXRlckNhY2hlW2VsZW0udW5pcXVlSURdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdIHx8IGVsZW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVtrZXldKSAmJiBvbGRDYWNoZVswXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsxXSA9PT0gZG9uZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FjaGVbMl0gPSBvbGRDYWNoZVsyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVba2V5XSA9IG5ld0NhY2hlOyAvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld0NhY2hlWzJdID0gbWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgPyBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgdmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXJzW2ldKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IDogbWF0Y2hlcnNbMF07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29uZGVuc2UodW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgbmV3VW5tYXRjaGVkID0gW10sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG4gICAgICAgICAgICBtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGVsZW0gPSB1bm1hdGNoZWRbaV0pIHtcbiAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XG4gICAgICAgICAgICAgIG5ld1VubWF0Y2hlZC5wdXNoKGVsZW0pO1xuXG4gICAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICBtYXAucHVzaChpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdVbm1hdGNoZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldE1hdGNoZXIocHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyW2V4cGFuZG9dKSB7XG4gICAgICAgICAgcG9zdEZpbHRlciA9IHNldE1hdGNoZXIocG9zdEZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlcltleHBhbmRvXSkge1xuICAgICAgICAgIHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKHBvc3RGaW5kZXIsIHBvc3RTZWxlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICB2YXIgdGVtcCxcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgcHJlTWFwID0gW10sXG4gICAgICAgICAgICAgIHBvc3RNYXAgPSBbXSxcbiAgICAgICAgICAgICAgcHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgLy8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcbiAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFtjb250ZXh0XSA6IGNvbnRleHQsIFtdKSxcbiAgICAgICAgICAgICAgLy8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG4gICAgICAgICAgbWF0Y2hlckluID0gcHJlRmlsdGVyICYmIChzZWVkIHx8ICFzZWxlY3RvcikgPyBjb25kZW5zZShlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCkgOiBlbGVtcyxcbiAgICAgICAgICAgICAgbWF0Y2hlck91dCA9IG1hdGNoZXIgPyAvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuICAgICAgICAgIHBvc3RGaW5kZXIgfHwgKHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyKSA/IC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgIFtdIDogLy8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG4gICAgICAgICAgcmVzdWx0cyA6IG1hdGNoZXJJbjsgLy8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblxuICAgICAgICAgIGlmIChtYXRjaGVyKSB7XG4gICAgICAgICAgICBtYXRjaGVyKG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sKTtcbiAgICAgICAgICB9IC8vIEFwcGx5IHBvc3RGaWx0ZXJcblxuXG4gICAgICAgICAgaWYgKHBvc3RGaWx0ZXIpIHtcbiAgICAgICAgICAgIHRlbXAgPSBjb25kZW5zZShtYXRjaGVyT3V0LCBwb3N0TWFwKTtcbiAgICAgICAgICAgIHBvc3RGaWx0ZXIodGVtcCwgW10sIGNvbnRleHQsIHhtbCk7IC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblxuICAgICAgICAgICAgaSA9IHRlbXAubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtID0gdGVtcFtpXSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXJPdXRbcG9zdE1hcFtpXV0gPSAhKG1hdGNoZXJJbltwb3N0TWFwW2ldXSA9IGVsZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgIGlmIChwb3N0RmluZGVyIHx8IHByZUZpbHRlcikge1xuICAgICAgICAgICAgICBpZiAocG9zdEZpbmRlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuICAgICAgICAgICAgICAgIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKG1hdGNoZXJJbltpXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIobnVsbCwgbWF0Y2hlck91dCA9IFtdLCB0ZW1wLCB4bWwpO1xuICAgICAgICAgICAgICB9IC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cblxuICAgICAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmICgoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmICh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2Yoc2VlZCwgZWxlbSkgOiBwcmVNYXBbaV0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlck91dCA9IGNvbmRlbnNlKG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgPyBtYXRjaGVyT3V0LnNwbGljZShwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGgpIDogbWF0Y2hlck91dCk7XG5cbiAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XG4gICAgICAgICAgICAgIHBvc3RGaW5kZXIobnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgbWF0Y2hlck91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zKSB7XG4gICAgICAgIHZhciBjaGVja0NvbnRleHQsXG4gICAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICBsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlW3Rva2Vuc1swXS50eXBlXSxcbiAgICAgICAgICAgIGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG4gICAgICAgICAgICBpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG4gICAgICAgICAgICAvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuICAgICAgICBtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcbiAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSksXG4gICAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4T2YoY2hlY2tDb250ZXh0LCBlbGVtKSA+IC0xO1xuICAgICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlKSxcbiAgICAgICAgICAgIG1hdGNoZXJzID0gW2Z1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICB2YXIgcmV0ID0gIWxlYWRpbmdSZWxhdGl2ZSAmJiAoeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQpIHx8ICgoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgPyBtYXRjaENvbnRleHQoZWxlbSwgY29udGV4dCwgeG1sKSA6IG1hdGNoQW55Q29udGV4dChlbGVtLCBjb250ZXh0LCB4bWwpKTsgLy8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cbiAgICAgICAgICBjaGVja0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1dO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbdG9rZW5zW2ldLnR5cGVdKSB7XG4gICAgICAgICAgICBtYXRjaGVycyA9IFthZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSwgbWF0Y2hlcildO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaGVyID0gRXhwci5maWx0ZXJbdG9rZW5zW2ldLnR5cGVdLmFwcGx5KG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzKTsgLy8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblxuICAgICAgICAgICAgaWYgKG1hdGNoZXJbZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGogPSArK2k7XG5cbiAgICAgICAgICAgICAgZm9yICg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlW3Rva2Vuc1tqXS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHNldE1hdGNoZXIoaSA+IDEgJiYgZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpLCBpID4gMSAmJiB0b1NlbGVjdG9yKCAvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuICAgICAgICAgICAgICB0b2tlbnMuc2xpY2UoMCwgaSAtIDEpLmNvbmNhdCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRva2Vuc1tpIC0gMl0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCJcbiAgICAgICAgICAgICAgfSkpLnJlcGxhY2UocnRyaW0sIFwiJDFcIiksIG1hdGNoZXIsIGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKHRva2Vucy5zbGljZShpLCBqKSksIGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zID0gdG9rZW5zLnNsaWNlKGopKSwgaiA8IGxlbiAmJiB0b1NlbGVjdG9yKHRva2VucykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRjaGVycy5wdXNoKG1hdGNoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyhlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzKSB7XG4gICAgICAgIHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICBieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uIHN1cGVyTWF0Y2hlcihzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCkge1xuICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgPSAwLFxuICAgICAgICAgICAgICBpID0gXCIwXCIsXG4gICAgICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG4gICAgICAgICAgICAgIHNldE1hdGNoZWQgPSBbXSxcbiAgICAgICAgICAgICAgY29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG4gICAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcbiAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXShcIipcIiwgb3V0ZXJtb3N0KSxcbiAgICAgICAgICAgICAgLy8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcbiAgICAgICAgICBkaXJydW5zVW5pcXVlID0gZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEsXG4gICAgICAgICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcbiAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcbiAgICAgICAgICB9IC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG4gICAgICAgICAgLy8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG4gICAgICAgICAgLy8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cblxuICAgICAgICAgIGZvciAoOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYnlFbGVtZW50ICYmIGVsZW0pIHtcbiAgICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKCFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcbiAgICAgICAgICAgICAgICB4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB3aGlsZSAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIoZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblxuXG4gICAgICAgICAgICBpZiAoYnlTZXQpIHtcbiAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuICAgICAgICAgICAgICBpZiAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcbiAgICAgICAgICAgICAgfSAvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cblxuICAgICAgICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgICAgIHVubWF0Y2hlZC5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG4gICAgICAgICAgLy8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblxuXG4gICAgICAgICAgbWF0Y2hlZENvdW50ICs9IGk7IC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuICAgICAgICAgIC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcbiAgICAgICAgICAvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcbiAgICAgICAgICAvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuICAgICAgICAgIC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcbiAgICAgICAgICAvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cbiAgICAgICAgICAvLyBudW1lcmljYWxseSB6ZXJvLlxuXG4gICAgICAgICAgaWYgKGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCkge1xuICAgICAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkge1xuICAgICAgICAgICAgICBtYXRjaGVyKHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgICAgLy8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuICAgICAgICAgICAgICBpZiAobWF0Y2hlZENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmICghKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cblxuICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XG4gICAgICAgICAgICB9IC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblxuXG4gICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHNldE1hdGNoZWQpOyAvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblxuICAgICAgICAgICAgaWYgKG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiYgbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBTaXp6bGUudW5pcXVlU29ydChyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXG5cbiAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB1bm1hdGNoZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGJ5U2V0ID8gbWFya0Z1bmN0aW9uKHN1cGVyTWF0Y2hlcikgOiBzdXBlck1hdGNoZXI7XG4gICAgICB9XG5cbiAgICAgIGNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgbWF0Y2hcbiAgICAgIC8qIEludGVybmFsIFVzZSBPbmx5ICovXG4gICAgICApIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBzZXRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzID0gW10sXG4gICAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xuXG4gICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgLy8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgbWF0Y2ggPSB0b2tlbml6ZShzZWxlY3Rvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKG1hdGNoW2ldKTtcblxuICAgICAgICAgICAgaWYgKGNhY2hlZFtleHBhbmRvXSkge1xuICAgICAgICAgICAgICBzZXRNYXRjaGVycy5wdXNoKGNhY2hlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cblxuICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyhlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzKSk7IC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXG4gICAgICAgICAgY2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAgICAgICAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICAgICAgICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgICAqL1xuXG5cbiAgICAgIHNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBmaW5kLFxuICAgICAgICAgICAgY29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3RvcixcbiAgICAgICAgICAgIG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3Rvcik7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdOyAvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuICAgICAgICAvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG4gICAgICAgICAgdG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSgwKTtcblxuICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbdG9rZW5zWzFdLnR5cGVdKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gKEV4cHIuZmluZFtcIklEXCJdKHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQpIHx8IFtdKVswXTtcblxuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzOyAvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBpbGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UodG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICB9IC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblxuXG4gICAgICAgICAgaSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KHNlbGVjdG9yKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07IC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcblxuICAgICAgICAgICAgaWYgKEV4cHIucmVsYXRpdmVbdHlwZSA9IHRva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmluZCA9IEV4cHIuZmluZFt0eXBlXSkge1xuICAgICAgICAgICAgICAvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcbiAgICAgICAgICAgICAgaWYgKHNlZWQgPSBmaW5kKHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIHJzaWJsaW5nLnRlc3QodG9rZW5zWzBdLnR5cGUpICYmIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkgfHwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3Rvcih0b2tlbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzZWVkKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICAvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cblxuICAgICAgICAoY29tcGlsZWQgfHwgY29tcGlsZShzZWxlY3RvciwgbWF0Y2gpKShzZWVkLCBjb250ZXh0LCAhZG9jdW1lbnRJc0hUTUwsIHJlc3VsdHMsICFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3Qoc2VsZWN0b3IpICYmIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkgfHwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfTsgLy8gT25lLXRpbWUgYXNzaWdubWVudHNcbiAgICAgIC8vIFNvcnQgc3RhYmlsaXR5XG5cblxuICAgICAgc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KHNvcnRPcmRlcikuam9pbihcIlwiKSA9PT0gZXhwYW5kbzsgLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuICAgICAgLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuXG4gICAgICBzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTsgLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5cbiAgICAgIHNldERvY3VtZW50KCk7IC8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4gICAgICAvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcblxuICAgICAgc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuICAgICAgICByZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKSAmIDE7XG4gICAgICB9KTsgLy8gU3VwcG9ydDogSUU8OFxuICAgICAgLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbiAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5cbiAgICAgIGlmICghYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBBR1BvbGljeS5jcmVhdGVIVE1MKFwiPGEgaHJlZj0nIyc+PC9hPlwiKTtcbiAgICAgICAgcmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCI7XG4gICAgICB9KSkge1xuICAgICAgICBhZGRIYW5kbGUoXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBpc1hNTCkge1xuICAgICAgICAgIGlmICghaXNYTUwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgIC8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcblxuXG4gICAgICBpZiAoIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBBR1BvbGljeS5jcmVhdGVIVE1MKFwiPGlucHV0Lz5cIik7XG4gICAgICAgIGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgXCJcIik7XG4gICAgICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBcIlwiO1xuICAgICAgfSkpIHtcbiAgICAgICAgYWRkSGFuZGxlKFwidmFsdWVcIiwgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICAgICAgaWYgKCFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgIC8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcblxuXG4gICAgICBpZiAoIWFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG4gICAgICB9KSkge1xuICAgICAgICBhZGRIYW5kbGUoYm9vbGVhbnMsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBpc1hNTCkge1xuICAgICAgICAgIHZhciB2YWw7XG5cbiAgICAgICAgICBpZiAoIWlzWE1MKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6ICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgPyB2YWwudmFsdWUgOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIEVYUE9TRVxuICAgICAgLy8gRG8gbm90IGV4cG9zZSBTaXp6bGUgdG8gdGhlIGdsb2JhbCBzY29wZSBpbiB0aGUgY2FzZSBvZiBBZEd1YXJkIEV4dGVuZGVkQ3NzIGJ1aWxkXG5cblxuICAgICAgcmV0dXJuIFNpenpsZTsgLy8gRVhQT1NFXG4gICAgfSh3aW5kb3cpOyAvLz4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+PlxuXG4gIH1cblxuICByZXR1cm4gU2l6emxlO1xufTtcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBBZGd1YXJkIFNvZnR3YXJlIEx0ZFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyBTaXp6bGUgYW5kIGFkZHMgc3VwcG9ydCBmb3IgXCJtYXRjaGVzLWNzc1wiIHBzZXVkbyBlbGVtZW50LlxuICovXG5cbnZhciBTdHlsZVByb3BlcnR5TWF0Y2hlciA9IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgdmFyIGlzUGhhbnRvbSA9ICEhd2luZG93Ll9waGFudG9tO1xuICB2YXIgdXNlRmFsbGJhY2sgPSBpc1BoYW50b20gJiYgISF3aW5kb3cuZ2V0TWF0Y2hlZENTU1J1bGVzO1xuICAvKipcbiAgICogVW5xdW90ZXMgc3BlY2lmaWVkIHZhbHVlXG4gICAqIFdlYmtpdC1iYXNlZCBicm93c2VycyBzaW5nbGVxdW90ZXMgPHN0cmluZz4gY29udGVudCBwcm9wZXJ0eSB2YWx1ZXNcbiAgICogT3RoZXIgYnJvd3NlcnMgZG91YmxlcXVvdGVzIGNvbnRlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cblxuICB2YXIgcmVtb3ZlQ29udGVudFF1b3RlcyA9IGZ1bmN0aW9uIHJlbW92ZUNvbnRlbnRRdW90ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL14oW1wiJ10pKFtcXHNcXFNdKilcXDEkLywgJyQyJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUuYmluZCh3aW5kb3cpO1xuICB2YXIgZ2V0TWF0Y2hlZENTU1J1bGVzID0gdXNlRmFsbGJhY2sgPyB3aW5kb3cuZ2V0TWF0Y2hlZENTU1J1bGVzLmJpbmQod2luZG93KSA6IG51bGw7XG4gIC8qKlxuICAgKiBUaGVyZSBpcyBhbiBpc3N1ZSBpbiBicm93c2VycyBiYXNlZCBvbiBvbGQgd2Via2l0OlxuICAgKiBnZXRDb21wdXRlZFN0eWxlKGVsLCBcIjpiZWZvcmVcIikgaXMgZW1wdHkgaWYgZWxlbWVudCBpcyBub3QgdmlzaWJsZS5cbiAgICpcbiAgICogVG8gY2lyY3VtdmVudCB0aGlzIGlzc3VlIHdlIHVzZSBnZXRNYXRjaGVkQ1NTUnVsZXMgaW5zdGVhZC5cbiAgICpcbiAgICogSXQgYXBwZWFycyB0aGF0IGdldE1hdGNoZWRDU1NSdWxlcyBzb3J0cyB0aGUgQ1NTIHJ1bGVzXG4gICAqIGluIGluY3JlYXNpbmcgb3JkZXIgb2Ygc3BlY2lmaXRpZXMgb2YgY29ycmVzcG9uZGluZyBzZWxlY3RvcnMuXG4gICAqIFdlIHBpY2sgdGhlIGNzcyBydWxlIHRoYXQgaXMgYmVpbmcgYXBwbGllZCB0byBhbiBlbGVtZW50IGJhc2VkIG9uIHRoaXMgYXNzdW1wdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgICAgICAgRE9NIG5vZGVcbiAgICogQHBhcmFtIHBzZXVkb0VsZW1lbnQgT3B0aW9uYWwgcHNldWRvRWxlbWVudCBuYW1lXG4gICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgIENTUyBwcm9wZXJ0eSBuYW1lXG4gICAqL1xuXG4gIHZhciBnZXRDb21wdXRlZFN0eWxlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGVQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHBzZXVkb0VsZW1lbnQsIHByb3BlcnR5TmFtZSkge1xuICAgIHZhciB2YWx1ZSA9ICcnO1xuXG4gICAgaWYgKHVzZUZhbGxiYWNrICYmIHBzZXVkb0VsZW1lbnQpIHtcbiAgICAgIHZhciBjc3NSdWxlcyA9IGdldE1hdGNoZWRDU1NSdWxlcyhlbGVtZW50LCBwc2V1ZG9FbGVtZW50KSB8fCBbXTtcbiAgICAgIHZhciBpID0gY3NzUnVsZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tID4gMCAmJiAhdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBjc3NSdWxlc1tpXS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgcHNldWRvRWxlbWVudCk7XG5cbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICB2YWx1ZSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKTsgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTkzNDQ1XG5cbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknICYmIHV0aWxzLmlzU2FmYXJpQnJvd3Nlcikge1xuICAgICAgICAgIHZhbHVlID0gKE1hdGgucm91bmQocGFyc2VGbG9hdCh2YWx1ZSkgKiAxMDApIC8gMTAwKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICB2YWx1ZSA9IHJlbW92ZUNvbnRlbnRRdW90ZXModmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEFkZHMgdXJsIHBhcmFtZXRlciBxdW90ZXMgZm9yIG5vbi1yZWdleCBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gICAqL1xuXG5cbiAgdmFyIGFkZFVybFF1b3RlcyA9IGZ1bmN0aW9uIGFkZFVybFF1b3RlcyhwYXR0ZXJuKSB7XG4gICAgLy8gZm9yIHJlZ2V4IHBhdHRlcm5zXG4gICAgaWYgKHBhdHRlcm5bMF0gPT09ICcvJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0gPT09ICcvJyAmJiBwYXR0ZXJuLmluZGV4T2YoJ1xcXFxcIicpIDwgMTApIHtcbiAgICAgIC8vIGUuZy4gL151cmxcXFxcKFthLXpdezR9OlthLXpdezV9L1xuICAgICAgLy8gb3IgL151cmxcXFxcKGRhdGFcXFxcOlxcXFxpbWFnZVxcXFwvZ2lmO2Jhc2U2NC4rL1xuICAgICAgdmFyIHJlID0gLyhcXF4pP3VybChcXFxcKT9cXFxcXFwoKFxcd3xcXFtcXHcpL2c7XG4gICAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKHJlLCAnJDF1cmwkMlxcXFxcXChcXFxcXCI/JDMnKTtcbiAgICB9IC8vIGZvciBub24tcmVnZXggcGF0dGVybnNcblxuXG4gICAgaWYgKHBhdHRlcm4uaW5kZXhPZigndXJsKFwiJykgPT09IC0xKSB7XG4gICAgICB2YXIgX3JlID0gL3VybFxcKCguKj8pXFwpL2c7XG4gICAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKF9yZSwgJ3VybChcIiQxXCIpJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH07XG4gIC8qKlxuICAgKiBDbGFzcyB0aGF0IG1hdGNoZXMgZWxlbWVudCBzdHlsZSBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgZXhwcmVzc2lvblxuICAgKiBAbWVtYmVyIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAbWVtYmVyIHtzdHJpbmd9IHBzZXVkb0VsZW1lbnRcbiAgICogQG1lbWJlciB7UmVnRXhwfSByZWdleFxuICAgKi9cblxuXG4gIHZhciBNYXRjaGVyID0gZnVuY3Rpb24gTWF0Y2hlcihwcm9wZXJ0eUZpbHRlciwgcHNldWRvRWxlbWVudCkge1xuICAgIHRoaXMucHNldWRvRWxlbWVudCA9IHBzZXVkb0VsZW1lbnQ7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGluZGV4ID0gcHJvcGVydHlGaWx0ZXIuaW5kZXhPZignOicpO1xuICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUZpbHRlci5zdWJzdHJpbmcoMCwgaW5kZXgpLnRyaW0oKTtcbiAgICAgIHZhciBwYXR0ZXJuID0gcHJvcGVydHlGaWx0ZXIuc3Vic3RyaW5nKGluZGV4ICsgMSkudHJpbSgpO1xuICAgICAgcGF0dGVybiA9IGFkZFVybFF1b3RlcyhwYXR0ZXJuKTsgLy8gVW5lc2NhcGluZyBwYXR0ZXJuXG4gICAgICAvLyBGb3Igbm9uLXJlZ2V4IHBhdHRlcm5zLCAoLCksWyxdIHNob3VsZCBiZSB1bmVzY2FwZWQsIGJlY2F1c2Ugd2UgcmVxdWlyZSBlc2NhcGluZyB0aGVtIGluIGZpbHRlciBydWxlcy5cbiAgICAgIC8vIEZvciByZWdleCBwYXR0ZXJucywgXCIsXFwgc2hvdWxkIGJlIGVzY2FwZWQsIGJlY2F1c2Ugd2UgbWFudWFsbHkgZXNjYXBlIHRob3NlIGluIGV4dGVuZGVkLWNzcy1zZWxlY3Rvci5qcy5cblxuICAgICAgaWYgKC9eXFwvLipcXC8kLy50ZXN0KHBhdHRlcm4pKSB7XG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgdGhpcy5yZWdleCA9IHV0aWxzLnBzZXVkb0FyZ1RvUmVnZXgocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC9cXFxcKFtcXFxcKClbXFxdXCJdKS9nLCAnJDEnKTtcbiAgICAgICAgdGhpcy5yZWdleCA9IHV0aWxzLmNyZWF0ZVVSTFJlZ2V4KHBhdHRlcm4pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB1dGlscy5sb2dFcnJvcihcIlN0eWxlUHJvcGVydHlNYXRjaGVyOiBpbnZhbGlkIG1hdGNoIHN0cmluZyBcIi5jb25jYXQocHJvcGVydHlGaWx0ZXIpKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBjaGVjayBpZiBlbGVtZW50IENTUyBwcm9wZXJ0eSBtYXRjaGVzIGZpbHRlciBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVja1xuICAgKi9cblxuXG4gIE1hdGNoZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5yZWdleCB8fCAhdGhpcy5wcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlUHJvcGVydHlWYWx1ZShlbGVtZW50LCB0aGlzLnBzZXVkb0VsZW1lbnQsIHRoaXMucHJvcGVydHlOYW1lKTtcbiAgICByZXR1cm4gdmFsdWUgJiYgdGhpcy5yZWdleC50ZXN0KHZhbHVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcHNldWRvLWNsYXNzIGFuZCByZWdpc3RlcnMgaXQgaW4gU2l6emxlXG4gICAqL1xuXG5cbiAgdmFyIGV4dGVuZFNpenpsZSA9IGZ1bmN0aW9uIGV4dGVuZFNpenpsZShzaXp6bGUpIHtcbiAgICAvLyBGaXJzdCBvZiBhbGwgd2Ugc2hvdWxkIHByZXBhcmUgU2l6emxlIGVuZ2luZVxuICAgIHNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snbWF0Y2hlcy1jc3MnXSA9IHNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChwcm9wZXJ0eUZpbHRlcikge1xuICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgTWF0Y2hlcihwcm9wZXJ0eUZpbHRlcik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2hlcyhlbGVtZW50KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgc2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydtYXRjaGVzLWNzcy1iZWZvcmUnXSA9IHNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChwcm9wZXJ0eUZpbHRlcikge1xuICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgTWF0Y2hlcihwcm9wZXJ0eUZpbHRlciwgJzpiZWZvcmUnKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5tYXRjaGVzKGVsZW1lbnQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBzaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ21hdGNoZXMtY3NzLWFmdGVyJ10gPSBzaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAocHJvcGVydHlGaWx0ZXIpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIocHJvcGVydHlGaWx0ZXIsICc6YWZ0ZXInKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5tYXRjaGVzKGVsZW1lbnQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTsgLy8gRVhQT1NFXG5cblxuICByZXR1cm4ge1xuICAgIGV4dGVuZFNpenpsZTogZXh0ZW5kU2l6emxlXG4gIH07XG59KHdpbmRvdyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgQWRndWFyZCBTb2Z0d2FyZSBMdGRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIG1hdGNoZXJVdGlscyA9IHt9O1xubWF0Y2hlclV0aWxzLk11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbi8qKlxuICogUGFyc2VzIGFyZ3VtZW50IG9mIG1hdGNoZXIgcHNldWRvIChmb3IgbWF0Y2hlcy1hdHRyIGFuZCBtYXRjaGVzLXByb3BlcnR5KVxuICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoZXJGaWx0ZXIgYXJndW1lbnQgb2YgcHNldWRvIGNsYXNzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblxubWF0Y2hlclV0aWxzLnBhcnNlTWF0Y2hlckZpbHRlciA9IGZ1bmN0aW9uIChtYXRjaGVyRmlsdGVyKSB7XG4gIHZhciBGVUxMX01BVENIX01BUktFUiA9ICdcIj1cIic7XG4gIHZhciByYXdBcmdzID0gW107XG5cbiAgaWYgKG1hdGNoZXJGaWx0ZXIuaW5kZXhPZihGVUxMX01BVENIX01BUktFUikgPT09IC0xKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgcHNldWRvIGFyZ1xuICAgIC8vIGUuZy4gOm1hdGNoZXMtYXR0cihcImRhdGEtbmFtZVwiKSBvciA6bWF0Y2hlcy1wcm9wZXJ0eShcImlubmVyLnByb3BcIilcbiAgICAvLyBTaXp6bGUgd2lsbCBwYXJzZSBpdCBhbmQgZ2V0IHJpZCBvZiBxdW90ZXNcbiAgICAvLyBzbyBpdCBtaWdodCBiZSB2YWxpZCBhcmcgYWxyZWFkeSB3aXRob3V0IHRoZW1cbiAgICByYXdBcmdzLnB1c2gobWF0Y2hlckZpbHRlcik7XG4gIH0gZWxzZSB7XG4gICAgbWF0Y2hlckZpbHRlci5zcGxpdCgnPScpLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgaWYgKGFyZ1swXSA9PT0gJ1wiJyAmJiBhcmdbYXJnLmxlbmd0aCAtIDFdID09PSAnXCInKSB7XG4gICAgICAgIHJhd0FyZ3MucHVzaChhcmcuc2xpY2UoMSwgLTEpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByYXdBcmdzO1xufTtcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXJnRGF0YVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFyZ1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc1JlZ2V4cFxuICovXG5cbi8qKlxuICogUGFyc2VzIHJhdyBtYXRjaGVyIGFyZ1xuICogQHBhcmFtIHtzdHJpbmd9IHJhd0FyZ1xuICogQHJldHVybnMge0FyZ0RhdGF9XG4gKi9cblxuXG5tYXRjaGVyVXRpbHMucGFyc2VSYXdNYXRjaGVyQXJnID0gZnVuY3Rpb24gKHJhd0FyZykge1xuICB2YXIgYXJnID0gcmF3QXJnO1xuICB2YXIgaXNSZWdleHAgPSAhIXJhd0FyZyAmJiByYXdBcmdbMF0gPT09ICcvJyAmJiByYXdBcmdbcmF3QXJnLmxlbmd0aCAtIDFdID09PSAnLyc7XG5cbiAgaWYgKGlzUmVnZXhwKSB7XG4gICAgLy8gdG8gYXZvaWQgYXQgbGVhc3Qgc3VjaCBjYXNlIOKAlCA6bWF0Y2hlcy1wcm9wZXJ0eShcIi8vXCIpXG4gICAgaWYgKHJhd0FyZy5sZW5ndGggPiAyKSB7XG4gICAgICBhcmcgPSB1dGlscy50b1JlZ0V4cChyYXdBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlZ2V4cDogXCIuY29uY2F0KHJhd0FyZykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXJnOiBhcmcsXG4gICAgaXNSZWdleHA6IGlzUmVnZXhwXG4gIH07XG59O1xuLyoqXG4gKiBAdHlwZWRlZiBDaGFpblxuICogQHByb3BlcnR5IHtPYmplY3R9IGJhc2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm9wXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmFsdWVcbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGluIHRoZSBiYXNlIG9iamVjdCAocmVjdXJzaXZlbHkpLlxuICogQHBhcmFtIHtPYmplY3R9IGJhc2VcbiAqIEBwYXJhbSB7QXJnRGF0YVtdfSBjaGFpbiBhcnJheSBvZiBvYmplY3RzIC0gcGFyc2VkIHN0cmluZyBwcm9wZXJ0eSBjaGFpblxuICogQHBhcmFtIHtBcnJheX0gW291dHB1dD1bXV0gcmVzdWx0IGFjY1xuICogQHJldHVybnMge0NoYWluW119IGFycmF5IG9mIG9iamVjdHNcbiAqL1xuXG5cbm1hdGNoZXJVdGlscy5maWx0ZXJSb290c0J5UmVnZXhwQ2hhaW4gPSBmdW5jdGlvbiAoYmFzZSwgY2hhaW4pIHtcbiAgdmFyIG91dHB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG4gIHZhciB0ZW1wUHJvcCA9IGNoYWluWzBdO1xuXG4gIGlmIChjaGFpbi5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICBmb3IgKHZhciBrZXkgaW4gYmFzZSkge1xuICAgICAgaWYgKHRlbXBQcm9wLmlzUmVnZXhwKSB7XG4gICAgICAgIGlmICh0ZW1wUHJvcC5hcmcudGVzdChrZXkpKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goe1xuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIHByb3A6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBiYXNlW2tleV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wUHJvcC5hcmcgPT09IGtleSkge1xuICAgICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICBwcm9wOiB0ZW1wUHJvcC5hcmcsXG4gICAgICAgICAgdmFsdWU6IGJhc2Vba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9IC8vIGlmIHRoZXJlIGlzIGEgcmVnZXhwIHByb3AgaW4gaW5wdXQgY2hhaW5cbiAgLy8gZS5nLiAndW5pdC4vXmFkLisvLnNyYycgZm9yICd1bml0LmFkLTFnZjIuc3JjIHVuaXQuYWQtZmdkMzQuc3JjJyksXG4gIC8vIGV2ZXJ5IGJhc2Uga2V5cyBzaG91bGQgYmUgdGVzdGVkIGJ5IHJlZ2V4cCBhbmQgaXQgY2FuIGJlIG1vcmUgdGhhdCBvbmUgcmVzdWx0c1xuXG5cbiAgaWYgKHRlbXBQcm9wLmlzUmVnZXhwKSB7XG4gICAgdmFyIG5leHRQcm9wID0gY2hhaW4uc2xpY2UoMSk7XG4gICAgdmFyIGJhc2VLZXlzID0gW107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuXG4gICAgZm9yICh2YXIgX2tleSBpbiBiYXNlKSB7XG4gICAgICBpZiAodGVtcFByb3AuYXJnLnRlc3QoX2tleSkpIHtcbiAgICAgICAgYmFzZUtleXMucHVzaChfa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiYXNlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBpdGVtID0gYmFzZVtrZXldO1xuICAgICAgbWF0Y2hlclV0aWxzLmZpbHRlclJvb3RzQnlSZWdleHBDaGFpbihpdGVtLCBuZXh0UHJvcCwgb3V0cHV0KTtcbiAgICB9KTtcbiAgfSAvLyBhdm9pZCBUeXBlRXJyb3Igd2hpbGUgYWNjZXNzaW5nIHRvIG51bGwtcHJvcCdzIGNoaWxkXG5cblxuICBpZiAoYmFzZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXh0QmFzZSA9IGJhc2VbdGVtcFByb3AuYXJnXTtcbiAgY2hhaW4gPSBjaGFpbi5zbGljZSgxKTtcblxuICBpZiAobmV4dEJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIG1hdGNoZXJVdGlscy5maWx0ZXJSb290c0J5UmVnZXhwQ2hhaW4obmV4dEJhc2UsIGNoYWluLCBvdXRwdXQpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG4vKipcbiAqIFZhbGlkYXRlcyBwYXJzZWQgYXJncyBvZiBtYXRjaGVzLXByb3BlcnR5IHBzZXVkb1xuICogQHBhcmFtIHsuLi5BcmdEYXRhfSBhcmdzXG4gKi9cblxuXG5tYXRjaGVyVXRpbHMudmFsaWRhdGVQcm9wTWF0Y2hlckFyZ3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjsgX2tleTIrKykge1xuICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChhcmdzW2ldLmlzUmVnZXhwKSB7XG4gICAgICBpZiAoIXV0aWxzLnN0YXJ0c1dpdGgoYXJnc1tpXS5hcmcudG9TdHJpbmcoKSwgJy8nKSB8fCAhdXRpbHMuZW5kc1dpdGgoYXJnc1tpXS5hcmcudG9TdHJpbmcoKSwgJy8nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIHNpbXBsZSBhcmcgY2hlY2sgaWYgaXQgaXMgbm90IGEgcmVnZXhwXG5cbiAgICB9IGVsc2UgaWYgKCEvXltcXHctXSskLy50ZXN0KGFyZ3NbaV0uYXJnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgU2l6emxlIGFuZCBhZGRzIHN1cHBvcnQgZm9yIFwibWF0Y2hlcy1hdHRyXCIgcHNldWRvIGVsZW1lbnQuXG4gKi9cblxudmFyIEF0dHJpYnV0ZXNNYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ2xhc3MgdGhhdCBtYXRjaGVzIGVsZW1lbnQgYXR0cmlidXRlcyBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgZXhwcmVzc2lvbnNcbiAgICogQHBhcmFtIHtBcmdEYXRhfSBuYW1lQXJnIC0gcGFyc2VkIG5hbWUgYXJndW1lbnRcbiAgICogQHBhcmFtIHtBcmdEYXRhfSB2YWx1ZUFyZyAtIHBhcnNlZCB2YWx1ZSBhcmd1bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHNldWRvRWxlbWVudFxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQG1lbWJlciB7c3RyaW5nfFJlZ0V4cH0gYXR0ck5hbWVcbiAgICogQG1lbWJlciB7Ym9vbGVhbn0gaXNSZWdleHBOYW1lXG4gICAqIEBtZW1iZXIge3N0cmluZ3xSZWdFeHB9IGF0dHJWYWx1ZVxuICAgKiBAbWVtYmVyIHtib29sZWFufSBpc1JlZ2V4cFZhbHVlXG4gICAqL1xuICB2YXIgQXR0ck1hdGNoZXIgPSBmdW5jdGlvbiBBdHRyTWF0Y2hlcihuYW1lQXJnLCB2YWx1ZUFyZywgcHNldWRvRWxlbWVudCkge1xuICAgIHRoaXMucHNldWRvRWxlbWVudCA9IHBzZXVkb0VsZW1lbnQ7XG4gICAgdGhpcy5hdHRyTmFtZSA9IG5hbWVBcmcuYXJnO1xuICAgIHRoaXMuaXNSZWdleHBOYW1lID0gbmFtZUFyZy5pc1JlZ2V4cDtcbiAgICB0aGlzLmF0dHJWYWx1ZSA9IHZhbHVlQXJnLmFyZztcbiAgICB0aGlzLmlzUmVnZXhwVmFsdWUgPSB2YWx1ZUFyZy5pc1JlZ2V4cDtcbiAgfTtcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIGVsZW1lbnQgYXR0cmlidXRlcyBtYXRjaGVzIGZpbHRlciBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVja1xuICAgKi9cblxuXG4gIEF0dHJNYXRjaGVyLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgZWxBdHRycyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblxuICAgIGlmIChlbEF0dHJzLmxlbmd0aCA9PT0gMCB8fCAhdGhpcy5hdHRyTmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgZWxBdHRycy5sZW5ndGgpIHtcbiAgICAgIHZhciBhdHRyID0gZWxBdHRyc1tpXTtcbiAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG4gICAgICB2YXIgYXR0ck5hbWVNYXRjaGVkID0gdGhpcy5pc1JlZ2V4cE5hbWUgPyB0aGlzLmF0dHJOYW1lLnRlc3QoYXR0ci5uYW1lKSA6IHRoaXMuYXR0ck5hbWUgPT09IGF0dHIubmFtZTtcblxuICAgICAgaWYgKCF0aGlzLmF0dHJWYWx1ZSkge1xuICAgICAgICAvLyBmb3IgOm1hdGNoZXMtYXR0cihcIi9yZWdleC9cIikgb3IgOm1hdGNoZXMtYXR0cihcImF0dHItbmFtZVwiKVxuICAgICAgICBtYXRjaGVkID0gYXR0ck5hbWVNYXRjaGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJWYWx1ZU1hdGNoZWQgPSB0aGlzLmlzUmVnZXhwVmFsdWUgPyB0aGlzLmF0dHJWYWx1ZS50ZXN0KGF0dHIudmFsdWUpIDogdGhpcy5hdHRyVmFsdWUgPT09IGF0dHIudmFsdWU7XG4gICAgICAgIG1hdGNoZWQgPSBhdHRyTmFtZU1hdGNoZWQgJiYgYXR0clZhbHVlTWF0Y2hlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBzZXVkby1jbGFzcyBhbmQgcmVnaXN0ZXJzIGl0IGluIFNpenpsZVxuICAgKi9cblxuXG4gIHZhciBleHRlbmRTaXp6bGUgPSBmdW5jdGlvbiBleHRlbmRTaXp6bGUoc2l6emxlKSB7XG4gICAgLy8gRmlyc3Qgb2YgYWxsIHdlIHNob3VsZCBwcmVwYXJlIFNpenpsZSBlbmdpbmVcbiAgICBzaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ21hdGNoZXMtYXR0ciddID0gc2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKGF0dHJGaWx0ZXIpIHtcbiAgICAgIHZhciBfbWF0Y2hlclV0aWxzJHBhcnNlTWEgPSBtYXRjaGVyVXRpbHMucGFyc2VNYXRjaGVyRmlsdGVyKGF0dHJGaWx0ZXIpLFxuICAgICAgICAgIF9tYXRjaGVyVXRpbHMkcGFyc2VNYTIgPSBfc2xpY2VkVG9BcnJheShfbWF0Y2hlclV0aWxzJHBhcnNlTWEsIDIpLFxuICAgICAgICAgIHJhd05hbWUgPSBfbWF0Y2hlclV0aWxzJHBhcnNlTWEyWzBdLFxuICAgICAgICAgIHJhd1ZhbHVlID0gX21hdGNoZXJVdGlscyRwYXJzZU1hMlsxXTtcblxuICAgICAgdmFyIG5hbWVBcmcgPSBtYXRjaGVyVXRpbHMucGFyc2VSYXdNYXRjaGVyQXJnKHJhd05hbWUpO1xuICAgICAgdmFyIHZhbHVlQXJnID0gbWF0Y2hlclV0aWxzLnBhcnNlUmF3TWF0Y2hlckFyZyhyYXdWYWx1ZSk7XG5cbiAgICAgIGlmICghYXR0ckZpbHRlciB8fCAhbWF0Y2hlclV0aWxzLnZhbGlkYXRlUHJvcE1hdGNoZXJBcmdzKG5hbWVBcmcsIHZhbHVlQXJnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDptYXRjaGVzLWF0dHIgcHNldWRvIGNsYXNzOiBcIi5jb25jYXQoYXR0ckZpbHRlcikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlciA9IG5ldyBBdHRyTWF0Y2hlcihuYW1lQXJnLCB2YWx1ZUFyZyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2hlcyhlbGVtZW50KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07IC8vIEVYUE9TRVxuXG5cbiAgcmV0dXJuIHtcbiAgICBleHRlbmRTaXp6bGU6IGV4dGVuZFNpenpsZVxuICB9O1xufSgpO1xuXG4vKipcbiAqIFBhcnNlcyByYXcgcHJvcGVydHkgYXJnXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEByZXR1cm5zIHtBcmdEYXRhW119IGFycmF5IG9mIG9iamVjdHNcbiAqL1xuXG52YXIgcGFyc2VSYXdQcm9wQ2hhaW4gPSBmdW5jdGlvbiBwYXJzZVJhd1Byb3BDaGFpbihpbnB1dCkge1xuICB2YXIgUFJPUFNfRElWSURFUiA9ICcuJztcbiAgdmFyIFJFR0VYUF9NQVJLRVIgPSAnLyc7XG4gIHZhciBwcm9wc0FyciA9IFtdO1xuICB2YXIgc3RyID0gaW5wdXQ7XG5cbiAgd2hpbGUgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHV0aWxzLnN0YXJ0c1dpdGgoc3RyLCBQUk9QU19ESVZJREVSKSkge1xuICAgICAgLy8gZm9yIGNhc2VzIGxpa2UgJy5wcm9wLmlkJyBhbmQgJ25lc3RlZC4udGVzdCdcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hhaW4gcHJvcGVydHk6IFwiLmNvbmNhdChpbnB1dCkpO1xuICAgIH1cblxuICAgIGlmICghdXRpbHMuc3RhcnRzV2l0aChzdHIsIFJFR0VYUF9NQVJLRVIpKSB7XG4gICAgICB2YXIgaXNSZWdleHAgPSBmYWxzZTtcbiAgICAgIHZhciBkaXZpZGVySW5kZXggPSBzdHIuaW5kZXhPZihQUk9QU19ESVZJREVSKTtcblxuICAgICAgaWYgKHN0ci5pbmRleE9mKFBST1BTX0RJVklERVIpID09PSAtMSkge1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyAnLicgbGVmdCBpbiBzdHJcbiAgICAgICAgLy8gdGFrZSB0aGUgcmVzdCBvZiBzdHIgYXMgcHJvcFxuICAgICAgICBwcm9wc0Fyci5wdXNoKHtcbiAgICAgICAgICBhcmc6IHN0cixcbiAgICAgICAgICBpc1JlZ2V4cDogaXNSZWdleHBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9wc0FycjtcbiAgICAgIH0gLy8gZWxzZSB0YWtlIHByb3AgZnJvbSBzdHJcblxuXG4gICAgICB2YXIgcHJvcCA9IHN0ci5zbGljZSgwLCBkaXZpZGVySW5kZXgpOyAvLyBmb3IgY2FzZXMgbGlrZSAnYXNhZGYuPysvLnRlc3QnXG5cbiAgICAgIGlmIChwcm9wLmluZGV4T2YoUkVHRVhQX01BUktFUikgPiAtMSkge1xuICAgICAgICAvLyBwcm9wIGlzICc/Ky8nXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hhaW4gcHJvcGVydHk6IFwiLmNvbmNhdChwcm9wKSk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzQXJyLnB1c2goe1xuICAgICAgICBhcmc6IHByb3AsXG4gICAgICAgIGlzUmVnZXhwOiBpc1JlZ2V4cFxuICAgICAgfSk7IC8vIGRlbGV0ZSBwcm9wIGZyb20gc3RyXG5cbiAgICAgIHN0ciA9IHN0ci5zbGljZShkaXZpZGVySW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWFsIHdpdGggcmVnZXhwXG4gICAgICB2YXIgcHJvcENodW5rcyA9IFtdO1xuICAgICAgcHJvcENodW5rcy5wdXNoKHN0ci5zbGljZSgwLCAxKSk7IC8vIGlmIHN0ciBzdGFydHMgd2l0aCAnLycsIGRlbGV0ZSBpdCBmcm9tIHN0ciBhbmQgZmluZCBjbG9zaW5nIHJlZ2V4cCBzbGFzaC5cbiAgICAgIC8vIG5vdGUgdGhhdCBjaGFpbmVkIHByb3BlcnR5IG5hbWUgY2FuIG5vdCBpbmNsdWRlICcvJyBvciAnLidcbiAgICAgIC8vIHNvIHRoZXJlIGlzIG5vIGNoZWNraW5nIGZvciBlc2NhcGVkIGNoYXJhY3RlcnNcblxuICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgdmFyIHJlZ2V4RW5kSW5kZXggPSBzdHIuaW5kZXhPZihSRUdFWFBfTUFSS0VSKTtcblxuICAgICAgaWYgKHJlZ2V4RW5kSW5kZXggPCAxKSB7XG4gICAgICAgIC8vIHJlZ2V4cCBzaG91bGQgYmUgYXQgbGVhc3QgPT09ICcvLi8nXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBhdm9pZCBhcmdzIGxpa2UgJy9pZCcgYW5kICd0ZXN0Li8vLmlkJ1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlZ2V4cDogXCIuY29uY2F0KFJFR0VYUF9NQVJLRVIpLmNvbmNhdChzdHIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pc1JlZ2V4cCA9IHRydWU7IC8vIHRha2UgdGhlIHJlc3QgcmVnZXhwIHBhcnRcblxuICAgICAgcHJvcENodW5rcy5wdXNoKHN0ci5zbGljZSgwLCByZWdleEVuZEluZGV4ICsgMSkpO1xuXG4gICAgICB2YXIgX3Byb3AgPSB1dGlscy50b1JlZ0V4cChwcm9wQ2h1bmtzLmpvaW4oJycpKTtcblxuICAgICAgcHJvcHNBcnIucHVzaCh7XG4gICAgICAgIGFyZzogX3Byb3AsXG4gICAgICAgIGlzUmVnZXhwOiBfaXNSZWdleHBcbiAgICAgIH0pOyAvLyBkZWxldGUgcHJvcCBmcm9tIHN0clxuXG4gICAgICBzdHIgPSBzdHIuc2xpY2UocmVnZXhFbmRJbmRleCArIDEpO1xuICAgIH1cblxuICAgIGlmICghc3RyKSB7XG4gICAgICByZXR1cm4gcHJvcHNBcnI7XG4gICAgfSAvLyBzdHIgc2hvdWxkIGJlIGxpa2UgJy5uZXh0UHJvcCcgbm93XG4gICAgLy8gc28gJ3p4LnByb3AnIG9yICcuJyBpcyBpbnZhbGlkXG5cblxuICAgIGlmICghdXRpbHMuc3RhcnRzV2l0aChzdHIsIFBST1BTX0RJVklERVIpIHx8IHV0aWxzLnN0YXJ0c1dpdGgoc3RyLCBQUk9QU19ESVZJREVSKSAmJiBzdHIubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYWluIHByb3BlcnR5OiBcIi5jb25jYXQoaW5wdXQpKTtcbiAgICB9XG5cbiAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gIH1cbn07XG5cbnZhciBjb252ZXJ0VHlwZUZyb21TdHIgPSBmdW5jdGlvbiBjb252ZXJ0VHlwZUZyb21TdHIodmFsdWUpIHtcbiAgdmFyIG51bVZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgdmFyIG91dHB1dDtcblxuICBpZiAoIU51bWJlci5pc05hTihudW1WYWx1ZSkpIHtcbiAgICBvdXRwdXQgPSBudW1WYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgb3V0cHV0ID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RydWUnOlxuICAgICAgICBvdXRwdXQgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZmFsc2UnOlxuICAgICAgICBvdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG91dHB1dCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG52YXIgY29udmVydFR5cGVJbnRvU3RyID0gZnVuY3Rpb24gY29udmVydFR5cGVJbnRvU3RyKHZhbHVlKSB7XG4gIHZhciBvdXRwdXQ7XG5cbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgb3V0cHV0ID0gJ3VuZGVmaW5lZCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbnVsbDpcbiAgICAgIG91dHB1dCA9ICdudWxsJztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG91dHB1dCA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIFNpenpsZSBhbmQgYWRkcyBzdXBwb3J0IGZvciBcIm1hdGNoZXMtcHJvcGVydHlcIiBwc2V1ZG8gZWxlbWVudC5cbiAqL1xuXG5cbnZhciBFbGVtZW50UHJvcGVydHlNYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ2xhc3MgdGhhdCBtYXRjaGVzIGVsZW1lbnQgcHJvcGVydGllcyBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgZXhwcmVzc2lvbnNcbiAgICogQHBhcmFtIHtBcmdEYXRhW119IHByb3BzQ2hhaW5BcmcgLSBhcnJheSBvZiBwYXJzZWQgcHJvcHMgY2hhaW4gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0FyZ0RhdGF9IHZhbHVlQXJnIC0gcGFyc2VkIHZhbHVlIGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwc2V1ZG9FbGVtZW50XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAbWVtYmVyIHtBcnJheX0gY2hhaW5lZFByb3BzXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59IGlzUmVnZXhwTmFtZVxuICAgKiBAbWVtYmVyIHtzdHJpbmd8UmVnRXhwfSBwcm9wVmFsdWVcbiAgICogQG1lbWJlciB7Ym9vbGVhbn0gaXNSZWdleHBWYWx1ZVxuICAgKi9cbiAgdmFyIFByb3BNYXRjaGVyID0gZnVuY3Rpb24gUHJvcE1hdGNoZXIocHJvcHNDaGFpbkFyZywgdmFsdWVBcmcsIHBzZXVkb0VsZW1lbnQpIHtcbiAgICB0aGlzLnBzZXVkb0VsZW1lbnQgPSBwc2V1ZG9FbGVtZW50O1xuICAgIHRoaXMuY2hhaW5lZFByb3BzID0gcHJvcHNDaGFpbkFyZztcbiAgICB0aGlzLnByb3BWYWx1ZSA9IHZhbHVlQXJnLmFyZztcbiAgICB0aGlzLmlzUmVnZXhwVmFsdWUgPSB2YWx1ZUFyZy5pc1JlZ2V4cDtcbiAgfTtcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIGVsZW1lbnQgcHJvcGVydGllcyBtYXRjaGVzIGZpbHRlciBwYXR0ZXJuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVja1xuICAgKi9cblxuXG4gIFByb3BNYXRjaGVyLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgb3duZXJPYmpBcnIgPSBtYXRjaGVyVXRpbHMuZmlsdGVyUm9vdHNCeVJlZ2V4cENoYWluKGVsZW1lbnQsIHRoaXMuY2hhaW5lZFByb3BzKTtcblxuICAgIGlmIChvd25lck9iakFyci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5wcm9wVmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3duZXJPYmpBcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJlYWxWYWx1ZSA9IG93bmVyT2JqQXJyW2ldLnZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUmVnZXhwVmFsdWUpIHtcbiAgICAgICAgICBtYXRjaGVkID0gdGhpcy5wcm9wVmFsdWUudGVzdChjb252ZXJ0VHlwZUludG9TdHIocmVhbFZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaGFuZGxlICdudWxsJyBhbmQgJ3VuZGVmaW5lZCcgcHJvcGVydHkgdmFsdWVzIHNldCBhcyBzdHJpbmdcbiAgICAgICAgICBpZiAocmVhbFZhbHVlID09PSAnbnVsbCcgfHwgcmVhbFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWF0Y2hlZCA9IHRoaXMucHJvcFZhbHVlID09PSByZWFsVmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRjaGVkID0gY29udmVydFR5cGVGcm9tU3RyKHRoaXMucHJvcFZhbHVlKSA9PT0gcmVhbFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVkO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwc2V1ZG8tY2xhc3MgYW5kIHJlZ2lzdGVycyBpdCBpbiBTaXp6bGVcbiAgICovXG5cblxuICB2YXIgZXh0ZW5kU2l6emxlID0gZnVuY3Rpb24gZXh0ZW5kU2l6emxlKHNpenpsZSkge1xuICAgIC8vIEZpcnN0IG9mIGFsbCB3ZSBzaG91bGQgcHJlcGFyZSBTaXp6bGUgZW5naW5lXG4gICAgc2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydtYXRjaGVzLXByb3BlcnR5J10gPSBzaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAocHJvcGVydHlGaWx0ZXIpIHtcbiAgICAgIGlmICghcHJvcGVydHlGaWx0ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhcmd1bWVudCBpcyBnaXZlbiBmb3IgOm1hdGNoZXMtcHJvcGVydHkgcHNldWRvIGNsYXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbWF0Y2hlclV0aWxzJHBhcnNlTWEgPSBtYXRjaGVyVXRpbHMucGFyc2VNYXRjaGVyRmlsdGVyKHByb3BlcnR5RmlsdGVyKSxcbiAgICAgICAgICBfbWF0Y2hlclV0aWxzJHBhcnNlTWEyID0gX3NsaWNlZFRvQXJyYXkoX21hdGNoZXJVdGlscyRwYXJzZU1hLCAyKSxcbiAgICAgICAgICByYXdQcm9wID0gX21hdGNoZXJVdGlscyRwYXJzZU1hMlswXSxcbiAgICAgICAgICByYXdWYWx1ZSA9IF9tYXRjaGVyVXRpbHMkcGFyc2VNYTJbMV07IC8vIGNoYWluZWQgcHJvcGVydHkgbmFtZSBjYW4gbm90IGluY2x1ZGUgJy8nIG9yICcuJ1xuICAgICAgLy8gc28gcmVnZXggcHJvcCBuYW1lcyB3aXRoIHN1Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIGFyZSBpbnZhbGlkXG5cblxuICAgICAgaWYgKHJhd1Byb3AuaW5kZXhPZignXFxcXC8nKSA+IC0xIHx8IHJhd1Byb3AuaW5kZXhPZignXFxcXC4nKSA+IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvcGVydHkgbmFtZTogXCIuY29uY2F0KHJhd1Byb3ApKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BzQ2hhaW5BcmcgPSBwYXJzZVJhd1Byb3BDaGFpbihyYXdQcm9wKTtcbiAgICAgIHZhciB2YWx1ZUFyZyA9IG1hdGNoZXJVdGlscy5wYXJzZVJhd01hdGNoZXJBcmcocmF3VmFsdWUpO1xuICAgICAgdmFyIHByb3BzVG9WYWxpZGF0ZSA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocHJvcHNDaGFpbkFyZyksIFt2YWx1ZUFyZ10pO1xuXG4gICAgICBpZiAoIW1hdGNoZXJVdGlscy52YWxpZGF0ZVByb3BNYXRjaGVyQXJncyhwcm9wc1RvVmFsaWRhdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOm1hdGNoZXMtcHJvcGVydHkgcHNldWRvIGNsYXNzOiBcIi5jb25jYXQocHJvcGVydHlGaWx0ZXIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgUHJvcE1hdGNoZXIocHJvcHNDaGFpbkFyZywgdmFsdWVBcmcpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLm1hdGNoZXMoZWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9OyAvLyBFWFBPU0VcblxuXG4gIHJldHVybiB7XG4gICAgZXh0ZW5kU2l6emxlOiBleHRlbmRTaXp6bGVcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBBZGd1YXJkIFNvZnR3YXJlIEx0ZFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyBTaXp6bGUgYW5kIGFkZHMgc3VwcG9ydCBmb3IgOmlzKCkgcHNldWRvIGVsZW1lbnQuXG4gKi9cblxudmFyIElzQW55TWF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENsYXNzIHRoYXQgbWF0Y2hlcyBlbGVtZW50IGJ5IG9uZSBvZiB0aGUgc2VsZWN0b3JzXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy86aXNcbiAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0b3JzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwc2V1ZG9FbGVtZW50XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdmFyIElzTWF0Y2hlciA9IGZ1bmN0aW9uIElzTWF0Y2hlcihzZWxlY3RvcnMsIHBzZXVkb0VsZW1lbnQpIHtcbiAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICB0aGlzLnBzZXVkb0VsZW1lbnQgPSBwc2V1ZG9FbGVtZW50O1xuICB9O1xuICAvKipcbiAgICogRnVuY3Rpb24gdG8gY2hlY2sgaWYgZWxlbWVudCBjYW4gYmUgbWF0Y2hlZCBieSBhbnkgcGFzc2VkIHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVja1xuICAgKi9cblxuXG4gIElzTWF0Y2hlci5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGlzTWF0Y2hlZCA9ICEhdGhpcy5zZWxlY3RvcnMuZmluZChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obm9kZXMpLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IGVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXNNYXRjaGVkO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwc2V1ZG8tY2xhc3MgYW5kIHJlZ2lzdGVycyBpdCBpbiBTaXp6bGVcbiAgICovXG5cblxuICB2YXIgZXh0ZW5kU2l6emxlID0gZnVuY3Rpb24gZXh0ZW5kU2l6emxlKHNpenpsZSkge1xuICAgIC8vIEZpcnN0IG9mIGFsbCB3ZSBzaG91bGQgcHJlcGFyZSBTaXp6bGUgZW5naW5lXG4gICAgc2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydpcyddID0gc2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOmlzIHBzZXVkby1jbGFzczogXCIuY29uY2F0KGlucHV0KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3RvcnMgPSBpbnB1dC5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy50cmltKCk7XG4gICAgICB9KTsgLy8gY29sbGVjdCB2YWxpZCBzZWxlY3RvcnMgYW5kIGxvZyBhYm91dCBpbnZhbGlkIG9uZXNcblxuICAgICAgdmFyIHZhbGlkU2VsZWN0b3JzID0gc2VsZWN0b3JzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoY3NzVXRpbHMuaXNTaW1wbGVTZWxlY3RvclZhbGlkKHNlbGVjdG9yKSkge1xuICAgICAgICAgIGFjYy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlscy5sb2dJbmZvKFwiSW52YWxpZCBzZWxlY3RvciBwYXNzZWQgdG8gOmlzKCkgcHNldWRvLWNsYXNzOiAnXCIuY29uY2F0KHNlbGVjdG9yLCBcIidcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIFtdKTtcbiAgICAgIHZhciBtYXRjaGVyID0gbmV3IElzTWF0Y2hlcih2YWxpZFNlbGVjdG9ycyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2hlcyhlbGVtZW50KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBleHRlbmRTaXp6bGU6IGV4dGVuZFNpenpsZVxuICB9O1xufSgpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEFkZ3VhcmQgU29mdHdhcmUgTHRkXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRXh0ZW5kZWQgc2VsZWN0b3IgZmFjdG9yeSBtb2R1bGUsIGZvciBjcmVhdGluZyBleHRlbmRlZCBzZWxlY3RvciBjbGFzc2VzLlxuICpcbiAqIEV4dGVuZGVkIHNlbGVjdGlvbiBjYXBhYmlsaXRpZXMgZGVzY3JpcHRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vRXh0ZW5kZWRDc3MvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kXG4gKi9cblxudmFyIEV4dGVuZGVkU2VsZWN0b3JGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAvLyB3aGlsZSBhZGRpbmcgbmV3IG1hcmtlcnMsIGNvbnN0YW50cyBpbiBvdGhlciBBZEd1YXJkIHJlcG9zIHNob3VsZCBiZSBjb3JyZWN0ZWRcbiAgLy8gQWRHdWFyZCBicm93c2VyIGV4dGVuc2lvbiA6IENzc0ZpbHRlclJ1bGUuU1VQUE9SVEVEX1BTRVVET19DTEFTU0VTIGFuZCBDc3NGaWx0ZXJSdWxlLkVYVEVOREVEX0NTU19NQVJLRVJTXG4gIC8vIHRzdXJsZmlsdGVyLCBTYWZhcmlDb252ZXJ0ZXJMaWIgOiBFWFRfQ1NTX1BTRVVET19JTkRJQ0FUT1JTXG4gIHZhciBQU0VVRE9fRVhURU5TSU9OU19NQVJLRVJTID0gWyc6aGFzJywgJzpjb250YWlucycsICc6aGFzLXRleHQnLCAnOm1hdGNoZXMtY3NzJywgJzotYWJwLWhhcycsICc6LWFicC1oYXMtdGV4dCcsICc6aWYnLCAnOmlmLW5vdCcsICc6eHBhdGgnLCAnOm50aC1hbmNlc3RvcicsICc6dXB3YXJkJywgJzpyZW1vdmUnLCAnOm1hdGNoZXMtYXR0cicsICc6bWF0Y2hlcy1wcm9wZXJ0eScsICc6LWFicC1jb250YWlucycsICc6aXMnXTtcbiAgdmFyIGluaXRpYWxpemVkID0gZmFsc2U7XG4gIHZhciBTaXp6bGU7XG4gIC8qKlxuICAgKiBMYXp5IGluaXRpYWxpemF0aW9uIG9mIHRoZSBFeHRlbmRlZFNlbGVjdG9yRmFjdG9yeSBhbmQgb2JqZWN0cyB0aGF0IG1pZ2h0IGJlIG5lY2Vzc2FyeSBmb3IgY3JlYXRpbmcgYW5kIGFwcGx5aW5nIHN0eWxlcy5cbiAgICogVGhpcyBtZXRob2QgZXh0ZW5kcyBTaXp6bGUgZW5naW5lIHRoYXQgd2UgdXNlIHVuZGVyIHRoZSBob29kIHdpdGggb3VyIGN1c3RvbSBwc2V1ZG8tY2xhc3Nlcy5cbiAgICovXG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplZCA9IHRydWU7IC8vIE91ciB2ZXJzaW9uIG9mIFNpenpsZSBpcyBpbml0aWFsaXplZCBsYXppbHkgYXMgd2VsbFxuXG4gICAgU2l6emxlID0gaW5pdGlhbGl6ZVNpenpsZSgpOyAvLyBBZGQgOm1hdGNoZXMtY3NzLSooKSBzdXBwb3J0XG5cbiAgICBTdHlsZVByb3BlcnR5TWF0Y2hlci5leHRlbmRTaXp6bGUoU2l6emxlKTsgLy8gQWRkIDptYXRjaGVzLWF0dHIoKSBzdXBwb3J0XG5cbiAgICBBdHRyaWJ1dGVzTWF0Y2hlci5leHRlbmRTaXp6bGUoU2l6emxlKTsgLy8gQWRkIDptYXRjaGVzLXByb3BlcnR5KCkgc3VwcG9ydFxuXG4gICAgRWxlbWVudFByb3BlcnR5TWF0Y2hlci5leHRlbmRTaXp6bGUoU2l6emxlKTsgLy8gQWRkIDppcygpIHN1cHBvcnRcblxuICAgIElzQW55TWF0Y2hlci5leHRlbmRTaXp6bGUoU2l6emxlKTsgLy8gQWRkIDpjb250YWlucywgOmhhcy10ZXh0LCA6LWFicC1jb250YWlucyBzdXBwb3J0XG5cbiAgICB2YXIgY29udGFpbnNQc2V1ZG8gPSBTaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAodGV4dCkge1xuICAgICAgaWYgKC9eXFxzKlxcLy4qXFwvW2dtaXN1eV0qXFxzKiQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICAgICAgICB2YXIgZmxhZ3NJbmRleCA9IHRleHQubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgdmFyIGZsYWdzID0gdGV4dC5zdWJzdHJpbmcoZmxhZ3NJbmRleCArIDEpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgZmxhZ3NJbmRleCArIDEpLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcKFtcXFxcXCJdKS9nLCAnJDEnKTtcbiAgICAgICAgdmFyIHJlZ2V4O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHRleHQsIGZsYWdzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOmNvbnRhaW5zIHBzZXVkbyBjbGFzczogXCIuY29uY2F0KHRleHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIHZhciBlbGVtVGV4dENvbnRlbnQgPSB1dGlscy5ub2RlVGV4dENvbnRlbnRHZXR0ZXIuYXBwbHkoZWxlbSk7XG4gICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoZWxlbVRleHRDb250ZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxcXChbXFxcXCgpW1xcXVwiXSkvZywgJyQxJyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgdmFyIGVsZW1UZXh0Q29udGVudCA9IHV0aWxzLm5vZGVUZXh0Q29udGVudEdldHRlci5hcHBseShlbGVtKTtcbiAgICAgICAgcmV0dXJuIGVsZW1UZXh0Q29udGVudC5pbmRleE9mKHRleHQpID4gLTE7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snY29udGFpbnMnXSA9IGNvbnRhaW5zUHNldWRvO1xuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snaGFzLXRleHQnXSA9IGNvbnRhaW5zUHNldWRvO1xuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snLWFicC1jb250YWlucyddID0gY29udGFpbnNQc2V1ZG87IC8vIEFkZCA6aWYsIDotYWJwLWhhcyBzdXBwb3J0XG5cbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ2lmJ10gPSBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ2hhcyddO1xuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snLWFicC1oYXMnXSA9IFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snaGFzJ107IC8vIEFkZCA6aWYtbm90IHN1cHBvcnRcblxuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snaWYtbm90J10gPSBTaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIFNpenpsZS5jb21waWxlKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBTaXp6bGUoc2VsZWN0b3IsIGVsZW0pLmxlbmd0aCA9PT0gMDtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmVnaXN0ZXJQYXJzZXJPbmx5VG9rZW5zKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdHJhdGUgY3VzdG9tIHRva2VucyBmb3IgcGFyc2VyLlxuICAgKiBOZWVkZWQgZm9yIHByb3BlciB3b3JrIG9mIHBzZXVkb3M6XG4gICAqIGZvciBjaGVja2luZyBpZiB0aGUgdG9rZW4gaXMgbGFzdCBhbmQgcHNldWRvLWNsYXNzIGFyZ3VtZW50cyB2YWxpZGF0aW9uXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJQYXJzZXJPbmx5VG9rZW5zKCkge1xuICAgIFNpenpsZS5zZWxlY3RvcnMucHNldWRvc1sneHBhdGgnXSA9IFNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRXhwcmVzc2lvbihzZWxlY3RvciwgbnVsbCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOnhwYXRoIHBzZXVkbyBjbGFzczogXCIuY29uY2F0KHNlbGVjdG9yKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ250aC1hbmNlc3RvciddID0gU2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZGVlcCA9IE51bWJlcihzZWxlY3Rvcik7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZGVlcCkgfHwgZGVlcCA8IDEgfHwgZGVlcCA+PSAyNTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6bnRoLWFuY2VzdG9yIHBzZXVkbyBjbGFzczogXCIuY29uY2F0KHNlbGVjdG9yKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ3Vwd2FyZCddID0gU2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOnVwd2FyZCBwc2V1ZG8gY2xhc3M6IFwiLmNvbmNhdChpbnB1dCkpO1xuICAgICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKCtpbnB1dCkgJiYgKCtpbnB1dCA8IDEgfHwgK2lucHV0ID49IDI1NikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6dXB3YXJkIHBzZXVkbyBjbGFzczogXCIuY29uY2F0KGlucHV0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ3JlbW92ZSddID0gU2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQgIT09ICcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOnJlbW92ZSBwc2V1ZG8gY2xhc3M6IFwiLmNvbmNhdChpbnB1dCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgdG9rZW4gY2FuIGJlIHVzZWQgYnkgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1NpbXBsZVRva2VuKHRva2VuKSB7XG4gICAgdmFyIHR5cGUgPSB0b2tlbi50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdJRCcgfHwgdHlwZSA9PT0gJ0NMQVNTJyB8fCB0eXBlID09PSAnQVRUUicgfHwgdHlwZSA9PT0gJ1RBRycgfHwgdHlwZSA9PT0gJ0NISUxEJykge1xuICAgICAgLy8ga25vd24gc2ltcGxlIHRva2Vuc1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdQU0VVRE8nKSB7XG4gICAgICAvLyBjaGVjayBpZiB2YWx1ZSBjb250YWlucyBhbnkgb2YgZXh0ZW5kZWQgcHNldWRvIGNsYXNzZXNcbiAgICAgIHZhciBpID0gUFNFVURPX0VYVEVOU0lPTlNfTUFSS0VSUy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKHRva2VuLnZhbHVlLmluZGV4T2YoUFNFVURPX0VYVEVOU0lPTlNfTUFSS0VSU1tpXSkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIGFsbCBvdGhlcnMgYXJlbid0IHNpbXBsZVxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzcGVjaWZpZWQgdG9rZW4gaXMgYSBjb21iaW5hdG9yXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNSZWxhdGlvblRva2VuKHRva2VuKSB7XG4gICAgdmFyIHR5cGUgPSB0b2tlbi50eXBlO1xuICAgIHJldHVybiB0eXBlID09PSAnICcgfHwgdHlwZSA9PT0gJz4nIHx8IHR5cGUgPT09ICcrJyB8fCB0eXBlID09PSAnfic7XG4gIH1cbiAgLyoqXG4gICAqIEV4dGVuZGVkU2VsZWN0b3JQYXJzZXIgaXMgYSBoZWxwZXIgY2xhc3MgZm9yIGNyZWF0aW5nIHZhcmlvdXMgc2VsZWN0b3IgaW5zdGFuY2VzIHdoaWNoXG4gICAqIGFsbCBzaGFyZXMgYSBtZXRob2QgYHF1ZXJ5U2VsZWN0b3JBbGwoKWAgYW5kIGBtYXRjaGVzKClgIGltcGxlbWVudGluZyBkaWZmZXJlbnQgc2VhcmNoIHN0cmF0ZWdpZXNcbiAgICogZGVwZW5kaW5nIG9uIGEgdHlwZSBvZiBzZWxlY3Rvci5cbiAgICpcbiAgICogQ3VycmVudGx5LCB0aGVyZSBhcmUgMyB0eXBlczpcbiAgICogIEEgdHJhaXQtbGVzcyBleHRlbmRlZCBzZWxlY3RvclxuICAgKiAgICAtIHdlIGRpcmVjdGx5IGZlZWQgc2VsZWN0b3Igc3RyaW5ncyB0byBTaXp6bGUuXG4gICAqICBBIHNwbGl0dGVkIGV4dGVuZGVkIHNlbGVjdG9yXG4gICAqICAgIC0gc3VjaCBhcyAjY29udGFpbmVyICNmZWVkSXRlbTpoYXMoLmFkcyksIHdoZXJlIGl0IGlzIHNwbGl0dGVkIHRvIGAjY29udGFpbmVyYCBhbmQgYCNmZWVkSXRlbTpoYXMoLmFkcylgLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIEV4dGVuZGVkU2VsZWN0b3JQYXJzZXIoc2VsZWN0b3JUZXh0LCB0b2tlbnMsIGRlYnVnKSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IGNzc1V0aWxzLm5vcm1hbGl6ZShzZWxlY3RvclRleHQpOyAvLyBQYXNzaW5nIGByZXR1cm5VbnNvcnRlZGAgaW4gb3JkZXIgdG8gcmVjZWl2ZSB0b2tlbnMgaW4gdGhlIG9yZGVyIHRoYXQncyB2YWxpZCBmb3IgdGhlIGJyb3dzZXJcbiAgICAgIC8vIEluIFNpenpsZSBpbnRlcm5hbGx5LCB0aGUgdG9rZW5zIGFyZSByZS1zb3J0ZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9FeHRlbmRlZENzcy9pc3N1ZXMvNTVcblxuICAgICAgdGhpcy50b2tlbnMgPSBTaXp6bGUudG9rZW5pemUodGhpcy5zZWxlY3RvclRleHQsIGZhbHNlLCB7XG4gICAgICAgIHJldHVyblVuc29ydGVkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7XG4gICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICB9XG5cbiAgICBpZiAoZGVidWcgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuZGVidWcgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIEV4dGVuZGVkU2VsZWN0b3JQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIG1ldGhvZCwgY3JlYXRlcyBhIHNlbGVjdG9yIGluc3RhbmNlIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBhIHNlbGVjdG9yLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjcmVhdGVTZWxlY3RvcjogZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3IoKSB7XG4gICAgICB2YXIgZGVidWcgPSB0aGlzLmRlYnVnO1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuICAgICAgdmFyIHNlbGVjdG9yVGV4dCA9IHRoaXMuc2VsZWN0b3JUZXh0O1xuXG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAvLyBDb21tYS1zZXBhcmF0ZSBzZWxlY3RvciAtIGNhbid0IG9wdGltaXplIGZ1cnRoZXJcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFpdExlc3NTZWxlY3RvcihzZWxlY3RvclRleHQsIGRlYnVnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHhwYXRoUGFydCA9IHRoaXMuZ2V0WHBhdGhQYXJ0KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgeHBhdGhQYXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IFhwYXRoU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCB4cGF0aFBhcnQsIGRlYnVnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwd2FyZFBhcnQgPSB0aGlzLmdldFVwd2FyZFBhcnQoKTtcblxuICAgICAgaWYgKHR5cGVvZiB1cHdhcmRQYXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgb3V0cHV0O1xuICAgICAgICB2YXIgdXB3YXJkRGVlcCA9IHBhcnNlSW50KHVwd2FyZFBhcnQsIDEwKTsgLy8gaWYgdXB3YXJkIHBhcmFtZXRlciBpcyBub3QgYSBudW1iZXIsIHdlIGNvbnNpZGVyIGl0IGFzIGEgc2VsZWN0b3JcblxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHVwd2FyZERlZXApKSB7XG4gICAgICAgICAgb3V0cHV0ID0gbmV3IFVwd2FyZFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgdXB3YXJkUGFydCwgZGVidWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwd2FyZCB3b3JrcyBsaWtlIG50aC1hbmNlc3RvclxuICAgICAgICAgIHZhciB4cGF0aCA9IHRoaXMuY29udmVydE50aEFuY2VzdG9yVG9rZW4odXB3YXJkRGVlcCk7XG4gICAgICAgICAgb3V0cHV0ID0gbmV3IFhwYXRoU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCB4cGF0aCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0gLy8gYXJndW1lbnQgb2YgcHNldWRvLWNsYXNzIHJlbW92ZTtcbiAgICAgIC8vIGl0J3MgZGVmaW5lZCBvbmx5IGlmIHJlbW92ZSBpcyBwYXJzZWQgYXMgbGFzdCB0b2tlblxuICAgICAgLy8gYW5kIGl0J3MgdmFsaWQgb25seSBpZiByZW1vdmUgYXJnIGlzIGVtcHR5IHN0cmluZ1xuXG5cbiAgICAgIHZhciByZW1vdmVQYXJ0ID0gdGhpcy5nZXRSZW1vdmVQYXJ0KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVtb3ZlUGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGhhc1ZhbGlkUmVtb3ZlUGFydCA9IHJlbW92ZVBhcnQgPT09ICcnO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZVNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgaGFzVmFsaWRSZW1vdmVQYXJ0LCBkZWJ1Zyk7XG4gICAgICB9XG5cbiAgICAgIHRva2VucyA9IHRva2Vuc1swXTtcbiAgICAgIHZhciBsID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgIHZhciBsYXN0UmVsVG9rZW5JbmQgPSB0aGlzLmdldFNwbGl0UG9pbnQoKTtcblxuICAgICAgaWYgKHR5cGVvZiBsYXN0UmVsVG9rZW5JbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvclRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUcmFpdExlc3NTZWxlY3RvcihzZWxlY3RvclRleHQsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm90QW5FeHRlbmRlZFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgZGVidWcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2ltcGxlID0gJyc7XG4gICAgICB2YXIgcmVsYXRpb24gPSBudWxsO1xuICAgICAgdmFyIGNvbXBsZXggPSAnJztcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsYXN0UmVsVG9rZW5JbmQ7IGkrKykge1xuICAgICAgICAvLyBidWlsZCBzaW1wbGUgcGFydFxuICAgICAgICBzaW1wbGUgKz0gdG9rZW5zW2ldLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgLy8gYnVpbGQgcmVsYXRpb24gcGFydFxuICAgICAgICByZWxhdGlvbiA9IHRva2Vuc1tpKytdLnR5cGU7XG4gICAgICB9IC8vIGkgaXMgcG9pbnRpbmcgdG8gdGhlIHN0YXJ0IG9mIGEgY29tcGxleCBwYXJ0LlxuXG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbXBsZXggKz0gdG9rZW5zW2ldLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGFzdFJlbFRva2VuSW5kID09PSAtMSA/IG5ldyBUcmFpdExlc3NTZWxlY3RvcihzZWxlY3RvclRleHQsIGRlYnVnKSA6IG5ldyBTcGxpdHRlZFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgc2ltcGxlLCByZWxhdGlvbiwgY29tcGxleCwgZGVidWcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IEFuIGluZGV4IG9mIGEgdG9rZW4gdGhhdCBpcyBzcGxpdCBwb2ludC5cbiAgICAgKiByZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgc2VsZWN0b3IgZG9lcyBub3QgY29udGFpbiBhbnkgY29tcGxleCB0b2tlbnNcbiAgICAgKiBvciBpdCBpcyBub3QgZWxpZ2libGUgZm9yIHNwbGl0dGluZy5cbiAgICAgKiBPdGhlcndpc2UgcmV0dXJucyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHJlbGF0aW9uIHRva2VuLlxuICAgICAqL1xuICAgIGdldFNwbGl0UG9pbnQ6IGZ1bmN0aW9uIGdldFNwbGl0UG9pbnQoKSB7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnNbMF07IC8vIFdlIHNwbGl0IHNlbGVjdG9yIG9ubHkgd2hlbiB0aGUgbGFzdCBjb21wb3VuZCBzZWxlY3RvclxuICAgICAgLy8gaXMgdGhlIG9ubHkgZXh0ZW5kZWQgc2VsZWN0b3IuXG5cbiAgICAgIHZhciBsYXRlc3RSZWxhdGlvblRva2VuSW5kZXggPSAtMTtcbiAgICAgIHZhciBoYXZlTWV0Q29tcGxleFRva2VuID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKGlzUmVsYXRpb25Ub2tlbih0b2tlbikpIHtcbiAgICAgICAgICBpZiAoaGF2ZU1ldENvbXBsZXhUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhdGVzdFJlbGF0aW9uVG9rZW5JbmRleCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU2ltcGxlVG9rZW4odG9rZW4pKSB7XG4gICAgICAgICAgaGF2ZU1ldENvbXBsZXhUb2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXZlTWV0Q29tcGxleFRva2VuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhdGVzdFJlbGF0aW9uVG9rZW5JbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSB4cGF0aCBzZWxlY3RvciBwYXJ0IGlmIGV4aXN0c1xuICAgICAqIHJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBzZWxlY3RvciBkb2VzIG5vdCBjb250YWluIHhwYXRoIHRva2Vuc1xuICAgICAqL1xuICAgIGdldFhwYXRoUGFydDogZnVuY3Rpb24gZ2V0WHBhdGhQYXJ0KCkge1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgdG9rZW5zTGVuZ3RoID0gdG9rZW5zLmxlbmd0aDsgaSA8IHRva2Vuc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ1BTRVVETycpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRva2VuLm1hdGNoZXM7XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzWzBdID09PSAneHBhdGgnKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzTGFzdFRva2VuKHRva2VucywgaSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHNldWRvOiBcXCc6eHBhdGhcXCcgc2hvdWxkIGJlIGF0IHRoZSBlbmQgb2YgdGhlIHNlbGVjdG9yJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoZXNbMF0gPT09ICdudGgtYW5jZXN0b3InKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzTGFzdFRva2VuKHRva2VucywgaSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHNldWRvOiBcXCc6bnRoLWFuY2VzdG9yXFwnIHNob3VsZCBiZSBhdCB0aGUgZW5kIG9mIHRoZSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGRlZXAgPSBtYXRjaGVzWzFdO1xuXG4gICAgICAgICAgICAgIGlmIChkZWVwID4gMCAmJiBkZWVwIDwgMjU2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydE50aEFuY2VzdG9yVG9rZW4oZGVlcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgbnRoLWFuY2VzdG9yL3Vwd2FyZCBkZWVwIHZhbHVlIHRvIHhwYXRoIGVxdWl2YWxlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVlcFxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBjb252ZXJ0TnRoQW5jZXN0b3JUb2tlbjogZnVuY3Rpb24gY29udmVydE50aEFuY2VzdG9yVG9rZW4oZGVlcCkge1xuICAgICAgdmFyIHJlc3VsdCA9ICcuLic7XG5cbiAgICAgIHdoaWxlIChkZWVwID4gMSkge1xuICAgICAgICByZXN1bHQgKz0gJy8uLic7XG4gICAgICAgIGRlZXAtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB0b2tlbiBpcyBsYXN0LFxuICAgICAqIGV4Y2VwdCBvZiByZW1vdmUgcHNldWRvLWNsYXNzXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgaW5kZXggb2YgdG9rZW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0xhc3RUb2tlbjogZnVuY3Rpb24gaXNMYXN0VG9rZW4odG9rZW5zLCBpKSB7XG4gICAgICAvLyBjaGVjayBpZCB0aGUgbmV4dCBwYXJzZWQgdG9rZW4gaXMgcmVtb3ZlIHBzZXVkb1xuICAgICAgdmFyIGlzTmV4dFJlbW92ZVRva2VuID0gdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICdQU0VVRE8nICYmIHRva2Vuc1tpICsgMV0ubWF0Y2hlcyAmJiB0b2tlbnNbaSArIDFdLm1hdGNoZXNbMF0gPT09ICdyZW1vdmUnOyAvLyBjaGVjayBpZiB0aGUgdG9rZW4gaXMgbGFzdFxuICAgICAgLy8gYW5kIGlmIGl0IGlzIG5vdCBjaGVjayBpZiBpdCBpcyByZW1vdmUgb25lXG4gICAgICAvLyB3aGljaCBzaG91bGQgYmUgc2tpcHBlZFxuXG4gICAgICByZXR1cm4gaSArIDEgIT09IHRva2Vucy5sZW5ndGggJiYgIWlzTmV4dFJlbW92ZVRva2VuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IHVwd2FyZCBwYXJhbWV0ZXJcbiAgICAgKiBvciB1bmRlZmluZWQgaWYgdGhlIGlucHV0IGRvZXMgbm90IGNvbnRhaW4gdXB3YXJkIHRva2Vuc1xuICAgICAqL1xuICAgIGdldFVwd2FyZFBhcnQ6IGZ1bmN0aW9uIGdldFVwd2FyZFBhcnQoKSB7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnNbMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoOyBpIDwgdG9rZW5zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnUFNFVURPJykge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gdG9rZW4ubWF0Y2hlcztcblxuICAgICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNbMF0gPT09ICd1cHdhcmQnKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzTGFzdFRva2VuKHRva2VucywgaSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHNldWRvOiBcXCc6dXB3YXJkXFwnIHNob3VsZCBiZSBhdCB0aGUgZW5kIG9mIHRoZSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gcmVtb3ZlIHBhcmFtZXRlclxuICAgICAqIG9yIHVuZGVmaW5lZCBpZiB0aGUgaW5wdXQgZG9lcyBub3QgY29udGFpbiByZW1vdmUgdG9rZW5zXG4gICAgICovXG4gICAgZ2V0UmVtb3ZlUGFydDogZnVuY3Rpb24gZ2V0UmVtb3ZlUGFydCgpIHtcbiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2Vuc1swXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHRva2Vuc0xlbmd0aCA9IHRva2Vucy5sZW5ndGg7IGkgPCB0b2tlbnNMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdQU0VVRE8nKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSB0b2tlbi5tYXRjaGVzO1xuXG4gICAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlc1swXSA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgICAgaWYgKGkgKyAxICE9PSB0b2tlbnNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHNldWRvOiBcXCc6cmVtb3ZlXFwnIHNob3VsZCBiZSBhdCB0aGUgZW5kIG9mIHRoZSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZ2xvYmFsRGVidWdnaW5nRmxhZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGlzRGVidWdnaW5nKCkge1xuICAgIHJldHVybiBnbG9iYWxEZWJ1Z2dpbmdGbGFnIHx8IHRoaXMuZGVidWc7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIHNlbGVjdG9yIHdoaWNoIGlzIG5vdCBhbiBleHRlbmRlZCBzZWxlY3Rvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yVGV4dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWJ1Z1xuICAgKiBAZmluYWxcbiAgICovXG5cblxuICBmdW5jdGlvbiBOb3RBbkV4dGVuZGVkU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBkZWJ1Zykge1xuICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0O1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcbiAgfVxuXG4gIE5vdEFuRXh0ZW5kZWRTZWxlY3Rvci5wcm90b3R5cGUgPSB7XG4gICAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbCgpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3JUZXh0KTtcbiAgICB9LFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRbdXRpbHMubWF0Y2hlc1Byb3BlcnR5TmFtZV0odGhpcy5zZWxlY3RvclRleHQpO1xuICAgIH0sXG4gICAgaXNEZWJ1Z2dpbmc6IGlzRGVidWdnaW5nXG4gIH07XG4gIC8qKlxuICAgKiBBIHRyYWl0LWxlc3MgZXh0ZW5kZWQgc2VsZWN0b3IgY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclRleHRcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZGVidWdcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFRyYWl0TGVzc1NlbGVjdG9yKHNlbGVjdG9yVGV4dCwgZGVidWcpIHtcbiAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDtcbiAgICB0aGlzLmRlYnVnID0gZGVidWc7XG4gICAgU2l6emxlLmNvbXBpbGUoc2VsZWN0b3JUZXh0KTtcbiAgfVxuXG4gIFRyYWl0TGVzc1NlbGVjdG9yLnByb3RvdHlwZSA9IHtcbiAgICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKCkge1xuICAgICAgcmV0dXJuIFNpenpsZSh0aGlzLnNlbGVjdG9yVGV4dCk7XG4gICAgfSxcblxuICAgIC8qKiBAZmluYWwgKi9cbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yKGVsZW1lbnQsIHRoaXMuc2VsZWN0b3JUZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqIEBmaW5hbCAqL1xuICAgIGlzRGVidWdnaW5nOiBpc0RlYnVnZ2luZ1xuICB9O1xuICAvKipcbiAgICogUGFyZW50YWwgY2xhc3MgZm9yIHN1Y2ggcHNldWRvLWNsYXNzZXMgYXMgeHBhdGgsIHVwd2FyZCwgcmVtb3ZlXG4gICAqIHdoaWNoIGFyZSBsaW1pdGVkIHRvIGJlIHRoZSBsYXN0IG9uZSB0b2tlbiBpbiBzZWxlY3RvclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwc2V1ZG9DbGFzc0FyZyBwc2V1ZG8tY2xhc3MgYXJnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlYnVnXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBwc2V1ZG9DbGFzc0FyZywgZGVidWcpIHtcbiAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDtcbiAgICB0aGlzLnBzZXVkb0NsYXNzQXJnID0gcHNldWRvQ2xhc3NBcmc7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgIFNpenpsZS5jb21waWxlKHRoaXMuc2VsZWN0b3JUZXh0KTtcbiAgfVxuXG4gIEJhc2VMYXN0QXJndW1lbnRTZWxlY3Rvci5wcm90b3R5cGUgPSB7XG4gICAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciByZXN1bHROb2RlcyA9IFtdO1xuICAgICAgdmFyIHNpbXBsZU5vZGVzO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3RvclRleHQpIHtcbiAgICAgICAgc2ltcGxlTm9kZXMgPSBTaXp6bGUodGhpcy5zZWxlY3RvclRleHQpO1xuXG4gICAgICAgIGlmICghc2ltcGxlTm9kZXMgfHwgIXNpbXBsZU5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHROb2RlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2ltcGxlTm9kZXMgPSBbZG9jdW1lbnRdO1xuICAgICAgfVxuXG4gICAgICBzaW1wbGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIF90aGlzLnNlYXJjaFJlc3VsdE5vZGVzKG5vZGUsIF90aGlzLnBzZXVkb0NsYXNzQXJnLCByZXN1bHROb2Rlcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBTaXp6bGUudW5pcXVlU29ydChyZXN1bHROb2Rlcyk7XG4gICAgfSxcblxuICAgIC8qKiBAZmluYWwgKi9cbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5pbmRleE9mKGVsZW1lbnQpID4gLTE7XG4gICAgfSxcblxuICAgIC8qKiBAZmluYWwgKi9cbiAgICBpc0RlYnVnZ2luZzogaXNEZWJ1Z2dpbmcsXG5cbiAgICAvKipcbiAgICAgKiBQcmltaXRpdmUgbWV0aG9kIHRoYXQgcmV0dXJucyBhbGwgbm9kZXMgaWYgcHNldWRvLWNsYXNzIGFyZyBpcyBkZWZpbmVkLlxuICAgICAqIFRoYXQgbG9naWMgd29ya3MgZm9yIHJlbW92ZSBwc2V1ZG8tY2xhc3MsXG4gICAgICogYnV0IGZvciBvdGhlcnMgaXQgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgY29udGV4dCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBzZXVkb0NsYXNzQXJnIHBzZXVkby1jbGFzcyBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdFxuICAgICAqL1xuICAgIHNlYXJjaFJlc3VsdE5vZGVzOiBmdW5jdGlvbiBzZWFyY2hSZXN1bHROb2Rlcyhub2RlLCBwc2V1ZG9DbGFzc0FyZywgcmVzdWx0KSB7XG4gICAgICBpZiAocHNldWRvQ2xhc3NBcmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogWHBhdGggc2VsZWN0b3IgY2xhc3NcbiAgICogTGltaXRlZCB0byBzdXBwb3J0ICd4cGF0aCcgdG8gYmUgb25seSB0aGUgbGFzdCBvbmUgdG9rZW4gaW4gc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yVGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30geHBhdGggdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZGVidWdcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhdWdtZW50cyBCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gWHBhdGhTZWxlY3RvcihzZWxlY3RvclRleHQsIHhwYXRoLCBkZWJ1Zykge1xuICAgIHZhciBOT19TRUxFQ1RPUl9NQVJLRVIgPSAnOnhwYXRoKC8vJztcbiAgICB2YXIgQk9EWV9TRUxFQ1RPUl9SRVBMQUNFUiA9ICdib2R5OnhwYXRoKC8vJztcbiAgICB2YXIgbW9kaWZpZWRTZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7IC8vIE5vcm1hbGx5LCBhIHBzZXVkby1jbGFzcyBpcyBhcHBsaWVkIHRvIG5vZGVzIHNlbGVjdGVkIGJ5IGEgc2VsZWN0b3IgLS0gc2VsZWN0b3I6eHBhdGgoLi4uKS5cbiAgICAvLyBIb3dldmVyLCA6eHBhdGggaXMgc3BlY2lhbCBhcyB0aGUgc2VsZWN0b3IgY2FuIGJlIG9tbWl0ZWQuXG4gICAgLy8gRm9yIGFueSBvdGhlciBwc2V1ZG8tY2xhc3MgdGhhdCB3b3VsZCBtZWFuIFwiYXBwbHkgdG8gQUxMIERPTSBub2Rlc1wiLFxuICAgIC8vIGJ1dCBpbiBjYXNlIG9mIDp4cGF0aCBpdCBqdXN0IG1lYW5zIFwiYXBwbHkgbWUgdG8gdGhlIGRvY3VtZW50XCIuXG5cbiAgICBpZiAodXRpbHMuc3RhcnRzV2l0aChzZWxlY3RvclRleHQsIE5PX1NFTEVDVE9SX01BUktFUikpIHtcbiAgICAgIG1vZGlmaWVkU2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0LnJlcGxhY2UoTk9fU0VMRUNUT1JfTUFSS0VSLCBCT0RZX1NFTEVDVE9SX1JFUExBQ0VSKTtcbiAgICB9XG5cbiAgICBCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3IuY2FsbCh0aGlzLCBtb2RpZmllZFNlbGVjdG9yVGV4dCwgeHBhdGgsIGRlYnVnKTtcbiAgfVxuXG4gIFhwYXRoU2VsZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3IucHJvdG90eXBlKTtcbiAgWHBhdGhTZWxlY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYcGF0aFNlbGVjdG9yO1xuICAvKipcbiAgICogQXBwbGllcyB4cGF0aCBwc2V1ZG8tY2xhc3MgdG8gcHJvdmlkZWQgY29udGV4dCBub2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGNvbnRleHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHNldWRvQ2xhc3NBcmcgeHBhdGhcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzdWx0XG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuICBYcGF0aFNlbGVjdG9yLnByb3RvdHlwZS5zZWFyY2hSZXN1bHROb2RlcyA9IGZ1bmN0aW9uIChub2RlLCBwc2V1ZG9DbGFzc0FyZywgcmVzdWx0KSB7XG4gICAgdmFyIHhwYXRoUmVzdWx0ID0gZG9jdW1lbnQuZXZhbHVhdGUocHNldWRvQ2xhc3NBcmcsIG5vZGUsIG51bGwsIFhQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX0lURVJBVE9SX1RZUEUsIG51bGwpO1xuICAgIHZhciBpTm9kZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG5cbiAgICB3aGlsZSAoaU5vZGUgPSB4cGF0aFJlc3VsdC5pdGVyYXRlTmV4dCgpKSB7XG4gICAgICByZXN1bHQucHVzaChpTm9kZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogVXB3YXJkIHNlbGVjdG9yIGNsYXNzXG4gICAqIExpbWl0ZWQgdG8gc3VwcG9ydCAndXB3YXJkJyB0byBiZSBvbmx5IHRoZSBsYXN0IG9uZSB0b2tlbiBpbiBzZWxlY3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cHdhcmRTZWxlY3RvciB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWJ1Z1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGF1Z21lbnRzIEJhc2VMYXN0QXJndW1lbnRTZWxlY3RvclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFVwd2FyZFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgdXB3YXJkU2VsZWN0b3IsIGRlYnVnKSB7XG4gICAgQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yLmNhbGwodGhpcywgc2VsZWN0b3JUZXh0LCB1cHdhcmRTZWxlY3RvciwgZGVidWcpO1xuICB9XG5cbiAgVXB3YXJkU2VsZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3IucHJvdG90eXBlKTtcbiAgVXB3YXJkU2VsZWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVXB3YXJkU2VsZWN0b3I7XG4gIC8qKlxuICAgKiBBcHBsaWVzIHVwd2FyZCBwc2V1ZG8tY2xhc3MgdG8gcHJvdmlkZWQgY29udGV4dCBub2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGNvbnRleHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXB3YXJkU2VsZWN0b3IgdXB3YXJkIHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cbiAgVXB3YXJkU2VsZWN0b3IucHJvdG90eXBlLnNlYXJjaFJlc3VsdE5vZGVzID0gZnVuY3Rpb24gKG5vZGUsIHVwd2FyZFNlbGVjdG9yLCByZXN1bHQpIHtcbiAgICBpZiAodXB3YXJkU2VsZWN0b3IgIT09ICcnKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuXG4gICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHBhcmVudC5jbG9zZXN0KHVwd2FyZFNlbGVjdG9yKTtcblxuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICB9O1xuICAvKipcbiAgICogUmVtb3ZlIHNlbGVjdG9yIGNsYXNzXG4gICAqIExpbWl0ZWQgdG8gc3VwcG9ydCAncmVtb3ZlJyB0byBiZSBvbmx5IHRoZSBsYXN0IG9uZSB0b2tlbiBpbiBzZWxlY3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JUZXh0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzVmFsaWRSZW1vdmVQYXJ0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlYnVnXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAYXVnbWVudHMgQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gUmVtb3ZlU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBoYXNWYWxpZFJlbW92ZVBhcnQsIGRlYnVnKSB7XG4gICAgdmFyIFJFTU9WRV9QU0VVRE9fTUFSS0VSID0gJzpyZW1vdmUoKSc7XG4gICAgdmFyIHJlbW92ZU1hcmtlckluZGV4ID0gc2VsZWN0b3JUZXh0LmluZGV4T2YoUkVNT1ZFX1BTRVVET19NQVJLRVIpOyAvLyBkZWxldGluZyByZW1vdmUgcGFydCBvZiBydWxlIGluc3RlYWQgb2Ygd2hpY2hcbiAgICAvLyBwc2V1ZG8tcHJvcGVydHkgcHJvcGVydHkgJ3JlbW92ZScgd2lsbCBiZSBhZGRlZCBieSBFeHRlbmRlZENzc1BhcnNlclxuXG4gICAgdmFyIG1vZGlmaWVkU2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0LnNsaWNlKDAsIHJlbW92ZU1hcmtlckluZGV4KTtcbiAgICBCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3IuY2FsbCh0aGlzLCBtb2RpZmllZFNlbGVjdG9yVGV4dCwgaGFzVmFsaWRSZW1vdmVQYXJ0LCBkZWJ1Zyk7IC8vIG1hcmsgZXh0ZW5kZWRTZWxlY3RvciBhcyBSZW1vdmUgb25lIGZvciBFeHRlbmRlZENzc1BhcnNlclxuXG4gICAgdGhpcy5pc1JlbW92ZVNlbGVjdG9yID0gdHJ1ZTtcbiAgfVxuXG4gIFJlbW92ZVNlbGVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yLnByb3RvdHlwZSk7XG4gIFJlbW92ZVNlbGVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlbW92ZVNlbGVjdG9yO1xuICAvKipcbiAgICogQSBzcGxpdHRlZCBleHRlbmRlZCBzZWxlY3RvciBjbGFzcy5cbiAgICpcbiAgICogI2NvbnRhaW5lciAjZmVlZEl0ZW06aGFzKC5hZHMpXG4gICAqICstLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICBzaW1wbGVcbiAgICogICAgICAgICAgICsgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uXG4gICAqICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyBjb21wbGV4XG4gICAqIFdlIHNwbGl0IHNlbGVjdG9yIG9ubHkgd2hlbiB0aGUgbGFzdCBzZWxlY3RvciBpcyBjb21wbGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNpbXBsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbXBsZXhcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZGVidWdcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIFRyYWl0TGVzc1NlbGVjdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFNwbGl0dGVkU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBzaW1wbGUsIHJlbGF0aW9uLCBjb21wbGV4LCBkZWJ1Zykge1xuICAgIFRyYWl0TGVzc1NlbGVjdG9yLmNhbGwodGhpcywgc2VsZWN0b3JUZXh0LCBkZWJ1Zyk7XG4gICAgdGhpcy5zaW1wbGUgPSBzaW1wbGU7XG4gICAgdGhpcy5yZWxhdGlvbiA9IHJlbGF0aW9uO1xuICAgIHRoaXMuY29tcGxleCA9IGNvbXBsZXg7XG4gICAgU2l6emxlLmNvbXBpbGUoY29tcGxleCk7XG4gIH1cblxuICBTcGxpdHRlZFNlbGVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhaXRMZXNzU2VsZWN0b3IucHJvdG90eXBlKTtcbiAgU3BsaXR0ZWRTZWxlY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGxpdHRlZFNlbGVjdG9yO1xuICAvKiogQG92ZXJyaWRlICovXG5cbiAgU3BsaXR0ZWRTZWxlY3Rvci5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciByZXN1bHROb2RlcyA9IFtdO1xuICAgIHZhciBzaW1wbGVOb2RlcztcbiAgICB2YXIgc2ltcGxlID0gdGhpcy5zaW1wbGU7XG4gICAgdmFyIHJlbGF0aW9uO1xuXG4gICAgaWYgKHNpbXBsZSkge1xuICAgICAgLy8gRmlyc3Qgd2UgdXNlIHNpbXBsZSBzZWxlY3RvciB0byBuYXJyb3cgb3VyIHNlYXJjaFxuICAgICAgc2ltcGxlTm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNpbXBsZSk7XG5cbiAgICAgIGlmICghc2ltcGxlTm9kZXMgfHwgIXNpbXBsZU5vZGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0Tm9kZXM7XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aW9uID0gdGhpcy5yZWxhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2ltcGxlTm9kZXMgPSBbZG9jdW1lbnRdO1xuICAgICAgcmVsYXRpb24gPSAnICc7XG4gICAgfVxuXG4gICAgc3dpdGNoIChyZWxhdGlvbikge1xuICAgICAgY2FzZSAnICc6XG4gICAgICAgIHNpbXBsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBfdGhpczIucmVsYXRpdmVTZWFyY2gobm9kZSwgcmVzdWx0Tm9kZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICB7XG4gICAgICAgICAgc2ltcGxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhub2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzMi5tYXRjaGVzKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHROb2Rlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgICB7XG4gICAgICAgICAgc2ltcGxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHBhcmVudE5vZGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLm1hdGNoZXMoY2hpbGROb2RlKSAmJiBjaGlsZE5vZGUucHJldmlvdXNFbGVtZW50U2libGluZyA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdE5vZGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnfic6XG4gICAgICAgIHtcbiAgICAgICAgICBzaW1wbGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMocGFyZW50Tm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIubWF0Y2hlcyhjaGlsZE5vZGUpICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oY2hpbGROb2RlKSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdE5vZGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU2l6emxlLnVuaXF1ZVNvcnQocmVzdWx0Tm9kZXMpO1xuICB9O1xuICAvKipcbiAgICogUGVyZm9ybXMgYSBzZWFyY2ggb2YgXCJjb21wbGV4XCIgcGFydCByZWxhdGl2ZSB0byByZXN1bHRzIGZvciB0aGUgXCJzaW1wbGVcIiBwYXJ0LlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgYSBub2RlIG1hdGNoaW5nIHRoZSBcInNpbXBsZVwiIHBhcnQuXG4gICAqIEBwYXJhbSB7Tm9kZVtdfSByZXN1bHQgYW4gYXJyYXkgdG8gYXBwZW5kIHNlYXJjaCByZXN1bHQuXG4gICAqL1xuXG5cbiAgU3BsaXR0ZWRTZWxlY3Rvci5wcm90b3R5cGUucmVsYXRpdmVTZWFyY2ggPSBmdW5jdGlvbiAobm9kZSwgcmVzdWx0cykge1xuICAgIFNpenpsZSh0aGlzLmNvbXBsZXgsIG5vZGUsIHJlc3VsdHMpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogV3JhcHMgdGhlIGlubmVyIGNsYXNzIHNvIHRoYXQgdGhlIGluc3RhbmNlIGlzIG5vdCBleHBvc2VkLlxuICAgICAqL1xuICAgIGNyZWF0ZVNlbGVjdG9yOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvcihzZWxlY3RvciwgdG9rZW5zLCBkZWJ1Zykge1xuICAgICAgcmV0dXJuIG5ldyBFeHRlbmRlZFNlbGVjdG9yUGFyc2VyKHNlbGVjdG9yLCB0b2tlbnMsIGRlYnVnKS5jcmVhdGVTZWxlY3RvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYXJrIGV2ZXJ5IHNlbGVjdG9yIGFzIGEgc2VsZWN0b3IgYmVpbmcgZGVidWdnZWQsIHNvIHRoYXQgdGltaW5nIGluZm9ybWF0aW9uXG4gICAgICogZm9yIHRoZSBzZWxlY3RvciBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlLlxuICAgICAqL1xuICAgIGVuYWJsZUdsb2JhbERlYnVnZ2luZzogZnVuY3Rpb24gZW5hYmxlR2xvYmFsRGVidWdnaW5nKCkge1xuICAgICAgZ2xvYmFsRGVidWdnaW5nRmxhZyA9IHRydWU7XG4gICAgfVxuICB9O1xufSgpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEFkZ3VhcmQgU29mdHdhcmUgTHRkXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdGhhdCBwYXJzZXMgc3R5bGVzaGVldHMgY29udGFpbmluZyBleHRlbmRlZCBzZWxlY3RvcnNcbiAqIGludG8gRXh0ZW5kZWRTZWxlY3RvciBpbnN0YW5jZXMgYW5kIGtleS12YWx1ZSBtYXBzIG9mIHN0eWxlIGRlY2xhcmF0aW9ucy5cbiAqIFBsZWFzZSBub3RlLCB0aGF0IGl0IGRvZXMgbm90IHN1cHBvcnQgYW55IGNvbXBsZXggdGhpbmdzIGxpa2UgbWVkaWEgcXVlcmllcyBhbmQgc3VjaC5cbiAqL1xuXG52YXIgRXh0ZW5kZWRDc3NQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZURlY2xFbmQgPSAvWzt9XS9nO1xuICB2YXIgcmVEZWNsRGl2aWRlciA9IC9bOzp9XS9nO1xuICB2YXIgcmVOb25XaGl0ZXNwYWNlID0gL1xcUy9nO1xuICB2YXIgU2l6emxlO1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFBhcnNlcihjc3NUZXh0KSB7XG4gICAgdGhpcy5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgfVxuXG4gIFBhcnNlci5wcm90b3R5cGUgPSB7XG4gICAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKHBvc2l0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDc3NQYXJzZXI6IHBhcnNlIGVycm9yIGF0IHBvc2l0aW9uIFwiLmNvbmNhdCh0aGlzLnBvc09mZnNldCArIHBvc2l0aW9uKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSB0b2tlbnMgY29ycmVzcG9uZCB0byBhIHZhbGlkIHNlbGVjdG9yLlxuICAgICAqIFNpenpsZSBpcyBkaWZmZXJlbnQgZnJvbSBicm93c2VycyBhbmQgc29tZSBzZWxlY3RvcnMgdGhhdCBpdCB0b2xlcmF0ZXMgYXJlbid0IGFjdHVhbGx5IHZhbGlkLlxuICAgICAqIEZvciBpbnN0YW5jZSwgXCJkaXYgPlwiIHdvbid0IHdvcmsgaW4gYSBicm93c2VyLCBidXQgaXQgd2lsbCBpbiBTaXp6bGUgKGl0J2QgYmUgdGhlIHNhbWUgYXMgXCJkaXYgPiAqXCIpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzZWxlY3RvcnMgQW4gYXJyYXkgb2YgU2VsZWN0b3JEYXRhIChzZWxlY3RvciwgZ3JvdXBzKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIGdyb3VwcyBhcmUgaW52YWxpZFxuICAgICAqL1xuICAgIHZhbGlkYXRlU2VsZWN0b3JzOiBmdW5jdGlvbiB2YWxpZGF0ZVNlbGVjdG9ycyhzZWxlY3RvcnMpIHtcbiAgICAgIHZhciBpU2VsZWN0b3JzID0gc2VsZWN0b3JzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGlTZWxlY3RvcnMtLSkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gc2VsZWN0b3JzW2lTZWxlY3RvcnNdLmdyb3VwcztcbiAgICAgICAgdmFyIGlHcm91cHMgPSBncm91cHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpR3JvdXBzLS0pIHtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gZ3JvdXBzW2lHcm91cHNdO1xuICAgICAgICAgIHZhciBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKFNpenpsZS5zZWxlY3RvcnMucmVsYXRpdmVbbGFzdFRva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzdHlsZXNoZWV0IGFuZCByZXR1cm5zIGEgbGlzdCBvZiBwYWlycyBvZiBhbiBFeHRlbmRlZFNlbGVjdG9yIGFuZCBhIHN0eWxlcyBtYXAuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiBjYXNlIG9mIGFuIG9idmlvdXNseSBpbnZhbGlkIGlucHV0LlxuICAgICAqIElmIGFueSBvZiB0aGUgc2VsZWN0b3JzIHVzZWQgaW4gdGhlIHN0eWxlc2hlZXQgY2Fubm90IGJlIGNvbXBpbGVkIGludG8gYW4gRXh0ZW5kZWRTZWxlY3RvcixcbiAgICAgKiBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBFeHRlbmRlZFN0eWxlXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHNlbGVjdG9yIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgRXh0ZW5kZWRTZWxlY3Rvcn0gY2xhc3NcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc3R5bGVNYXAgQSBtYXAgb2Ygc3R5bGVzIHBhcnNlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5LjxFeHRlbmRlZFN0eWxlPn0gQW4gYXJyYXkgb2YgdGhlIHN0eWxlcyBwYXJzZWRcbiAgICAgKi9cbiAgICBwYXJzZUNzczogZnVuY3Rpb24gcGFyc2VDc3MoKSB7XG4gICAgICB0aGlzLnBvc09mZnNldCA9IDA7XG5cbiAgICAgIGlmICghdGhpcy5jc3NUZXh0KSB7XG4gICAgICAgIHRoaXMuZXJyb3IoMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgIHdoaWxlICh0aGlzLmNzc1RleHQpIHtcbiAgICAgICAgLy8gQXBwbHkgdG9sZXJhbnQgdG9rZW5pemF0aW9uLlxuICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSBTaXp6bGUudG9rZW5pemUodGhpcy5jc3NUZXh0LCBmYWxzZSwge1xuICAgICAgICAgIHRvbGVyYW50OiB0cnVlLFxuICAgICAgICAgIHJldHVyblVuc29ydGVkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2VsZWN0b3JEYXRhID0gcGFyc2VSZXN1bHQuc2VsZWN0b3JzO1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9IHBhcnNlUmVzdWx0Lm5leHRJbmRleDtcblxuICAgICAgICBpZiAodGhpcy5jc3NUZXh0LmNoYXJDb2RlQXQodGhpcy5uZXh0SW5kZXgpICE9PSAxMjMgfHxcbiAgICAgICAgLyogY2hhckNvZGUgb2YgJ3snICovXG4gICAgICAgICF0aGlzLnZhbGlkYXRlU2VsZWN0b3JzKHNlbGVjdG9yRGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKHRoaXMubmV4dEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dEluZGV4Kys7IC8vIE1vdmUgdGhlIHBvaW50ZXIgdG8gdGhlIHN0YXJ0IG9mIHN0eWxlIGRlY2xhcmF0aW9uLlxuXG4gICAgICAgIHZhciBzdHlsZU1hcCA9IHRoaXMucGFyc2VOZXh0U3R5bGUoKTtcbiAgICAgICAgdmFyIGRlYnVnID0gZmFsc2U7IC8vIElmIHRoZXJlIGlzIGEgc3R5bGUgcHJvcGVydHkgJ2RlYnVnJywgbWFyayB0aGUgc2VsZWN0b3JcbiAgICAgICAgLy8gYXMgYSBkZWJ1Z2dhYmxlIHNlbGVjdG9yLCBhbmQgZGVsZXRlIHRoZSBzdHlsZSBkZWNsYXJhdGlvbi5cblxuICAgICAgICB2YXIgZGVidWdQcm9wZXJ0eVZhbHVlID0gc3R5bGVNYXBbJ2RlYnVnJ107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWJ1Z1Byb3BlcnR5VmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKGRlYnVnUHJvcGVydHlWYWx1ZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIEV4dGVuZGVkU2VsZWN0b3JGYWN0b3J5LmVuYWJsZUdsb2JhbERlYnVnZ2luZygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlYnVnID0gdHJ1ZTtcbiAgICAgICAgICBkZWxldGUgc3R5bGVNYXBbJ2RlYnVnJ107XG4gICAgICAgIH0gLy8gQ3JlYXRpbmcgYW4gRXh0ZW5kZWRTZWxlY3RvciBpbnN0YW5jZSBmb3IgZXZlcnkgc2VsZWN0b3Igd2UgZ290IGZyb20gU2l6emxlLnRva2VuaXplLlxuICAgICAgICAvLyBUaGlzIGlzIHF1aXRlIGltcG9ydGFudCBhcyBTaXp6bGUgZG9lcyBhIHBvb3Igam9iIGF0IGV4ZWN1dGluZyBzZWxlY3RvcnMgbGlrZSBcInNlbGVjdG9yMSwgc2VsZWN0b3IyXCIuXG5cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGVjdG9yRGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHNlbGVjdG9yRGF0YVtpXTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW5kZWRTZWxlY3RvciA9IEV4dGVuZGVkU2VsZWN0b3JGYWN0b3J5LmNyZWF0ZVNlbGVjdG9yKGRhdGEuc2VsZWN0b3JUZXh0LCBkYXRhLmdyb3VwcywgZGVidWcpO1xuXG4gICAgICAgICAgICBpZiAoZXh0ZW5kZWRTZWxlY3Rvci5wc2V1ZG9DbGFzc0FyZyAmJiBleHRlbmRlZFNlbGVjdG9yLmlzUmVtb3ZlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgcmVtb3ZlIHBzZXVkby1jbGFzcyBpbiBydWxlLFxuICAgICAgICAgICAgICAvLyB0aGUgZWxlbWVudCB3aWxsIGJlIHJlbW92ZWQgYW5kIG5vIG90aGVyIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgICAgICAgc3R5bGVNYXBbJ3JlbW92ZSddID0gJ3RydWUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBzZWxlY3RvcjogZXh0ZW5kZWRTZWxlY3RvcixcbiAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlTWFwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdXRpbHMubG9nRXJyb3IoXCJFeHRlbmRlZENzc1BhcnNlcjogaWdub3JpbmcgaW52YWxpZCBzZWxlY3RvciBcIi5jb25jYXQoZGF0YS5zZWxlY3RvclRleHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcbiAgICBwYXJzZU5leHRTdHlsZTogZnVuY3Rpb24gcGFyc2VOZXh0U3R5bGUoKSB7XG4gICAgICB2YXIgc3R5bGVNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdmFyIGJyYWNrZXRQb3MgPSB0aGlzLnBhcnNlVW50aWxDbG9zaW5nQnJhY2tldChzdHlsZU1hcCk7IC8vIEN1dCBvdXQgbWF0Y2hlZCBwb3J0aW9uIGZyb20gY3NzVGV4dC5cblxuICAgICAgcmVOb25XaGl0ZXNwYWNlLmxhc3RJbmRleCA9IGJyYWNrZXRQb3MgKyAxO1xuICAgICAgdmFyIG1hdGNoID0gcmVOb25XaGl0ZXNwYWNlLmV4ZWModGhpcy5jc3NUZXh0KTtcblxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY3NzVGV4dCA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGVNYXA7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaFBvcyA9IG1hdGNoLmluZGV4O1xuICAgICAgdGhpcy5jc3NUZXh0ID0gdGhpcy5jc3NUZXh0LnNsaWNlKG1hdGNoUG9zKTtcbiAgICAgIHRoaXMucG9zT2Zmc2V0ICs9IG1hdGNoUG9zO1xuICAgICAgcmV0dXJuIHN0eWxlTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IGFuIGluZGV4IG9mIHRoZSBuZXh0ICd9JyBpbiBgdGhpcy5jc3NUZXh0YC5cbiAgICAgKi9cbiAgICBwYXJzZVVudGlsQ2xvc2luZ0JyYWNrZXQ6IGZ1bmN0aW9uIHBhcnNlVW50aWxDbG9zaW5nQnJhY2tldChzdHlsZU1hcCkge1xuICAgICAgLy8gRXhwZWN0cyBcIjpcIiwgXCI7XCIsIGFuZCBcIn1cIi5cbiAgICAgIHJlRGVjbERpdmlkZXIubGFzdEluZGV4ID0gdGhpcy5uZXh0SW5kZXg7XG4gICAgICB2YXIgbWF0Y2ggPSByZURlY2xEaXZpZGVyLmV4ZWModGhpcy5jc3NUZXh0KTtcblxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXJyb3IodGhpcy5uZXh0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hQb3MgPSBtYXRjaC5pbmRleDtcbiAgICAgIHZhciBtYXRjaGVkID0gbWF0Y2hbMF07XG5cbiAgICAgIGlmIChtYXRjaGVkID09PSAnfScpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoUG9zO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2hlZCA9PT0gJzonKSB7XG4gICAgICAgIHZhciBjb2xvbkluZGV4ID0gbWF0Y2hQb3M7IC8vIEV4cGVjdHMgXCI7XCIgYW5kIFwifVwiLlxuXG4gICAgICAgIHJlRGVjbEVuZC5sYXN0SW5kZXggPSBjb2xvbkluZGV4O1xuICAgICAgICBtYXRjaCA9IHJlRGVjbEVuZC5leGVjKHRoaXMuY3NzVGV4dCk7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcihjb2xvbkluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoUG9zID0gbWF0Y2guaW5kZXg7XG4gICAgICAgIG1hdGNoZWQgPSBtYXRjaFswXTsgLy8gUG9wdWxhdGVzIHRoZSBgc3R5bGVNYXBgIGtleS12YWx1ZSBtYXAuXG5cbiAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5jc3NUZXh0LnNsaWNlKHRoaXMubmV4dEluZGV4LCBjb2xvbkluZGV4KS50cmltKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY3NzVGV4dC5zbGljZShjb2xvbkluZGV4ICsgMSwgbWF0Y2hQb3MpLnRyaW0oKTtcbiAgICAgICAgc3R5bGVNYXBbcHJvcGVydHldID0gdmFsdWU7IC8vIElmIGZvdW5kIFwifVwiLCByZS1ydW4gdGhlIG91dGVyIGxvb3AuXG5cbiAgICAgICAgaWYgKG1hdGNoZWQgPT09ICd9Jykge1xuICAgICAgICAgIHJldHVybiBtYXRjaFBvcztcbiAgICAgICAgfVxuICAgICAgfSAvLyBtYXRjaFBvcyBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIG5leHQgJzsnLlxuICAgICAgLy8gSW5jcmVhc2UgJ25leHRJbmRleCcgYW5kIHJlLXJ1biB0aGUgbG9vcC5cblxuXG4gICAgICB0aGlzLm5leHRJbmRleCA9IG1hdGNoUG9zICsgMTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVW50aWxDbG9zaW5nQnJhY2tldChzdHlsZU1hcCk7IC8vIFNob3VsZCBiZSBhIHN1YmplY3Qgb2YgdGFpbC1jYWxsIG9wdGltaXphdGlvbi5cbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgcGFyc2VDc3M6IGZ1bmN0aW9uIHBhcnNlQ3NzKGNzc1RleHQpIHtcbiAgICAgIFNpenpsZSA9IGluaXRpYWxpemVTaXp6bGUoKTtcbiAgICAgIHJldHVybiBuZXcgUGFyc2VyKGNzc1V0aWxzLm5vcm1hbGl6ZShjc3NUZXh0KSkucGFyc2VDc3MoKTtcbiAgICB9XG4gIH07XG59KCk7XG5cbi8qKlxuICogVGhpcyBjYWxsYmFjayBpcyB1c2VkIHRvIGdldCBhZmZlY3RlZCBub2RlIGVsZW1lbnRzIGFuZCBoYW5kbGUgc3R5bGUgcHJvcGVydGllc1xuICogYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlbSBpZiBpdCBpcyBuZWNlc3NhcnlcbiAqIEBjYWxsYmFjayBiZWZvcmVTdHlsZUFwcGxpZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBhZmZlY3RlZEVsZW1lbnQgLSBPYmplY3QgY29udGFpbmluZyBET00gbm9kZSBhbmQgcnVsZSB0byBiZSBhcHBsaWVkXG4gKiBAcmV0dXJuIHtvYmplY3R9IGFmZmVjdGVkRWxlbWVudCAtIFNhbWUgb3IgbW9kaWZpZWQgb2JqZWN0IGNvbnRhaW5pbmcgRE9NIG5vZGUgYW5kIHJ1bGUgdG8gYmUgYXBwbGllZFxuICovXG5cbi8qKlxuICogRXh0ZW5kZWQgY3NzIGNsYXNzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWd1cmF0aW9uLnN0eWxlU2hlZXQgLSB0aGUgQ1NTIHN0eWxlc2hlZXQgdGV4dFxuICogQHBhcmFtIHtiZWZvcmVTdHlsZUFwcGxpZWR9IFtjb25maWd1cmF0aW9uLmJlZm9yZVN0eWxlQXBwbGllZF0gLSB0aGUgY2FsbGJhY2sgdGhhdCBoYW5kbGVzIGFmZmVjdGVkIGVsZW1lbnRzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBFeHRlbmRlZENzcyhjb25maWd1cmF0aW9uKSB7XG4gIGlmICghY29uZmlndXJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBpcyBub3QgcHJvdmlkZWQuJyk7XG4gIH1cblxuICB2YXIgc3R5bGVTaGVldCA9IGNvbmZpZ3VyYXRpb24uc3R5bGVTaGVldDtcbiAgdmFyIGJlZm9yZVN0eWxlQXBwbGllZCA9IGNvbmZpZ3VyYXRpb24uYmVmb3JlU3R5bGVBcHBsaWVkO1xuXG4gIGlmIChiZWZvcmVTdHlsZUFwcGxpZWQgJiYgdHlwZW9mIGJlZm9yZVN0eWxlQXBwbGllZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgY29uZmlndXJhdGlvbi4gVHlwZSBvZiAnYmVmb3JlU3R5bGVBcHBsaWVkJyBmaWVsZCBzaG91bGQgYmUgYSBmdW5jdGlvbiwgcmVjZWl2ZWQ6IFwiLmNvbmNhdChfdHlwZW9mKGJlZm9yZVN0eWxlQXBwbGllZCkpKTtcbiAgfSAvLyBXZSB1c2UgRXZlbnRUcmFja2VyIHRvIHRyYWNrIHRoZSBldmVudCB0aGF0IGlzIGxpa2VseSB0byBjYXVzZSB0aGUgbXV0YXRpb24uXG4gIC8vIFRoZSBwcm9ibGVtIGlzIHRoYXQgd2UgY2Fubm90IHVzZSBgd2luZG93LmV2ZW50YCBkaXJlY3RseSBmcm9tIHRoZSBtdXRhdGlvbiBvYnNlcnZlciBjYWxsXG4gIC8vIGFzIHdlJ3JlIG5vdCBpbiB0aGUgZXZlbnQgaGFuZGxlciBjb250ZXh0IGFueW1vcmUuXG5cblxuICB2YXIgRXZlbnRUcmFja2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZ25vcmVkRXZlbnRUeXBlcyA9IFsnbW91c2VvdmVyJywgJ21vdXNlbGVhdmUnLCAnbW91c2VlbnRlcicsICdtb3VzZW91dCddO1xuICAgIHZhciBMQVNUX0VWRU5UX1RJTUVPVVRfTVMgPSAxMDtcbiAgICB2YXIgRVZFTlRTID0gWy8vIGtleWJvYXJkIGV2ZW50c1xuICAgICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgLy8gbW91c2UgZXZlbnRzXG4gICAgJ2F1eGNsaWNrJywgJ2NsaWNrJywgJ2NvbnRleHRtZW51JywgJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnLCAnbW91c2Vtb3ZlJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZXVwJywgJ3BvaW50ZXJsb2NrY2hhbmdlJywgJ3BvaW50ZXJsb2NrZXJyb3InLCAnc2VsZWN0JywgJ3doZWVsJ107IC8vICd3aGVlbCcgZXZlbnQgbWFrZXMgc2Nyb2xsaW5nIGluIFNhZmFyaSB0d2l0Y2h5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0V4dGVuZGVkQ3NzL2lzc3Vlcy8xMjBcblxuICAgIHZhciBzYWZhcmlQcm9ibGVtYXRpY0V2ZW50cyA9IFsnd2hlZWwnXTtcbiAgICB2YXIgdHJhY2tlZEV2ZW50cyA9IHV0aWxzLmlzU2FmYXJpQnJvd3NlciA/IEVWRU5UUy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gIShzYWZhcmlQcm9ibGVtYXRpY0V2ZW50cy5pbmRleE9mKGVsKSA+IC0xKTtcbiAgICB9KSA6IEVWRU5UUztcbiAgICB2YXIgbGFzdEV2ZW50VHlwZTtcbiAgICB2YXIgbGFzdEV2ZW50VGltZTtcblxuICAgIHZhciB0cmFja0V2ZW50ID0gZnVuY3Rpb24gdHJhY2tFdmVudChlKSB7XG4gICAgICBsYXN0RXZlbnRUeXBlID0gZS50eXBlO1xuICAgICAgbGFzdEV2ZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgfTtcblxuICAgIHRyYWNrZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZOYW1lKSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldk5hbWUsIHRyYWNrRXZlbnQsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgdmFyIGdldExhc3RFdmVudFR5cGUgPSBmdW5jdGlvbiBnZXRMYXN0RXZlbnRUeXBlKCkge1xuICAgICAgcmV0dXJuIGxhc3RFdmVudFR5cGU7XG4gICAgfTtcblxuICAgIHZhciBnZXRUaW1lU2luY2VMYXN0RXZlbnQgPSBmdW5jdGlvbiBnZXRUaW1lU2luY2VMYXN0RXZlbnQoKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxhc3RFdmVudFRpbWU7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc0lnbm9yZWRFdmVudFR5cGU6IGZ1bmN0aW9uIGlzSWdub3JlZEV2ZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIGlnbm9yZWRFdmVudFR5cGVzLmluZGV4T2YoZ2V0TGFzdEV2ZW50VHlwZSgpKSA+IC0xICYmIGdldFRpbWVTaW5jZUxhc3RFdmVudCgpIDwgTEFTVF9FVkVOVF9USU1FT1VUX01TO1xuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcnVsZXMgPSBbXTtcbiAgdmFyIGFmZmVjdGVkRWxlbWVudHMgPSBbXTtcbiAgdmFyIHJlbW92YWxzU3RhdGlzdGljID0ge307XG4gIHZhciBkb21PYnNlcnZlZDtcbiAgdmFyIGV2ZW50TGlzdGVuZXJTdXBwb3J0ZWQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgdmFyIGRvbU11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgZnVuY3Rpb24gb2JzZXJ2ZURvY3VtZW50KGNhbGxiYWNrKSB7XG4gICAgLy8gV2UgYXJlIHRyeWluZyB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGNhbGxiYWNrIGNhbGxzIGJ5IG5vdCBjYWxsaW5nIGl0IG9uIGFsbCBraW5kIG9mIFwiaG92ZXJcIiBldmVudHMuXG4gICAgLy8gVGhlIHJhdGlvbmFsZSBiZWhpbmQgdGhpcyBpcyB0aGF0IFwiaG92ZXJcIiBldmVudHMgb2Z0ZW4gY2F1c2UgYXR0cmlidXRlcyBtb2RpZmljYXRpb24sXG4gICAgLy8gYnV0IHJlLWFwcGx5aW5nIGV4dENTUyBydWxlcyB3aWxsIGJlIHVzZWxlc3MgYXMgdGhlc2UgYXR0cmlidXRlIGNoYW5nZXMgYXJlIHVzdWFsbHkgdHJhbnNpZW50LlxuICAgIHZhciBpc0lnbm9yZWRNdXRhdGlvbiA9IGZ1bmN0aW9uIGlzSWdub3JlZE11dGF0aW9uKG11dGF0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG11dGF0aW9ucy50eXBlICE9PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIGlmICh1dGlscy5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBkb21NdXRhdGlvbk9ic2VydmVyID0gbmV3IHV0aWxzLk11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICBpZiAoIW11dGF0aW9ucyB8fCBtdXRhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEV2ZW50VHJhY2tlci5pc0lnbm9yZWRFdmVudFR5cGUoKSAmJiBpc0lnbm9yZWRNdXRhdGlvbihtdXRhdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgZG9tTXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbJ2lkJywgJ2NsYXNzJ11cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRMaXN0ZW5lclN1cHBvcnRlZCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUF0dHJNb2RpZmllZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzY29ubmVjdERvY3VtZW50KGNhbGxiYWNrKSB7XG4gICAgaWYgKGRvbU11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGRvbU11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRMaXN0ZW5lclN1cHBvcnRlZCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUF0dHJNb2RpZmllZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE1BWF9TVFlMRV9QUk9URUNUSU9OX0NPVU5UID0gNTA7XG4gIHZhciBwcm90ZWN0aW9uT2JzZXJ2ZXJPcHRpb24gPSB7XG4gICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3R5bGUnXVxuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBNdXRhdGlvbk9ic2VydmVyIHByb3RlY3Rpb24gZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHN0eWxlc1xuICAgKiBAcmV0dXJuIHtwcm90ZWN0aW9uRnVuY3Rpb259XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3RlY3Rpb25GdW5jdGlvbihzdHlsZXMpIHtcbiAgICBmdW5jdGlvbiBwcm90ZWN0aW9uRnVuY3Rpb24obXV0YXRpb25zLCBvYnNlcnZlcikge1xuICAgICAgaWYgKCFtdXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG11dGF0aW9uID0gbXV0YXRpb25zWzBdO1xuICAgICAgdmFyIHRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBzZXRTdHlsZVRvRWxlbWVudCh0YXJnZXQsIHN0eWxlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoKytvYnNlcnZlci5zdHlsZVByb3RlY3Rpb25Db3VudCA8IE1BWF9TVFlMRV9QUk9URUNUSU9OX0NPVU5UKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0LCBwcm90ZWN0aW9uT2JzZXJ2ZXJPcHRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbHMubG9nRXJyb3IoJ0V4dGVuZGVkQ3NzOiBpbmZpbml0ZSBsb29wIHByb3RlY3Rpb24gZm9yIHN0eWxlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3RlY3Rpb25GdW5jdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB1cCBhIE11dGF0aW9uT2JzZXJ2ZXIgd2hpY2ggcHJvdGVjdHMgc3R5bGUgYXR0cmlidXRlcyBmcm9tIGNoYW5nZXNcbiAgICogQHBhcmFtIG5vZGUgRE9NIG5vZGVcbiAgICogQHBhcmFtIHJ1bGVzIHJ1bGVzXG4gICAqIEByZXR1cm5zIE11dGF0aW9uIG9ic2VydmVyIHVzZWQgdG8gcHJvdGVjdCBhdHRyaWJ1dGUgb3IgbnVsbCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gcHJvdGVjdFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHByb3RlY3RTdHlsZUF0dHJpYnV0ZShub2RlLCBydWxlcykge1xuICAgIGlmICghdXRpbHMuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlcyA9IHJ1bGVzLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIHIuc3R5bGU7XG4gICAgfSk7XG4gICAgdmFyIHByb3RlY3Rpb25PYnNlcnZlciA9IG5ldyB1dGlscy5NdXRhdGlvbk9ic2VydmVyKGNyZWF0ZVByb3RlY3Rpb25GdW5jdGlvbihzdHlsZXMpKTtcbiAgICBwcm90ZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCBwcm90ZWN0aW9uT2JzZXJ2ZXJPcHRpb24pOyAvLyBBZGRzIGFuIGV4cGFuZG8gdG8gdGhlIG9ic2VydmVyIHRvIGtlZXAgJ3N0eWxlIGZpeCBjb3VudHMnLlxuXG4gICAgcHJvdGVjdGlvbk9ic2VydmVyLnN0eWxlUHJvdGVjdGlvbkNvdW50ID0gMDtcbiAgICByZXR1cm4gcHJvdGVjdGlvbk9ic2VydmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU3VmZml4KHN0ciwgc3VmZml4KSB7XG4gICAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2Yoc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIGFmZmVjdGVkRWxlbWVudCBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgRE9NIG5vZGVcbiAgICogQHBhcmFtIG5vZGUgIERPTSBub2RlXG4gICAqIEByZXR1cm5zICAgICBhZmZlY3RlZEVsZW1lbnQgZm91bmQgb3IgbnVsbFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGZpbmRBZmZlY3RlZEVsZW1lbnQobm9kZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWZmZWN0ZWRFbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGFmZmVjdGVkRWxlbWVudHNbaV0ubm9kZSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gYWZmZWN0ZWRFbGVtZW50c1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoYWZmZWN0ZWRFbGVtZW50KSB7XG4gICAgdmFyIG5vZGUgPSBhZmZlY3RlZEVsZW1lbnQubm9kZTtcbiAgICBhZmZlY3RlZEVsZW1lbnQucmVtb3ZlZCA9IHRydWU7XG4gICAgdmFyIGVsZW1lbnRTZWxlY3RvciA9IHV0aWxzLmdldE5vZGVTZWxlY3Rvcihub2RlKTsgLy8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaGFzIGJlZW4gYWxyZWFkeSByZW1vdmVkIGVhcmxpZXJcblxuICAgIHZhciBlbGVtZW50UmVtb3ZhbHNDb3VudGVyID0gcmVtb3ZhbHNTdGF0aXN0aWNbZWxlbWVudFNlbGVjdG9yXSB8fCAwOyAvLyBpZiByZW1vdmFscyBhdHRlbXB0cyBoYXBwZW5lZCBtb3JlIHRoYW4gc3BlY2lmaWVkIHdlIGRvIG5vdCB0cnkgdG8gcmVtb3ZlIG5vZGUgYWdhaW5cblxuICAgIGlmIChlbGVtZW50UmVtb3ZhbHNDb3VudGVyID4gTUFYX1NUWUxFX1BST1RFQ1RJT05fQ09VTlQpIHtcbiAgICAgIHV0aWxzLmxvZ0Vycm9yKCdFeHRlbmRlZENzczogaW5maW5pdGUgbG9vcCBwcm90ZWN0aW9uIGZvciBTRUxFQ1RPUicsIGVsZW1lbnRTZWxlY3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgcmVtb3ZhbHNTdGF0aXN0aWNbZWxlbWVudFNlbGVjdG9yXSA9IGVsZW1lbnRSZW1vdmFsc0NvdW50ZXIgKyAxO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBzdHlsZSB0byB0aGUgc3BlY2lmaWVkIERPTSBub2RlXG4gICAqIEBwYXJhbSBhZmZlY3RlZEVsZW1lbnQgT2JqZWN0IGNvbnRhaW5pbmcgRE9NIG5vZGUgYW5kIHJ1bGUgdG8gYmUgYXBwbGllZFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFwcGx5U3R5bGUoYWZmZWN0ZWRFbGVtZW50KSB7XG4gICAgaWYgKGFmZmVjdGVkRWxlbWVudC5wcm90ZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIC8vIFN0eWxlIGlzIGFscmVhZHkgYXBwbGllZCBhbmQgcHJvdGVjdGVkIGJ5IHRoZSBvYnNlcnZlclxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChiZWZvcmVTdHlsZUFwcGxpZWQpIHtcbiAgICAgIGFmZmVjdGVkRWxlbWVudCA9IGJlZm9yZVN0eWxlQXBwbGllZChhZmZlY3RlZEVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWFmZmVjdGVkRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9hZmZlY3RlZEVsZW1lbnQgPSBhZmZlY3RlZEVsZW1lbnQsXG4gICAgICAgIG5vZGUgPSBfYWZmZWN0ZWRFbGVtZW50Lm5vZGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFmZmVjdGVkRWxlbWVudC5ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0eWxlID0gYWZmZWN0ZWRFbGVtZW50LnJ1bGVzW2ldLnN0eWxlO1xuXG4gICAgICBpZiAoc3R5bGVbJ3JlbW92ZSddID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmVtb3ZlRWxlbWVudChhZmZlY3RlZEVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNldFN0eWxlVG9FbGVtZW50KG5vZGUsIHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgc3R5bGUgdG8gdGhlIHNwZWNpZmllZCBET00gbm9kZVxuICAgKiBAcGFyYW0gbm9kZSBlbGVtZW50XG4gICAqIEBwYXJhbSBzdHlsZSBzdHlsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNldFN0eWxlVG9FbGVtZW50KG5vZGUsIHN0eWxlKSB7XG4gICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIC8vIEFwcGx5IHRoaXMgc3R5bGUgb25seSB0byBleGlzdGluZyBwcm9wZXJ0aWVzXG4gICAgICAvLyBXZSBjYW4ndCB1c2UgaGFzT3duUHJvcGVydHkgaGVyZSAoZG9lcyBub3Qgd29yayBpbiBGRilcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTsgLy8gRmlyc3Qgd2Ugc2hvdWxkIHJlbW92ZSAhaW1wb3J0YW50IGF0dHJpYnV0ZSAob3IgaXQgd29uJ3QgYmUgYXBwbGllZCcpXG5cbiAgICAgICAgdmFsdWUgPSByZW1vdmVTdWZmaXgodmFsdWUudHJpbSgpLCAnIWltcG9ydGFudCcpLnRyaW0oKTtcbiAgICAgICAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB2YWx1ZSwgJ2ltcG9ydGFudCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXZlcnRzIHN0eWxlIGZvciB0aGUgYWZmZWN0ZWQgb2JqZWN0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmV2ZXJ0U3R5bGUoYWZmZWN0ZWRFbGVtZW50KSB7XG4gICAgaWYgKGFmZmVjdGVkRWxlbWVudC5wcm90ZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGFmZmVjdGVkRWxlbWVudC5wcm90ZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGFmZmVjdGVkRWxlbWVudC5ub2RlLnN0eWxlLmNzc1RleHQgPSBhZmZlY3RlZEVsZW1lbnQub3JpZ2luYWxTdHlsZTtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBzcGVjaWZpZWQgcnVsZSBhbmQgcmV0dXJucyBsaXN0IG9mIGVsZW1lbnRzIGFmZmVjdGVkXG4gICAqIEBwYXJhbSBydWxlIFJ1bGUgdG8gYXBwbHlcbiAgICogQHJldHVybnMgTGlzdCBvZiBlbGVtZW50cyBhZmZlY3RlZCBieSB0aGlzIHJ1bGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBhcHBseVJ1bGUocnVsZSkge1xuICAgIHZhciBkZWJ1ZyA9IHJ1bGUuc2VsZWN0b3IuaXNEZWJ1Z2dpbmcoKTtcbiAgICB2YXIgc3RhcnQ7XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIHN0YXJ0ID0gdXRpbHMuQXN5bmNXcmFwcGVyLm5vdygpO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XG4gICAgdmFyIG5vZGVzID0gc2VsZWN0b3IucXVlcnlTZWxlY3RvckFsbCgpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBhZmZlY3RlZEVsZW1lbnQgPSBmaW5kQWZmZWN0ZWRFbGVtZW50KG5vZGUpO1xuXG4gICAgICBpZiAoYWZmZWN0ZWRFbGVtZW50KSB7XG4gICAgICAgIGFmZmVjdGVkRWxlbWVudC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICBhcHBseVN0eWxlKGFmZmVjdGVkRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcHBseWluZyBzdHlsZSBmaXJzdCB0aW1lXG4gICAgICAgIHZhciBvcmlnaW5hbFN0eWxlID0gbm9kZS5zdHlsZS5jc3NUZXh0O1xuICAgICAgICBhZmZlY3RlZEVsZW1lbnQgPSB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAvLyBhZmZlY3RlZCBET00gbm9kZVxuICAgICAgICAgIHJ1bGVzOiBbcnVsZV0sXG4gICAgICAgICAgLy8gcnVsZXMgdG8gYmUgYXBwbGllZFxuICAgICAgICAgIG9yaWdpbmFsU3R5bGU6IG9yaWdpbmFsU3R5bGUsXG4gICAgICAgICAgLy8gb3JpZ2luYWwgbm9kZSBzdHlsZVxuICAgICAgICAgIHByb3RlY3Rpb25PYnNlcnZlcjogbnVsbCAvLyBzdHlsZSBhdHRyaWJ1dGUgb2JzZXJ2ZXJcblxuICAgICAgICB9O1xuICAgICAgICBhcHBseVN0eWxlKGFmZmVjdGVkRWxlbWVudCk7XG4gICAgICAgIGFmZmVjdGVkRWxlbWVudHMucHVzaChhZmZlY3RlZEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICB2YXIgZWxhcHNlZCA9IHV0aWxzLkFzeW5jV3JhcHBlci5ub3coKSAtIHN0YXJ0O1xuXG4gICAgICBpZiAoISgndGltaW5nU3RhdHMnIGluIHJ1bGUpKSB7XG4gICAgICAgIHJ1bGUudGltaW5nU3RhdHMgPSBuZXcgdXRpbHMuU3RhdHMoKTtcbiAgICAgIH1cblxuICAgICAgcnVsZS50aW1pbmdTdGF0cy5wdXNoKGVsYXBzZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyBmaWx0ZXJpbmcgcnVsZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBhcHBseVJ1bGVzKCkge1xuICAgIHZhciBlbGVtZW50c0luZGV4ID0gW107IC8vIHNvbWUgcnVsZXMgY291bGQgbWFrZSBjYWxsIC0gc2VsZWN0b3IucXVlcnlTZWxlY3RvckFsbCgpIHRlbXBvcmFyaWx5IHRvIGNoYW5nZSBub2RlIGlkIGF0dHJpYnV0ZVxuICAgIC8vIHRoaXMgY2F1c2VkIE11dGF0aW9uT2JzZXJ2ZXIgdG8gY2FsbCByZWN1cnNpdmVseVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9FeHRlbmRlZENzcy9pc3N1ZXMvODFcblxuICAgIHN0b3BPYnNlcnZlKCk7XG4gICAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgdmFyIG5vZGVzID0gYXBwbHlSdWxlKHJ1bGUpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZWxlbWVudHNJbmRleCwgbm9kZXMpO1xuICAgIH0pOyAvLyBOb3cgcmV2ZXJ0IHN0eWxlcyBmb3IgZWxlbWVudHMgd2hpY2ggYXJlIG5vIG1vcmUgYWZmZWN0ZWRcblxuICAgIHZhciBsID0gYWZmZWN0ZWRFbGVtZW50cy5sZW5ndGg7IC8vIGRvIG5vdGhpbmcgaWYgdGhlcmUgaXMgbm8gZWxlbWVudHMgdG8gcHJvY2Vzc1xuXG4gICAgaWYgKGVsZW1lbnRzSW5kZXgubGVuZ3RoID4gMCkge1xuICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICB2YXIgb2JqID0gYWZmZWN0ZWRFbGVtZW50c1tsXTtcblxuICAgICAgICBpZiAoZWxlbWVudHNJbmRleC5pbmRleE9mKG9iai5ub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBUaW1lIHRvIHJldmVydCBzdHlsZVxuICAgICAgICAgIHJldmVydFN0eWxlKG9iaik7XG4gICAgICAgICAgYWZmZWN0ZWRFbGVtZW50cy5zcGxpY2UobCwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9iai5yZW1vdmVkKSB7XG4gICAgICAgICAgLy8gQWRkIHN0eWxlIHByb3RlY3Rpb24gb2JzZXJ2ZXJcbiAgICAgICAgICAvLyBQcm90ZWN0IFwic3R5bGVcIiBhdHRyaWJ1dGUgZnJvbSBjaGFuZ2VzXG4gICAgICAgICAgaWYgKCFvYmoucHJvdGVjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICBvYmoucHJvdGVjdGlvbk9ic2VydmVyID0gcHJvdGVjdFN0eWxlQXR0cmlidXRlKG9iai5ub2RlLCBvYmoucnVsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQWZ0ZXIgc3R5bGVzIGFyZSBhcHBsaWVkIHdlIGNhbiBzdGFydCBvYnNlcnZlIGFnYWluXG5cblxuICAgIG9ic2VydmUoKTtcbiAgICBwcmludFRpbWluZ0luZm8oKTtcbiAgfVxuXG4gIHZhciBBUFBMWV9SVUxFU19ERUxBWSA9IDE1MDtcbiAgdmFyIGFwcGx5UnVsZXNTY2hlZHVsZXIgPSBuZXcgdXRpbHMuQXN5bmNXcmFwcGVyKGFwcGx5UnVsZXMsIEFQUExZX1JVTEVTX0RFTEFZKTtcbiAgdmFyIG1haW5DYWxsYmFjayA9IGFwcGx5UnVsZXNTY2hlZHVsZXIucnVuLmJpbmQoYXBwbHlSdWxlc1NjaGVkdWxlcik7XG5cbiAgZnVuY3Rpb24gb2JzZXJ2ZSgpIHtcbiAgICBpZiAoZG9tT2JzZXJ2ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEhhbmRsZSBkeW5hbWljYWxseSBhZGRlZCBlbGVtZW50c1xuXG5cbiAgICBkb21PYnNlcnZlZCA9IHRydWU7XG4gICAgb2JzZXJ2ZURvY3VtZW50KG1haW5DYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wT2JzZXJ2ZSgpIHtcbiAgICBpZiAoIWRvbU9ic2VydmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9tT2JzZXJ2ZWQgPSBmYWxzZTtcbiAgICBkaXNjb25uZWN0RG9jdW1lbnQobWFpbkNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgIGFwcGx5UnVsZXMoKTtcblxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgYXBwbHlSdWxlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlcyBFeHRlbmRlZENzcyBhbmQgcmVtb3ZlcyBvdXIgc3R5bGVzIGZyb20gbWF0Y2hlZCBlbGVtZW50c1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgc3RvcE9ic2VydmUoKTtcbiAgICBhZmZlY3RlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV2ZXJ0U3R5bGUob2JqKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB0aW1pbmdzUHJpbnRlZCA9IGZhbHNlO1xuICAvKipcbiAgICogUHJpbnRzIHRpbWluZyBpbmZvcm1hdGlvbiBmb3IgYWxsIHNlbGVjdG9ycyBtYXJrZWQgYXMgXCJkZWJ1Z1wiXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHByaW50VGltaW5nSW5mbygpIHtcbiAgICBpZiAodGltaW5nc1ByaW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1pbmdzUHJpbnRlZCA9IHRydWU7XG4gICAgdmFyIHRpbWluZ3MgPSBydWxlcy5maWx0ZXIoZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIHJldHVybiBydWxlLnNlbGVjdG9yLmlzRGVidWdnaW5nKCk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RvclRleHQ6IHJ1bGUuc2VsZWN0b3Iuc2VsZWN0b3JUZXh0LFxuICAgICAgICB0aW1pbmdTdGF0czogcnVsZS50aW1pbmdTdGF0c1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIGlmICh0aW1pbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQWRkIGxvY2F0aW9uLmhyZWYgdG8gdGhlIG1lc3NhZ2UgdG8gZGlzdGluZ3Vpc2ggZnJhbWVzXG5cblxuICAgIHV0aWxzLmxvZ0luZm8oJ1tFeHRlbmRlZENzc10gVGltaW5ncyBmb3IgJW86XFxuJW8gKGluIG1pbGxpc2Vjb25kcyknLCB3aW5kb3cubG9jYXRpb24uaHJlZiwgdGltaW5ncyk7XG4gIH0gLy8gRmlyc3Qgb2YgYWxsIHBhcnNlIHRoZSBzdHlsZXNoZWV0XG5cblxuICBydWxlcyA9IEV4dGVuZGVkQ3NzUGFyc2VyLnBhcnNlQ3NzKHN0eWxlU2hlZXQpOyAvLyBFWFBPU0VcblxuICB0aGlzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuICB0aGlzLmFwcGx5ID0gYXBwbHk7XG4gIC8qKiBFeHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkgKi9cblxuICB0aGlzLl9nZXRBZmZlY3RlZEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhZmZlY3RlZEVsZW1lbnRzO1xuICB9O1xufVxuLyoqXG4gKiBFeHBvc2UgcXVlcnlTZWxlY3RvckFsbCBmb3IgZGVidWdnaW5nIGFuZCB2YWxpZGF0aW5nIHNlbGVjdG9yc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclRleHQgc2VsZWN0b3IgdGV4dFxuICogQHBhcmFtIHtib29sZWFufSBub1RpbWluZyBpZiB0cnVlIC0tIGRvIG5vdCBwcmludCB0aGUgdGltaW5nIHRvIHRoZSBjb25zb2xlXG4gKiBAcmV0dXJucyB7QXJyYXk8Tm9kZT58Tm9kZUxpc3R9IGEgbGlzdCBvZiBlbGVtZW50cyBmb3VuZFxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhcmd1bWVudCBpcyBub3QgYSB2YWxpZCBzZWxlY3RvclxuICovXG5cblxuRXh0ZW5kZWRDc3MucXVlcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3JUZXh0LCBub1RpbWluZykge1xuICBpZiAodHlwZW9mIHNlbGVjdG9yVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbGVjdG9yIHRleHQgaXMgZW1wdHknKTtcbiAgfVxuXG4gIHZhciBub3cgPSB1dGlscy5Bc3luY1dyYXBwZXIubm93O1xuICB2YXIgc3RhcnQgPSBub3coKTtcblxuICB0cnkge1xuICAgIHJldHVybiBFeHRlbmRlZFNlbGVjdG9yRmFjdG9yeS5jcmVhdGVTZWxlY3RvcihzZWxlY3RvclRleHQpLnF1ZXJ5U2VsZWN0b3JBbGwoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB2YXIgZW5kID0gbm93KCk7XG5cbiAgICBpZiAoIW5vVGltaW5nKSB7XG4gICAgICB1dGlscy5sb2dJbmZvKFwiW0V4dGVuZGVkQ3NzXSBFbGFwc2VkOiBcIi5jb25jYXQoTWF0aC5yb3VuZCgoZW5kIC0gc3RhcnQpICogMTAwMCksIFwiIFxcdTAzQkNzLlwiKSk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFeHRlbmRlZENzcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/extended-css/dist/extended-css.esm.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz85NmNmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLG9CQUFvQixDQUFFO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js":
/*!************************************************************!*\
  !*** ./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n/**\n * AdGuard Scriptlets\n * Version 1.3.20\n */\n\n/**\n * Returns wildcard symbol\n * @returns {string} '*'\n */\nvar getWildcardSymbol = function getWildcardSymbol() {\n  return '*';\n};\n\n/**\n * Generate random six symbols id\n */\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n}\n\n/**\n * Set getter and setter to property if it's configurable\n * @param {Object} object target object with property\n * @param {string} property property name\n * @param {Object} descriptor contains getter and setter functions\n * @returns {boolean} is operation successful\n */\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\n\n/**\n * @typedef Chain\n * @property {Object} base\n * @property {string} prop\n * @property {string} [chain]\n */\n\n/**\n * Check if the property exists in the base object (recursively)\n *\n * If property doesn't exist in base object,\n * defines this property as 'undefined'\n * and returns base, property name and remaining part of property chain\n *\n * @param {Object} base\n * @param {string} chain\n * @returns {Chain}\n */\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos); // https://github.com/AdguardTeam/Scriptlets/issues/128\n\n  if (base === null) {\n    // if base is null, return 'null' as base.\n    // it's needed for triggering the reason logging while debugging\n    return {\n      base: base,\n      prop: prop,\n      chain: chain\n    };\n  }\n\n  var nextBase = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (nextBase !== undefined) {\n    return getPropertyInChain(nextBase, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: nextBase,\n    prop: prop,\n    chain: chain\n  };\n}\n\n/**\n * @typedef Chain\n * @property {Object} base\n * @property {string} prop\n * @property {string} [chain]\n */\n\n/**\n * Check if the property exists in the base object (recursively).\n * Similar to getPropertyInChain but upgraded for json-prune:\n * handle wildcard properties and does not define nonexistent base property as 'undefined'\n *\n * @param {Object} base\n * @param {string} chain\n * @param {boolean} [lookThrough=false]\n * should the method look through it's props in order to wildcard\n * @param {Array} [output=[]] result acc\n * @returns {Chain[]} array of objects\n */\n\nfunction getWildcardPropertyInChain(base, chain) {\n  var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    // for paths like 'a.b.*' every final nested prop should be processed\n    if (chain === getWildcardSymbol() || chain === '[]') {\n      // eslint-disable-next-line no-restricted-syntax\n      for (var key in base) {\n        // to process each key in base except inherited ones\n        if (Object.prototype.hasOwnProperty.call(base, key)) {\n          output.push({\n            base: base,\n            prop: key\n          });\n        }\n      }\n    } else {\n      output.push({\n        base: base,\n        prop: chain\n      });\n    }\n\n    return output;\n  }\n\n  var prop = chain.slice(0, pos);\n  var shouldLookThrough = prop === '[]' && Array.isArray(base) || prop === getWildcardSymbol() && base instanceof Object;\n\n  if (shouldLookThrough) {\n    var nextProp = chain.slice(pos + 1);\n    var baseKeys = Object.keys(base); // if there is a wildcard prop in input chain (e.g. 'ad.*.src' for 'ad.0.src ad.1.src'),\n    // each one of base keys should be considered as a potential chain prop in final path\n\n    baseKeys.forEach(function (key) {\n      var item = base[key];\n      getWildcardPropertyInChain(item, nextProp, lookThrough, output);\n    });\n  }\n\n  var nextBase = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (nextBase !== undefined) {\n    getWildcardPropertyInChain(nextBase, chain, lookThrough, output);\n  }\n\n  return output;\n}\n\n/**\n * Determines whether the passed value is NaN\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\n * @param {*} num\n * @returns {boolean}\n */\nvar nativeIsNaN = function nativeIsNaN(num) {\n  var native = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat\n\n  return native(num);\n};\n/**\n * Determines whether the passed value is a finite number\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite\n * @param {*} num\n * @returns {boolean}\n */\n\nvar nativeIsFinite = function nativeIsFinite(num) {\n  var native = Number.isFinite || window.isFinite; // eslint-disable-line compat/compat\n\n  return native(num);\n};\n\n/**\n * Converts object to array of pairs.\n * Object.entries() polyfill because it is not supported by IE\n * https://caniuse.com/?search=Object.entries\n * @param {Object} object\n * @returns {Array} array of pairs\n */\nvar getObjectEntries = function getObjectEntries(object) {\n  var keys = Object.keys(object);\n  var entries = [];\n  keys.forEach(function (key) {\n    return entries.push([key, object[key]]);\n  });\n  return entries;\n};\n/**\n * Converts array of pairs to object.\n * Object.fromEntries() polyfill because it is not supported by IE\n * https://caniuse.com/?search=Object.fromEntries\n * @param {Array} entries - array of pairs\n * @returns {Object}\n */\n\nvar getObjectFromEntries = function getObjectFromEntries(entries) {\n  var output = entries.reduce(function (acc, el) {\n    var key = el[0];\n    var value = el[1];\n    acc[key] = value;\n    return acc;\n  }, {});\n  return output;\n};\n/**\n * Checks whether the obj is an empty object\n * @param {Object} obj\n * @returns {boolean}\n */\n\nvar isEmptyObject = function isEmptyObject(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * String.prototype.replaceAll polifill\n * @param {string} input input string\n * @param {string} substr to look for\n * @param {string} newSubstr replacement\n * @returns {string}\n */\n\nvar replaceAll = function replaceAll(input, substr, newSubstr) {\n  return input.split(substr).join(newSubstr);\n};\n/**\n * Escapes special chars in string\n * @param {string} str\n * @returns {string}\n */\n\nvar escapeRegExp = function escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\n/**\n * Converts search string to the regexp\n * TODO think about nested dependencies, but be careful with dependency loops\n * @param {string} str search string\n * @returns {RegExp}\n */\n\nvar toRegExp = function toRegExp(str) {\n  if (!str || str === '') {\n    var DEFAULT_VALUE = '.?';\n    return new RegExp(DEFAULT_VALUE);\n  }\n\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n/**\n * Get string before regexp first match\n * @param {string} str\n * @param {RegExp} rx\n */\n\nvar getBeforeRegExp = function getBeforeRegExp(str, rx) {\n  var index = str.search(rx);\n  return str.substring(0, index);\n};\n/**\n * Checks whether the string starts with the substring\n * @param {string} str full string\n * @param {string} prefix substring\n * @returns {boolean}\n */\n\nvar startsWith = function startsWith(str, prefix) {\n  // if str === '', (str && false) will return ''\n  // that's why it has to be !!str\n  return !!str && str.indexOf(prefix) === 0;\n};\n/**\n * Checks whether the string ends with the substring\n * @param {string} str full string\n * @param {string} ending substring\n * @returns {boolean}\n */\n\nvar endsWith = function endsWith(str, ending) {\n  // if str === '', (str && false) will return ''\n  // that's why it has to be !!str\n  return !!str && str.indexOf(ending) === str.length - ending.length;\n};\nvar substringAfter = function substringAfter(str, separator) {\n  if (!str) {\n    return str;\n  }\n\n  var index = str.indexOf(separator);\n  return index < 0 ? '' : str.substring(index + separator.length);\n};\nvar substringBefore = function substringBefore(str, separator) {\n  if (!str || !separator) {\n    return str;\n  }\n\n  var index = str.indexOf(separator);\n  return index < 0 ? str : str.substring(0, index);\n};\n/**\n * Wrap str in single qoutes and replaces single quotes to doudle one\n * @param {string} str\n */\n\nvar wrapInSingleQuotes = function wrapInSingleQuotes(str) {\n  if (str[0] === '\\'' && str[str.length - 1] === '\\'' || str[0] === '\"' && str[str.length - 1] === '\"') {\n    str = str.substring(1, str.length - 1);\n  } // eslint-disable-next-line no-useless-escape\n\n\n  str = str.replace(/\\'/g, '\"');\n  return \"'\".concat(str, \"'\");\n};\n/**\n * Returns substring enclosed in the widest braces\n * @param {string} str\n */\n\nvar getStringInBraces = function getStringInBraces(str) {\n  var firstIndex = str.indexOf('(');\n  var lastIndex = str.lastIndexOf(')');\n  return str.substring(firstIndex + 1, lastIndex);\n};\n/**\n * Prepares RTCPeerConnection config as string for proper logging\n * @param {*} config\n * @returns {string} stringified config\n*/\n\nvar convertRtcConfigToString = function convertRtcConfigToString(config) {\n  var UNDEF_STR = 'undefined';\n  var str = UNDEF_STR;\n\n  if (config === null) {\n    str = 'null';\n  } else if (config instanceof Object) {\n    var SERVERS_PROP_NAME = 'iceServers';\n    var URLS_PROP_NAME = 'urls';\n    /*\n        const exampleConfig = {\n            'iceServers': [\n                'urls': ['stun:35.66.206.188:443'],\n            ],\n        };\n    */\n\n    if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {\n      str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();\n    }\n  }\n\n  return str;\n};\n/**\n * @typedef {Object} MatchData\n * @property {boolean} isInvertedMatch\n * @property {RegExp} matchRegexp\n */\n\n/**\n * Parses match arg with possible negation for no matching.\n * Needed for prevent-setTimeout, prevent-setInterval,\n * prevent-requestAnimationFrame and prevent-window-open\n * @param {string} match\n * @returns {MatchData}\n */\n\nvar parseMatchArg = function parseMatchArg(match) {\n  var INVERT_MARKER = '!';\n  var isInvertedMatch = startsWith(match, INVERT_MARKER);\n  var matchValue = isInvertedMatch ? match.slice(1) : match;\n  var matchRegexp = toRegExp(matchValue);\n  return {\n    isInvertedMatch: isInvertedMatch,\n    matchRegexp: matchRegexp\n  };\n};\n/**\n * @typedef {Object} DelayData\n * @property {boolean} isInvertedDelayMatch\n * @property {number|null} delayMatch\n */\n\n/**\n * Parses delay arg with possible negation for no matching.\n * Needed for prevent-setTimeout and prevent-setInterval\n * @param {string} delay\n * @returns {DelayData}\n */\n\nvar parseDelayArg = function parseDelayArg(delay) {\n  var INVERT_MARKER = '!';\n  var isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);\n  var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;\n  delayValue = parseInt(delayValue, 10);\n  var delayMatch = nativeIsNaN(delayValue) ? null : delayValue;\n  return {\n    isInvertedDelayMatch: isInvertedDelayMatch,\n    delayMatch: delayMatch\n  };\n};\n/**\n * Converts object to string for logging\n * @param {Object} obj data object\n * @returns {string}\n */\n\nvar objectToString = function objectToString(obj) {\n  return isEmptyObject(obj) ? '{}' : getObjectEntries(obj).map(function (pair) {\n    var key = pair[0];\n    var value = pair[1];\n    var recordValueStr = value;\n\n    if (value instanceof Object) {\n      recordValueStr = \"{ \".concat(objectToString(value), \" }\");\n    }\n\n    return \"\".concat(key, \":\\\"\").concat(recordValueStr, \"\\\"\");\n  }).join(' ');\n};\n/**\n * Converts types into a string\n * @param {*} value\n * @returns {string}\n */\n\nvar convertTypeToString = function convertTypeToString(value) {\n  var output;\n\n  if (typeof value === 'undefined') {\n    output = 'undefined';\n  } else if (typeof value === 'object') {\n    if (value === null) {\n      output = 'null';\n    } else {\n      output = objectToString(value);\n    }\n  } else {\n    output = value.toString();\n  }\n\n  return output;\n};\n\n/**\n * Generates function which silents global errors on page generated by scriptlet\n * If error doesn't belong to our error we transfer it to the native onError handler\n * @param {string} rid - unique identifier of scriptlet\n * @return {onError}\n */\nfunction createOnErrorHandler(rid) {\n  // eslint-disable-next-line consistent-return\n  var nativeOnError = window.onerror;\n  return function onError(error) {\n    if (typeof error === 'string' && error.indexOf(rid) !== -1) {\n      return true;\n    }\n\n    if (nativeOnError instanceof Function) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOnError.apply(this, [error].concat(args));\n    }\n\n    return false;\n  };\n}\n\n/**\n * Noop function\n * @return {undefined} undefined\n */\nvar noopFunc = function noopFunc() {};\n/**\n * Function returns null\n * @return {null} null\n */\n\nvar noopNull = function noopNull() {\n  return null;\n};\n/**\n * Function returns true\n * @return {boolean} true\n */\n\nvar trueFunc = function trueFunc() {\n  return true;\n};\n/**\n * Function returns false\n * @return {boolean} false\n */\n\nvar falseFunc = function falseFunc() {\n  return false;\n};\n/**\n * Function returns this\n */\n\nfunction noopThis() {\n  return this;\n}\n/**\n * Function returns empty string\n * @return {string} empty string\n */\n\nvar noopStr = function noopStr() {\n  return '';\n};\n/**\n * Function returns empty array\n * @return {Array} empty array\n */\n\nvar noopArray = function noopArray() {\n  return [];\n};\n/**\n * Function returns empty object\n * @return {Object} empty object\n */\n\nvar noopObject = function noopObject() {\n  return {};\n};\n/**\n * Function returns Promise.reject()\n */\n\nvar noopPromiseReject = function noopPromiseReject() {\n  return Promise.reject();\n}; // eslint-disable-line compat/compat\n\n/**\n * Returns Promise object that is resolved with an empty response\n */\n// eslint-disable-next-line compat/compat\n\nvar noopPromiseResolve = function noopPromiseResolve() {\n  return Promise.resolve(new Response());\n};\n\n/* eslint-disable no-console, no-underscore-dangle */\n\n/**\n * Hit used only for debug purposes now\n * @param {Source} source\n * @param {string} [message] - optional message;\n * use LOG_MARKER = 'log: ' at the start of a message\n * for logging scriptlets\n */\nvar hit = function hit(source, message) {\n  if (source.verbose !== true) {\n    return;\n  }\n\n  try {\n    var log = console.log.bind(console);\n    var trace = console.trace.bind(console); // eslint-disable-line compat/compat\n\n    var prefix = source.ruleText || '';\n\n    if (source.domainName) {\n      var AG_SCRIPTLET_MARKER = '#%#//';\n      var UBO_SCRIPTLET_MARKER = '##+js';\n      var ruleStartIndex;\n\n      if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {\n        ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);\n      } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {\n        ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);\n      } // delete all domains from ruleText and leave just rule part\n\n\n      var rulePart = source.ruleText.slice(ruleStartIndex); // prepare applied scriptlet rule for specific domain\n\n      prefix = \"\".concat(source.domainName).concat(rulePart);\n    } // Used to check if scriptlet uses 'hit' function for logging\n\n\n    var LOG_MARKER = 'log: ';\n\n    if (message) {\n      if (message.indexOf(LOG_MARKER) === -1) {\n        log(\"\".concat(prefix, \" message:\\n\").concat(message));\n      } else {\n        log(message.slice(LOG_MARKER.length));\n      }\n    }\n\n    log(\"\".concat(prefix, \" trace start\"));\n\n    if (trace) {\n      trace();\n    }\n\n    log(\"\".concat(prefix, \" trace end\"));\n  } catch (e) {// try catch for Edge 15\n    // In according to this issue https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14495220/\n    // console.log throws an error\n  } // This is necessary for unit-tests only!\n\n\n  if (typeof window.__debug === 'function') {\n    window.__debug(source);\n  }\n};\n\n/**\n * DOM tree changes observer. Used for 'remove-attr' and 'remove-class' scriptlets\n * @param {Function} callback\n * @param {Boolean} observeAttrs - optional parameter - should observer check attibutes changes\n */\nvar observeDOMChanges = function observeDOMChanges(callback) {\n  var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var attrsToObserv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  /**\n   * Returns a wrapper, passing the call to 'method' at maximum once per 'delay' milliseconds.\n   * Those calls that fall into the \"cooldown\" period, are ignored\n   * @param {Function} method\n   * @param {Number} delay - milliseconds\n   */\n  var throttle = function throttle(method, delay) {\n    var wait = false;\n    var savedArgs;\n\n    var wrapper = function wrapper() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (wait) {\n        savedArgs = args;\n        return;\n      }\n\n      method.apply(void 0, args);\n      wait = true;\n      setTimeout(function () {\n        wait = false;\n\n        if (savedArgs) {\n          wrapper(savedArgs);\n          savedArgs = null;\n        }\n      }, delay);\n    };\n\n    return wrapper;\n  };\n  /**\n   * 'delay' in milliseconds for 'throttle' method\n   */\n\n\n  var THROTTLE_DELAY_MS = 20;\n  /**\n   * Used for remove-class\n   */\n  // eslint-disable-next-line no-use-before-define, compat/compat\n\n  var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));\n\n  var connect = function connect() {\n    if (attrsToObserv.length > 0) {\n      observer.observe(document.documentElement, {\n        childList: true,\n        subtree: true,\n        attributes: observeAttrs,\n        attributeFilter: attrsToObserv\n      });\n    } else {\n      observer.observe(document.documentElement, {\n        childList: true,\n        subtree: true,\n        attributes: observeAttrs\n      });\n    }\n  };\n\n  var disconnect = function disconnect() {\n    observer.disconnect();\n  };\n\n  function callbackWrapper() {\n    disconnect();\n    callback();\n    connect();\n  }\n\n  connect();\n};\n\n/**\n * Checks if the stackTrace contains stackRegexp\n * // https://github.com/AdguardTeam/Scriptlets/issues/82\n * @param {string|undefined} stackMatch - input stack value to match\n * @param {string} stackTrace - script error stack trace\n * @returns {boolean}\n */\n\nvar matchStackTrace = function matchStackTrace(stackMatch, stackTrace) {\n  if (!stackMatch || stackMatch === '') {\n    return true;\n  }\n\n  var stackRegexp = toRegExp(stackMatch);\n  var refinedStackTrace = stackTrace.split('\\n').slice(2) // get rid of our own functions in the stack trace\n  .map(function (line) {\n    return line.trim();\n  }) // trim the lines\n  .join('\\n');\n  return stackRegexp.test(refinedStackTrace);\n};\n\n/**\n * Some browsers do not support Array.prototype.flat()\n * for example, Opera 42 which is used for browserstack tests\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\n * @param {Array} input\n */\nvar flatten = function flatten(input) {\n  var stack = [];\n  input.forEach(function (el) {\n    return stack.push(el);\n  });\n  var res = [];\n\n  while (stack.length) {\n    // pop value from stack\n    var next = stack.pop();\n\n    if (Array.isArray(next)) {\n      // push back array items, won't modify the original input\n      next.forEach(function (el) {\n        return stack.push(el);\n      });\n    } else {\n      res.push(next);\n    }\n  } // reverse to restore input order\n\n\n  return res.reverse();\n};\n\n/**\n * Finds shadow-dom host (elements with shadowRoot property) in DOM of rootElement.\n * @param {HTMLElement} rootElement\n * @returns {HTMLElement[]} shadow-dom hosts\n */\n\nvar findHostElements = function findHostElements(rootElement) {\n  var hosts = []; // Element.querySelectorAll() returns list of elements\n  // which are defined in DOM of Element.\n  // Meanwhile, inner DOM of the element with shadowRoot property\n  // is absolutely another DOM and which can not be reached by querySelectorAll('*')\n\n  var domElems = rootElement.querySelectorAll('*');\n  domElems.forEach(function (el) {\n    if (el.shadowRoot) {\n      hosts.push(el);\n    }\n  });\n  return hosts;\n};\n/**\n * A collection of nodes.\n *\n * @external NodeList\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/NodeList NodeList}\n */\n\n/**\n * @typedef {Object} PierceData\n * @property {HTMLElement[]} targets found elements that match the specified selector\n * @property {HTMLElement[]} innerHosts inner shadow-dom hosts\n */\n\n/**\n * Pierces open shadow-dom in order to find:\n * - elements by 'selector' matching\n * - inner shadow-dom hosts\n * @param {string} selector\n * @param {HTMLElement[]|external:NodeList} hostElements\n * @returns {PierceData}\n */\n\nvar pierceShadowDom = function pierceShadowDom(selector, hostElements) {\n  var targets = [];\n  var innerHostsAcc = []; // it's possible to get a few hostElements found by baseSelector on the page\n\n  hostElements.forEach(function (host) {\n    // check presence of selector element inside base element if it's not in shadow-dom\n    var simpleElems = host.querySelectorAll(selector);\n    targets = targets.concat([].slice.call(simpleElems));\n    var shadowRootElem = host.shadowRoot;\n    var shadowChildren = shadowRootElem.querySelectorAll(selector);\n    targets = targets.concat([].slice.call(shadowChildren)); // find inner shadow-dom hosts inside processing shadow-dom\n\n    innerHostsAcc.push(findHostElements(shadowRootElem));\n  }); // if there were more than one host element,\n  // innerHostsAcc is an array of arrays and should be flatten\n\n  var innerHosts = flatten(innerHostsAcc);\n  return {\n    targets: targets,\n    innerHosts: innerHosts\n  };\n};\n\n/**\n * Prepares cookie string if given parameters are ok\n * @param {string} name cookie name to set\n * @param {string} value cookie value to set\n * @returns {string|null} cookie string if ok OR null if not\n */\n\nvar prepareCookie = function prepareCookie(name, value) {\n  if (!name || !value) {\n    return null;\n  }\n\n  var valueToSet;\n\n  if (value === 'true') {\n    valueToSet = 'true';\n  } else if (value === 'True') {\n    valueToSet = 'True';\n  } else if (value === 'false') {\n    valueToSet = 'false';\n  } else if (value === 'False') {\n    valueToSet = 'False';\n  } else if (value === 'yes') {\n    valueToSet = 'yes';\n  } else if (value === 'Yes') {\n    valueToSet = 'Yes';\n  } else if (value === 'Y') {\n    valueToSet = 'Y';\n  } else if (value === 'no') {\n    valueToSet = 'no';\n  } else if (value === 'ok') {\n    valueToSet = 'ok';\n  } else if (value === 'OK') {\n    valueToSet = 'OK';\n  } else if (/^\\d+$/.test(value)) {\n    valueToSet = parseFloat(value);\n\n    if (nativeIsNaN(valueToSet)) {\n      return null;\n    }\n\n    if (Math.abs(valueToSet) < 0 || Math.abs(valueToSet) > 15) {\n      return null;\n    }\n  } else {\n    return null;\n  }\n\n  var pathToSet = 'path=/;';\n  var cookieData = \"\".concat(encodeURIComponent(name), \"=\").concat(encodeURIComponent(valueToSet), \"; \").concat(pathToSet);\n  return cookieData;\n};\n\nvar shouldMatchAnyDelay = function shouldMatchAnyDelay(delay) {\n  return delay === getWildcardSymbol();\n};\n/**\n * Handles input delay value\n * @param {*} delay\n * @returns {number} proper number delay value\n */\n\nvar getMatchDelay = function getMatchDelay(delay) {\n  var DEFAULT_DELAY = 1000;\n  var parsedDelay = parseInt(delay, 10);\n  var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY // default scriptlet value\n  : parsedDelay;\n  return delayMatch;\n};\n/**\n * Checks delay match condition\n * @param {*} inputDelay\n * @param {number} realDelay\n * @returns {boolean}\n */\n\nvar isDelayMatched = function isDelayMatched(inputDelay, realDelay) {\n  return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);\n};\n/**\n * Handles input boost value\n * @param {*} boost\n * @returns {number} proper number boost multiplier value\n */\n\nvar getBoostMultiplier = function getBoostMultiplier(boost) {\n  var DEFAULT_MULTIPLIER = 0.05;\n  var MIN_MULTIPLIER = 0.02;\n  var MAX_MULTIPLIER = 50;\n  var parsedBoost = parseFloat(boost);\n  var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER // default scriptlet value\n  : parsedBoost;\n\n  if (boostMultiplier < MIN_MULTIPLIER) {\n    boostMultiplier = MIN_MULTIPLIER;\n  }\n\n  if (boostMultiplier > MAX_MULTIPLIER) {\n    boostMultiplier = MAX_MULTIPLIER;\n  }\n\n  return boostMultiplier;\n};\n\n/**\n * Collects Request options to object\n * @param {Request} request\n * @returns {Object} data object\n */\n\nvar getRequestData = function getRequestData(request) {\n  var REQUEST_INIT_OPTIONS = ['url', 'method', 'headers', 'body', 'mode', 'credentials', 'cache', 'redirect', 'referrer', 'integrity'];\n  var entries = REQUEST_INIT_OPTIONS.map(function (key) {\n    // if request has no such option, value will be undefined\n    var value = request[key];\n    return [key, value];\n  });\n  return getObjectFromEntries(entries);\n};\n/**\n * Collects fetch args to object\n * @param {*} args fetch args\n * @returns {Object} data object\n */\n\nvar getFetchData = function getFetchData(args) {\n  var fetchPropsObj = {};\n  var fetchUrl;\n  var fetchInit;\n\n  if (args[0] instanceof Request) {\n    // if Request passed to fetch, it will be in array\n    var requestData = getRequestData(args[0]);\n    fetchUrl = requestData.url;\n    fetchInit = requestData;\n  } else {\n    fetchUrl = args[0]; // eslint-disable-line prefer-destructuring\n\n    fetchInit = args[1]; // eslint-disable-line prefer-destructuring\n  }\n\n  fetchPropsObj.url = fetchUrl;\n\n  if (fetchInit instanceof Object) {\n    Object.keys(fetchInit).forEach(function (prop) {\n      fetchPropsObj[prop] = fetchInit[prop];\n    });\n  }\n\n  return fetchPropsObj;\n};\n/**\n * Converts prevent-fetch propsToMatch input string to object\n * @param {string} propsToMatchStr\n * @returns {Object} object where 'key' is prop name and 'value' is prop value\n */\n\nvar convertMatchPropsToObj = function convertMatchPropsToObj(propsToMatchStr) {\n  var PROPS_DIVIDER = ' ';\n  var PAIRS_MARKER = ':';\n  var propsObj = {};\n  var props = propsToMatchStr.split(PROPS_DIVIDER);\n  props.forEach(function (prop) {\n    var dividerInd = prop.indexOf(PAIRS_MARKER);\n\n    if (dividerInd === -1) {\n      propsObj.url = toRegExp(prop);\n    } else {\n      var key = prop.slice(0, dividerInd);\n      var value = prop.slice(dividerInd + 1);\n      propsObj[key] = toRegExp(value);\n    }\n  });\n  return propsObj;\n};\n\nvar handleOldReplacement = function handleOldReplacement(replacement) {\n  var result; // defaults to return noopFunc instead of window.open\n\n  if (!replacement) {\n    result = noopFunc;\n  } else if (replacement === 'trueFunc') {\n    result = trueFunc;\n  } else if (replacement.indexOf('=') > -1) {\n    // We should return noopFunc instead of window.open\n    // but with some property if website checks it (examples 5, 6)\n    // https://github.com/AdguardTeam/Scriptlets/issues/71\n    var isProp = startsWith(replacement, '{') && endsWith(replacement, '}');\n\n    if (isProp) {\n      var propertyPart = replacement.slice(1, -1);\n      var propertyName = substringBefore(propertyPart, '=');\n      var propertyValue = substringAfter(propertyPart, '=');\n\n      if (propertyValue === 'noopFunc') {\n        result = {};\n        result[propertyName] = noopFunc;\n      }\n    }\n  }\n\n  return result;\n};\nvar createDecoy = function createDecoy(args) {\n  var OBJECT_TAG_NAME = 'object';\n  var OBJECT_URL_PROP_NAME = 'data';\n  var IFRAME_TAG_NAME = 'iframe';\n  var IFRAME_URL_PROP_NAME = 'src';\n  var replacement = args.replacement,\n      url = args.url,\n      delay = args.delay;\n  var tag;\n  var urlProp;\n\n  if (replacement === 'obj') {\n    tag = OBJECT_TAG_NAME;\n    urlProp = OBJECT_URL_PROP_NAME;\n  } else {\n    tag = IFRAME_TAG_NAME;\n    urlProp = IFRAME_URL_PROP_NAME;\n  }\n\n  var decoy = document.createElement(tag);\n  decoy[urlProp] = url;\n  decoy.style.setProperty('height', '1px', 'important');\n  decoy.style.setProperty('position', 'fixed', 'important');\n  decoy.style.setProperty('top', '-1px', 'important');\n  decoy.style.setProperty('width', '1px', 'important');\n  document.body.appendChild(decoy);\n  setTimeout(function () {\n    return decoy.remove();\n  }, delay * 1000);\n  return decoy;\n};\nvar getPreventGetter = function getPreventGetter(nativeGetter) {\n  var preventGetter = function preventGetter(target, prop) {\n    if (prop && prop === 'closed') {\n      return false;\n    }\n\n    if (typeof nativeGetter === 'function') {\n      return noopFunc;\n    }\n\n    return prop && target[prop];\n  };\n\n  return preventGetter;\n};\n\n/**\n * Validates event type\n * @param {*} type\n * @returns {boolean}\n */\nvar validateType = function validateType(type) {\n  // https://github.com/AdguardTeam/Scriptlets/issues/125\n  return typeof type !== 'undefined';\n};\n/**\n * Validates event listener\n * @param {*} listener\n * @returns {boolean}\n */\n\nvar validateListener = function validateListener(listener) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters\n  return typeof listener !== 'undefined' && (typeof listener === 'function' || typeof listener === 'object' // https://github.com/AdguardTeam/Scriptlets/issues/76\n  && listener !== null && typeof listener.handleEvent === 'function');\n};\n/**\n * Serialize valid event listener\n * https://developer.mozilla.org/en-US/docs/Web/API/EventListener\n * @param {EventListener} listener valid listener\n * @returns {string}\n */\n\nvar listenerToString = function listenerToString(listener) {\n  return typeof listener === 'function' ? listener.toString() : listener.handleEvent.toString();\n};\n\n/**\n * This file must export all used dependencies\n */\n\nvar dependencies = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getWildcardSymbol: getWildcardSymbol,\n    randomId: randomId,\n    setPropertyAccess: setPropertyAccess,\n    getPropertyInChain: getPropertyInChain,\n    getWildcardPropertyInChain: getWildcardPropertyInChain,\n    replaceAll: replaceAll,\n    escapeRegExp: escapeRegExp,\n    toRegExp: toRegExp,\n    getBeforeRegExp: getBeforeRegExp,\n    startsWith: startsWith,\n    endsWith: endsWith,\n    substringAfter: substringAfter,\n    substringBefore: substringBefore,\n    wrapInSingleQuotes: wrapInSingleQuotes,\n    getStringInBraces: getStringInBraces,\n    convertRtcConfigToString: convertRtcConfigToString,\n    parseMatchArg: parseMatchArg,\n    parseDelayArg: parseDelayArg,\n    objectToString: objectToString,\n    convertTypeToString: convertTypeToString,\n    createOnErrorHandler: createOnErrorHandler,\n    noopFunc: noopFunc,\n    noopNull: noopNull,\n    trueFunc: trueFunc,\n    falseFunc: falseFunc,\n    noopThis: noopThis,\n    noopStr: noopStr,\n    noopArray: noopArray,\n    noopObject: noopObject,\n    noopPromiseReject: noopPromiseReject,\n    noopPromiseResolve: noopPromiseResolve,\n    hit: hit,\n    observeDOMChanges: observeDOMChanges,\n    matchStackTrace: matchStackTrace,\n    findHostElements: findHostElements,\n    pierceShadowDom: pierceShadowDom,\n    flatten: flatten,\n    prepareCookie: prepareCookie,\n    nativeIsNaN: nativeIsNaN,\n    nativeIsFinite: nativeIsFinite,\n    shouldMatchAnyDelay: shouldMatchAnyDelay,\n    getMatchDelay: getMatchDelay,\n    isDelayMatched: isDelayMatched,\n    getBoostMultiplier: getBoostMultiplier,\n    getRequestData: getRequestData,\n    getFetchData: getFetchData,\n    convertMatchPropsToObj: convertMatchPropsToObj,\n    getObjectEntries: getObjectEntries,\n    getObjectFromEntries: getObjectFromEntries,\n    isEmptyObject: isEmptyObject,\n    handleOldReplacement: handleOldReplacement,\n    createDecoy: createDecoy,\n    getPreventGetter: getPreventGetter,\n    validateType: validateType,\n    validateListener: validateListener,\n    listenerToString: listenerToString\n});\n\n/**\n * Concat dependencies to scriptlet code\n * @param {string} scriptlet string view of scriptlet\n */\n\nfunction attachDependencies(scriptlet) {\n  var _scriptlet$injections = scriptlet.injections,\n      injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;\n  return injections.reduce(function (accum, dep) {\n    return \"\".concat(accum, \"\\n\").concat(dependencies[dep.name]);\n  }, scriptlet.toString());\n}\n/**\n * Add scriptlet call to existing code\n * @param {Function} scriptlet\n * @param {string} code\n */\n\nfunction addCall(scriptlet, code) {\n  return \"\".concat(code, \";\\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\\n        \").concat(scriptlet.name, \".apply(this, updatedArgs);\\n    \");\n}\n/**\n * Wrap function into IIFE (Immediately invoked function expression)\n *\n * @param {Source} source - object with scriptlet properties\n * @param {string} code - scriptlet source code with dependencies\n *\n * @returns {string} full scriptlet code\n *\n * @example\n * const source = {\n *      args: [\"aaa\", \"bbb\"],\n *      name: 'noeval',\n * };\n * const code = \"function noeval(source, args) { alert(source); } noeval.apply(this, args);\"\n * const result = wrapInIIFE(source, code);\n *\n * // result\n * `(function(source, args) {\n *      function noeval(source) { alert(source); }\n *      noeval.apply(this, args);\n * )({\"args\": [\"aaa\", \"bbb\"], \"name\":\"noeval\"}, [\"aaa\", \"bbb\"])`\n */\n\nfunction passSourceAndProps(source, code) {\n  if (source.hit) {\n    source.hit = source.hit.toString();\n  }\n\n  var sourceString = JSON.stringify(source);\n  var argsString = source.args ? \"[\".concat(source.args.map(JSON.stringify), \"]\") : undefined;\n  var params = argsString ? \"\".concat(sourceString, \", \").concat(argsString) : sourceString;\n  return \"(function(source, args){\\n\".concat(code, \"\\n})(\").concat(params, \");\");\n}\n/**\n * Wrap code in no name function\n * @param {string} code which must be wrapped\n */\n\nfunction wrapInNonameFunc(code) {\n  return \"function(source, args){\\n\".concat(code, \"\\n}\");\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defineProperty = _defineProperty;\n\n/**\n * Iterate over iterable argument and evaluate current state with transitions\n * @param {string} init first transition name\n * @param {Array|Collection|string} iterable\n * @param {Object} transitions transtion functions\n * @param {any} args arguments which should be passed to transition functions\n */\nfunction iterateWithTransitions(iterable, transitions, init, args) {\n  var state = init || Object.keys(transitions)[0];\n\n  for (var i = 0; i < iterable.length; i += 1) {\n    state = transitions[state](iterable, i, args);\n  }\n\n  return state;\n}\n/**\n * AdGuard scriptlet rule mask\n */\n\n\nvar ADG_SCRIPTLET_MASK = '#//scriptlet';\n/**\n * Helper to accumulate an array of strings char by char\n */\n\nvar wordSaver = function wordSaver() {\n  var str = '';\n  var strs = [];\n\n  var saveSymb = function saveSymb(s) {\n    str += s;\n    return str;\n  };\n\n  var saveStr = function saveStr() {\n    strs.push(str);\n    str = '';\n  };\n\n  var getAll = function getAll() {\n    return [].concat(strs);\n  };\n\n  return {\n    saveSymb: saveSymb,\n    saveStr: saveStr,\n    getAll: getAll\n  };\n};\n\nvar substringAfter$1 = function substringAfter(str, separator) {\n  if (!str) {\n    return str;\n  }\n\n  var index = str.indexOf(separator);\n  return index < 0 ? '' : str.substring(index + separator.length);\n};\n/**\n * Parse and validate scriptlet rule\n * @param {*} ruleText\n * @returns {{name: string, args: Array<string>}}\n */\n\n\nvar parseRule = function parseRule(ruleText) {\n  var _transitions;\n\n  ruleText = substringAfter$1(ruleText, ADG_SCRIPTLET_MASK);\n  /**\n   * Transition names\n   */\n\n  var TRANSITION = {\n    OPENED: 'opened',\n    PARAM: 'param',\n    CLOSED: 'closed'\n  };\n  /**\n   * Transition function: the current index position in start, end or between params\n   * @param {string} rule\n   * @param {number} index\n   * @param {Object} Object\n   * @property {Object} Object.sep contains prop symb with current separator char\n   */\n\n  var opened = function opened(rule, index, _ref) {\n    var sep = _ref.sep;\n    var char = rule[index];\n    var transition;\n\n    switch (char) {\n      case ' ':\n      case '(':\n      case ',':\n        {\n          transition = TRANSITION.OPENED;\n          break;\n        }\n\n      case '\\'':\n      case '\"':\n        {\n          sep.symb = char;\n          transition = TRANSITION.PARAM;\n          break;\n        }\n\n      case ')':\n        {\n          transition = index === rule.length - 1 ? TRANSITION.CLOSED : TRANSITION.OPENED;\n          break;\n        }\n\n      default:\n        {\n          throw new Error('The rule is not a scriptlet');\n        }\n    }\n\n    return transition;\n  };\n  /**\n   * Transition function: the current index position inside param\n   * @param {string} rule\n   * @param {number} index\n   * @param {Object} Object\n   * @property {Object} Object.sep contains prop `symb` with current separator char\n   * @property {Object} Object.saver helper which allow to save strings by car by char\n   */\n\n\n  var param = function param(rule, index, _ref2) {\n    var saver = _ref2.saver,\n        sep = _ref2.sep;\n    var char = rule[index];\n\n    switch (char) {\n      case '\\'':\n      case '\"':\n        {\n          var preIndex = index - 1;\n          var before = rule[preIndex];\n\n          if (char === sep.symb && before !== '\\\\') {\n            sep.symb = null;\n            saver.saveStr();\n            return TRANSITION.OPENED;\n          }\n        }\n      // eslint-disable-next-line no-fallthrough\n\n      default:\n        {\n          saver.saveSymb(char);\n          return TRANSITION.PARAM;\n        }\n    }\n  };\n\n  var transitions = (_transitions = {}, defineProperty(_transitions, TRANSITION.OPENED, opened), defineProperty(_transitions, TRANSITION.PARAM, param), defineProperty(_transitions, TRANSITION.CLOSED, function () {}), _transitions);\n  var sep = {\n    symb: null\n  };\n  var saver = wordSaver();\n  var state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, {\n    sep: sep,\n    saver: saver\n  });\n\n  if (state !== 'closed') {\n    throw new Error(\"Invalid scriptlet rule \".concat(ruleText));\n  }\n\n  var args = saver.getAll();\n  return {\n    name: args[0],\n    args: args.slice(1)\n  };\n};\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet abort-on-property-read\n *\n * @description\n * Aborts a script when it attempts to **read** the specified property.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-readjs-\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L864\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('abort-on-property-read', property[, stack])\n * ```\n *\n * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`\n * - `stack` - optional, string or regular expression that must match the current function call stack trace\n *\n * **Examples**\n * ```\n * ! Aborts script when it tries to access `window.alert`\n * example.org#%#//scriptlet('abort-on-property-read', 'alert')\n *\n * ! Aborts script when it tries to access `navigator.language`\n * example.org#%#//scriptlet('abort-on-property-read', 'navigator.language')\n *\n * ! Aborts script when it tries to access `window.adblock` and it's error stack trace contains `test.js`\n * example.org#%#//scriptlet('abort-on-property-read', 'adblock', 'test.js')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction abortOnPropertyRead(source, property, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var rid = randomId();\n\n  var abort = function abort() {\n    hit(source);\n    throw new ReferenceError(rid);\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    setPropertyAccess(base, prop, {\n      get: abort,\n      set: function set() {}\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\nabortOnPropertyRead.names = ['abort-on-property-read', // aliases are needed for matching the related scriptlet converted into our syntax\n'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'ubo-abort-on-property-read', 'ubo-aopr', 'abp-abort-on-property-read'];\nabortOnPropertyRead.injections = [randomId, toRegExp, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, matchStackTrace];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet abort-on-property-write\n *\n * @description\n * Aborts a script when it attempts to **write** the specified property.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-writejs-\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L896\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('abort-on-property-write', property[, stack])\n * ```\n *\n * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`\n * - `stack` - optional, string or regular expression that must match the current function call stack trace\n *\n * **Examples**\n * ```\n * ! Aborts script when it tries to set `window.adblock` value\n * example.org#%#//scriptlet('abort-on-property-write', 'adblock')\n *\n * ! Aborts script when it tries to set `window.adblock` value and it's error stack trace contains `checking.js`\n * example.org#%#//scriptlet('abort-on-property-write', 'adblock', 'checking.js')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction abortOnPropertyWrite(source, property, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var rid = randomId();\n\n  var abort = function abort() {\n    hit(source);\n    throw new ReferenceError(rid);\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    setPropertyAccess(base, prop, {\n      set: abort\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\nabortOnPropertyWrite.names = ['abort-on-property-write', // aliases are needed for matching the related scriptlet converted into our syntax\n'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'ubo-abort-on-property-write', 'ubo-aopw', 'abp-abort-on-property-write'];\nabortOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-setTimeout\n *\n * @description\n * Prevents a `setTimeout` call if:\n * 1) the text of the callback is matching the specified search string/regexp which does not start with `!`;\n * otherwise mismatched calls should be defused;\n * 2) the timeout is matching the specified delay; otherwise mismatched calls should be defused.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-settimeout-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-setTimeout'[, search[, delay]])\n * ```\n *\n * Call with no arguments will log calls to setTimeout while debugging (`log-setTimeout` superseding),\n * so production filter lists' rules definitely require at least one of the parameters:\n * - `search` - optional, string or regular expression.\n * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.\n * If do not start with `!`, the stringified callback will be matched.\n * If not set, prevents all `setTimeout` calls due to specified `delay`.\n * - `delay` - optional, must be an integer.\n * If starts with `!`, scriptlet will not match the delay but all other will be defused.\n * If do not start with `!`, the delay passed to the `setTimeout` call will be matched.\n *\n * > If `prevent-setTimeout` without parameters logs smth like `setTimeout(undefined, 1000)`,\n * it means that no callback was passed to setTimeout() and that's not scriptlet issue\n *\n * **Examples**\n * 1. Prevents `setTimeout` calls if the callback matches `/\\.test/` regardless of the delay.\n *     ```bash\n *     example.org#%#//scriptlet('prevent-setTimeout', '/\\.test/')\n *     ```\n *\n *     For instance, the following call will be prevented:\n *     ```javascript\n *     setTimeout(function () {\n *         window.test = \"value\";\n *     }, 100);\n *     ```\n *\n * 2. Prevents `setTimeout` calls if the callback does not contain `value`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setTimeout', '!value')\n *     ```\n *\n *     For instance, only the first of the following calls will be prevented:\n *     ```javascript\n *     setTimeout(function () {\n *         window.test = \"test -- prevented\";\n *     }, 300);\n *     setTimeout(function () {\n *         window.test = \"value -- executed\";\n *     }, 400);\n *     setTimeout(function () {\n *         window.value = \"test -- executed\";\n *     }, 500);\n *     ```\n *\n * 3. Prevents `setTimeout` calls if the callback contains `value` and the delay is not set to `300`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setTimeout', 'value', '!300')\n *     ```\n *\n *     For instance, only the first of the following calls will not be prevented:\n *     ```javascript\n *     setTimeout(function () {\n *         window.test = \"value 1 -- executed\";\n *     }, 300);\n *     setTimeout(function () {\n *         window.test = \"value 2 -- prevented\";\n *     }, 400);\n *     setTimeout(function () {\n *         window.test = \"value 3 -- prevented\";\n *     }, 500);\n *     ```\n *\n * 4. Prevents `setTimeout` calls if the callback does not contain `value` and the delay is not set to `300`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setTimeout', '!value', '!300')\n *     ```\n *\n *     For instance, only the second of the following calls will be prevented:\n *     ```javascript\n *     setTimeout(function () {\n *         window.test = \"test -- executed\";\n *     }, 300);\n *     setTimeout(function () {\n *         window.test = \"test -- prevented\";\n *     }, 400);\n *     setTimeout(function () {\n *         window.test = \"value -- executed\";\n *     }, 400);\n *     setTimeout(function () {\n *         window.value = \"test -- executed\";\n *     }, 500);\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventSetTimeout(source, match, delay) {\n  var nativeTimeout = window.setTimeout;\n  var log = console.log.bind(console); // eslint-disable-line no-console\n  // logs setTimeouts to console if no arguments have been specified\n\n  var shouldLog = typeof match === 'undefined' && typeof delay === 'undefined';\n\n  var _parseMatchArg = parseMatchArg(match),\n      isInvertedMatch = _parseMatchArg.isInvertedMatch,\n      matchRegexp = _parseMatchArg.matchRegexp;\n\n  var _parseDelayArg = parseDelayArg(delay),\n      isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,\n      delayMatch = _parseDelayArg.delayMatch;\n\n  var timeoutWrapper = function timeoutWrapper(callback, timeout) {\n    var shouldPrevent = false; // https://github.com/AdguardTeam/Scriptlets/issues/105\n\n    var cbString = String(callback);\n\n    if (shouldLog) {\n      hit(source);\n      log(\"setTimeout(\".concat(cbString, \", \").concat(timeout, \")\"));\n    } else if (!delayMatch) {\n      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch;\n    } else if (!match) {\n      shouldPrevent = timeout === delayMatch !== isInvertedDelayMatch;\n    } else {\n      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch && timeout === delayMatch !== isInvertedDelayMatch;\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return nativeTimeout(noopFunc, timeout);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeTimeout.apply(window, [callback, timeout].concat(args));\n  };\n\n  window.setTimeout = timeoutWrapper;\n}\npreventSetTimeout.names = ['prevent-setTimeout', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-setTimeout-if.js', // new implementation of setTimeout-defuser.js\n'ubo-no-setTimeout-if.js', 'nostif.js', // new short name of no-setTimeout-if\n'ubo-nostif.js', 'ubo-no-setTimeout-if', 'ubo-nostif', // old scriptlet names which should be supported as well.\n// should be removed eventually.\n// do not remove until other filter lists maintainers use them\n'setTimeout-defuser.js', 'ubo-setTimeout-defuser.js', 'ubo-setTimeout-defuser', 'std.js', 'ubo-std.js', 'ubo-std'];\npreventSetTimeout.injections = [hit, noopFunc, parseMatchArg, parseDelayArg, toRegExp, startsWith, nativeIsNaN];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-setInterval\n *\n * @description\n * Prevents a `setInterval` call if:\n * 1) the text of the callback is matching the specified `search` string/regexp which does not start with `!`;\n * otherwise mismatched calls should be defused;\n * 2) the interval is matching the specified `delay`; otherwise mismatched calls should be defused.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setinterval-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-setInterval'[, search[, delay]])\n * ```\n *\n * Call with no arguments will log calls to setInterval while debugging (`log-setInterval` superseding),\n * so production filter lists' rules definitely require at least one of the parameters:\n * - `search` - optional, string or regular expression.\n * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.\n * If do not start with `!`, the stringified callback will be matched.\n * If not set, prevents all `setInterval` calls due to specified `delay`.\n * - `delay` - optional, must be an integer.\n * If starts with `!`, scriptlet will not match the delay but all other will be defused.\n * If do not start with `!`, the delay passed to the `setInterval` call will be matched.\n *\n * > If `prevent-setInterval` without parameters logs smth like `setInterval(undefined, 1000)`,\n * it means that no callback was passed to setInterval() and that's not scriptlet issue\n\n *  **Examples**\n * 1. Prevents `setInterval` calls if the callback matches `/\\.test/` regardless of the delay.\n *     ```bash\n *     example.org#%#//scriptlet('prevent-setInterval', '/\\.test/')\n *     ```\n *\n *     For instance, the following call will be prevented:\n *     ```javascript\n *     setInterval(function () {\n *         window.test = \"value\";\n *     }, 100);\n *     ```\n *\n * 2. Prevents `setInterval` calls if the callback does not contain `value`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setInterval', '!value')\n *     ```\n *\n *     For instance, only the first of the following calls will be prevented:\n *     ```javascript\n *     setInterval(function () {\n *         window.test = \"test -- prevented\";\n *     }, 300);\n *     setInterval(function () {\n *         window.test = \"value -- executed\";\n *     }, 400);\n *     setInterval(function () {\n *         window.value = \"test -- executed\";\n *     }, 500);\n *     ```\n *\n * 3. Prevents `setInterval` calls if the callback contains `value` and the delay is not set to `300`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setInterval', 'value', '!300')\n *     ```\n *\n *     For instance, only the first of the following calls will not be prevented:\n *     ```javascript\n *     setInterval(function () {\n *         window.test = \"value 1 -- executed\";\n *     }, 300);\n *     setInterval(function () {\n *         window.test = \"value 2 -- prevented\";\n *     }, 400);\n *     setInterval(function () {\n *         window.test = \"value 3 -- prevented\";\n *     }, 500);\n *     ```\n *\n * 4. Prevents `setInterval` calls if the callback does not contain `value` and the delay is not set to `300`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setInterval', '!value', '!300')\n *     ```\n *\n *     For instance, only the second of the following calls will be prevented:\n *     ```javascript\n *     setInterval(function () {\n *         window.test = \"test -- executed\";\n *     }, 300);\n *     setInterval(function () {\n *         window.test = \"test -- prevented\";\n *     }, 400);\n *     setInterval(function () {\n *         window.test = \"value -- executed\";\n *     }, 400);\n *     setInterval(function () {\n *         window.value = \"test -- executed\";\n *     }, 500);\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventSetInterval(source, match, delay) {\n  var nativeInterval = window.setInterval;\n  var log = console.log.bind(console); // eslint-disable-line no-console\n  // logs setIntervals to console if no arguments have been specified\n\n  var shouldLog = typeof match === 'undefined' && typeof delay === 'undefined';\n\n  var _parseMatchArg = parseMatchArg(match),\n      isInvertedMatch = _parseMatchArg.isInvertedMatch,\n      matchRegexp = _parseMatchArg.matchRegexp;\n\n  var _parseDelayArg = parseDelayArg(delay),\n      isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,\n      delayMatch = _parseDelayArg.delayMatch;\n\n  var intervalWrapper = function intervalWrapper(callback, interval) {\n    var shouldPrevent = false; // https://github.com/AdguardTeam/Scriptlets/issues/105\n\n    var cbString = String(callback);\n\n    if (shouldLog) {\n      hit(source);\n      log(\"setInterval(\".concat(cbString, \", \").concat(interval, \")\"));\n    } else if (!delayMatch) {\n      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch;\n    } else if (!match) {\n      shouldPrevent = interval === delayMatch !== isInvertedDelayMatch;\n    } else {\n      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch && interval === delayMatch !== isInvertedDelayMatch;\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return nativeInterval(noopFunc, interval);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeInterval.apply(window, [callback, interval].concat(args));\n  };\n\n  window.setInterval = intervalWrapper;\n}\npreventSetInterval.names = ['prevent-setInterval', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-setInterval-if.js', // new implementation of setInterval-defuser.js\n'ubo-no-setInterval-if.js', 'setInterval-defuser.js', // old name should be supported as well\n'ubo-setInterval-defuser.js', 'nosiif.js', // new short name of no-setInterval-if\n'ubo-nosiif.js', 'sid.js', // old short scriptlet name\n'ubo-sid.js', 'ubo-no-setInterval-if', 'ubo-setInterval-defuser', 'ubo-nosiif', 'ubo-sid'];\npreventSetInterval.injections = [hit, noopFunc, parseMatchArg, parseDelayArg, toRegExp, startsWith, nativeIsNaN];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-window-open\n *\n * @description\n * Prevents `window.open` calls when URL either matches or not matches the specified string/regexp. Using it without parameters prevents all `window.open` calls.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#windowopen-defuserjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-window-open'[, match[, delay[, replacement]]])\n * ```\n *\n * - `match` - optional, string or regular expression. If not set, all window.open calls will be matched.\n * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.\n * If do not start with `!`, the stringified callback will be matched.\n * - `delay` - optional, number of seconds. If not set, scriptlet will return `null`,\n * otherwise valid sham window object as injected `iframe` will be returned\n * for accessing it's methods (blur(), focus() etc.) and will be removed after the delay.\n * - `replacement` - optional, string; one of the predefined constants:\n *     - `obj` - for returning an object instead of default iframe;\n *        for cases when the page requires a valid `window` instance to be returned\n *     - `log` - for logging window.open calls; permitted for production filter lists.\n *\n * **Examples**\n * 1. Prevent all `window.open` calls:\n * ```\n *     example.org#%#//scriptlet('prevent-window-open')\n * ```\n *\n * 2. Prevent `window.open` for all URLs containing `example`:\n * ```\n *     example.org#%#//scriptlet('prevent-window-open', 'example')\n * ```\n *\n * 3. Prevent `window.open` for all URLs matching RegExp `/example\\./`:\n * ```\n *     example.org#%#//scriptlet('prevent-window-open', '/example\\./')\n * ```\n *\n * 4. Prevent `window.open` for all URLs **NOT** containing `example`:\n * ```\n *     example.org#%#//scriptlet('prevent-window-open', '!example')\n * ```\n *\n * Old syntax of prevent-window-open parameters:\n * - `match` - optional, defaults to \"matching\", any positive number or nothing for \"matching\", 0 or empty string for \"not matching\"\n * - `search` - optional, string or regexp for matching the URL passed to `window.open` call; defaults to search all `window.open` call\n * - `replacement` - optional, string to return prop value or property instead of window.open; defaults to return noopFunc.\n * **Examples**\n * ```\n *     example.org#%#//scriptlet('prevent-window-open', '1', '/example\\./'\n *     example.org#%#//scriptlet('prevent-window-open', '0', 'example')\n *     example.org#%#//scriptlet('prevent-window-open', '', '', 'trueFunc')\n *     example.org#%#//scriptlet('prevent-window-open', '1', '', '{propName=noopFunc}')\n * ```\n *\n * > For better compatibility with uBO, old syntax is not recommended to use.\n */\n\n/* eslint-enable max-len */\n\nfunction preventWindowOpen(source) {\n  var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getWildcardSymbol();\n  var delay = arguments.length > 2 ? arguments[2] : undefined;\n  var replacement = arguments.length > 3 ? arguments[3] : undefined;\n  // default match value is needed for preventing all window.open calls\n  // if scriptlet runs without args\n  var nativeOpen = window.open;\n  var isNewSyntax = match !== '0' && match !== '1';\n\n  var oldOpenWrapper = function oldOpenWrapper(str) {\n    match = Number(match) > 0; // 'delay' was 'search' prop for matching in old syntax\n\n    var searchRegexp = toRegExp(delay);\n\n    if (match !== searchRegexp.test(str)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOpen.apply(window, [str].concat(args));\n    }\n\n    hit(source);\n    return handleOldReplacement(replacement);\n  };\n\n  var newOpenWrapper = function newOpenWrapper(url) {\n    var shouldLog = replacement && replacement.indexOf('log') > -1;\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    if (shouldLog) {\n      var argsStr = args && args.length > 0 ? \", \".concat(args.join(', ')) : '';\n      var logMessage = \"log: window-open: \".concat(url).concat(argsStr);\n      hit(source, logMessage);\n    }\n\n    var shouldPrevent = false;\n\n    if (match === getWildcardSymbol()) {\n      shouldPrevent = true;\n    } else {\n      var _parseMatchArg = parseMatchArg(match),\n          isInvertedMatch = _parseMatchArg.isInvertedMatch,\n          matchRegexp = _parseMatchArg.matchRegexp;\n\n      shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;\n    }\n\n    if (shouldPrevent) {\n      var parsedDelay = parseInt(delay, 10);\n      var result;\n\n      if (nativeIsNaN(parsedDelay)) {\n        result = noopNull();\n      } else {\n        var decoyArgs = {\n          replacement: replacement,\n          url: url,\n          delay: parsedDelay\n        };\n        var decoy = createDecoy(decoyArgs);\n        var popup = decoy.contentWindow;\n\n        if (typeof popup === 'object' && popup !== null) {\n          Object.defineProperty(popup, 'closed', {\n            value: false\n          });\n        } else {\n          var nativeGetter = decoy.contentWindow && decoy.contentWindow.get;\n          Object.defineProperty(decoy, 'contentWindow', {\n            get: getPreventGetter(nativeGetter)\n          });\n          popup = decoy.contentWindow;\n        }\n\n        result = popup;\n      }\n\n      hit(source);\n      return result;\n    }\n\n    return nativeOpen.apply(window, [url].concat(args));\n  };\n\n  window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;\n}\npreventWindowOpen.names = ['prevent-window-open', // aliases are needed for matching the related scriptlet converted into our syntax\n'window.open-defuser.js', 'ubo-window.open-defuser.js', 'ubo-window.open-defuser', 'nowoif.js', 'ubo-nowoif.js', 'ubo-nowoif'];\npreventWindowOpen.injections = [hit, toRegExp, nativeIsNaN, parseMatchArg, handleOldReplacement, createDecoy, getPreventGetter, noopNull, getWildcardSymbol, noopFunc, trueFunc, startsWith, endsWith, substringBefore, substringAfter];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet abort-current-inline-script\n *\n * @description\n * Aborts an inline script when it attempts to **read** the specified property\n * AND when the contents of the `<script>` element contains the specified\n * text or matches the regular expression.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-current-inline-scriptjs-\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L928\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('abort-current-inline-script', property[, search])\n * ```\n *\n * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`\n * - `search` - optional, string or regular expression that must match the inline script contents. If not set, abort all inline scripts which are trying to access the specified property\n *\n * > Note please that for inline script with addEventListener in it\n * `property` should be set as `EventTarget.prototype.addEventListener`,\n * not just `addEventListener`.\n *\n * **Examples**\n * 1. Aborts all inline scripts trying to access `window.alert`\n *     ```\n *     example.org#%#//scriptlet('abort-current-inline-script', 'alert')\n *     ```\n *\n * 2. Aborts inline scripts which are trying to access `window.alert` and contain `Hello, world`.\n *     ```\n *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', 'Hello, world')\n *     ```\n *\n *     For instance, the following script will be aborted\n *     ```html\n *     <script>alert(\"Hello, world\");</script>\n *     ```\n *\n * 3. Aborts inline scripts which are trying to access `window.alert` and match this regexp: `/Hello.+world/`.\n *     ```\n *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', '/Hello.+world/')\n *     ```\n *\n *     For instance, the following scripts will be aborted:\n *     ```html\n *     <script>alert(\"Hello, big world\");</script>\n *     ```\n *     ```html\n *     <script>alert(\"Hello, little world\");</script>\n *     ```\n *\n *     This script will not be aborted:\n *     ```html\n *     <script>alert(\"Hi, little world\");</script>\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction abortCurrentInlineScript(source, property, search) {\n  var searchRegexp = toRegExp(search);\n  var rid = randomId();\n\n  var getCurrentScript = function getCurrentScript() {\n    if ('currentScript' in document) {\n      return document.currentScript; // eslint-disable-line compat/compat\n    }\n\n    var scripts = document.getElementsByTagName('script');\n    return scripts[scripts.length - 1];\n  };\n\n  var ourScript = getCurrentScript();\n\n  var abort = function abort() {\n    var scriptEl = getCurrentScript();\n\n    if (!scriptEl) {\n      return;\n    }\n\n    var content = scriptEl.textContent; // We are using Node.prototype.textContent property descriptor\n    // to get the real script content\n    // even when document.currentScript.textContent is replaced.\n    // https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-593638991\n\n    try {\n      var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;\n      content = textContentGetter.call(scriptEl);\n    } catch (e) {} // eslint-disable-line no-empty\n\n\n    if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {\n      hit(source);\n      throw new ReferenceError(rid);\n    }\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain; // The scriptlet might be executed before the chain property has been created\n    // (for instance, document.body before the HTML body was loaded).\n    // In this case we're checking whether the base element exists or not\n    // and if not, we simply exit without overriding anything.\n    // e.g. https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-575841092\n\n    if (base instanceof Object === false && base === null) {\n      var props = property.split('.');\n      var propIndex = props.indexOf(prop);\n      var baseName = props[propIndex - 1];\n      console.log(\"The scriptlet had been executed before the \".concat(baseName, \" was loaded.\")); // eslint-disable-line no-console\n\n      return;\n    }\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    var currentValue = base[prop];\n    setPropertyAccess(base, prop, {\n      set: function set(value) {\n        abort();\n        currentValue = value;\n      },\n      get: function get() {\n        abort();\n        return currentValue;\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\nabortCurrentInlineScript.names = ['abort-current-inline-script', // aliases are needed for matching the related scriptlet converted into our syntax\n'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'ubo-abort-current-inline-script', 'ubo-acis', 'abp-abort-current-inline-script'];\nabortCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet set-constant\n *\n * @description\n * Creates a constant property and assigns it one of the values from the predefined list.\n *\n * > Actually, it's not a constant. Please note, that it can be rewritten with a value of a different type.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#set-constantjs-\n *\n * Related ABP snippet:\n * https://github.com/adblockplus/adblockpluscore/blob/adblockpluschrome-3.9.4/lib/content/snippets.js#L1361\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('set-constant', property, value[, stack])\n * ```\n *\n * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`.\n * - `value` - required. Possible values:\n *     - positive decimal integer `<= 32767`\n *     - one of the predefined constants:\n *         - `undefined`\n *         - `false`\n *         - `true`\n *         - `null`\n *         - `emptyObj` - empty object\n *         - `emptyArr` - empty array\n *         - `noopFunc` - function with empty body\n *         - `trueFunc` - function returning true\n *         - `falseFunc` - function returning false\n *         - `''` - empty string\n *         - `-1` - number value `-1`\n * - `stack` - optional, string or regular expression that must match the current function call stack trace\n *\n * **Examples**\n * ```\n * ! window.firstConst === false // this comparision will return false\n * example.org#%#//scriptlet('set-constant', 'firstConst', 'false')\n *\n * ! window.second() === trueFunc // 'second' call will return true\n * example.org#%#//scriptlet('set-constant', 'secondConst', 'trueFunc')\n *\n * ! document.third() === falseFunc  // 'third' call will return false if the method is related to checking.js\n * example.org#%#//scriptlet('set-constant', 'secondConst', 'trueFunc', 'checking.js')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction setConstant(source, property, value, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var emptyArr = noopArray();\n  var emptyObj = noopObject();\n  var constantValue;\n\n  if (value === 'undefined') {\n    constantValue = undefined;\n  } else if (value === 'false') {\n    constantValue = false;\n  } else if (value === 'true') {\n    constantValue = true;\n  } else if (value === 'null') {\n    constantValue = null;\n  } else if (value === 'emptyArr') {\n    constantValue = emptyArr;\n  } else if (value === 'emptyObj') {\n    constantValue = emptyObj;\n  } else if (value === 'noopFunc') {\n    constantValue = noopFunc;\n  } else if (value === 'trueFunc') {\n    constantValue = trueFunc;\n  } else if (value === 'falseFunc') {\n    constantValue = falseFunc;\n  } else if (/^\\d+$/.test(value)) {\n    constantValue = parseFloat(value);\n\n    if (nativeIsNaN(constantValue)) {\n      return;\n    }\n\n    if (Math.abs(constantValue) > 0x7FFF) {\n      return;\n    }\n  } else if (value === '-1') {\n    constantValue = -1;\n  } else if (value === '') {\n    constantValue = '';\n  } else {\n    return;\n  }\n\n  var canceled = false;\n\n  var mustCancel = function mustCancel(value) {\n    if (canceled) {\n      return canceled;\n    }\n\n    canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;\n    return canceled;\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain; // The scriptlet might be executed before the chain property has been created.\n    // In this case we're checking whether the base element exists or not\n    // and if not, we simply exit without overriding anything\n\n    if (base instanceof Object === false && base === null) {\n      // log the reason only while debugging\n      if (source.verbose) {\n        var props = property.split('.');\n        var propIndex = props.indexOf(prop);\n        var baseName = props[propIndex - 1];\n        console.log(\"set-constant failed because the property '\".concat(baseName, \"' does not exist\")); // eslint-disable-line no-console\n      }\n\n      return;\n    }\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    if (mustCancel(base[prop])) {\n      return;\n    }\n\n    hit(source);\n    setPropertyAccess(base, prop, {\n      get: function get() {\n        return constantValue;\n      },\n      set: function set(a) {\n        if (mustCancel(a)) {\n          constantValue = a;\n        }\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n}\nsetConstant.names = ['set-constant', // aliases are needed for matching the related scriptlet converted into our syntax\n'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set', 'abp-override-property-read'];\nsetConstant.injections = [hit, noopArray, noopObject, noopFunc, trueFunc, falseFunc, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet remove-cookie\n *\n * @description\n * Removes current page cookies by passed string matching with name. For current domain and subdomains. Runs on load and before unload.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#cookie-removerjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('remove-cookie'[, match])\n * ```\n *\n * - `match` - optional, string or regex matching the cookie name. If not specified all accessible cookies will be removed.\n *\n * **Examples**\n * 1. Removes all cookies:\n * ```\n *     example.org#%#//scriptlet('remove-cookie')\n * ```\n *\n * 2. Removes cookies which name contains `example` string.\n * ```\n *     example.org#%#//scriptlet('remove-cookie', 'example')\n * ```\n *\n *     For instance this cookie will be removed\n *     ```javascript\n *     document.cookie = '__example=randomValue';\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction removeCookie(source, match) {\n  var matchRegexp = toRegExp(match);\n\n  var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {\n    var cookieSpec = \"\".concat(cookieName, \"=\");\n    var domain1 = \"; domain=\".concat(hostName);\n    var domain2 = \"; domain=.\".concat(hostName);\n    var path = '; path=/';\n    var expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';\n    document.cookie = cookieSpec + expiration;\n    document.cookie = cookieSpec + domain1 + expiration;\n    document.cookie = cookieSpec + domain2 + expiration;\n    document.cookie = cookieSpec + path + expiration;\n    document.cookie = cookieSpec + domain1 + path + expiration;\n    document.cookie = cookieSpec + domain2 + path + expiration;\n    hit(source);\n  };\n\n  var rmCookie = function rmCookie() {\n    document.cookie.split(';').forEach(function (cookieStr) {\n      var pos = cookieStr.indexOf('=');\n\n      if (pos === -1) {\n        return;\n      }\n\n      var cookieName = cookieStr.slice(0, pos).trim();\n\n      if (!matchRegexp.test(cookieName)) {\n        return;\n      }\n\n      var hostParts = document.location.hostname.split('.');\n\n      for (var i = 0; i <= hostParts.length - 1; i += 1) {\n        var hostName = hostParts.slice(i).join('.');\n\n        if (hostName) {\n          removeCookieFromHost(cookieName, hostName);\n        }\n      }\n    });\n  };\n\n  rmCookie();\n  window.addEventListener('beforeunload', rmCookie);\n}\nremoveCookie.names = ['remove-cookie', // aliases are needed for matching the related scriptlet converted into our syntax\n'cookie-remover.js', 'ubo-cookie-remover.js', 'ubo-cookie-remover'];\nremoveCookie.injections = [toRegExp, hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-addEventListener\n *\n * @description\n * Prevents adding event listeners for the specified events and callbacks.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-defuserjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-addEventListener'[, eventSearch[, functionSearch]])\n * ```\n *\n * - `eventSearch` - optional, string or regex matching the event name. If not specified, the scriptlets prevents all event listeners\n * - `functionSearch` - optional, string or regex matching the event listener function body. If not set, the scriptlet prevents all event listeners with event name matching `eventSearch`\n *\n * **Examples**\n * 1. Prevent all `click` listeners:\n * ```\n *     example.org#%#//scriptlet('prevent-addEventListener', 'click')\n * ```\n\n2. Prevent 'click' listeners with the callback body containing `searchString`.\n * ```\n *     example.org#%#//scriptlet('prevent-addEventListener', 'click', 'searchString')\n * ```\n *\n *     For instance, this listener will not be called:\n * ```javascript\n *     el.addEventListener('click', () => {\n *         window.test = 'searchString';\n *     });\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventAddEventListener(source, eventSearch, funcSearch) {\n  var eventSearchRegexp = toRegExp(eventSearch);\n  var funcSearchRegexp = toRegExp(funcSearch);\n  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;\n\n  function addEventListenerWrapper(type, listener) {\n    var shouldPrevent = false;\n\n    if (validateType(type) && validateListener(listener)) {\n      shouldPrevent = eventSearchRegexp.test(type.toString()) && funcSearchRegexp.test(listenerToString(listener));\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return undefined;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeAddEventListener.apply(this, [type, listener].concat(args));\n  }\n\n  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;\n}\npreventAddEventListener.names = ['prevent-addEventListener', // aliases are needed for matching the related scriptlet converted into our syntax\n'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js', 'ubo-addEventListener-defuser', 'ubo-aeld'];\npreventAddEventListener.injections = [hit, toRegExp, validateType, validateListener, listenerToString];\n\n/* eslint-disable consistent-return, no-eval */\n/**\n * @scriptlet prevent-bab\n *\n * @description\n * Prevents BlockAdblock script from detecting an ad blocker.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#bab-defuserjs-\n *\n * It also can be used as `$redirect` sometimes.\n * See [redirect description](../wiki/about-redirects.md#prevent-bab).\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-bab')\n * ```\n */\n\nfunction preventBab(source) {\n  var nativeSetTimeout = window.setTimeout;\n  var babRegex = /\\.bab_elementid.$/;\n\n  var timeoutWrapper = function timeoutWrapper(callback) {\n    if (typeof callback !== 'string' || !babRegex.test(callback)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeSetTimeout.apply(window, [callback].concat(args));\n    }\n\n    hit(source);\n  };\n\n  window.setTimeout = timeoutWrapper;\n  var signatures = [['blockadblock'], ['babasbm'], [/getItem\\('babn'\\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];\n\n  var check = function check(str) {\n    for (var i = 0; i < signatures.length; i += 1) {\n      var tokens = signatures[i];\n      var match = 0;\n\n      for (var j = 0; j < tokens.length; j += 1) {\n        var token = tokens[j];\n        var found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;\n\n        if (found) {\n          match += 1;\n        }\n      }\n\n      if (match / tokens.length >= 0.8) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var nativeEval = window.eval;\n\n  var evalWrapper = function evalWrapper(str) {\n    if (!check(str)) {\n      return nativeEval(str);\n    }\n\n    hit(source);\n    var bodyEl = document.body;\n\n    if (bodyEl) {\n      bodyEl.style.removeProperty('visibility');\n    }\n\n    var el = document.getElementById('babasbmsgx');\n\n    if (el) {\n      el.parentNode.removeChild(el);\n    }\n  };\n\n  window.eval = evalWrapper.bind(window);\n}\npreventBab.names = ['prevent-bab', // aliases are needed for matching the related scriptlet converted into our syntax\n'nobab.js', 'ubo-nobab.js', 'bab-defuser.js', 'ubo-bab-defuser.js', 'ubo-nobab', 'ubo-bab-defuser'];\npreventBab.injections = [hit];\n\n/* eslint-disable no-unused-vars, no-extra-bind, func-names */\n/* eslint-disable max-len */\n\n/**\n * @scriptlet nowebrtc\n *\n * @description\n * Disables WebRTC by overriding `RTCPeerConnection`. The overriden function will log every attempt to create a new connection.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('nowebrtc')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction nowebrtc(source) {\n  var propertyName = '';\n\n  if (window.RTCPeerConnection) {\n    propertyName = 'RTCPeerConnection';\n  } else if (window.webkitRTCPeerConnection) {\n    propertyName = 'webkitRTCPeerConnection';\n  }\n\n  if (propertyName === '') {\n    return;\n  }\n\n  var rtcReplacement = function rtcReplacement(config) {\n    hit(source, \"Document tried to create an RTCPeerConnection: \".concat(convertRtcConfigToString(config)));\n  };\n\n  rtcReplacement.prototype = {\n    close: noopFunc,\n    createDataChannel: noopFunc,\n    createOffer: noopFunc,\n    setRemoteDescription: noopFunc\n  };\n  var rtc = window[propertyName];\n  window[propertyName] = rtcReplacement;\n\n  if (rtc.prototype) {\n    rtc.prototype.createDataChannel = function (a, b) {\n      return {\n        close: noopFunc,\n        send: noopFunc\n      };\n    }.bind(null);\n  }\n}\nnowebrtc.names = ['nowebrtc', // aliases are needed for matching the related scriptlet converted into our syntax\n'nowebrtc.js', 'ubo-nowebrtc.js', 'ubo-nowebrtc'];\nnowebrtc.injections = [hit, noopFunc, convertRtcConfigToString];\n\n/**\n * @scriptlet log-addEventListener\n *\n * @description\n * Logs all addEventListener calls to the console.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-loggerjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('log-addEventListener')\n * ```\n */\n\nfunction logAddEventListener(source) {\n  // eslint-disable-next-line no-console\n  var log = console.log.bind(console);\n  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;\n\n  function addEventListenerWrapper(type, listener) {\n    if (validateType(type) && validateListener(listener)) {\n      var logMessage = \"log: addEventListener(\\\"\".concat(type, \"\\\", \").concat(listenerToString(listener), \")\");\n      hit(source, logMessage);\n    } else if (source.verbose) {\n      // logging while debugging\n      var _logMessage = \"Invalid event type or listener passed to addEventListener:\\ntype: \".concat(convertTypeToString(type), \"\\nlistener: \").concat(convertTypeToString(listener));\n\n      log(_logMessage);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeAddEventListener.apply(this, [type, listener].concat(args));\n  }\n\n  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;\n}\nlogAddEventListener.names = ['log-addEventListener', // aliases are needed for matching the related scriptlet converted into our syntax\n'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js', 'ubo-addEventListener-logger', 'ubo-aell'];\nlogAddEventListener.injections = [hit, validateType, validateListener, listenerToString, convertTypeToString, objectToString, isEmptyObject, getObjectEntries];\n\n/* eslint-disable no-console, no-eval */\n/**\n * @scriptlet log-eval\n *\n * @description\n * Logs all `eval()` or `new Function()` calls to the console.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('log-eval')\n * ```\n */\n\nfunction logEval(source) {\n  var log = console.log.bind(console); // wrap eval function\n\n  var nativeEval = window.eval;\n\n  function evalWrapper(str) {\n    hit(source);\n    log(\"eval(\\\"\".concat(str, \"\\\")\"));\n    return nativeEval(str);\n  }\n\n  window.eval = evalWrapper; // wrap new Function\n\n  var nativeFunction = window.Function;\n\n  function FunctionWrapper() {\n    hit(source);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    log(\"new Function(\".concat(args.join(', '), \")\"));\n    return nativeFunction.apply(this, [].concat(args));\n  }\n\n  FunctionWrapper.prototype = Object.create(nativeFunction.prototype);\n  FunctionWrapper.prototype.constructor = FunctionWrapper;\n  window.Function = FunctionWrapper;\n}\nlogEval.names = ['log-eval'];\nlogEval.injections = [hit];\n\n/**\n * @scriptlet log\n *\n * @description\n * A simple scriptlet which only purpose is to print arguments to console.\n * This scriptlet can be helpful for debugging and troubleshooting other scriptlets.\n *\n * **Example**\n * ```\n * example.org#%#//scriptlet('log', 'arg1', 'arg2')\n * ```\n */\nfunction log() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  console.log(args); // eslint-disable-line no-console\n}\nlog.names = ['log'];\n\n/* eslint-disable no-eval, no-extra-bind */\n/**\n * @scriptlet noeval\n *\n * @description\n * Prevents page to use eval.\n * Notifies about attempts in the console\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#noevaljs-\n *\n * It also can be used as `$redirect` rules sometimes.\n * See [redirect description](../wiki/about-redirects.md#noeval).\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('noeval')\n * ```\n */\n\nfunction noeval(source) {\n  window.eval = function evalWrapper(s) {\n    hit(source, \"AdGuard has prevented eval:\\n\".concat(s));\n  }.bind();\n}\nnoeval.names = ['noeval', // aliases are needed for matching the related scriptlet converted into our syntax\n'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js', 'ubo-noeval', 'ubo-silent-noeval'];\nnoeval.injections = [hit];\n\n/* eslint-disable no-eval, no-extra-bind, func-names */\n/**\n * @scriptlet prevent-eval-if\n *\n * @description\n * Prevents page to use eval matching payload.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#noeval-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-eval-if'[, search])\n * ```\n *\n * - `search` - optional, string or regexp for matching stringified eval payload.\n * If 'search is not specified  all stringified eval payload will be matched\n *\n * **Examples**\n * ```\n * ! Prevents eval if it matches 'test'\n * example.org#%#//scriptlet('prevent-eval-if', 'test')\n * ```\n *\n * @param {string|RegExp} [search] string or regexp matching stringified eval payload\n */\n\nfunction preventEvalIf(source, search) {\n  var searchRegexp = toRegExp(search);\n  var nativeEval = window.eval;\n\n  window.eval = function (payload) {\n    if (!searchRegexp.test(payload.toString())) {\n      return nativeEval.call(window, payload);\n    }\n\n    hit(source, payload);\n    return undefined;\n  }.bind(window);\n}\npreventEvalIf.names = ['prevent-eval-if', // aliases are needed for matching the related scriptlet converted into our syntax\n'noeval-if.js', 'ubo-noeval-if.js', 'ubo-noeval-if'];\npreventEvalIf.injections = [toRegExp, hit];\n\n/* eslint-disable no-console, func-names, no-multi-assign */\n/**\n * @scriptlet prevent-fab-3.2.0\n *\n * @description\n * Prevents execution of the FAB script v3.2.0.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#fuckadblockjs-320-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-fab-3.2.0')\n * ```\n */\n\nfunction preventFab(source) {\n  hit(source); // redefines Fab function for adblock detection\n\n  var Fab = function Fab() {};\n\n  Fab.prototype.check = noopFunc;\n  Fab.prototype.clearEvent = noopFunc;\n  Fab.prototype.emitEvent = noopFunc;\n\n  Fab.prototype.on = function (a, b) {\n    if (!a) {\n      b();\n    }\n\n    return this;\n  };\n\n  Fab.prototype.onDetected = noopThis;\n\n  Fab.prototype.onNotDetected = function (a) {\n    a();\n    return this;\n  };\n\n  Fab.prototype.setOption = noopFunc;\n  Fab.prototype.options = {\n    set: noopFunc,\n    get: noopFunc\n  };\n  var fab = new Fab();\n  var getSetFab = {\n    get: function get() {\n      return Fab;\n    },\n    set: function set() {}\n  };\n  var getsetfab = {\n    get: function get() {\n      return fab;\n    },\n    set: function set() {}\n  }; // redefined Fab data properties which if 'FuckAdBlock' variable exists\n\n  if (Object.prototype.hasOwnProperty.call(window, 'FuckAdBlock')) {\n    window.FuckAdBlock = Fab;\n  } else {\n    // or redefined Fab accessor properties\n    Object.defineProperty(window, 'FuckAdBlock', getSetFab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'BlockAdBlock')) {\n    window.BlockAdBlock = Fab;\n  } else {\n    Object.defineProperty(window, 'BlockAdBlock', getSetFab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'SniffAdBlock')) {\n    window.SniffAdBlock = Fab;\n  } else {\n    Object.defineProperty(window, 'SniffAdBlock', getSetFab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'fuckAdBlock')) {\n    window.fuckAdBlock = fab;\n  } else {\n    Object.defineProperty(window, 'fuckAdBlock', getsetfab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'blockAdBlock')) {\n    window.blockAdBlock = fab;\n  } else {\n    Object.defineProperty(window, 'blockAdBlock', getsetfab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'sniffAdBlock')) {\n    window.sniffAdBlock = fab;\n  } else {\n    Object.defineProperty(window, 'sniffAdBlock', getsetfab);\n  }\n}\npreventFab.names = ['prevent-fab-3.2.0', // aliases are needed for matching the related scriptlet converted into our syntax\n'nofab.js', 'ubo-nofab.js', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'ubo-nofab'];\npreventFab.injections = [hit, noopFunc, noopThis];\n\n/* eslint-disable no-console, func-names, no-multi-assign */\n/**\n * @scriptlet set-popads-dummy\n *\n * @description\n * Sets static properties PopAds and popns.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#popads-dummyjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('set-popads-dummy')\n * ```\n */\n\nfunction setPopadsDummy(source) {\n  delete window.PopAds;\n  delete window.popns;\n  Object.defineProperties(window, {\n    PopAds: {\n      get: function get() {\n        hit(source);\n        return {};\n      }\n    },\n    popns: {\n      get: function get() {\n        hit(source);\n        return {};\n      }\n    }\n  });\n}\nsetPopadsDummy.names = ['set-popads-dummy', // aliases are needed for matching the related scriptlet converted into our syntax\n'popads-dummy.js', 'ubo-popads-dummy.js', 'ubo-popads-dummy'];\nsetPopadsDummy.injections = [hit];\n\n/**\n * @scriptlet prevent-popads-net\n *\n * @description\n * Aborts on property write (PopAds, popns), throws reference error with random id.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#popadsnetjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-popads-net')\n * ```\n */\n\nfunction preventPopadsNet(source) {\n  var rid = randomId();\n\n  var throwError = function throwError() {\n    throw new ReferenceError(rid);\n  };\n\n  delete window.PopAds;\n  delete window.popns;\n  Object.defineProperties(window, {\n    PopAds: {\n      set: throwError\n    },\n    popns: {\n      set: throwError\n    }\n  });\n  window.onerror = createOnErrorHandler(rid).bind();\n  hit(source);\n}\npreventPopadsNet.names = ['prevent-popads-net', // aliases are needed for matching the related scriptlet converted into our syntax\n'popads.net.js', 'ubo-popads.net.js', 'ubo-popads.net'];\npreventPopadsNet.injections = [createOnErrorHandler, randomId, hit];\n\n/* eslint-disable func-names */\n/**\n * @scriptlet prevent-adfly\n *\n * @description\n * Prevents anti-adblock scripts on adfly short links.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#adfly-defuserjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-adfly')\n * ```\n */\n\nfunction preventAdfly(source) {\n  var isDigit = function isDigit(data) {\n    return /^\\d$/.test(data);\n  };\n\n  var handler = function handler(encodedURL) {\n    var evenChars = '';\n    var oddChars = '';\n\n    for (var i = 0; i < encodedURL.length; i += 1) {\n      if (i % 2 === 0) {\n        evenChars += encodedURL.charAt(i);\n      } else {\n        oddChars = encodedURL.charAt(i) + oddChars;\n      }\n    }\n\n    var data = (evenChars + oddChars).split('');\n\n    for (var _i = 0; _i < data.length; _i += 1) {\n      if (isDigit(data[_i])) {\n        for (var ii = _i + 1; ii < data.length; ii += 1) {\n          if (isDigit(data[ii])) {\n            // eslint-disable-next-line no-bitwise\n            var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);\n\n            if (temp < 10) {\n              data[_i] = temp.toString();\n            }\n\n            _i = ii;\n            break;\n          }\n        }\n      }\n    }\n\n    data = data.join('');\n    var decodedURL = window.atob(data).slice(16, -16);\n    /* eslint-disable compat/compat */\n\n    if (window.stop) {\n      window.stop();\n    }\n    /* eslint-enable compat/compat */\n\n\n    window.onbeforeunload = null;\n    window.location.href = decodedURL;\n  };\n\n  var val; // Do not apply handler more than one time\n\n  var applyHandler = true;\n  var result = setPropertyAccess(window, 'ysmm', {\n    configurable: false,\n    set: function set(value) {\n      if (applyHandler) {\n        applyHandler = false;\n\n        try {\n          if (typeof value === 'string') {\n            handler(value);\n          }\n        } catch (err) {} // eslint-disable-line no-empty\n\n      }\n\n      val = value;\n    },\n    get: function get() {\n      return val;\n    }\n  });\n\n  if (result) {\n    hit(source);\n  } else {\n    window.console.error('Failed to set up prevent-adfly scriptlet');\n  }\n}\npreventAdfly.names = ['prevent-adfly', // aliases are needed for matching the related scriptlet converted into our syntax\n'adfly-defuser.js', 'ubo-adfly-defuser.js', 'ubo-adfly-defuser'];\npreventAdfly.injections = [setPropertyAccess, hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet debug-on-property-read\n *\n * @description\n * This scriptlet is basically the same as [abort-on-property-read](#abort-on-property-read), but instead of aborting it starts the debugger.\n *\n * **It is not supposed to be used in production filter lists!**\n *\n * **Syntax**\n * ```\n * ! Debug script if it tries to access `window.alert`\n * example.org#%#//scriptlet('debug-on-property-read', 'alert')\n * ! of `window.open`\n * example.org#%#//scriptlet('debug-on-property-read', 'open')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction debugOnPropertyRead(source, property, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var rid = randomId();\n\n  var abort = function abort() {\n    hit(source);\n    debugger; // eslint-disable-line no-debugger\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    setPropertyAccess(base, prop, {\n      get: abort,\n      set: noopFunc\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\ndebugOnPropertyRead.names = ['debug-on-property-read'];\ndebugOnPropertyRead.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace, noopFunc];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet debug-on-property-write\n *\n * @description\n * This scriptlet is basically the same as [abort-on-property-write](#abort-on-property-write), but instead of aborting it starts the debugger.\n *\n * **It is not supposed to be used in production filter lists!**\n *\n * **Syntax**\n * ```\n * ! Aborts script when it tries to write in property `window.test`\n * example.org#%#//scriptlet('debug-on-property-write', 'test')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction debugOnPropertyWrite(source, property, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var rid = randomId();\n\n  var abort = function abort() {\n    hit(source);\n    debugger; // eslint-disable-line no-debugger\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    setPropertyAccess(base, prop, {\n      set: abort\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\ndebugOnPropertyWrite.names = ['debug-on-property-write'];\ndebugOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet debug-current-inline-script\n *\n * @description\n * This scriptlet is basically the same as [abort-current-inline-script](#abort-current-inline-script), but instead of aborting it starts the debugger.\n *\n * **It is not supposed to be used in production filter lists!**\n *\n * **Syntax**\n *```\n * ! Aborts script when it tries to access `window.alert`\n * example.org#%#//scriptlet('debug-current-inline-script', 'alert')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction debugCurrentInlineScript(source, property) {\n  var search = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var searchRegexp = toRegExp(search);\n  var rid = randomId();\n\n  var getCurrentScript = function getCurrentScript() {\n    if ('currentScript' in document) {\n      return document.currentScript; // eslint-disable-line compat/compat\n    }\n\n    var scripts = document.getElementsByTagName('script');\n    return scripts[scripts.length - 1];\n  };\n\n  var ourScript = getCurrentScript();\n\n  var abort = function abort() {\n    var scriptEl = getCurrentScript();\n\n    if (scriptEl instanceof HTMLScriptElement && scriptEl.textContent.length > 0 && scriptEl !== ourScript && (!search || searchRegexp.test(scriptEl.textContent))) {\n      hit(source);\n      debugger; // eslint-disable-line no-debugger\n    }\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    var currentValue = base[prop];\n    setPropertyAccess(base, prop, {\n      set: function set(value) {\n        abort();\n        currentValue = value;\n      },\n      get: function get() {\n        abort();\n        return currentValue;\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\ndebugCurrentInlineScript.names = ['debug-current-inline-script'];\ndebugCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet remove-attr\n *\n * @description\n * Removes the specified attributes from DOM nodes. This scriptlet runs once when the page loads\n * and after that periodically in order to DOM tree changes.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-attrjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('remove-attr', attrs[, selector])\n * ```\n *\n * - `attrs`  required, attribute or list of attributes joined by '|'\n * - `selector`  optional, CSS selector, specifies DOM nodes from which the attributes will be removed\n *\n * **Examples**\n * 1.  Removes by attribute\n *     ```\n *     example.org#%#//scriptlet('remove-attr', 'example|test')\n *     ```\n *\n *     ```html\n *     <!-- before  -->\n *     <div example=\"true\" test=\"true\">Some text</div>\n *\n *     <!-- after -->\n *     <div>Some text</div>\n *     ```\n *\n * 2. Removes with specified selector\n *     ```\n *     example.org#%#//scriptlet('remove-attr', 'example', 'div[class=\"inner\"]')\n *     ```\n *\n *     ```html\n *     <!-- before -->\n *     <div class=\"wrapper\" example=\"true\">\n *         <div class=\"inner\" example=\"true\">Some text</div>\n *     </div>\n *\n *     <!-- after -->\n *     <div class=\"wrapper\" example=\"true\">\n *         <div class=\"inner\">Some text</div>\n *     </div>\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction removeAttr(source, attrs, selector) {\n  if (!attrs) {\n    return;\n  }\n\n  attrs = attrs.split(/\\s*\\|\\s*/);\n\n  if (!selector) {\n    selector = \"[\".concat(attrs.join('],['), \"]\");\n  }\n\n  var rmattr = function rmattr() {\n    var nodes = [].slice.call(document.querySelectorAll(selector));\n    var removed = false;\n    nodes.forEach(function (node) {\n      attrs.forEach(function (attr) {\n        node.removeAttribute(attr);\n        removed = true;\n      });\n    });\n\n    if (removed) {\n      hit(source);\n    }\n  };\n\n  rmattr(); // 'true' for observing attributes\n\n  observeDOMChanges(rmattr, true);\n}\nremoveAttr.names = ['remove-attr', // aliases are needed for matching the related scriptlet converted into our syntax\n'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js', 'ubo-remove-attr', 'ubo-ra'];\nremoveAttr.injections = [hit, observeDOMChanges];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet remove-class\n *\n * @description\n * Removes the specified classes from DOM nodes. This scriptlet runs once after the page loads\n * and after that periodically in order to DOM tree changes.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-classjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('remove-class', classes[, selector])\n * ```\n *\n * - `classes`  required, class or list of classes separated by '|'\n * - `selector`  optional, CSS selector, specifies DOM nodes from which the classes will be removed.\n * If there is no `selector`, each class of `classes` independently will be removed from all nodes which has one\n *\n * **Examples**\n * 1.  Removes by classes\n *     ```\n *     example.org#%#//scriptlet('remove-class', 'example|test')\n *     ```\n *\n *     ```html\n *     <!-- before  -->\n *     <div id=\"first\" class=\"nice test\">Some text</div>\n *     <div id=\"second\" class=\"rare example for test\">Some text</div>\n *     <div id=\"third\" class=\"testing better example\">Some text</div>\n *\n *     <!-- after -->\n *     <div id=\"first\" class=\"nice\">Some text</div>\n *     <div id=\"second\" class=\"rare for\">Some text</div>\n *     <div id=\"third\" class=\"testing better\">Some text</div>\n *     ```\n *\n * 2. Removes with specified selector\n *     ```\n *     example.org#%#//scriptlet('remove-class', 'branding', 'div[class^=\"inner\"]')\n *     ```\n *\n *     ```html\n *     <!-- before -->\n *     <div class=\"wrapper true branding\">\n *         <div class=\"inner bad branding\">Some text</div>\n *     </div>\n *\n *     <!-- after -->\n *     <div class=\"wrapper true branding\">\n *         <div class=\"inner bad\">Some text</div>\n *     </div>\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction removeClass(source, classNames, selector) {\n  if (!classNames) {\n    return;\n  }\n\n  classNames = classNames.split(/\\s*\\|\\s*/);\n  var selectors = [];\n\n  if (!selector) {\n    selectors = classNames.map(function (className) {\n      return \".\".concat(className);\n    });\n  }\n\n  var removeClassHandler = function removeClassHandler() {\n    var nodes = new Set();\n\n    if (selector) {\n      var foundedNodes = [].slice.call(document.querySelectorAll(selector));\n      foundedNodes.forEach(function (n) {\n        return nodes.add(n);\n      });\n    } else if (selectors.length > 0) {\n      selectors.forEach(function (s) {\n        var elements = document.querySelectorAll(s);\n\n        for (var i = 0; i < elements.length; i += 1) {\n          var element = elements[i];\n          nodes.add(element);\n        }\n      });\n    }\n\n    var removed = false;\n    nodes.forEach(function (node) {\n      classNames.forEach(function (className) {\n        if (node.classList.contains(className)) {\n          node.classList.remove(className);\n          removed = true;\n        }\n      });\n    });\n\n    if (removed) {\n      hit(source);\n    }\n  };\n\n  removeClassHandler();\n  var CLASS_ATTR_NAME = ['class']; // 'true' for observing attributes\n  // 'class' for observing only classes\n\n  observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);\n}\nremoveClass.names = ['remove-class', // aliases are needed for matching the related scriptlet converted into our syntax\n'remove-class.js', 'ubo-remove-class.js', 'rc.js', 'ubo-rc.js', 'ubo-remove-class', 'ubo-rc'];\nremoveClass.injections = [hit, observeDOMChanges];\n\n/**\n * @scriptlet disable-newtab-links\n *\n * @description\n * Prevents opening new tabs and windows if there is `target` attribute in element.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#disable-newtab-linksjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('disable-newtab-links')\n * ```\n */\n\nfunction disableNewtabLinks(source) {\n  document.addEventListener('click', function (ev) {\n    var target = ev.target;\n\n    while (target !== null) {\n      if (target.localName === 'a' && target.hasAttribute('target')) {\n        ev.stopPropagation();\n        ev.preventDefault();\n        hit(source);\n        break;\n      }\n\n      target = target.parentNode;\n    }\n  });\n}\ndisableNewtabLinks.names = ['disable-newtab-links', // aliases are needed for matching the related scriptlet converted into our syntax\n'disable-newtab-links.js', 'ubo-disable-newtab-links.js', 'ubo-disable-newtab-links'];\ndisableNewtabLinks.injections = [hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet adjust-setInterval\n *\n * @description\n * Adjusts interval for specified setInterval() callbacks.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-setinterval-boosterjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('adjust-setInterval'[, match [, interval[, boost]]])\n * ```\n *\n * - `match` - optional, string/regular expression, matching in stringified callback function\n * - `interval` - optional, defaults to 1000, matching setInterval delay; decimal integer OR '*' for any delay\n * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down (0.02...50), interval multiplier\n *\n * **Examples**\n * 1. Adjust all setInterval() x20 times where interval equal 1000ms:\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval')\n *     ```\n *\n * 2. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 1000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', 'example')\n *     ```\n *\n * 3. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 400ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', 'example', '400')\n *     ```\n *\n * 4. Slow down setInterval() x2 times where callback matched with `example` and interval equal 1000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', 'example', '', '2')\n *     ```\n * 5. Adjust all setInterval() x50 times where interval equal 2000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', '', '2000', '0.02')\n *     ```\n * 6. Adjust all setInterval() x50 times where interval is randomized\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', '', '*', '0.02')\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction adjustSetInterval(source, match, interval, boost) {\n  var nativeSetInterval = window.setInterval;\n  var matchRegexp = toRegExp(match);\n\n  var intervalWrapper = function intervalWrapper(cb, d) {\n    if (matchRegexp.test(cb.toString()) && isDelayMatched(interval, d)) {\n      d *= getBoostMultiplier(boost);\n      hit(source);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeSetInterval.apply(window, [cb, d].concat(args));\n  };\n\n  window.setInterval = intervalWrapper;\n}\nadjustSetInterval.names = ['adjust-setInterval', // aliases are needed for matching the related scriptlet converted into our syntax\n'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js', 'ubo-nano-setInterval-booster', 'ubo-nano-sib'];\nadjustSetInterval.injections = [hit, toRegExp, getBoostMultiplier, isDelayMatched, nativeIsNaN, nativeIsFinite, getMatchDelay, getWildcardSymbol, shouldMatchAnyDelay];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet adjust-setTimeout\n *\n * @description\n * Adjusts timeout for specified setTimout() callbacks.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-settimeout-boosterjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('adjust-setTimeout'[, match [, timeout[, boost]]])\n * ```\n *\n * - `match` - optional, string/regular expression, matching in stringified callback function\n * - `timeout` - optional, defaults to 1000, matching setTimout delay; decimal integer OR '*' for any delay\n * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down (0.02...50), timeout multiplier\n *\n * **Examples**\n * 1. Adjust all setTimeout() x20 times where timeout equal 1000ms:\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout')\n *     ```\n *\n * 2. Adjust all setTimeout() x20 times where callback mathed with `example` and timeout equal 1000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', 'example')\n *     ```\n *\n * 3. Adjust all setTimeout() x20 times where callback mathed with `example` and timeout equal 400ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '400')\n *     ```\n *\n * 4. Slow down setTimeout() x2 times where callback matched with `example` and timeout equal 1000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '', '2')\n *     ```\n * 5. Adjust all setTimeout() x50 times where timeout equal 2000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', '', '2000', '0.02')\n *     ```\n * 6. Adjust all setTimeout() x20 times where callback mathed with `test` and timeout is randomized\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', 'test', '*')\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction adjustSetTimeout(source, match, timeout, boost) {\n  var nativeSetTimeout = window.setTimeout;\n  var matchRegexp = toRegExp(match);\n\n  var timeoutWrapper = function timeoutWrapper(cb, d) {\n    if (matchRegexp.test(cb.toString()) && isDelayMatched(timeout, d)) {\n      d *= getBoostMultiplier(boost);\n      hit(source);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeSetTimeout.apply(window, [cb, d].concat(args));\n  };\n\n  window.setTimeout = timeoutWrapper;\n}\nadjustSetTimeout.names = ['adjust-setTimeout', // aliases are needed for matching the related scriptlet converted into our syntax\n'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js', 'ubo-nano-setTimeout-booster', 'ubo-nano-stb'];\nadjustSetTimeout.injections = [hit, toRegExp, getBoostMultiplier, isDelayMatched, nativeIsNaN, nativeIsFinite, getMatchDelay, getWildcardSymbol, shouldMatchAnyDelay];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet dir-string\n *\n * @description\n * Wraps the `console.dir` API to call the `toString` method of the argument.\n * There are several adblock circumvention systems that detect browser devtools\n * and hide themselves. Therefore, if we force them to think\n * that devtools are open (using this scrciptlet),\n * it will automatically disable the adblock circumvention script.\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L766\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('dir-string'[, times])\n * ```\n * - `times` - optional, the number of times to call the `toString` method of the argument to `console.dir`\n *\n * **Example**\n * ```\n * ! Run 2 times\n * example.org#%#//scriptlet('dir-string', '2')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction dirString(source, times) {\n  var _console = console,\n      dir = _console.dir;\n  times = parseInt(times, 10);\n\n  function dirWrapper(object) {\n    // eslint-disable-next-line no-unused-vars\n    var temp;\n\n    for (var i = 0; i < times; i += 1) {\n      // eslint-disable-next-line no-unused-expressions\n      temp = \"\".concat(object);\n    }\n\n    if (typeof dir === 'function') {\n      dir.call(this, object);\n    }\n\n    hit(source, temp);\n  } // eslint-disable-next-line no-console\n\n\n  console.dir = dirWrapper;\n}\ndirString.names = ['dir-string', 'abp-dir-string'];\ndirString.injections = [hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet json-prune\n *\n * @description\n * Removes specified properties from the result of calling JSON.parse and returns the caller\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prunejs-\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/master/lib/content/snippets.js#L1285\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('json-prune'[, propsToRemove [, obligatoryProps [, stack]]])\n * ```\n *\n * - `propsToRemove` - optional, string of space-separated properties to remove\n * - `obligatoryProps` - optional, string of space-separated properties which must be all present for the pruning to occur\n * - `stack` - optional, string or regular expression that must match the current function call stack trace\n *\n * > Note please that you can use wildcard `*` for chain property name.\n * e.g. 'ad.*.src' instead of 'ad.0.src ad.1.src ad.2.src ...'\n *\n * **Examples**\n * 1. Removes property `example` from the results of JSON.parse call\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'example')\n *     ```\n *\n *     For instance, the following call will return `{ one: 1}`\n *\n *     ```html\n *     JSON.parse('{\"one\":1,\"example\":true}')\n *     ```\n *\n * 2. If there are no specified properties in the result of JSON.parse call, pruning will NOT occur\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'one', 'obligatoryProp')\n *     ```\n *\n *     For instance, the following call will return `{ one: 1, two: 2}`\n *\n *     ```html\n *     JSON.parse('{\"one\":1,\"two\":2}')\n *     ```\n *\n * 3. A property in a list of properties can be a chain of properties\n *\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'a.b', 'adpath.url.first')\n *     ```\n *\n * 4. Removes property `content.ad` from the results of JSON.parse call it's error stack trace contains `test.js`\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'content.ad', '', 'test.js')\n *     ```\n *\n * 5. A property in a list of properties can be a chain of properties with wildcard in it\n *\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'content.*.media.src', 'content.*.media.preroll')\n *     ```\n *\n * 6. Call with no arguments will log the current hostname and json payload at the console\n *     ```\n *     example.org#%#//scriptlet('json-prune')\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction jsonPrune(source, propsToRemove, requiredInitialProps, stack) {\n  if (!!stack && !matchStackTrace(stack, new Error().stack)) {\n    return;\n  } // eslint-disable-next-line no-console\n\n\n  var log = console.log.bind(console);\n  var prunePaths = propsToRemove !== undefined && propsToRemove !== '' ? propsToRemove.split(/ +/) : [];\n  var requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== '' ? requiredInitialProps.split(/ +/) : [];\n\n  function isPruningNeeded(root) {\n    if (!root) {\n      return false;\n    }\n\n    var shouldProcess;\n\n    for (var i = 0; i < requiredPaths.length; i += 1) {\n      var requiredPath = requiredPaths[i];\n      var lastNestedPropName = requiredPath.split('.').pop();\n      var hasWildcard = requiredPath.indexOf('.*.') > -1 || requiredPath.indexOf('*.') > -1 || requiredPath.indexOf('.*') > -1 || requiredPath.indexOf('.[].') > -1 || requiredPath.indexOf('[].') > -1 || requiredPath.indexOf('.[]') > -1; // if the path has wildcard, getPropertyInChain should 'look through' chain props\n\n      var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard); // start value of 'shouldProcess' due to checking below\n\n      shouldProcess = !hasWildcard;\n\n      for (var _i = 0; _i < details.length; _i += 1) {\n        if (hasWildcard) {\n          // if there is a wildcard,\n          // at least one (||) of props chain should be present in object\n          shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) || shouldProcess;\n        } else {\n          // otherwise each one (&&) of them should be there\n          shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) && shouldProcess;\n        }\n      }\n    }\n\n    return shouldProcess;\n  }\n  /**\n   * Prunes properties of 'root' object\n   * @param {Object} root\n   */\n\n\n  var jsonPruner = function jsonPruner(root) {\n    if (prunePaths.length === 0) {\n      log(window.location.hostname, root);\n      return root;\n    }\n\n    try {\n      if (isPruningNeeded(root) === false) {\n        return root;\n      } // if pruning is needed, we check every input pathToRemove\n      // and delete it if root has it\n\n\n      prunePaths.forEach(function (path) {\n        var ownerObjArr = getWildcardPropertyInChain(root, path, true);\n        ownerObjArr.forEach(function (ownerObj) {\n          if (ownerObj !== undefined && ownerObj.base) {\n            delete ownerObj.base[ownerObj.prop];\n            hit(source);\n          }\n        });\n      });\n    } catch (e) {\n      log(e.toString());\n    }\n\n    return root;\n  };\n\n  var nativeJSONParse = JSON.parse;\n\n  var jsonParseWrapper = function jsonParseWrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // dealing with stringified json in args, which should be parsed.\n    // so we call nativeJSONParse as JSON.parse which is bound to JSON object\n    var root = nativeJSONParse.apply(JSON, args);\n    return jsonPruner(root);\n  }; // JSON.parse mocking\n\n\n  jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);\n  JSON.parse = jsonParseWrapper; // eslint-disable-next-line compat/compat\n\n  var nativeResponseJson = Response.prototype.json; // eslint-disable-next-line func-names\n\n  var responseJsonWrapper = function responseJsonWrapper() {\n    var promise = nativeResponseJson.apply(this);\n    return promise.then(function (obj) {\n      return jsonPruner(obj);\n    });\n  }; // do nothing if browser does not support Response (e.g. Internet Explorer)\n  // https://developer.mozilla.org/en-US/docs/Web/API/Response\n\n\n  if (typeof Response === 'undefined') {\n    return;\n  } // eslint-disable-next-line compat/compat\n\n\n  Response.prototype.json = responseJsonWrapper;\n}\njsonPrune.names = ['json-prune', // aliases are needed for matching the related scriptlet converted into our syntax\n'json-prune.js', 'ubo-json-prune.js', 'ubo-json-prune', 'abp-json-prune'];\njsonPrune.injections = [hit, matchStackTrace, getWildcardPropertyInChain, toRegExp, getWildcardSymbol];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-requestAnimationFrame\n *\n * @description\n * Prevents a `requestAnimationFrame` call\n * if the text of the callback is matching the specified search string which does not start with `!`;\n * otherwise mismatched calls should be defused.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-requestanimationframe-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-requestAnimationFrame'[, search])\n * ```\n *\n * - `search` - optional, string or regular expression.\n * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.\n * If do not start with `!`, the stringified callback will be matched.\n *\n * Call with no argument will log all requestAnimationFrame calls while debugging.\n * So do not use the scriptlet without any parameter in production filter lists.\n *\n * **Examples**\n * 1. Prevents `requestAnimationFrame` calls if the callback matches `/\\.test/`.\n *     ```bash\n *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '/\\.test/')\n *     ```\n *\n *     For instance, the following call will be prevented:\n *     ```javascript\n *     var times = 0;\n *     requestAnimationFrame(function change() {\n *         window.test = 'new value';\n *         if (times < 2) {\n *             times += 1;\n *             requestAnimationFrame(change);\n *         }\n *     });\n *     ```\n * 2. Prevents `requestAnimationFrame` calls if **does not match** 'check'.\n *     ```bash\n *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '!check')\n *     ```\n *\n *     For instance, only the first call will be prevented:\n *\n *     ```javascript\n *     var timesFirst = 0;\n *     requestAnimationFrame(function changeFirst() {\n *         window.check = 'should not be prevented';\n *         if (timesFirst < 2) {\n *             timesFirst += 1;\n *             requestAnimationFrame(changeFirst);\n *         }\n *     });\n *\n *     var timesSecond = 0;\n *     requestAnimationFrame(function changeSecond() {\n *         window.second = 'should be prevented';\n *         if (timesSecond < 2) {\n *             timesSecond += 1;\n *             requestAnimationFrame(changeSecond);\n *         }\n *     });\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventRequestAnimationFrame(source, match) {\n  var nativeRequestAnimationFrame = window.requestAnimationFrame; // logs requestAnimationFrame to console if no arguments have been specified\n\n  var shouldLog = typeof match === 'undefined';\n\n  var _parseMatchArg = parseMatchArg(match),\n      isInvertedMatch = _parseMatchArg.isInvertedMatch,\n      matchRegexp = _parseMatchArg.matchRegexp;\n\n  var rafWrapper = function rafWrapper(callback) {\n    var shouldPrevent = false;\n\n    if (shouldLog) {\n      var logMessage = \"log: requestAnimationFrame(\\\"\".concat(callback.toString(), \"\\\")\");\n      hit(source, logMessage);\n    } else {\n      shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return nativeRequestAnimationFrame(noopFunc);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return nativeRequestAnimationFrame.apply(window, [callback].concat(args));\n  };\n\n  window.requestAnimationFrame = rafWrapper;\n}\npreventRequestAnimationFrame.names = ['prevent-requestAnimationFrame', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-requestAnimationFrame-if.js', 'ubo-no-requestAnimationFrame-if.js', 'norafif.js', 'ubo-norafif.js', 'ubo-no-requestAnimationFrame-if', 'ubo-norafif'];\npreventRequestAnimationFrame.injections = [hit, noopFunc, parseMatchArg, toRegExp, startsWith];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet set-cookie\n *\n * @description\n * Sets a cookie with the specified name and value. Cookie path defaults to root.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('set-cookie', name, value)\n * ```\n *\n * - `name` - required, cookie name to be set\n * - `value` - required, cookie value; possible values:\n *     - number `>= 0 && <= 15`\n *     - one of the predefined constants:\n *         - `true` / `True`\n *         - `false` / `False`\n *         - `yes` / `Yes` / `Y`\n *         - `no`\n *         - `ok` / `OK`\n *\n * **Examples**\n * ```\n * example.org#%#//scriptlet('set-cookie', 'ReadlyCookieConsent', '1'\n *\n * example.org#%#//scriptlet('set-cookie', 'gdpr-settings-cookie', 'true')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction setCookie(source, name, value) {\n  var cookieData = prepareCookie(name, value);\n\n  if (cookieData) {\n    hit(source);\n    document.cookie = cookieData;\n  }\n}\nsetCookie.names = ['set-cookie'];\nsetCookie.injections = [hit, nativeIsNaN, prepareCookie];\n\n/**\n * @scriptlet set-cookie-reload\n *\n * @description\n * Sets a cookie with the specified name and value, and then reloads the current page.\n * If reloading option is not needed, use [set-cookie](#set-cookie) scriptlet.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('set-cookie-reload', name, value)\n * ```\n *\n * - `name` - required, cookie name to be set\n * - `value` - required, cookie value; possible values:\n *     - number `>= 0 && <= 15`\n *     - one of the predefined constants:\n *         - `true` / `True`\n *         - `false` / `False`\n *         - `yes` / `Yes` / `Y`\n *         - `no`\n *         - `ok` / `OK`\n *\n * **Examples**\n * ```\n * example.org#%#//scriptlet('set-cookie-reload', 'checking', 'ok')\n *\n * example.org#%#//scriptlet('set-cookie-reload', 'gdpr-settings-cookie', '1')\n * ```\n */\n\nfunction setCookieReload(source, name, value) {\n  var isCookieAlreadySet = document.cookie.split(';').some(function (cookieStr) {\n    var pos = cookieStr.indexOf('=');\n\n    if (pos === -1) {\n      return false;\n    }\n\n    var cookieName = cookieStr.slice(0, pos).trim();\n    var cookieValue = cookieStr.slice(pos + 1).trim();\n    return name === cookieName && value === cookieValue;\n  });\n  var shouldReload = !isCookieAlreadySet;\n  var cookieData = prepareCookie(name, value);\n\n  if (cookieData) {\n    hit(source);\n    document.cookie = cookieData;\n\n    if (shouldReload) {\n      window.location.reload();\n    }\n  }\n}\nsetCookieReload.names = ['set-cookie-reload'];\nsetCookieReload.injections = [hit, nativeIsNaN, prepareCookie];\n\n/**\n * @scriptlet hide-in-shadow-dom\n *\n * @description\n * Hides elements inside open shadow DOM elements.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('hide-in-shadow-dom', selector[, baseSelector])\n * ```\n *\n * - `selector`  required, CSS selector of element in shadow-dom to hide\n * - `baseSelector`  optional, selector of specific page DOM element,\n * narrows down the part of the page DOM where shadow-dom host supposed to be,\n * defaults to document.documentElement\n *\n * > `baseSelector` should match element of the page DOM, but not of shadow DOM\n *\n * **Examples**\n * ```\n * ! hides menu bar\n * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')\n *\n * ! hides floating element\n * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'vt-ui-contact-fab')\n * ```\n */\n\nfunction hideInShadowDom(source, selector, baseSelector) {\n  // do nothing if browser does not support ShadowRoot\n  // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot\n  if (!Element.prototype.attachShadow) {\n    return;\n  }\n\n  var hideElement = function hideElement(targetElement) {\n    var DISPLAY_NONE_CSS = 'display:none!important;';\n    targetElement.style.cssText = DISPLAY_NONE_CSS;\n  };\n  /**\n   * Handles shadow-dom piercing and hiding of found elements\n   */\n\n\n  var hideHandler = function hideHandler() {\n    // start value of shadow-dom hosts for the page dom\n    var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector); // if there is shadow-dom host, they should be explored\n\n    while (hostElements.length !== 0) {\n      var isHidden = false;\n\n      var _pierceShadowDom = pierceShadowDom(selector, hostElements),\n          targets = _pierceShadowDom.targets,\n          innerHosts = _pierceShadowDom.innerHosts;\n\n      targets.forEach(function (targetEl) {\n        hideElement(targetEl);\n        isHidden = true;\n      });\n\n      if (isHidden) {\n        hit(source);\n      } // continue to pierce for inner shadow-dom hosts\n      // and search inside them while the next iteration\n\n\n      hostElements = innerHosts;\n    }\n  };\n\n  hideHandler();\n  observeDOMChanges(hideHandler, true);\n}\nhideInShadowDom.names = ['hide-in-shadow-dom'];\nhideInShadowDom.injections = [hit, observeDOMChanges, flatten, findHostElements, pierceShadowDom];\n\n/**\n * @scriptlet remove-in-shadow-dom\n *\n * @description\n * Removes elements inside open shadow DOM elements.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('remove-in-shadow-dom', selector[, baseSelector])\n * ```\n *\n * - `selector`  required, CSS selector of element in shadow-dom to remove\n * - `baseSelector`  optional, selector of specific page DOM element,\n * narrows down the part of the page DOM where shadow-dom host supposed to be,\n * defaults to document.documentElement\n *\n * > `baseSelector` should match element of the page DOM, but not of shadow DOM\n *\n * **Examples**\n * ```\n * ! removes menu bar\n * virustotal.com#%#//scriptlet('remove-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')\n *\n * ! removes floating element\n * virustotal.com#%#//scriptlet('remove-in-shadow-dom', 'vt-ui-contact-fab')\n * ```\n */\n\nfunction removeInShadowDom(source, selector, baseSelector) {\n  // do nothing if browser does not support ShadowRoot\n  // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot\n  if (!Element.prototype.attachShadow) {\n    return;\n  }\n\n  var removeElement = function removeElement(targetElement) {\n    targetElement.remove();\n  };\n  /**\n   * Handles shadow-dom piercing and removing of found elements\n   */\n\n\n  var removeHandler = function removeHandler() {\n    // start value of shadow-dom hosts for the page dom\n    var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector); // if there is shadow-dom host, they should be explored\n\n    while (hostElements.length !== 0) {\n      var isRemoved = false;\n\n      var _pierceShadowDom = pierceShadowDom(selector, hostElements),\n          targets = _pierceShadowDom.targets,\n          innerHosts = _pierceShadowDom.innerHosts;\n\n      targets.forEach(function (targetEl) {\n        removeElement(targetEl);\n        isRemoved = true;\n      });\n\n      if (isRemoved) {\n        hit(source);\n      } // continue to pierce for inner shadow-dom hosts\n      // and search inside them while the next iteration\n\n\n      hostElements = innerHosts;\n    }\n  };\n\n  removeHandler();\n  observeDOMChanges(removeHandler, true);\n}\nremoveInShadowDom.names = ['remove-in-shadow-dom'];\nremoveInShadowDom.injections = [hit, observeDOMChanges, flatten, findHostElements, pierceShadowDom];\n\n/**\n * @scriptlet no-floc\n *\n * @description\n * Prevents using Google Chrome tracking feature called Federated Learning of Cohorts (aka \"FLoC\")\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-flocjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('no-floc')\n * ```\n */\n\nfunction noFloc(source) {\n  var FLOC_PROPERTY_NAME = 'interestCohort';\n\n  if (Document instanceof Object === false) {\n    return;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(Document.prototype, FLOC_PROPERTY_NAME) || Document.prototype[FLOC_PROPERTY_NAME] instanceof Function === false) {\n    return;\n  } // document.interestCohort() is async function so it's better to return Promise.reject()\n  // https://github.com/WICG/floc/blob/dcd4c042fa6a81b048e04a78b184ea4203a75219/README.md\n\n\n  Document.prototype[FLOC_PROPERTY_NAME] = noopPromiseReject;\n  hit(source);\n}\nnoFloc.names = ['no-floc', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-floc.js', 'ubo-no-floc.js', 'ubo-no-floc'];\nnoFloc.injections = [hit, noopPromiseReject];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-fetch\n *\n * @description\n * Prevents `fetch` calls if **all** given parameters match\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-fetch-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-fetch'[, propsToMatch])\n * ```\n *\n * - `propsToMatch` - optional, string of space-separated properties to match; possible props:\n *   - string or regular expression for matching the URL passed to fetch call; empty string or wildcard `*` for all fetch calls match\n *   - colon-separated pairs `name:value` where\n *     - `name` is [`init` option name](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters)\n *     - `value` is string or regular expression for matching the value of the option passed to fetch call\n *\n * > Usage with no arguments will log fetch calls to browser console;\n * which is usefull for debugging but permitted for production filter lists.\n *\n * **Examples**\n * 1. Prevent all fetch calls\n *     ```\n *     example.org#%#//scriptlet('prevent-fetch', '*')\n *     ```\n *\n * 2. Prevent fetch call for specific url\n *     ```\n *     example.org#%#//scriptlet('prevent-fetch', '/url\\\\.part/')\n *     ```\n *\n * 3. Prevent fetch call for specific request method\n *     ```\n *     example.org#%#//scriptlet('prevent-fetch', 'method:HEAD')\n *     ```\n *\n * 4. Prevent fetch call for specific url and request method\n *     ```\n *     example.org#%#//scriptlet('prevent-fetch', '/specified_url_part/ method:/HEAD|GET/')\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventFetch(source, propsToMatch) {\n  // do nothing if browser does not support fetch or Proxy (e.g. Internet Explorer)\n  // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n  if (typeof fetch === 'undefined' || typeof Proxy === 'undefined') {\n    return;\n  }\n\n  var handlerWrapper = function handlerWrapper(target, thisArg, args) {\n    var shouldPrevent = false;\n    var fetchData = getFetchData(args);\n\n    if (typeof propsToMatch === 'undefined') {\n      // log if no propsToMatch given\n      var logMessage = \"log: fetch( \".concat(objectToString(fetchData), \" )\");\n      hit(source, logMessage);\n    } else if (propsToMatch === '' || propsToMatch === getWildcardSymbol()) {\n      // prevent all fetch calls\n      shouldPrevent = true;\n    } else {\n      var matchData = convertMatchPropsToObj(propsToMatch); // prevent only if all props match\n\n      shouldPrevent = Object.keys(matchData).every(function (matchKey) {\n        var matchValue = matchData[matchKey];\n        return Object.prototype.hasOwnProperty.call(fetchData, matchKey) && matchValue.test(fetchData[matchKey]);\n      });\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return noopPromiseResolve();\n    }\n\n    return Reflect.apply(target, thisArg, args);\n  };\n\n  var fetchHandler = {\n    apply: handlerWrapper\n  };\n  fetch = new Proxy(fetch, fetchHandler); // eslint-disable-line no-global-assign\n}\npreventFetch.names = ['prevent-fetch', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-fetch-if.js', 'ubo-no-fetch-if.js', 'ubo-no-fetch-if'];\npreventFetch.injections = [hit, getFetchData, objectToString, convertMatchPropsToObj, noopPromiseResolve, getWildcardSymbol, toRegExp, isEmptyObject, getRequestData, getObjectEntries, getObjectFromEntries];\n\n/**\n * This file must export all scriptlets which should be accessible\n */\n\nvar scriptletList = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    abortOnPropertyRead: abortOnPropertyRead,\n    abortOnPropertyWrite: abortOnPropertyWrite,\n    preventSetTimeout: preventSetTimeout,\n    preventSetInterval: preventSetInterval,\n    preventWindowOpen: preventWindowOpen,\n    abortCurrentInlineScript: abortCurrentInlineScript,\n    setConstant: setConstant,\n    removeCookie: removeCookie,\n    preventAddEventListener: preventAddEventListener,\n    preventBab: preventBab,\n    nowebrtc: nowebrtc,\n    logAddEventListener: logAddEventListener,\n    logEval: logEval,\n    log: log,\n    noeval: noeval,\n    preventEvalIf: preventEvalIf,\n    preventFab: preventFab,\n    setPopadsDummy: setPopadsDummy,\n    preventPopadsNet: preventPopadsNet,\n    preventAdfly: preventAdfly,\n    debugOnPropertyRead: debugOnPropertyRead,\n    debugOnPropertyWrite: debugOnPropertyWrite,\n    debugCurrentInlineScript: debugCurrentInlineScript,\n    removeAttr: removeAttr,\n    removeClass: removeClass,\n    disableNewtabLinks: disableNewtabLinks,\n    adjustSetInterval: adjustSetInterval,\n    adjustSetTimeout: adjustSetTimeout,\n    dirString: dirString,\n    jsonPrune: jsonPrune,\n    preventRequestAnimationFrame: preventRequestAnimationFrame,\n    setCookie: setCookie,\n    setCookieReload: setCookieReload,\n    hideInShadowDom: hideInShadowDom,\n    removeInShadowDom: removeInShadowDom,\n    noFloc: noFloc,\n    preventFetch: preventFetch\n});\n\n/**\n * Store of ADG redirects names and thier analogs.\n * As it is not a compatibility table, no need to keep in redirects array third-party redirects.\n *\n * Needed only for converion purposes.\n * e.g. googletagmanager-gtm is removed and should be removed from compatibility table as well\n * but now it works as alias for google-analytics so it should stay valid for compiler\n */\nvar redirects = [{\n  adg: '1x1-transparent.gif',\n  ubo: '1x1.gif',\n  abp: '1x1-transparent-gif'\n}, {\n  adg: '2x2-transparent.png',\n  ubo: '2x2.png',\n  abp: '2x2-transparent-png'\n}, {\n  adg: '3x2-transparent.png',\n  ubo: '3x2.png',\n  abp: '3x2-transparent-png'\n}, {\n  adg: '32x32-transparent.png',\n  ubo: '32x32.png',\n  abp: '32x32-transparent-png'\n}, {\n  adg: 'amazon-apstag',\n  ubo: 'amazon_apstag.js'\n}, {\n  adg: 'google-analytics',\n  ubo: 'google-analytics_analytics.js'\n}, {\n  adg: 'google-analytics-ga',\n  ubo: 'google-analytics_ga.js'\n}, {\n  adg: 'googlesyndication-adsbygoogle',\n  ubo: 'googlesyndication_adsbygoogle.js'\n}, {\n  // https://github.com/AdguardTeam/Scriptlets/issues/127\n  adg: 'googletagmanager-gtm',\n  ubo: 'google-analytics_ga.js'\n}, {\n  adg: 'googletagservices-gpt',\n  ubo: 'googletagservices_gpt.js'\n}, {\n  adg: 'metrika-yandex-watch'\n}, {\n  adg: 'metrika-yandex-tag'\n}, {\n  adg: 'noeval',\n  ubo: 'noeval-silent.js'\n}, {\n  adg: 'noopcss',\n  abp: 'blank-css'\n}, {\n  adg: 'noopframe',\n  ubo: 'noop.html',\n  abp: 'blank-html'\n}, {\n  adg: 'noopjs',\n  ubo: 'noop.js',\n  abp: 'blank-js'\n}, {\n  adg: 'nooptext',\n  ubo: 'noop.txt',\n  abp: 'blank-text'\n}, {\n  adg: 'noopmp3-0.1s',\n  ubo: 'noop-0.1s.mp3',\n  abp: 'blank-mp3'\n}, {\n  adg: 'noopmp4-1s',\n  ubo: 'noop-1s.mp4',\n  abp: 'blank-mp4'\n}, {\n  adg: 'noopvmap-1.0',\n  ubo: 'noop-vmap1.0.xml'\n}, {\n  adg: 'noopvast-2.0'\n}, {\n  adg: 'noopvast-3.0'\n}, {\n  adg: 'prevent-bab',\n  ubo: 'nobab.js'\n}, {\n  adg: 'prevent-fab-3.2.0',\n  ubo: 'nofab.js'\n}, {\n  adg: 'prevent-popads-net',\n  ubo: 'popads.js'\n}, {\n  adg: 'scorecardresearch-beacon',\n  ubo: 'scorecardresearch_beacon.js'\n}, {\n  adg: 'set-popads-dummy',\n  ubo: 'popads-dummy.js'\n}, {\n  adg: 'empty',\n  ubo: 'empty'\n}];\n\nvar JS_RULE_MARKER = '#%#';\nvar COMMENT_MARKER = '!';\n/**\n * Checks if rule text is comment e.g. !!example.org##+js(set-constant.js, test, false)\n * @param {string} rule\n * @return {boolean}\n */\n\nvar isComment = function isComment(rule) {\n  return startsWith(rule, COMMENT_MARKER);\n};\n/* ************************************************************************\n *\n * Scriptlets\n *\n ************************************************************************** */\n\n/**\n * uBlock scriptlet rule mask\n */\n\n\nvar UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\\s*\\+js/;\nvar UBO_SCRIPTLET_MASK_1 = '##+js';\nvar UBO_SCRIPTLET_MASK_2 = '##script:inject';\nvar UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';\nvar UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';\n/**\n * AdBlock Plus snippet rule mask\n */\n\nvar ABP_SCRIPTLET_MASK = '#$#';\nvar ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';\n/**\n * AdGuard CSS rule mask\n */\n\nvar ADG_CSS_MASK_REG = /#@?\\$#.+?\\s*\\{.*\\}\\s*$/g;\n/**\n * Checks if the `rule` is AdGuard scriptlet rule\n * @param {string} rule - rule text\n */\n\nvar isAdgScriptletRule = function isAdgScriptletRule(rule) {\n  return !isComment(rule) && rule.indexOf(ADG_SCRIPTLET_MASK) > -1;\n};\n/**\n * Checks if the `rule` is uBO scriptlet rule\n * @param {string} rule rule text\n */\n\n\nvar isUboScriptletRule = function isUboScriptletRule(rule) {\n  return (rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);\n};\n/**\n * Checks if the `rule` is AdBlock Plus snippet\n * @param {string} rule rule text\n */\n\n\nvar isAbpSnippetRule = function isAbpSnippetRule(rule) {\n  return (rule.indexOf(ABP_SCRIPTLET_MASK) > -1 || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);\n};\n/**\n * Finds scriptlet by it's name\n * @param {string} name - scriptlet name\n */\n\n\nvar getScriptletByName = function getScriptletByName(name) {\n  var scriptlets = Object.keys(scriptletList).map(function (key) {\n    return scriptletList[key];\n  });\n  return scriptlets.find(function (s) {\n    return s.names // full match name checking\n    && (s.names.indexOf(name) > -1 // or check ubo alias name without '.js' at the end\n    || !endsWith(name, '.js') && s.names.indexOf(\"\".concat(name, \".js\")) > -1);\n  });\n};\n/**\n * Checks if the scriptlet name is valid\n * @param {string} name - Scriptlet name\n */\n\n\nvar isValidScriptletName = function isValidScriptletName(name) {\n  if (!name) {\n    return false;\n  }\n\n  var scriptlet = getScriptletByName(name);\n\n  if (!scriptlet) {\n    return false;\n  }\n\n  return true;\n};\n/* ************************************************************************\n *\n * Redirects\n *\n ************************************************************************** */\n\n/**\n * Redirect resources markers\n */\n\n\nvar ADG_UBO_REDIRECT_MARKER = 'redirect=';\nvar ABP_REDIRECT_MARKER = 'rewrite=abp-resource:';\nvar EMPTY_REDIRECT_MARKER = 'empty';\nvar VALID_SOURCE_TYPES = ['image', 'media', 'subdocument', 'stylesheet', 'script', 'xmlhttprequest', 'other'];\n/**\n * Source types for redirect rules if there is no one of them.\n * Used for ADG -> UBO conversion.\n */\n\nvar ABSENT_SOURCE_TYPE_REPLACEMENT = [{\n  NAME: 'nooptext',\n  TYPES: VALID_SOURCE_TYPES\n}, {\n  NAME: 'noopjs',\n  TYPES: ['script']\n}, {\n  NAME: 'noopframe',\n  TYPES: ['subdocument']\n}, {\n  NAME: '1x1-transparent.gif',\n  TYPES: ['image']\n}, {\n  NAME: 'noopmp3-0.1s',\n  TYPES: ['media']\n}, {\n  NAME: 'noopmp4-1s',\n  TYPES: ['media']\n}, {\n  NAME: 'googlesyndication-adsbygoogle',\n  TYPES: ['xmlhttprequest', 'script']\n}, {\n  NAME: 'google-analytics',\n  TYPES: ['script']\n}, {\n  NAME: 'googletagservices-gpt',\n  TYPES: ['script']\n}];\nvar validAdgRedirects = redirects.filter(function (el) {\n  return el.adg;\n});\n/**\n * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names\n * It's used for UBO -> ADG converting\n */\n\nvar uboToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {\n  return el.ubo;\n}).map(function (el) {\n  return [el.ubo, el.adg];\n}));\n/**\n * Compatibility object where KEYS = ABP redirect names and VALUES = ADG redirect names\n * It's used for ABP -> ADG converting\n */\n\nvar abpToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {\n  return el.abp;\n}).map(function (el) {\n  return [el.abp, el.adg];\n}));\n/**\n * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names\n * It's used for ADG -> UBO converting\n */\n\nvar adgToUboCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {\n  return el.ubo;\n}).map(function (el) {\n  return [el.adg, el.ubo];\n}));\n/**\n * Needed for AdGuard redirect names validation where KEYS = **valid** AdGuard redirect names\n * 'adgToUboCompatibility' is still needed for ADG -> UBO converting\n */\n\nvar validAdgCompatibility = getObjectFromEntries(validAdgRedirects.map(function (el) {\n  return [el.adg, 'valid adg redirect'];\n}));\nvar REDIRECT_RULE_TYPES = {\n  VALID_ADG: {\n    marker: ADG_UBO_REDIRECT_MARKER,\n    compatibility: validAdgCompatibility\n  },\n  ADG: {\n    marker: ADG_UBO_REDIRECT_MARKER,\n    compatibility: adgToUboCompatibility\n  },\n  UBO: {\n    marker: ADG_UBO_REDIRECT_MARKER,\n    compatibility: uboToAdgCompatibility\n  },\n  ABP: {\n    marker: ABP_REDIRECT_MARKER,\n    compatibility: abpToAdgCompatibility\n  }\n};\n/**\n * Parses redirect rule modifiers\n * @param {string} rule\n * @returns {Array}\n */\n\nvar parseModifiers = function parseModifiers(rule) {\n  return substringAfter(rule, '$').split(',');\n};\n/**\n * Gets redirect resource name\n * @param {string} rule\n * @param {string} marker - specific Adg/Ubo or Abp redirect resources marker\n * @returns {string} - redirect resource name\n */\n\n\nvar getRedirectName = function getRedirectName(rule, marker) {\n  var ruleModifiers = parseModifiers(rule);\n  var redirectNamePart = ruleModifiers.find(function (el) {\n    return el.indexOf(marker) > -1;\n  });\n  return substringAfter(redirectNamePart, marker);\n};\n/**\n * Checks if the `rule` is AdGuard redirect rule.\n * Discards comments and JS rules and checks if the `rule` has 'redirect' modifier.\n * @param {string} rule - rule text\n */\n\n\nvar isAdgRedirectRule = function isAdgRedirectRule(rule) {\n  var MARKER_IN_BASE_PART_MASK = '/((?!\\\\$|\\\\,).{1})redirect=(.{0,}?)\\\\$(popup)?/';\n  return !isComment(rule) && rule.indexOf(REDIRECT_RULE_TYPES.ADG.marker) > -1 // some js rules may have 'redirect=' in it, so we should get rid of them\n  && rule.indexOf(JS_RULE_MARKER) === -1 // get rid of rules like '_redirect=*://look.$popup'\n  && !toRegExp(MARKER_IN_BASE_PART_MASK).test(rule);\n};\n/**\n * Checks if the `rule` satisfies the `type`\n * @param {string} rule - rule text\n * @param {'VALID_ADG'|'ADG'|'UBO'|'ABP'} type - type of a redirect rule\n */\n\n\nvar isRedirectRuleByType = function isRedirectRuleByType(rule, type) {\n  var _REDIRECT_RULE_TYPES$ = REDIRECT_RULE_TYPES[type],\n      marker = _REDIRECT_RULE_TYPES$.marker,\n      compatibility = _REDIRECT_RULE_TYPES$.compatibility;\n\n  if (rule && !isComment(rule) && rule.indexOf(marker) > -1) {\n    var redirectName = getRedirectName(rule, marker);\n\n    if (!redirectName) {\n      return false;\n    }\n\n    return redirectName === Object.keys(compatibility).find(function (el) {\n      return el === redirectName;\n    });\n  }\n\n  return false;\n};\n/**\n* Checks if the `rule` is **valid** AdGuard redirect resource rule\n* @param {string} rule - rule text\n* @returns {boolean}\n*/\n\n\nvar isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {\n  return isRedirectRuleByType(rule, 'VALID_ADG');\n};\n/**\n* Checks if the AdGuard redirect `rule` has Ubo analog. Needed for Adg->Ubo conversion\n* @param {string} rule - AdGuard rule text\n* @returns {boolean} - true if the rule can be converted to Ubo\n*/\n\n\nvar isAdgRedirectCompatibleWithUbo = function isAdgRedirectCompatibleWithUbo(rule) {\n  return isAdgRedirectRule(rule) && isRedirectRuleByType(rule, 'ADG');\n};\n/**\n* Checks if the Ubo redirect `rule` has AdGuard analog. Needed for Ubo->Adg conversion\n* @param {string} rule - Ubo rule text\n* @returns {boolean} - true if the rule can be converted to AdGuard\n*/\n\n\nvar isUboRedirectCompatibleWithAdg = function isUboRedirectCompatibleWithAdg(rule) {\n  return isRedirectRuleByType(rule, 'UBO');\n};\n/**\n* Checks if the Abp redirect `rule` has AdGuard analog. Needed for Abp->Adg conversion\n* @param {string} rule - Abp rule text\n* @returns {boolean} - true if the rule can be converted to AdGuard\n*/\n\n\nvar isAbpRedirectCompatibleWithAdg = function isAbpRedirectCompatibleWithAdg(rule) {\n  return isRedirectRuleByType(rule, 'ABP');\n};\n/**\n * Checks if the rule has specified content type before Adg -> Ubo conversion.\n *\n * Used ONLY for Adg -> Ubo conversion\n * because Ubo redirect rules must contain content type, but Adg and Abp must not.\n *\n * Also source type can not be added automatically because of such valid rules:\n * ! Abp:\n * $rewrite=abp-resource:blank-js,xmlhttprequest\n * ! Adg:\n * $script,redirect=noopvast-2.0\n * $xmlhttprequest,redirect=noopvast-2.0\n *\n * @param {string} rule\n * @returns {boolean}\n */\n\n\nvar hasValidContentType = function hasValidContentType(rule) {\n  var ruleModifiers = parseModifiers(rule); // rule can have more than one source type modifier\n\n  var sourceTypes = ruleModifiers.filter(function (el) {\n    return VALID_SOURCE_TYPES.indexOf(el) > -1;\n  });\n  var isSourceTypeSpecified = sourceTypes.length > 0;\n  var isEmptyRedirect = ruleModifiers.indexOf(\"\".concat(ADG_UBO_REDIRECT_MARKER).concat(EMPTY_REDIRECT_MARKER)) > -1;\n\n  if (isEmptyRedirect) {\n    // no source type for 'empty' is allowed\n    return true;\n  }\n\n  return isSourceTypeSpecified;\n};\n\nvar validator = {\n  UBO_SCRIPTLET_MASK_REG: UBO_SCRIPTLET_MASK_REG,\n  ABP_SCRIPTLET_MASK: ABP_SCRIPTLET_MASK,\n  ABP_SCRIPTLET_EXCEPTION_MASK: ABP_SCRIPTLET_EXCEPTION_MASK,\n  isComment: isComment,\n  isAdgScriptletRule: isAdgScriptletRule,\n  isUboScriptletRule: isUboScriptletRule,\n  isAbpSnippetRule: isAbpSnippetRule,\n  getScriptletByName: getScriptletByName,\n  isValidScriptletName: isValidScriptletName,\n  REDIRECT_RULE_TYPES: REDIRECT_RULE_TYPES,\n  ABSENT_SOURCE_TYPE_REPLACEMENT: ABSENT_SOURCE_TYPE_REPLACEMENT,\n  isAdgRedirectRule: isAdgRedirectRule,\n  isValidAdgRedirectRule: isValidAdgRedirectRule,\n  isAdgRedirectCompatibleWithUbo: isAdgRedirectCompatibleWithUbo,\n  isUboRedirectCompatibleWithAdg: isUboRedirectCompatibleWithAdg,\n  isAbpRedirectCompatibleWithAdg: isAbpRedirectCompatibleWithAdg,\n  parseModifiers: parseModifiers,\n  getRedirectName: getRedirectName,\n  hasValidContentType: hasValidContentType\n};\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar arrayLikeToArray = _arrayLikeToArray;\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nvar iterableToArray = _iterableToArray;\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nvar unsupportedIterableToArray = _unsupportedIterableToArray;\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nvar toConsumableArray = _toConsumableArray;\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar arrayWithHoles = _arrayWithHoles;\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar nonIterableRest = _nonIterableRest;\n\nfunction _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}\n\nvar toArray = _toArray;\n\n/**\n * AdGuard scriptlet rule\n */\n\nvar ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\\/\\/scriptlet\\(.+\\)/; // eslint-disable-next-line no-template-curly-in-string\n\nvar ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})'; // eslint-disable-next-line no-template-curly-in-string\n\nvar ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';\n/**\n * uBlock scriptlet rule mask\n */\n// eslint-disable-next-line no-template-curly-in-string\n\nvar UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})'; // eslint-disable-next-line no-template-curly-in-string\n\nvar UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';\nvar UBO_ALIAS_NAME_MARKER = 'ubo-';\nvar UBO_SCRIPTLET_JS_ENDING = '.js'; // https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#xhr\n\nvar UBO_XHR_TYPE = 'xhr';\nvar ADG_XHR_TYPE = 'xmlhttprequest';\nvar ADG_SET_CONSTANT_NAME = 'set-constant';\nvar ADG_SET_CONSTANT_EMPTY_STRING = '';\nvar UBO_SET_CONSTANT_EMPTY_STRING = '\\'\\'';\nvar ADG_PREVENT_FETCH_NAME = 'prevent-fetch';\nvar ADG_PREVENT_FETCH_EMPTY_STRING = '';\nvar ADG_PREVENT_FETCH_WILDCARD = getWildcardSymbol();\nvar UBO_NO_FETCH_IF_WILDCARD = '/^/';\nvar ESCAPED_COMMA_SEPARATOR = '\\\\,';\nvar COMMA_SEPARATOR = ',';\nvar MAX_REMOVE_ATTR_CLASS_ARGS_COUNT = 3;\nvar REMOVE_ATTR_METHOD = 'removeAttr';\nvar REMOVE_CLASS_METHOD = 'removeClass';\nvar REMOVE_ATTR_ALIASES = scriptletList[REMOVE_ATTR_METHOD].names;\nvar REMOVE_CLASS_ALIASES = scriptletList[REMOVE_CLASS_METHOD].names;\nvar ADG_REMOVE_ATTR_NAME = REMOVE_ATTR_ALIASES[0];\nvar ADG_REMOVE_CLASS_NAME = REMOVE_CLASS_ALIASES[0];\n/**\n * Returns array of strings separated by space which not in quotes\n * @param {string} str\n */\n\nvar getSentences = function getSentences(str) {\n  var reg = /'.*?'|\".*?\"|\\S+/g;\n  return str.match(reg);\n};\n/**\n * Replaces string with data by placeholders\n * @param {string} str\n * @param {Object} data - where keys are placeholders names\n */\n\n\nvar replacePlaceholders = function replacePlaceholders(str, data) {\n  return Object.keys(data).reduce(function (acc, key) {\n    var reg = new RegExp(\"\\\\$\\\\{\".concat(key, \"\\\\}\"), 'g');\n    acc = acc.replace(reg, data[key]);\n    return acc;\n  }, str);\n};\n/**\n * Converts string of UBO scriptlet rule to AdGuard scritlet rule\n * @param {string} rule - UBO scriptlet rule\n * @returns {Array} - array with one AdGuard scriptlet rule\n */\n\n\nvar convertUboScriptletToAdg = function convertUboScriptletToAdg(rule) {\n  var domains = getBeforeRegExp(rule, validator.UBO_SCRIPTLET_MASK_REG);\n  var mask = rule.match(validator.UBO_SCRIPTLET_MASK_REG)[0];\n  var template;\n\n  if (mask.indexOf('@') > -1) {\n    template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;\n  } else {\n    template = ADGUARD_SCRIPTLET_TEMPLATE;\n  }\n\n  var parsedArgs = getStringInBraces(rule).split(/,\\s/g);\n\n  if (parsedArgs.length === 1) {\n    // Most probably this is not correct separator, in this case we use ','\n    parsedArgs = getStringInBraces(rule).split(/,/g);\n  }\n\n  var scriptletName = parsedArgs[0].indexOf(UBO_SCRIPTLET_JS_ENDING) > -1 ? \"ubo-\".concat(parsedArgs[0]) : \"ubo-\".concat(parsedArgs[0]).concat(UBO_SCRIPTLET_JS_ENDING);\n\n  if ((REMOVE_ATTR_ALIASES.indexOf(scriptletName) > -1 || REMOVE_CLASS_ALIASES.indexOf(scriptletName) > -1) && parsedArgs.length > MAX_REMOVE_ATTR_CLASS_ARGS_COUNT) {\n    parsedArgs = [parsedArgs[0], parsedArgs[1], // if there are more than 3 args for remove-attr/class scriptlet,\n    // ubo rule has maltiple selector separated by comma. so we should:\n    // 1. join them into a single string\n    // 2. replace escaped commas by regular ones\n    // https://github.com/AdguardTeam/Scriptlets/issues/133\n    replaceAll(parsedArgs.slice(2).join(\"\".concat(COMMA_SEPARATOR, \" \")), ESCAPED_COMMA_SEPARATOR, COMMA_SEPARATOR)];\n  }\n\n  var args = parsedArgs.map(function (arg, index) {\n    var outputArg = arg;\n\n    if (index === 0) {\n      outputArg = scriptletName;\n    } // for example: dramaserial.xyz##+js(abort-current-inline-script, $, popup)\n\n\n    if (arg === '$') {\n      outputArg = '$$';\n    }\n\n    return outputArg;\n  }).map(function (arg) {\n    return wrapInSingleQuotes(arg);\n  }).join(\"\".concat(COMMA_SEPARATOR, \" \"));\n  var adgRule = replacePlaceholders(template, {\n    domains: domains,\n    args: args\n  });\n  return [adgRule];\n};\n/**\n * Convert string of ABP snippet rule to AdGuard scritlet rule\n * @param {string} rule - ABP snippet rule\n * @returns {Array} - array of AdGuard scriptlet rules -\n * one or few items depends on Abp-rule\n */\n\nvar convertAbpSnippetToAdg = function convertAbpSnippetToAdg(rule) {\n  var SEMICOLON_DIVIDER = /;(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/g;\n  var mask = rule.indexOf(validator.ABP_SCRIPTLET_MASK) > -1 ? validator.ABP_SCRIPTLET_MASK : validator.ABP_SCRIPTLET_EXCEPTION_MASK;\n  var template = mask === validator.ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;\n  var domains = substringBefore(rule, mask);\n  var args = substringAfter(rule, mask);\n  return args.split(SEMICOLON_DIVIDER).map(function (args) {\n    return getSentences(args).filter(function (arg) {\n      return arg;\n    }).map(function (arg, index) {\n      return index === 0 ? \"abp-\".concat(arg) : arg;\n    }).map(function (arg) {\n      return wrapInSingleQuotes(arg);\n    }).join(\"\".concat(COMMA_SEPARATOR, \" \"));\n  }).map(function (args) {\n    return replacePlaceholders(template, {\n      domains: domains,\n      args: args\n    });\n  });\n};\n/**\n * Converts scriptlet rule to AdGuard one\n * @param {string} rule\n * @returns {Array} - array of AdGuard scriptlet rules -\n * one item for Adg and Ubo or few items for Abp\n */\n\nvar convertScriptletToAdg = function convertScriptletToAdg(rule) {\n  var result;\n\n  if (validator.isUboScriptletRule(rule)) {\n    result = convertUboScriptletToAdg(rule);\n  } else if (validator.isAbpSnippetRule(rule)) {\n    result = convertAbpSnippetToAdg(rule);\n  } else if (validator.isAdgScriptletRule(rule) || validator.isComment(rule)) {\n    result = [rule];\n  }\n\n  return result;\n};\n/**\n * Converts UBO scriptlet rule to AdGuard one\n * @param {string} rule - AdGuard scriptlet rule\n * @returns {string} - UBO scriptlet rule\n */\n\nvar convertAdgScriptletToUbo = function convertAdgScriptletToUbo(rule) {\n  var res;\n\n  if (validator.isAdgScriptletRule(rule)) {\n    var _parseRule = parseRule(rule),\n        parsedName = _parseRule.name,\n        parsedParams = _parseRule.args;\n\n    var preparedParams; // https://github.com/AdguardTeam/FiltersCompiler/issues/102\n\n    if (parsedName === ADG_SET_CONSTANT_NAME && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_STRING) {\n      preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_STRING];\n    } else if (parsedName === ADG_PREVENT_FETCH_NAME // https://github.com/AdguardTeam/Scriptlets/issues/109\n    && (parsedParams[0] === ADG_PREVENT_FETCH_WILDCARD || parsedParams[0] === ADG_PREVENT_FETCH_EMPTY_STRING)) {\n      preparedParams = [UBO_NO_FETCH_IF_WILDCARD];\n    } else if ((parsedName === ADG_REMOVE_ATTR_NAME || parsedName === ADG_REMOVE_CLASS_NAME) && parsedParams[1] && parsedParams[1].indexOf(COMMA_SEPARATOR) > -1) {\n      preparedParams = [parsedParams[0], replaceAll(parsedParams[1], COMMA_SEPARATOR, ESCAPED_COMMA_SEPARATOR)];\n    } else {\n      preparedParams = parsedParams;\n    } // object of name and aliases for the Adg-scriptlet\n\n\n    var adgScriptletObject = Object.keys(scriptletList).map(function (el) {\n      return scriptletList[el];\n    }).map(function (s) {\n      var _s$names = toArray(s.names),\n          name = _s$names[0],\n          aliases = _s$names.slice(1);\n\n      return {\n        name: name,\n        aliases: aliases\n      };\n    }).find(function (el) {\n      return el.name === parsedName || el.aliases.indexOf(parsedName) >= 0;\n    });\n    var aliases = adgScriptletObject.aliases;\n\n    if (aliases.length > 0) {\n      var uboAlias = adgScriptletObject.aliases // eslint-disable-next-line no-restricted-properties\n      .find(function (alias) {\n        return alias.includes(UBO_ALIAS_NAME_MARKER);\n      });\n\n      if (uboAlias) {\n        var mask = rule.match(ADGUARD_SCRIPTLET_MASK_REG)[0];\n        var template;\n\n        if (mask.indexOf('@') > -1) {\n          template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;\n        } else {\n          template = UBO_SCRIPTLET_TEMPLATE;\n        }\n\n        var domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);\n        var uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '') // '.js' in the Ubo scriptlet name can be omitted\n        // https://github.com/gorhill/uBlock/wiki/Resources-Library#general-purpose-scriptlets\n        .replace(UBO_SCRIPTLET_JS_ENDING, '');\n        var args = preparedParams.length > 0 ? \"\".concat(uboName, \", \").concat(preparedParams.join(\"\".concat(COMMA_SEPARATOR, \" \"))) : uboName;\n        var uboRule = replacePlaceholders(template, {\n          domains: domains,\n          args: args\n        });\n        res = uboRule;\n      }\n    }\n  }\n\n  return res;\n};\n/**\n * Checks whether the ADG scriptlet exists or UBO/ABP scriptlet is compatible to ADG\n * @param {string} input - can be ADG or UBO or ABP scriptlet rule\n * @returns {boolean}\n */\n\nvar isValidScriptletRule = function isValidScriptletRule(input) {\n  if (!input) {\n    return false;\n  } // ABP 'input' rule may contain more than one snippet\n\n\n  var rulesArray = convertScriptletToAdg(input); // checking if each of parsed scriptlets is valid\n  // if at least one of them is not valid - whole 'input' rule is not valid too\n\n  var isValid = rulesArray.every(function (rule) {\n    var parsedRule = parseRule(rule);\n    return validator.isValidScriptletName(parsedRule.name);\n  });\n  return isValid;\n};\n/**\n * Converts Ubo redirect rule to Adg one\n * @param {string} rule\n * @returns {string}\n */\n\nvar convertUboRedirectToAdg = function convertUboRedirectToAdg(rule) {\n  var firstPartOfRule = substringBefore(rule, '$');\n  var uboModifiers = validator.parseModifiers(rule);\n  var adgModifiers = uboModifiers.map(function (el) {\n    if (el.indexOf(validator.REDIRECT_RULE_TYPES.UBO.marker) > -1) {\n      var uboName = substringAfter(el, validator.REDIRECT_RULE_TYPES.UBO.marker);\n      var adgName = validator.REDIRECT_RULE_TYPES.UBO.compatibility[uboName];\n      return \"\".concat(validator.REDIRECT_RULE_TYPES.ADG.marker).concat(adgName);\n    }\n\n    if (el === UBO_XHR_TYPE) {\n      return ADG_XHR_TYPE;\n    }\n\n    return el;\n  }).join(COMMA_SEPARATOR);\n  return \"\".concat(firstPartOfRule, \"$\").concat(adgModifiers);\n};\n/**\n * Converts Abp redirect rule to Adg one\n * @param {string} rule\n * @returns {string}\n */\n\nvar convertAbpRedirectToAdg = function convertAbpRedirectToAdg(rule) {\n  var firstPartOfRule = substringBefore(rule, '$');\n  var abpModifiers = validator.parseModifiers(rule);\n  var adgModifiers = abpModifiers.map(function (el) {\n    if (el.indexOf(validator.REDIRECT_RULE_TYPES.ABP.marker) > -1) {\n      var abpName = substringAfter(el, validator.REDIRECT_RULE_TYPES.ABP.marker);\n      var adgName = validator.REDIRECT_RULE_TYPES.ABP.compatibility[abpName];\n      return \"\".concat(validator.REDIRECT_RULE_TYPES.ADG.marker).concat(adgName);\n    }\n\n    return el;\n  }).join(COMMA_SEPARATOR);\n  return \"\".concat(firstPartOfRule, \"$\").concat(adgModifiers);\n};\n/**\n * Converts redirect rule to AdGuard one\n * @param {string} rule\n * @returns {string}\n */\n\nvar convertRedirectToAdg = function convertRedirectToAdg(rule) {\n  var result;\n\n  if (validator.isUboRedirectCompatibleWithAdg(rule)) {\n    result = convertUboRedirectToAdg(rule);\n  } else if (validator.isAbpRedirectCompatibleWithAdg(rule)) {\n    result = convertAbpRedirectToAdg(rule);\n  } else if (validator.isValidAdgRedirectRule(rule)) {\n    result = rule;\n  }\n\n  return result;\n};\n/**\n * Converts Adg redirect rule to Ubo one\n * 1. Checks if there is Ubo analog for Adg rule\n * 2. Parses the rule and chechs if there are any source type modifiers which are required by Ubo\n *    and if there are no one we add it manually to the end.\n *    Source types are chosen according to redirect name\n *    e.g. ||ad.com^$redirect=<name>,important  ->>  ||ad.com^$redirect=<name>,important,script\n * 3. Replaces Adg redirect name by Ubo analog\n * @param {string} rule\n * @returns {string}\n */\n\nvar convertAdgRedirectToUbo = function convertAdgRedirectToUbo(rule) {\n  if (!validator.isAdgRedirectCompatibleWithUbo(rule)) {\n    throw new Error(\"Unable to convert for uBO - unsupported redirect in rule: \".concat(rule));\n  }\n\n  var basePart = substringBefore(rule, '$');\n  var adgModifiers = validator.parseModifiers(rule);\n  var adgRedirectModifier = adgModifiers.find(function (el) {\n    return el.indexOf(validator.REDIRECT_RULE_TYPES.ADG.marker) > -1;\n  });\n  var adgRedirectName = adgRedirectModifier.slice(validator.REDIRECT_RULE_TYPES.ADG.marker.length);\n  var uboRedirectName = validator.REDIRECT_RULE_TYPES.ADG.compatibility[adgRedirectName];\n  var uboRedirectModifier = \"\".concat(validator.REDIRECT_RULE_TYPES.UBO.marker).concat(uboRedirectName);\n\n  if (!validator.hasValidContentType(rule)) {\n    // add missed source types as content type modifiers\n    var sourceTypesData = validator.ABSENT_SOURCE_TYPE_REPLACEMENT.find(function (el) {\n      return el.NAME === adgRedirectName;\n    });\n\n    if (typeof sourceTypesData === 'undefined') {\n      throw new Error(\"Unable to convert for uBO - no types to add for specific redirect in rule: \".concat(rule));\n    }\n\n    var additionModifiers = sourceTypesData.TYPES;\n    adgModifiers.push.apply(adgModifiers, toConsumableArray(additionModifiers));\n  }\n\n  var uboModifiers = adgModifiers.map(function (el) {\n    if (el === adgRedirectModifier) {\n      return uboRedirectModifier;\n    }\n\n    return el;\n  }).join(COMMA_SEPARATOR);\n  return \"\".concat(basePart, \"$\").concat(uboModifiers);\n};\n\n/**\n * @redirect google-analytics\n *\n * @description\n * Mocks Google's Analytics and Tag Manager APIs.\n * [Covers obsolete googletagmanager-gtm redirect functionality](https://github.com/AdguardTeam/Scriptlets/issues/127).\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/8cd2a1d263a96421487b39040c1d23eb01169484/src/web_accessible_resources/google-analytics_analytics.js\n *\n * **Example**\n * ```\n * ||google-analytics.com/analytics.js$script,redirect=google-analytics\n * ||googletagmanager.com/gtm.js$script,redirect=googletagmanager-gtm\n * ```\n */\n\nfunction GoogleAnalytics(source) {\n  // eslint-disable-next-line func-names\n  var Tracker = function Tracker() {}; // constructor\n\n\n  var proto = Tracker.prototype;\n  proto.get = noopFunc;\n  proto.set = noopFunc;\n  proto.send = noopFunc;\n  var googleAnalyticsName = window.GoogleAnalyticsObject || 'ga'; // a -- fake arg for 'ga.length < 1' antiadblock checking\n  // eslint-disable-next-line no-unused-vars\n\n  function ga(a) {\n    var len = arguments.length;\n\n    if (len === 0) {\n      return;\n    } // eslint-disable-next-line prefer-rest-params\n\n\n    var lastArg = arguments[len - 1];\n    var replacer;\n\n    if (lastArg instanceof Object && lastArg !== null && typeof lastArg.hitCallback === 'function') {\n      replacer = lastArg.hitCallback;\n    } else if (typeof lastArg === 'function') {\n      // https://github.com/AdguardTeam/Scriptlets/issues/98\n      replacer = function replacer() {\n        lastArg(ga.create());\n      };\n    }\n\n    try {\n      setTimeout(replacer, 1); // eslint-disable-next-line no-empty\n    } catch (ex) {}\n  }\n\n  ga.create = function () {\n    return new Tracker();\n  };\n\n  ga.getByName = noopNull;\n  ga.getAll = noopArray;\n  ga.remove = noopFunc;\n  ga.loaded = true;\n  window[googleAnalyticsName] = ga;\n  var _window = window,\n      dataLayer = _window.dataLayer,\n      google_optimize = _window.google_optimize; // eslint-disable-line camelcase\n\n  if (dataLayer instanceof Object === false) {\n    return;\n  }\n\n  if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {\n    dataLayer.hide.end();\n  }\n\n  if (typeof dataLayer.push === 'function') {\n    dataLayer.push = function (data) {\n      if (data instanceof Object && typeof data.eventCallback === 'function') {\n        setTimeout(data.eventCallback, 1);\n      }\n    };\n  } // https://github.com/AdguardTeam/Scriptlets/issues/81\n\n\n  if (google_optimize instanceof Object && typeof google_optimize.get === 'function') {\n    // eslint-disable-line camelcase\n    var googleOptimizeWrapper = {};\n    googleOptimizeWrapper.get = noopFunc;\n    window.google_optimize = googleOptimizeWrapper;\n  }\n\n  hit(source);\n}\nGoogleAnalytics.names = ['google-analytics', 'ubo-google-analytics_analytics.js', 'google-analytics_analytics.js', // https://github.com/AdguardTeam/Scriptlets/issues/127\n'googletagmanager-gtm', 'ubo-googletagmanager_gtm.js', 'googletagmanager_gtm.js'];\nGoogleAnalytics.injections = [hit, noopFunc, noopNull, noopArray];\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @redirect google-analytics-ga\n *\n * @description\n * Mocks old Google Analytics API.\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/google-analytics_ga.js\n *\n * **Example**\n * ```\n * ||google-analytics.com/ga.js$script,redirect=google-analytics-ga\n * ```\n */\n\nfunction GoogleAnalyticsGa(source) {\n  // Gaq constructor\n  function Gaq() {}\n\n  Gaq.prototype.Na = noopFunc;\n  Gaq.prototype.O = noopFunc;\n  Gaq.prototype.Sa = noopFunc;\n  Gaq.prototype.Ta = noopFunc;\n  Gaq.prototype.Va = noopFunc;\n  Gaq.prototype._createAsyncTracker = noopFunc;\n  Gaq.prototype._getAsyncTracker = noopFunc;\n  Gaq.prototype._getPlugin = noopFunc;\n\n  Gaq.prototype.push = function (data) {\n    if (typeof data === 'function') {\n      data();\n      return;\n    }\n\n    if (Array.isArray(data) === false) {\n      return;\n    } // https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiDomainDirectory#_gat.GA_Tracker_._link\n\n\n    if (data[0] === '_link' && typeof data[1] === 'string') {\n      window.location.assign(data[1]);\n    } // https://github.com/gorhill/uBlock/issues/2162\n\n\n    if (data[0] === '_set' && data[1] === 'hitCallback' && typeof data[2] === 'function') {\n      data[2]();\n    }\n  };\n\n  var gaq = new Gaq();\n  var asyncTrackers = window._gaq || [];\n\n  if (Array.isArray(asyncTrackers)) {\n    while (asyncTrackers[0]) {\n      gaq.push(asyncTrackers.shift());\n    }\n  } // eslint-disable-next-line no-multi-assign\n\n\n  window._gaq = gaq.qf = gaq; // Gat constructor\n\n  function Gat() {} // Mock tracker api\n\n\n  var api = ['_addIgnoredOrganic', '_addIgnoredRef', '_addItem', '_addOrganic', '_addTrans', '_clearIgnoredOrganic', '_clearIgnoredRef', '_clearOrganic', '_cookiePathCopy', '_deleteCustomVar', '_getName', '_setAccount', '_getAccount', '_getClientInfo', '_getDetectFlash', '_getDetectTitle', '_getLinkerUrl', '_getLocalGifPath', '_getServiceMode', '_getVersion', '_getVisitorCustomVar', '_initData', '_link', '_linkByPost', '_setAllowAnchor', '_setAllowHash', '_setAllowLinker', '_setCampContentKey', '_setCampMediumKey', '_setCampNameKey', '_setCampNOKey', '_setCampSourceKey', '_setCampTermKey', '_setCampaignCookieTimeout', '_setCampaignTrack', '_setClientInfo', '_setCookiePath', '_setCookiePersistence', '_setCookieTimeout', '_setCustomVar', '_setDetectFlash', '_setDetectTitle', '_setDomainName', '_setLocalGifPath', '_setLocalRemoteServerMode', '_setLocalServerMode', '_setReferrerOverride', '_setRemoteServerMode', '_setSampleRate', '_setSessionTimeout', '_setSiteSpeedSampleRate', '_setSessionCookieTimeout', '_setVar', '_setVisitorCookieTimeout', '_trackEvent', '_trackPageLoadTime', '_trackPageview', '_trackSocial', '_trackTiming', '_trackTrans', '_visitCode'];\n  var tracker = api.reduce(function (res, funcName) {\n    res[funcName] = noopFunc;\n    return res;\n  }, {});\n\n  tracker._getLinkerUrl = function (a) {\n    return a;\n  };\n\n  Gat.prototype._anonymizeIP = noopFunc;\n  Gat.prototype._createTracker = noopFunc;\n  Gat.prototype._forceSSL = noopFunc;\n  Gat.prototype._getPlugin = noopFunc;\n\n  Gat.prototype._getTracker = function () {\n    return tracker;\n  };\n\n  Gat.prototype._getTrackerByName = function () {\n    return tracker;\n  };\n\n  Gat.prototype._getTrackers = noopFunc;\n  Gat.prototype.aa = noopFunc;\n  Gat.prototype.ab = noopFunc;\n  Gat.prototype.hb = noopFunc;\n  Gat.prototype.la = noopFunc;\n  Gat.prototype.oa = noopFunc;\n  Gat.prototype.pa = noopFunc;\n  Gat.prototype.u = noopFunc;\n  var gat = new Gat();\n  window._gat = gat;\n  hit(source);\n}\nGoogleAnalyticsGa.names = ['google-analytics-ga', 'ubo-google-analytics_ga.js', 'google-analytics_ga.js'];\nGoogleAnalyticsGa.injections = [hit, noopFunc];\n\n/* eslint-disable max-len */\n\n/**\n * @redirect googlesyndication-adsbygoogle\n *\n * @description\n * Mocks Google AdSense API.\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googlesyndication_adsbygoogle.js\n *\n * **Example**\n * ```\n * ||pagead2.googlesyndication.com/pagead/js/adsbygoogle.js$script,redirect=googlesyndication-adsbygoogle\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction GoogleSyndicationAdsByGoogle(source) {\n  window.adsbygoogle = {\n    // https://github.com/AdguardTeam/Scriptlets/issues/113\n    // length: 0,\n    loaded: true,\n    push: function push() {\n      if (typeof this.length === 'undefined') {\n        this.length = 0;\n        this.length += 1;\n      }\n    }\n  };\n  var adElems = document.querySelectorAll('.adsbygoogle');\n  var css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';\n  var statusAttrName = 'data-adsbygoogle-status';\n  var ASWIFT_IFRAME_MARKER = 'aswift_';\n  var GOOGLE_ADS_IFRAME_MARKER = 'google_ads_iframe_';\n  var executed = false;\n\n  for (var i = 0; i < adElems.length; i += 1) {\n    var adElemChildNodes = adElems[i].childNodes;\n    var childNodesQuantity = adElemChildNodes.length; // childNodes of .adsbygoogle can be defined if scriptlet was executed before\n    // so we should check are that childNodes exactly defined by us\n    // TODO: remake after scriptlets context developing in 1.3\n\n    var areIframesDefined = false;\n\n    if (childNodesQuantity > 0) {\n      // it should be only 2 child iframes if scriptlet was executed\n      areIframesDefined = childNodesQuantity === 2 // the first of child nodes should be aswift iframe\n      && adElemChildNodes[0].tagName.toLowerCase() === 'iframe' && adElemChildNodes[0].id.indexOf(ASWIFT_IFRAME_MARKER) > -1 // the second of child nodes should be google_ads iframe\n      && adElemChildNodes[1].tagName.toLowerCase() === 'iframe' && adElemChildNodes[1].id.indexOf(GOOGLE_ADS_IFRAME_MARKER) > -1;\n    }\n\n    if (!areIframesDefined) {\n      // here we do the job if scriptlet has not been executed earlier\n      adElems[i].setAttribute(statusAttrName, 'done');\n      var aswiftIframe = document.createElement('iframe');\n      aswiftIframe.id = \"\".concat(ASWIFT_IFRAME_MARKER).concat(i);\n      aswiftIframe.style = css;\n      adElems[i].appendChild(aswiftIframe);\n      var innerAswiftIframe = document.createElement('iframe');\n      aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);\n      var googleadsIframe = document.createElement('iframe');\n      googleadsIframe.id = \"\".concat(GOOGLE_ADS_IFRAME_MARKER).concat(i);\n      googleadsIframe.style = css;\n      adElems[i].appendChild(googleadsIframe);\n      var innerGoogleadsIframe = document.createElement('iframe');\n      googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);\n      executed = true;\n    }\n  }\n\n  if (executed) {\n    hit(source);\n  }\n}\nGoogleSyndicationAdsByGoogle.names = ['googlesyndication-adsbygoogle', 'ubo-googlesyndication_adsbygoogle.js', 'googlesyndication_adsbygoogle.js'];\nGoogleSyndicationAdsByGoogle.injections = [hit];\n\n/**\n * @redirect googletagservices-gpt\n *\n * @description\n * Mocks Google Publisher Tag API.\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googletagservices_gpt.js\n *\n * **Example**\n * ```\n * ||googletagservices.com/tag/js/gpt.js$script,redirect=googletagservices-gpt\n * ```\n */\n\nfunction GoogleTagServicesGpt(source) {\n  var companionAdsService = {\n    addEventListener: noopThis,\n    enableSyncLoading: noopFunc,\n    setRefreshUnfilledSlots: noopFunc\n  };\n  var contentService = {\n    addEventListener: noopThis,\n    setContent: noopFunc\n  };\n\n  function PassbackSlot() {} // constructor\n\n\n  PassbackSlot.prototype.display = noopFunc;\n  PassbackSlot.prototype.get = noopNull;\n  PassbackSlot.prototype.set = noopThis;\n  PassbackSlot.prototype.setClickUrl = noopThis;\n  PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;\n  PassbackSlot.prototype.setTargeting = noopThis;\n  PassbackSlot.prototype.updateTargetingFromMap = noopThis;\n\n  function SizeMappingBuilder() {} // constructor\n\n\n  SizeMappingBuilder.prototype.addSize = noopThis;\n  SizeMappingBuilder.prototype.build = noopNull;\n\n  function Slot() {} // constructor\n\n\n  Slot.prototype.addService = noopThis;\n  Slot.prototype.clearCategoryExclusions = noopThis;\n  Slot.prototype.clearTargeting = noopThis;\n  Slot.prototype.defineSizeMapping = noopThis;\n  Slot.prototype.get = noopNull;\n  Slot.prototype.getAdUnitPath = noopArray;\n  Slot.prototype.getAttributeKeys = noopArray;\n  Slot.prototype.getCategoryExclusions = noopArray;\n  Slot.prototype.getDomId = noopStr;\n  Slot.prototype.getSlotElementId = noopStr;\n  Slot.prototype.getSlotId = noopThis;\n  Slot.prototype.getTargeting = noopArray;\n  Slot.prototype.getTargetingKeys = noopArray;\n  Slot.prototype.set = noopThis;\n  Slot.prototype.setCategoryExclusion = noopThis;\n  Slot.prototype.setClickUrl = noopThis;\n  Slot.prototype.setCollapseEmptyDiv = noopThis;\n  Slot.prototype.setTargeting = noopThis;\n  var pubAdsService = {\n    addEventListener: noopThis,\n    clear: noopFunc,\n    clearCategoryExclusions: noopThis,\n    clearTagForChildDirectedTreatment: noopThis,\n    clearTargeting: noopThis,\n    collapseEmptyDivs: noopFunc,\n    defineOutOfPagePassback: function defineOutOfPagePassback() {\n      return new PassbackSlot();\n    },\n    definePassback: function definePassback() {\n      return new PassbackSlot();\n    },\n    disableInitialLoad: noopFunc,\n    display: noopFunc,\n    enableAsyncRendering: noopFunc,\n    enableSingleRequest: noopFunc,\n    enableSyncRendering: noopFunc,\n    enableVideoAds: noopFunc,\n    get: noopNull,\n    getAttributeKeys: noopArray,\n    getTargeting: noopFunc,\n    getTargetingKeys: noopArray,\n    getSlots: noopArray,\n    refresh: noopFunc,\n    set: noopThis,\n    setCategoryExclusion: noopThis,\n    setCentering: noopFunc,\n    setCookieOptions: noopThis,\n    setForceSafeFrame: noopThis,\n    setLocation: noopThis,\n    setPublisherProvidedId: noopThis,\n    setRequestNonPersonalizedAds: noopThis,\n    setSafeFrameConfig: noopThis,\n    setTagForChildDirectedTreatment: noopThis,\n    setTargeting: noopThis,\n    setVideoContent: noopThis,\n    updateCorrelator: noopFunc\n  };\n  var _window = window,\n      _window$googletag = _window.googletag,\n      googletag = _window$googletag === void 0 ? {} : _window$googletag;\n  var _googletag$cmd = googletag.cmd,\n      cmd = _googletag$cmd === void 0 ? [] : _googletag$cmd;\n  googletag.apiReady = true;\n  googletag.cmd = [];\n\n  googletag.cmd.push = function (a) {\n    try {\n      a(); // eslint-disable-next-line no-empty\n    } catch (ex) {}\n\n    return 1;\n  };\n\n  googletag.companionAds = function () {\n    return companionAdsService;\n  };\n\n  googletag.content = function () {\n    return contentService;\n  };\n\n  googletag.defineOutOfPageSlot = function () {\n    return new Slot();\n  };\n\n  googletag.defineSlot = function () {\n    return new Slot();\n  };\n\n  googletag.destroySlots = noopFunc;\n  googletag.disablePublisherConsole = noopFunc;\n  googletag.display = noopFunc;\n  googletag.enableServices = noopFunc;\n  googletag.getVersion = noopStr;\n\n  googletag.pubads = function () {\n    return pubAdsService;\n  };\n\n  googletag.pubadsReady = true;\n  googletag.setAdIframeTitle = noopFunc;\n\n  googletag.sizeMapping = function () {\n    return new SizeMappingBuilder();\n  };\n\n  window.googletag = googletag;\n\n  while (cmd.length !== 0) {\n    googletag.cmd.push(cmd.shift());\n  }\n\n  hit(source);\n}\nGoogleTagServicesGpt.names = ['googletagservices-gpt', 'ubo-googletagservices_gpt.js', 'googletagservices_gpt.js'];\nGoogleTagServicesGpt.injections = [hit, noopFunc, noopThis, noopNull, noopArray, noopStr];\n\n/**\n * @redirect scorecardresearch-beacon\n *\n * @description\n * Mocks Scorecard Research API.\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/scorecardresearch_beacon.js\n *\n * **Example**\n * ```\n * ||sb.scorecardresearch.com/beacon.js$script,redirect=scorecardresearch-beacon\n * ```\n */\n\nfunction ScoreCardResearchBeacon(source) {\n  window.COMSCORE = {\n    purge: function purge() {\n      // eslint-disable-next-line no-underscore-dangle\n      window._comscore = [];\n    },\n    beacon: function beacon() {}\n  };\n  hit(source);\n}\nScoreCardResearchBeacon.names = ['scorecardresearch-beacon', 'ubo-scorecardresearch_beacon.js', 'scorecardresearch_beacon.js'];\nScoreCardResearchBeacon.injections = [hit];\n\n/**\n * @redirect metrika-yandex-tag\n *\n * @description\n * Mocks Yandex Metrika API.\n * https://yandex.ru/support/metrica/objects/method-reference.html\n *\n * **Example**\n * ```\n * ||mc.yandex.ru/metrika/tag.js$script,redirect=metrika-yandex-tag\n * ```\n */\n\nfunction metrikaYandexTag(source) {\n  var asyncCallbackFromOptions = function asyncCallbackFromOptions(param) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var callback = options.callback;\n    var ctx = options.ctx;\n\n    if (typeof callback === 'function') {\n      callback = ctx !== undefined ? callback.bind(ctx) : callback;\n      setTimeout(function () {\n        return callback();\n      });\n    }\n  };\n\n  var init = noopFunc;\n  /**\n   * https://yandex.ru/support/metrica/objects/addfileextension.html\n   */\n\n  var addFileExtension = noopFunc;\n  /**\n   * https://yandex.ru/support/metrica/objects/extlink.html\n   */\n\n  var extLink = asyncCallbackFromOptions;\n  /**\n   * https://yandex.ru/support/metrica/objects/file.html\n   */\n\n  var file = asyncCallbackFromOptions;\n  /**\n   * https://yandex.ru/support/metrica/objects/get-client-id.html\n   * @param {Function} cb\n   */\n\n  var getClientID = function getClientID(cb) {\n    setTimeout(cb(null));\n  };\n  /**\n   * https://yandex.ru/support/metrica/objects/hit.html\n   */\n\n\n  var hitFunc = asyncCallbackFromOptions;\n  /**\n   * https://yandex.ru/support/metrica/objects/notbounce.html\n   */\n\n  var notBounce = asyncCallbackFromOptions;\n  /**\n   * https://yandex.ru/support/metrica/objects/params-method.html\n   */\n\n  var params = noopFunc;\n  /**\n   * https://yandex.ru/support/metrica/objects/reachgoal.html\n   * @param {string} target\n   * @param {Object} params\n   * @param {Function} callback\n   * @param {any} ctx\n   */\n\n  var reachGoal = function reachGoal(target, params, callback, ctx) {\n    asyncCallbackFromOptions(null, {\n      callback: callback,\n      ctx: ctx\n    });\n  };\n  /**\n   * https://yandex.ru/support/metrica/objects/set-user-id.html\n   */\n\n\n  var setUserID = noopFunc;\n  /**\n   * https://yandex.ru/support/metrica/objects/user-params.html\n   */\n\n  var userParams = noopFunc;\n  var api = {\n    init: init,\n    addFileExtension: addFileExtension,\n    extLink: extLink,\n    file: file,\n    getClientID: getClientID,\n    hit: hitFunc,\n    notBounce: notBounce,\n    params: params,\n    reachGoal: reachGoal,\n    setUserID: setUserID,\n    userParams: userParams\n  };\n\n  function ym(id, funcName) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return api[funcName] && api[funcName].apply(api, args);\n  }\n\n  window.ym = ym;\n  hit(source);\n}\nmetrikaYandexTag.names = ['metrika-yandex-tag'];\nmetrikaYandexTag.injections = [hit, noopFunc];\n\n/**\n * @redirect metrika-yandex-watch\n *\n * @description\n * Mocks the old Yandex Metrika API.\n * https://yandex.ru/support/metrica/objects/_method-reference.html\n *\n * **Example**\n * ```\n * ||mc.yandex.ru/metrika/watch.js$script,redirect=metrika-yandex-watch\n * ```\n */\n\nfunction metrikaYandexWatch(source) {\n  var cbName = 'yandex_metrika_callbacks';\n  /**\n   * Gets callback and its context from options and call it in async way\n   * @param {Object} options Yandex Metrika API options\n   */\n\n  var asyncCallbackFromOptions = function asyncCallbackFromOptions() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = options.callback;\n    var ctx = options.ctx;\n\n    if (typeof callback === 'function') {\n      callback = ctx !== undefined ? callback.bind(ctx) : callback;\n      setTimeout(function () {\n        return callback();\n      });\n    }\n  };\n\n  function Metrika() {} // constructor\n  // Methods without options\n\n\n  Metrika.prototype.addFileExtension = noopFunc;\n  Metrika.prototype.getClientID = noopFunc;\n  Metrika.prototype.setUserID = noopFunc;\n  Metrika.prototype.userParams = noopFunc; // Methods with options\n  // The order of arguments should be kept in according to API\n\n  Metrika.prototype.extLink = function (url, options) {\n    asyncCallbackFromOptions(options);\n  };\n\n  Metrika.prototype.file = function (url, options) {\n    asyncCallbackFromOptions(options);\n  };\n\n  Metrika.prototype.hit = function (url, options) {\n    asyncCallbackFromOptions(options);\n  };\n\n  Metrika.prototype.reachGoal = function (target, params, cb, ctx) {\n    asyncCallbackFromOptions({\n      callback: cb,\n      ctx: ctx\n    });\n  };\n\n  Metrika.prototype.notBounce = asyncCallbackFromOptions;\n\n  if (window.Ya) {\n    window.Ya.Metrika = Metrika;\n  } else {\n    window.Ya = {\n      Metrika: Metrika\n    };\n  }\n\n  if (window[cbName] && Array.isArray(window[cbName])) {\n    window[cbName].forEach(function (func) {\n      if (typeof func === 'function') {\n        func();\n      }\n    });\n  }\n\n  hit(source);\n}\nmetrikaYandexWatch.names = ['metrika-yandex-watch'];\nmetrikaYandexWatch.injections = [hit, noopFunc];\n\n/**\n * @redirect amazon-apstag\n *\n * @description\n * Mocks Amazon's apstag.js\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/f842ab6d3c1cf0394f95d27092bf59627262da40/src/web_accessible_resources/amazon_apstag.js\n *\n * **Example**\n * ```\n * ||amazon-adsystem.com/aax2/apstag.js$script,redirect=amazon-apstag\n * ```\n */\n\nfunction AmazonApstag(source) {\n  var apstagWrapper = {\n    fetchBids: function fetchBids(a, b) {\n      if (typeof b === 'function') {\n        b([]);\n      }\n    },\n    init: noopFunc,\n    setDisplayBids: noopFunc,\n    targetingKeys: noopFunc\n  };\n  window.apstag = apstagWrapper;\n  hit(source);\n}\nAmazonApstag.names = ['amazon-apstag', 'ubo-amazon_apstag.js', 'amazon_apstag.js'];\nAmazonApstag.injections = [hit, noopFunc];\n\nvar redirectsList = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    noeval: noeval,\n    GoogleAnalytics: GoogleAnalytics,\n    GoogleAnalyticsGa: GoogleAnalyticsGa,\n    GoogleSyndicationAdsByGoogle: GoogleSyndicationAdsByGoogle,\n    GoogleTagServicesGpt: GoogleTagServicesGpt,\n    ScoreCardResearchBeacon: ScoreCardResearchBeacon,\n    metrikaYandexTag: metrikaYandexTag,\n    metrikaYandexWatch: metrikaYandexWatch,\n    preventFab: preventFab,\n    preventBab: preventBab,\n    setPopadsDummy: setPopadsDummy,\n    preventPopadsNet: preventPopadsNet,\n    AmazonApstag: AmazonApstag\n});\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar classCallCheck = _classCallCheck;\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar createClass = _createClass;\n\nfunction isNothing(subject) {\n  return typeof subject === 'undefined' || subject === null;\n}\n\nfunction isObject(subject) {\n  return typeof subject === 'object' && subject !== null;\n}\n\nfunction toArray$1(sequence) {\n  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];\n  return [sequence];\n}\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction repeat(string, count) {\n  var result = '',\n      cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\nfunction isNegativeZero(number) {\n  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n}\n\nvar isNothing_1 = isNothing;\nvar isObject_1 = isObject;\nvar toArray_1 = toArray$1;\nvar repeat_1 = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1 = extend;\nvar common = {\n  isNothing: isNothing_1,\n  isObject: isObject_1,\n  toArray: toArray_1,\n  repeat: repeat_1,\n  isNegativeZero: isNegativeZero_1,\n  extend: extend_1\n};\n\n// YAML error class. http://stackoverflow.com/questions/8458984\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : ''); // Include stack trace in error object\n\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = new Error().stack || '';\n  }\n} // Inherit from Error\n\n\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result = this.name + ': ';\n  result += this.reason || '(unknown reason)';\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\nvar exception = YAMLException;\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name = name;\n  this.buffer = buffer;\n  this.position = position;\n  this.line = line;\n  this.column = column;\n}\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n  if (!this.buffer) return null;\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n  head = '';\n  start = this.position;\n\n  while (start > 0 && \"\\0\\r\\n\\x85\\u2028\\u2029\".indexOf(this.buffer.charAt(start - 1)) === -1) {\n    start -= 1;\n\n    if (this.position - start > maxLength / 2 - 1) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && \"\\0\\r\\n\\x85\\u2028\\u2029\".indexOf(this.buffer.charAt(end)) === -1) {\n    end += 1;\n\n    if (end - this.position > maxLength / 2 - 1) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\nMark.prototype.toString = function toString(compact) {\n  var snippet,\n      where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\nvar mark = Mark;\n\nvar TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];\nvar YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  }); // TODO: Add tag format check.\n\n  this.tag = tag;\n  this.kind = options['kind'] || null;\n\n  this.resolve = options['resolve'] || function () {\n    return true;\n  };\n\n  this.construct = options['construct'] || function (data) {\n    return data;\n  };\n\n  this.instanceOf = options['instanceOf'] || null;\n  this.predicate = options['predicate'] || null;\n  this.represent = options['represent'] || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type;\n\n/*eslint-disable max-len*/\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n    result.push(currentType);\n  });\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\nfunction compileMap()\n/* lists... */\n{\n  var result = {\n    scalar: {},\n    sequence: {},\n    mapping: {},\n    fallback: {}\n  },\n      index,\n      length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n\n  return result;\n}\n\nfunction Schema(definition) {\n  this.include = definition.include || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\nSchema.DEFAULT = null;\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new exception('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) {\n    return schema instanceof Schema;\n  })) {\n    throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type$1) {\n    return type$1 instanceof type;\n  })) {\n    throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\nvar schema = Schema;\n\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function construct(data) {\n    return data !== null ? data : '';\n  }\n});\n\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function construct(data) {\n    return data !== null ? data : [];\n  }\n});\n\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function construct(data) {\n    return data !== null ? data : {};\n  }\n});\n\nvar failsafe = new schema({\n  explicit: [str, seq, map]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n  var max = data.length;\n  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function canonical() {\n      return '~';\n    },\n    lowercase: function lowercase() {\n      return 'null';\n    },\n    uppercase: function uppercase() {\n      return 'NULL';\n    },\n    camelcase: function camelcase() {\n      return 'Null';\n    }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n  var max = data.length;\n  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' || data === 'True' || data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function lowercase(object) {\n      return object ? 'true' : 'false';\n    },\n    uppercase: function uppercase(object) {\n      return object ? 'TRUE' : 'FALSE';\n    },\n    camelcase: function camelcase(object) {\n      return object ? 'True' : 'False';\n    }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  || 0x41\n  /* A */\n  <= c && c <= 0x46\n  /* F */\n  || 0x61\n  /* a */\n  <= c && c <= 0x66\n  /* f */\n  ;\n}\n\nfunction isOctCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x37\n  /* 7 */\n  ;\n}\n\nfunction isDecCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ;\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n  if (!max) return false;\n  ch = data[index]; // sign\n\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index]; // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n\n      return hasDigits && ch !== '_';\n    }\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n\n      return hasDigits && ch !== '_';\n    } // base 8\n\n\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isOctCode(data.charCodeAt(index))) return false;\n      hasDigits = true;\n    }\n\n    return hasDigits && ch !== '_';\n  } // base 10 (except 0) or base 60\n  // value should not start with `_`;\n\n\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (ch === ':') break;\n\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n\n    hasDigits = true;\n  } // Should have digits and should not end with `_`\n\n\n  if (!hasDigits || ch === '_') return false; // if !base60 - done;\n\n  if (ch !== ':') return true; // base60 almost not used, no needs to optimize\n\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data,\n      sign = 1,\n      ch,\n      base,\n      digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value, 16);\n    return sign * parseInt(value, 8);\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n    value = 0;\n    base = 1;\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n    return sign * value;\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary: function binary(obj) {\n      return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\n    },\n    octal: function octal(obj) {\n      return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);\n    },\n    decimal: function decimal(obj) {\n      return obj.toString(10);\n    },\n\n    /* eslint-disable max-len */\n    hexadecimal: function hexadecimal(obj) {\n      return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\n    }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary: [2, 'bin'],\n    octal: [8, 'oct'],\n    decimal: [10, 'dec'],\n    hexadecimal: [16, 'hex']\n  }\n});\n\nvar YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers\n'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2\n// special case, seems not from spec\n'|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // 20:59\n'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' + // .inf\n'|[-+]?\\\\.(?:inf|Inf|INF)' + // .nan\n'|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n  // Probably should update regexp & check speed\n  data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n  value = data.replace(/_/g, '').toLowerCase();\n  sign = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n  } else if (value === '.nan') {\n    return NaN;\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n    value = 0.0;\n    base = 1;\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n    return sign * value;\n  }\n\n  return sign * parseFloat(value, 10);\n}\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase':\n        return '.nan';\n\n      case 'uppercase':\n        return '.NAN';\n\n      case 'camelcase':\n        return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase':\n        return '.inf';\n\n      case 'uppercase':\n        return '.INF';\n\n      case 'camelcase':\n        return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase':\n        return '-.inf';\n\n      case 'uppercase':\n        return '-.INF';\n\n      case 'camelcase':\n        return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\nvar json = new schema({\n  include: [failsafe],\n  implicit: [_null, bool, int, float]\n});\n\nvar core = new schema({\n  include: [json]\n});\n\nvar YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n'-([0-9][0-9])' + // [2] month\n'-([0-9][0-9])$'); // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n'-([0-9][0-9]?)' + // [2] month\n'-([0-9][0-9]?)' + // [3] day\n'(?:[Tt]|[ \\\\t]+)' + // ...\n'([0-9][0-9]?)' + // [4] hour\n':([0-9][0-9])' + // [5] minute\n':([0-9][0-9])' + // [6] second\n'(?:\\\\.([0-9]*))?' + // [7] fraction\n'(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n'(?::([0-9][0-9]))?))?$'); // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match,\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      fraction = 0,\n      delta = null,\n      tz_hour,\n      tz_minute,\n      date;\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n  if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day\n\n  year = +match[1];\n  month = +match[2] - 1; // JS month starts with 0\n\n  day = +match[3];\n\n  if (!match[4]) {\n    // no hour\n    return new Date(Date.UTC(year, month, day));\n  } // match: [4] hour [5] minute [6] second [7] fraction\n\n\n  hour = +match[4];\n  minute = +match[5];\n  second = +match[6];\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n\n    while (fraction.length < 3) {\n      // milli-seconds\n      fraction += '0';\n    }\n\n    fraction = +fraction;\n  } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n\n  if (match[9]) {\n    tz_hour = +match[10];\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n  if (delta) date.setTime(date.getTime() - delta);\n  return date;\n}\n\nfunction representYamlTimestamp(object\n/*, style*/\n) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\nfunction commonjsRequire (target) {\n\tthrow new Error('Could not dynamically require \"' + target + '\". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');\n}\n\n/*eslint-disable no-bitwise*/\n\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = commonjsRequire;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {} // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n  var code,\n      idx,\n      bitlen = 0,\n      max = data.length,\n      map = BASE64_MAP; // Convert one by one.\n\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx)); // Skip CR/LF\n\n    if (code > 64) continue; // Fail on illegal characters\n\n    if (code < 0) return false;\n    bitlen += 6;\n  } // If there are any bits left, source was corrupted\n\n\n  return bitlen % 8 === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx,\n      tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''),\n      // remove CR/LF & padding to simplify scan\n  max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = []; // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = bits << 6 | map.indexOf(input.charAt(idx));\n  } // Dump tail\n\n\n  tailbits = max % 4 * 6;\n\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 0xFF);\n    result.push(bits >> 8 & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 0xFF);\n    result.push(bits >> 2 & 0xFF);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 0xFF);\n  } // Wrap into Buffer for NodeJS and leave Array for browser\n\n\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object\n/*, style*/\n) {\n  var result = '',\n      bits = 0,\n      idx,\n      tail,\n      max = object.length,\n      map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  } // Dump tail\n\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[bits >> 18 & 0x3F];\n    result += map[bits >> 12 & 0x3F];\n    result += map[bits >> 6 & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[bits >> 10 & 0x3F];\n    result += map[bits >> 4 & 0x3F];\n    result += map[bits << 2 & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[bits >> 2 & 0x3F];\n    result += map[bits << 4 & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n  var objectKeys = [],\n      index,\n      length,\n      pair,\n      pairKey,\n      pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n  var index,\n      length,\n      pair,\n      keys,\n      result,\n      object = data;\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n    keys = Object.keys(pair);\n    if (keys.length !== 1) return false;\n    result[index] = [keys[0], pair[keys[0]]];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n  var index,\n      length,\n      pair,\n      keys,\n      result,\n      object = data;\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    keys = Object.keys(pair);\n    result[index] = [keys[0], pair[keys[0]]];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n  var key,\n      object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$1.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar default_safe = new schema({\n  include: [core],\n  implicit: [timestamp, merge],\n  explicit: [binary, omap, pairs, set]\n});\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return typeof object === 'undefined';\n}\n\nvar _undefined = new type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n\nfunction resolveJavascriptRegExp(data) {\n  if (data === null) return false;\n  if (data.length === 0) return false;\n  var regexp = data,\n      tail = /\\/([gim]*)$/.exec(data),\n      modifiers = ''; // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    if (modifiers.length > 3) return false; // if expression starts with /, is should be properly terminated\n\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n  }\n\n  return true;\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail = /\\/([gim]*)$/.exec(data),\n      modifiers = ''; // `/foo/gim` - tail can be maximum 4 chars\n\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object\n/*, style*/\n) {\n  var result = '/' + object.source + '/';\n  if (object.global) result += 'g';\n  if (object.multiline) result += 'm';\n  if (object.ignoreCase) result += 'i';\n  return result;\n}\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nvar regexp = new type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n\nvar esprima; // Browserified version does not have esprima\n//\n// 1. For node.js just require module as deps\n// 2. For browser try to require mudule via external AMD system.\n//    If not found - try to fallback to window.esprima. If not\n//    found too - then fail to parse.\n//\n\ntry {\n  // workaround to exclude package from browserify list.\n  var _require$1 = commonjsRequire;\n  esprima = _require$1('esprima');\n} catch (_) {\n  /* eslint-disable no-redeclare */\n\n  /* global window */\n  if (typeof window !== 'undefined') esprima = window.esprima;\n}\n\nfunction resolveJavascriptFunction(data) {\n  if (data === null) return false;\n\n  try {\n    var source = '(' + data + ')',\n        ast = esprima.parse(source, {\n      range: true\n    });\n\n    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction constructJavascriptFunction(data) {\n  /*jslint evil:true*/\n  var source = '(' + data + ')',\n      ast = esprima.parse(source, {\n    range: true\n  }),\n      params = [],\n      body;\n\n  if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n    throw new Error('Failed to resolve function');\n  }\n\n  ast.body[0].expression.params.forEach(function (param) {\n    params.push(param.name);\n  });\n  body = ast.body[0].expression.body.range; // Esprima's ranges include the first '{' and the last '}' characters on\n  // function expressions. So cut them out.\n\n  if (ast.body[0].expression.body.type === 'BlockStatement') {\n    /*eslint-disable no-new-func*/\n    return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n  } // ES6 arrow functions can omit the BlockStatement. In that case, just return\n  // the body.\n\n  /*eslint-disable no-new-func*/\n\n\n  return new Function(params, 'return ' + source.slice(body[0], body[1]));\n}\n\nfunction representJavascriptFunction(object\n/*, style*/\n) {\n  return object.toString();\n}\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nvar _function = new type('tag:yaml.org,2002:js/function', {\n  kind: 'scalar',\n  resolve: resolveJavascriptFunction,\n  construct: constructJavascriptFunction,\n  predicate: isFunction,\n  represent: representJavascriptFunction\n});\n\nvar default_full = schema.DEFAULT = new schema({\n  include: [default_safe],\n  explicit: [_undefined, regexp, _function]\n});\n\n/*eslint-disable max-len,no-use-before-define*/\n\n\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\nvar CONTEXT_FLOW_IN = 1;\nvar CONTEXT_FLOW_OUT = 2;\nvar CONTEXT_BLOCK_IN = 3;\nvar CONTEXT_BLOCK_OUT = 4;\nvar CHOMPING_CLIP = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP = 3;\nvar PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\nfunction _class(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction is_EOL(c) {\n  return c === 0x0A\n  /* LF */\n  || c === 0x0D\n  /* CR */\n  ;\n}\n\nfunction is_WHITE_SPACE(c) {\n  return c === 0x09\n  /* Tab */\n  || c === 0x20\n  /* Space */\n  ;\n}\n\nfunction is_WS_OR_EOL(c) {\n  return c === 0x09\n  /* Tab */\n  || c === 0x20\n  /* Space */\n  || c === 0x0A\n  /* LF */\n  || c === 0x0D\n  /* CR */\n  ;\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C\n  /* , */\n  || c === 0x5B\n  /* [ */\n  || c === 0x5D\n  /* ] */\n  || c === 0x7B\n  /* { */\n  || c === 0x7D\n  /* } */\n  ;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if (0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ) {\n    return c - 0x30;\n  }\n  /*eslint-disable no-bitwise*/\n\n\n  lc = c | 0x20;\n\n  if (0x61\n  /* a */\n  <= lc && lc <= 0x66\n  /* f */\n  ) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78\n  /* x */\n  ) {\n      return 2;\n    }\n\n  if (c === 0x75\n  /* u */\n  ) {\n      return 4;\n    }\n\n  if (c === 0x55\n  /* U */\n  ) {\n      return 8;\n    }\n\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if (0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return c === 0x30\n  /* 0 */\n  ? '\\x00' : c === 0x61\n  /* a */\n  ? '\\x07' : c === 0x62\n  /* b */\n  ? '\\x08' : c === 0x74\n  /* t */\n  ? '\\x09' : c === 0x09\n  /* Tab */\n  ? '\\x09' : c === 0x6E\n  /* n */\n  ? '\\x0A' : c === 0x76\n  /* v */\n  ? '\\x0B' : c === 0x66\n  /* f */\n  ? '\\x0C' : c === 0x72\n  /* r */\n  ? '\\x0D' : c === 0x65\n  /* e */\n  ? '\\x1B' : c === 0x20\n  /* Space */\n  ? ' ' : c === 0x22\n  /* \" */\n  ? '\\x22' : c === 0x2F\n  /* / */\n  ? '/' : c === 0x5C\n  /* \\ */\n  ? '\\x5C' : c === 0x4E\n  /* N */\n  ? '\\x85' : c === 0x5F\n  /* _ */\n  ? '\\xA0' : c === 0x4C\n  /* L */\n  ? \"\\u2028\" : c === 0x50\n  /* P */\n  ? \"\\u2029\" : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  } // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n\n\n  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\n\nvar simpleEscapeMap = new Array(256);\n\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\nfunction State(input, options) {\n  this.input = input;\n  this.filename = options['filename'] || null;\n  this.schema = options['schema'] || default_full;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy = options['legacy'] || false;\n  this.json = options['json'] || false;\n  this.listener = options['listener'] || null;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap = this.schema.compiledTypeMap;\n  this.length = input.length;\n  this.position = 0;\n  this.line = 0;\n  this.lineStart = 0;\n  this.lineIndent = 0;\n  this.documents = [];\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n}\n\nfunction generateError(state, message) {\n  return new exception(message, new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\nvar directiveHandlers = {\n  YAML: function handleYamlDirective(state, name, args) {\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = minor < 2;\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n  TAG: function handleTagDirective(state, name, args) {\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$2.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n\n        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$2.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n  var index, quantity; // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  } // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n\n\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json && !_hasOwnProperty$2.call(overridableKeys, keyNode) && _hasOwnProperty$2.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    _result[keyNode] = valueNode;\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A\n  /* LF */\n  ) {\n      state.position++;\n    } else if (ch === 0x0D\n  /* CR */\n  ) {\n      state.position++;\n\n      if (state.input.charCodeAt(state.position) === 0x0A\n      /* LF */\n      ) {\n          state.position++;\n        }\n    } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23\n    /* # */\n    ) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0x0A\n        /* LF */\n        && ch !== 0x0D\n        /* CR */\n        && ch !== 0);\n      }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20\n      /* Space */\n      ) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n  ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n\n  if ((ch === 0x2D\n  /* - */\n  || ch === 0x2E\n  /* . */\n  ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n    _position += 3;\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23\n  /* # */\n  || ch === 0x26\n  /* & */\n  || ch === 0x2A\n  /* * */\n  || ch === 0x21\n  /* ! */\n  || ch === 0x7C\n  /* | */\n  || ch === 0x3E\n  /* > */\n  || ch === 0x27\n  /* ' */\n  || ch === 0x22\n  /* \" */\n  || ch === 0x25\n  /* % */\n  || ch === 0x40\n  /* @ */\n  || ch === 0x60\n  /* ` */\n  ) {\n      return false;\n    }\n\n  if (ch === 0x3F\n  /* ? */\n  || ch === 0x2D\n  /* - */\n  ) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        return false;\n      }\n    }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A\n    /* : */\n    ) {\n        following = state.input.charCodeAt(state.position + 1);\n\n        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n          break;\n        }\n      } else if (ch === 0x23\n    /* # */\n    ) {\n        preceding = state.input.charCodeAt(state.position - 1);\n\n        if (is_WS_OR_EOL(preceding)) {\n          break;\n        }\n      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch, captureStart, captureEnd;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27\n  /* ' */\n  ) {\n      return false;\n    }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27\n    /* ' */\n    ) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n\n        if (ch === 0x27\n        /* ' */\n        ) {\n            captureStart = state.position;\n            state.position++;\n            captureEnd = state.position;\n          } else {\n          return true;\n        }\n      } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22\n  /* \" */\n  ) {\n      return false;\n    }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22\n    /* \" */\n    ) {\n        captureSegment(state, captureStart, state.position, true);\n        state.position++;\n        return true;\n      } else if (ch === 0x5C\n    /* \\ */\n    ) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n\n        if (is_EOL(ch)) {\n          skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?\n        } else if (ch < 256 && simpleEscapeCheck[ch]) {\n          state.result += simpleEscapeMap[ch];\n          state.position++;\n        } else if ((tmp = escapedHexLen(ch)) > 0) {\n          hexLength = tmp;\n          hexResult = 0;\n\n          for (; hexLength > 0; hexLength--) {\n            ch = state.input.charCodeAt(++state.position);\n\n            if ((tmp = fromHexCode(ch)) >= 0) {\n              hexResult = (hexResult << 4) + tmp;\n            } else {\n              throwError(state, 'expected hexadecimal character');\n            }\n          }\n\n          state.result += charFromCodepoint(hexResult);\n          state.position++;\n        } else {\n          throwError(state, 'unknown escape sequence');\n        }\n\n        captureStart = captureEnd = state.position;\n      } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag = state.tag,\n      _result,\n      _anchor = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = {},\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B\n  /* [ */\n  ) {\n      terminator = 0x5D;\n      /* ] */\n\n      isMapping = false;\n      _result = [];\n    } else if (ch === 0x7B\n  /* { */\n  ) {\n      terminator = 0x7D;\n      /* } */\n\n      isMapping = true;\n      _result = {};\n    } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F\n    /* ? */\n    ) {\n        following = state.input.charCodeAt(state.position + 1);\n\n        if (is_WS_OR_EOL(following)) {\n          isPair = isExplicitPair = true;\n          state.position++;\n          skipSeparationSpace(state, true, nodeIndent);\n        }\n      }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A\n    /* : */\n    ) {\n        isPair = true;\n        ch = state.input.charCodeAt(++state.position);\n        skipSeparationSpace(state, true, nodeIndent);\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        valueNode = state.result;\n      }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C\n    /* , */\n    ) {\n        readNext = true;\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent = nodeIndent,\n      emptyLines = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C\n  /* | */\n  ) {\n      folding = false;\n    } else if (ch === 0x3E\n  /* > */\n  ) {\n      folding = true;\n    } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B\n    /* + */\n    || ch === 0x2D\n    /* - */\n    ) {\n        if (CHOMPING_CLIP === chomping) {\n          chomping = ch === 0x2B\n          /* + */\n          ? CHOMPING_KEEP : CHOMPING_STRIP;\n        } else {\n          throwError(state, 'repeat of a chomping mode identifier');\n        }\n      } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do {\n      ch = state.input.charCodeAt(++state.position);\n    } while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23\n    /* # */\n    ) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (!is_EOL(ch) && ch !== 0);\n      }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20\n    /* Space */\n    ) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    } // End of the scalar.\n\n\n    if (state.lineIndent < textIndent) {\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) {\n          // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      } // Break this `while` cycle and go to the funciton's epilogue.\n\n\n      break;\n    } // Folded style: use fancy rules to handle line breaks.\n\n\n    if (folding) {\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true; // except for the first content line (cf. Example 8.1)\n\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1); // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) {\n          // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        } // Several line breaks - perceive as different lines.\n\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      } // Literal style: just add exact number of line breaks between content lines.\n\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && ch !== 0) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag = state.tag,\n      _anchor = state.anchor,\n      _result = [],\n      following,\n      detected = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (ch !== 0x2D\n    /* - */\n    ) {\n        break;\n      }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n\n    _result.push(state.result);\n\n    skipSeparationSpace(state, true, -1);\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _pos,\n      _tag = state.tag,\n      _anchor = state.anchor,\n      _result = {},\n      overridableKeys = {},\n      keyTag = null,\n      keyNode = null,\n      valueNode = null,\n      atExplicitKey = false,\n      detected = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    _pos = state.position; //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n\n    if ((ch === 0x3F\n    /* ? */\n    || ch === 0x3A\n    /* : */\n    ) && is_WS_OR_EOL(following)) {\n      if (ch === 0x3F\n      /* ? */\n      ) {\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = true;\n          allowCompact = true;\n        } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following; //\n      // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n      //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A\n        /* : */\n        ) {\n            ch = state.input.charCodeAt(++state.position);\n\n            if (!is_WS_OR_EOL(ch)) {\n              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n            }\n\n            if (atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n              keyTag = keyNode = valueNode = null;\n            }\n\n            detected = true;\n            atExplicitKey = false;\n            allowCompact = false;\n            keyTag = state.tag;\n            keyNode = state.result;\n          } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    } else {\n        break; // Reading is done. Go to the epilogue.\n      } //\n    // Common reading code for both explicit and implicit notations.\n    //\n\n\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && ch !== 0) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  } //\n  // Epilogue.\n  //\n  // Special case: last mapping's node contains only the key in explicit notation.\n\n\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n  } // Expose the resulting mapping.\n\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x21\n  /* ! */\n  ) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C\n  /* < */\n  ) {\n      isVerbatim = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else if (ch === 0x21\n  /* ! */\n  ) {\n      isNamed = true;\n      tagHandle = '!!';\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do {\n      ch = state.input.charCodeAt(++state.position);\n    } while (ch !== 0 && ch !== 0x3E\n    /* > */\n    );\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      if (ch === 0x21\n      /* ! */\n      ) {\n          if (!isNamed) {\n            tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n              throwError(state, 'named tag handle cannot contain such characters');\n            }\n\n            isNamed = true;\n            _position = state.position + 1;\n          } else {\n            throwError(state, 'tag suffix cannot contain exclamation marks');\n          }\n        }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n  } else if (_hasOwnProperty$2.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position, ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x26\n  /* & */\n  ) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias, ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x2A\n  /* * */\n  ) return false;\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$2.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1,\n      // 1: this>parent, 0: this=parent, -1: this<parent\n  atNewLine = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag = null;\n  state.anchor = null;\n  state.kind = null;\n  state.result = null;\n  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag !== null && state.tag !== '!') {\n    if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) {\n          // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n\n          break;\n        }\n      }\n    } else if (_hasOwnProperty$2.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) {\n        // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n\n  return state.tag !== null || state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25\n    /* % */\n    ) {\n        break;\n      }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23\n      /* # */\n      ) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (ch !== 0 && !is_EOL(ch));\n\n          break;\n        }\n\n      if (is_EOL(ch)) break;\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$2.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D\n  /* - */\n  && state.input.charCodeAt(state.position + 1) === 0x2D\n  /* - */\n  && state.input.charCodeAt(state.position + 2) === 0x2D\n  /* - */\n  ) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n    if (state.input.charCodeAt(state.position) === 0x2E\n    /* . */\n    ) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n      }\n\n    return;\n  }\n\n  if (state.position < state.length - 1) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A\n    /* LF */\n    && input.charCodeAt(input.length - 1) !== 0x0D\n    /* CR */\n    ) {\n        input += '\\n';\n      } // Strip BOM\n\n\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  } // Use 0 as string terminator. That significantly simplifies bounds check.\n\n\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20\n  /* Space */\n  ) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < state.length - 1) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n\n  throw new exception('expected a single document in the stream, but found more');\n}\n\nfunction safeLoadAll(input, iterator, options) {\n  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  return loadAll(input, iterator, common.extend({\n    schema: default_safe\n  }, options));\n}\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({\n    schema: default_safe\n  }, options));\n}\n\nvar loadAll_1 = loadAll;\nvar load_1 = load;\nvar safeLoadAll_1 = safeLoadAll;\nvar safeLoad_1 = safeLoad;\nvar loader = {\n  loadAll: loadAll_1,\n  load: load_1,\n  safeLoadAll: safeLoadAll_1,\n  safeLoad: safeLoad_1\n};\n\n/*eslint-disable no-use-before-define*/\n\n\nvar _toString$2 = Object.prototype.toString;\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar CHAR_TAB = 0x09;\n/* Tab */\n\nvar CHAR_LINE_FEED = 0x0A;\n/* LF */\n\nvar CHAR_CARRIAGE_RETURN = 0x0D;\n/* CR */\n\nvar CHAR_SPACE = 0x20;\n/* Space */\n\nvar CHAR_EXCLAMATION = 0x21;\n/* ! */\n\nvar CHAR_DOUBLE_QUOTE = 0x22;\n/* \" */\n\nvar CHAR_SHARP = 0x23;\n/* # */\n\nvar CHAR_PERCENT = 0x25;\n/* % */\n\nvar CHAR_AMPERSAND = 0x26;\n/* & */\n\nvar CHAR_SINGLE_QUOTE = 0x27;\n/* ' */\n\nvar CHAR_ASTERISK = 0x2A;\n/* * */\n\nvar CHAR_COMMA = 0x2C;\n/* , */\n\nvar CHAR_MINUS = 0x2D;\n/* - */\n\nvar CHAR_COLON = 0x3A;\n/* : */\n\nvar CHAR_EQUALS = 0x3D;\n/* = */\n\nvar CHAR_GREATER_THAN = 0x3E;\n/* > */\n\nvar CHAR_QUESTION = 0x3F;\n/* ? */\n\nvar CHAR_COMMERCIAL_AT = 0x40;\n/* @ */\n\nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n/* [ */\n\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n/* ] */\n\nvar CHAR_GRAVE_ACCENT = 0x60;\n/* ` */\n\nvar CHAR_LEFT_CURLY_BRACKET = 0x7B;\n/* { */\n\nvar CHAR_VERTICAL_LINE = 0x7C;\n/* | */\n\nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n/* } */\n\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = '\\\\0';\nESCAPE_SEQUENCES[0x07] = '\\\\a';\nESCAPE_SEQUENCES[0x08] = '\\\\b';\nESCAPE_SEQUENCES[0x09] = '\\\\t';\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85] = '\\\\N';\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\nvar DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n  if (map === null) return {};\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty$3.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State$1(options) {\n  this.schema = options['schema'] || default_full;\n  this.indent = Math.max(1, options['indent'] || 2);\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys = options['sortKeys'] || false;\n  this.lineWidth = options['lineWidth'] || 80;\n  this.noRefs = options['noRefs'] || false;\n  this.noCompatMode = options['noCompatMode'] || false;\n  this.condenseFlow = options['condenseFlow'] || false;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n  this.tag = null;\n  this.result = '';\n  this.duplicates = [];\n  this.usedDuplicates = null;\n} // Indents every line in a string. Empty lines (\\n only) are not indented.\n\n\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n} // [33] s-white ::= s-space | s-tab\n\n\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n} // Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnt mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n\n\nfunction isPrintable(c) {\n  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF\n  /* BOM */\n  || 0x10000 <= c && c <= 0x10FFFF;\n} // [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\n\n\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c) // byte-order-mark\n  && c !== 0xFEFF // b-char\n  && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n} // Simplified test for values allowed after the first character in plain style.\n\n\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF // - c-flow-indicator\n  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // - \":\" - \"#\"\n  // /* An ns-char preceding */ \"#\"\n  && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));\n} // Simplified test for values allowed as the first character in plain style.\n\n\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white\n  // - (c-indicator ::=\n  // - | ? | : | , | [ | ] | { | }\n  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | # | & | * | ! | | | = | > | ' | \"\n  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | % | @ | `)\n  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n} // Determines whether block indentation indicator is required.\n\n\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN = 1,\n    STYLE_SINGLE = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED = 4,\n    STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n\n  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true; // Check if any line can be folded.\n\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    } // in case the end is missing a \\n\n\n\n    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n  } // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n\n\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;\n  } // Edge case: block indentation indicator can only have one digit.\n\n\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  } // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n\n\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n} // Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//     No ending newline => unaffected; already using strip \"-\" chomping.\n//     Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n\n\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n\n    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n\n    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.\n\n    var singleLineOnly = iskey // No block styles in flow mode.\n    || state.flowLevel > -1 && level >= state.flowLevel;\n\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }();\n} // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n\n\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n\n  var clip = string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : clip ? '' : '-';\n  return indentIndicator + chomp + '\\n';\n} // (See the note for writeScalar.)\n\n\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n} // Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n\n\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g; // first line (possibly an empty line)\n\n  var result = function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }(); // If we haven't reached the first content line yet, don't add an extra \\n.\n\n\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented; // rest of the lines\n\n  var match;\n\n  while (match = lineRe.exec(string)) {\n    var prefix = match[1],\n        line = match[2];\n    moreIndented = line[0] === ' ';\n    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n} // Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n\n\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n\n  var match; // start is an inclusive index. end, curr, and next are exclusive.\n\n  var start = 0,\n      end,\n      curr = 0,\n      next = 0;\n  var result = ''; // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n\n  while (match = breakRe.exec(line)) {\n    next = match.index; // maintain invariant: curr - start <= width\n\n    if (next - start > width) {\n      end = curr > start ? curr : next; // derive end <= length-2\n\n      result += '\\n' + line.slice(start, end); // skip the space that was output as \\n\n\n      start = end + 1; // derive start <= length-1\n    }\n\n    curr = next;\n  } // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n\n\n  result += '\\n'; // Insert a break if the remainder is too long and there is a break available.\n\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n} // Escapes a double-quoted string.\n\n\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n\n    if (char >= 0xD800 && char <= 0xDBFF\n    /* high surrogate */\n    ) {\n        nextChar = string.charCodeAt(i + 1);\n\n        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF\n        /* low surrogate */\n        ) {\n            // Combine the surrogate pair and store it escaped.\n            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.\n\n            i++;\n            continue;\n          }\n      }\n\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n    if (state.condenseFlow) pairBuffer += '\"';\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer; // Allow sorting keys so that the output file is deterministic\n\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString$2.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty$3.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\n\n\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString$2.call(state.dump);\n\n  if (block) {\n    block = state.flowLevel < 0 || state.flowLevel > level;\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n\n    if (type === '[object Object]') {\n      if (block && Object.keys(state.dump).length !== 0) {\n        writeBlockMapping(state, level, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n\n      if (block && state.dump.length !== 0) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList, index, length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n  var state = new State$1(options);\n  if (!state.noRefs) getDuplicateReferences(input, state);\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({\n    schema: default_safe\n  }, options));\n}\n\nvar dump_1 = dump;\nvar safeDump_1 = safeDump;\nvar dumper = {\n  dump: dump_1,\n  safeDump: safeDump_1\n};\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\nvar Type$1 = type;\nvar Schema$1 = schema;\nvar FAILSAFE_SCHEMA = failsafe;\nvar JSON_SCHEMA = json;\nvar CORE_SCHEMA = core;\nvar DEFAULT_SAFE_SCHEMA = default_safe;\nvar DEFAULT_FULL_SCHEMA = default_full;\nvar load$1 = loader.load;\nvar loadAll$1 = loader.loadAll;\nvar safeLoad$1 = loader.safeLoad;\nvar safeLoadAll$1 = loader.safeLoadAll;\nvar dump$1 = dumper.dump;\nvar safeDump$1 = dumper.safeDump;\nvar YAMLException$1 = exception; // Deprecated schema names from JS-YAML 2.0.x\n\nvar MINIMAL_SCHEMA = failsafe;\nvar SAFE_SCHEMA = default_safe;\nvar DEFAULT_SCHEMA = default_full; // Deprecated functions from JS-YAML 1.x.x\n\nvar scan = deprecated('scan');\nvar parse = deprecated('parse');\nvar compose = deprecated('compose');\nvar addConstructor = deprecated('addConstructor');\nvar jsYaml = {\n  Type: Type$1,\n  Schema: Schema$1,\n  FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n  JSON_SCHEMA: JSON_SCHEMA,\n  CORE_SCHEMA: CORE_SCHEMA,\n  DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,\n  DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,\n  load: load$1,\n  loadAll: loadAll$1,\n  safeLoad: safeLoad$1,\n  safeLoadAll: safeLoadAll$1,\n  dump: dump$1,\n  safeDump: safeDump$1,\n  YAMLException: YAMLException$1,\n  MINIMAL_SCHEMA: MINIMAL_SCHEMA,\n  SAFE_SCHEMA: SAFE_SCHEMA,\n  DEFAULT_SCHEMA: DEFAULT_SCHEMA,\n  scan: scan,\n  parse: parse,\n  compose: compose,\n  addConstructor: addConstructor\n};\n\nvar jsYaml$1 = jsYaml;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\n * Redirect - object used to redirect some requests\n * e.g.\n * {\n *      title: 1x1-transparent.gif\n *      comment: http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever\n *      contentType: image/gif;base64\n *      content: R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\n * }\n * @typedef {Object} Redirect\n * @property {string} title\n * @property {string} comment\n * @property {string} content\n * @property {string} contentType\n */\n\nvar Redirects = /*#__PURE__*/function () {\n  /**\n   * Converts rawYaml into JS object with sources titles used as keys\n   * @param rawYaml\n   * @returns {Object<Redirect>} - return object with titles in the keys and RedirectSources\n   * in the values\n   */\n  function Redirects(rawYaml) {\n    classCallCheck(this, Redirects);\n\n    try {\n      var arrOfRedirects = jsYaml$1.safeLoad(rawYaml);\n      this.redirects = arrOfRedirects.reduce(function (acc, redirect) {\n        return _objectSpread(_objectSpread({}, acc), {}, defineProperty({}, redirect.title, redirect));\n      }, {});\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log(\"Was unable to load YAML into JS due to: \".concat(e.message));\n      throw e;\n    }\n  }\n  /**\n   * Returns redirect source object\n   * @param {string} title\n   * @return {Redirect}\n   */\n\n\n  createClass(Redirects, [{\n    key: \"getRedirect\",\n    value: function getRedirect(title) {\n      var _this = this;\n\n      if (Object.prototype.hasOwnProperty.call(this.redirects, title)) {\n        return this.redirects[title];\n      } // look title among aliases\n\n\n      var values = Object.keys(this.redirects).map(function (key) {\n        return _this.redirects[key];\n      });\n      return values.find(function (redirect) {\n        var aliases = redirect.aliases;\n\n        if (!aliases) {\n          return false;\n        }\n\n        return aliases.indexOf(title) > -1;\n      });\n    }\n  }]);\n\n  return Redirects;\n}();\n\n/**\n * Finds redirect resource by it's name\n * @param {string} name - redirect name\n */\n\nvar getRedirectByName = function getRedirectByName(name) {\n  var redirects = Object.keys(redirectsList).map(function (key) {\n    return redirectsList[key];\n  });\n  return redirects.find(function (r) {\n    return r.names && r.names.indexOf(name) > -1;\n  });\n};\n/**\n * @typedef {Object} Source - redirect properties\n * @property {string} name redirect name\n * @property {Array<string>} args Arguments for redirect function\n * @property {'extension'|'test'} [engine] -\n * Defines the final form of redirect string presentation\n * @property {boolean} [verbose] flag to enable printing to console debug information\n */\n\n/**\n * Returns redirect code by param\n * @param {Source} source\n * @returns {string} redirect code\n */\n\n\nvar getRedirectCode = function getRedirectCode(source) {\n  var redirect = getRedirectByName(source.name);\n  var result = attachDependencies(redirect);\n  result = addCall(redirect, result); // redirect code for different sources is checked in tests\n  // so it should be just a code without any source and props passed\n\n  result = source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);\n  return result;\n};\n\nvar redirectsCjs = {\n  Redirects: Redirects,\n  getCode: getRedirectCode,\n  isAdgRedirectRule: validator.isAdgRedirectRule,\n  isValidAdgRedirectRule: validator.isValidAdgRedirectRule,\n  isAdgRedirectCompatibleWithUbo: validator.isAdgRedirectCompatibleWithUbo,\n  isUboRedirectCompatibleWithAdg: validator.isUboRedirectCompatibleWithAdg,\n  isAbpRedirectCompatibleWithAdg: validator.isAbpRedirectCompatibleWithAdg,\n  convertUboRedirectToAdg: convertUboRedirectToAdg,\n  convertAbpRedirectToAdg: convertAbpRedirectToAdg,\n  convertRedirectToAdg: convertRedirectToAdg,\n  convertAdgRedirectToUbo: convertAdgRedirectToUbo\n};\n\n/**\n * @typedef {Object} Source - scriptlet properties\n * @property {string} name Scriptlet name\n * @property {Array<string>} args Arguments for scriptlet function\n * @property {'extension'|'corelibs'|'test'} engine -\n * Defines the final form of scriptlet string presentation\n * @property {string} [version]\n * @property {boolean} [verbose] flag to enable printing to console debug information\n * @property {string} [ruleText] Source rule text is used for debugging purposes\n * @property {string} [domainName] domain name where scriptlet is applied; for debugging purposes\n */\n\n/**\n * Returns scriptlet code by param\n * @param {Source} source\n * @returns {string} scriptlet code\n */\n\nfunction getScriptletCode(source) {\n  if (!validator.isValidScriptletName(source.name)) {\n    return null;\n  }\n\n  var scriptlet = validator.getScriptletByName(source.name);\n  var result = attachDependencies(scriptlet);\n  result = addCall(scriptlet, result);\n  result = source.engine === 'corelibs' || source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);\n  return result;\n}\n/**\n * Scriptlets variable\n *\n * @returns {Object} object with methods:\n * `invoke` method receives one argument with `Source` type\n * `validate` method receives one argument with `String` type\n */\n\n\nvar scriptletsObject = function () {\n  return {\n    invoke: getScriptletCode,\n    isValidScriptletName: validator.isValidScriptletName,\n    isValidScriptletRule: isValidScriptletRule,\n    isAdgScriptletRule: validator.isAdgScriptletRule,\n    isUboScriptletRule: validator.isUboScriptletRule,\n    isAbpSnippetRule: validator.isAbpSnippetRule,\n    convertUboToAdg: convertUboScriptletToAdg,\n    convertAbpToAdg: convertAbpSnippetToAdg,\n    convertScriptletToAdg: convertScriptletToAdg,\n    convertAdgToUbo: convertAdgScriptletToUbo,\n    redirects: redirectsCjs\n  };\n}();\n\n/**\n * Add module exports to be used as node package\n */\n\nmodule.exports = scriptletsObject;\n\n/**\n * -------------------------------------------\n * |                                         |\n * |  If you want to add your own scriptlet  |\n * |  please put your code below             |\n * |                                         |\n * -------------------------------------------\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vbm9kZV9tb2R1bGVzL3NjcmlwdGxldHMvZGlzdC9janMvc2NyaXB0bGV0cy5janMuanM/ZDAwNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLDJCQUEyQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEZBQTRGLGFBQWE7QUFDekc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTs7QUFFQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsYUFBYTtBQUNsRjtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZTs7QUFFeEI7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlFQUFpRTs7QUFFakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDRIQUE0SDs7QUFFNUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDRIQUE0SDs7QUFFNUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOzs7QUFHbEM7QUFDQTs7QUFFQSxvQkFBb0I7OztBQUdwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdILDZDQUE2Qzs7QUFFN0MsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJDQUEyQyx5Q0FBeUMsaUJBQWlCO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQSxzQ0FBc0MsRUFBRSxlQUFlLEVBQUUsWUFBWTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELHFCQUFxQjtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBOztBQUVBLCtDQUErQyxrQkFBa0I7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGdCQUFnQixlQUFlO0FBQy9COztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRFQUE0RTtBQUM1RSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLDBGQUEwRjtBQUMxRixPQUFPO0FBQ1A7QUFDQSw0REFBNEQ7QUFDNUQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsT0FBTztBQUNQO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDREQUE0RCxzQkFBc0I7QUFDbEY7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxtRUFBbUU7QUFDbkUsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxPQUFPO0FBQ1AsOERBQThEO0FBQzlELE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMLGNBQWM7QUFDZCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBLG9FQUFvRSwwQkFBMEI7QUFDOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLCtFQUErRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7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QUVBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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LCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQWRHdWFyZCBTY3JpcHRsZXRzXG4gKiBWZXJzaW9uIDEuMy4yMFxuICovXG5cbi8qKlxuICogUmV0dXJucyB3aWxkY2FyZCBzeW1ib2xcbiAqIEByZXR1cm5zIHtzdHJpbmd9ICcqJ1xuICovXG52YXIgZ2V0V2lsZGNhcmRTeW1ib2wgPSBmdW5jdGlvbiBnZXRXaWxkY2FyZFN5bWJvbCgpIHtcbiAgcmV0dXJuICcqJztcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgcmFuZG9tIHNpeCBzeW1ib2xzIGlkXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUlkKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpO1xufVxuXG4vKipcbiAqIFNldCBnZXR0ZXIgYW5kIHNldHRlciB0byBwcm9wZXJ0eSBpZiBpdCdzIGNvbmZpZ3VyYWJsZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0YXJnZXQgb2JqZWN0IHdpdGggcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciBjb250YWlucyBnZXR0ZXIgYW5kIHNldHRlciBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufSBpcyBvcGVyYXRpb24gc3VjY2Vzc2Z1bFxuICovXG5mdW5jdGlvbiBzZXRQcm9wZXJ0eUFjY2VzcyhvYmplY3QsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XG4gIHZhciBjdXJyZW50RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGN1cnJlbnREZXNjcmlwdG9yICYmICFjdXJyZW50RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIENoYWluXG4gKiBAcHJvcGVydHkge09iamVjdH0gYmFzZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3BcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2hhaW5dXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGluIHRoZSBiYXNlIG9iamVjdCAocmVjdXJzaXZlbHkpXG4gKlxuICogSWYgcHJvcGVydHkgZG9lc24ndCBleGlzdCBpbiBiYXNlIG9iamVjdCxcbiAqIGRlZmluZXMgdGhpcyBwcm9wZXJ0eSBhcyAndW5kZWZpbmVkJ1xuICogYW5kIHJldHVybnMgYmFzZSwgcHJvcGVydHkgbmFtZSBhbmQgcmVtYWluaW5nIHBhcnQgb2YgcHJvcGVydHkgY2hhaW5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYmFzZVxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluXG4gKiBAcmV0dXJucyB7Q2hhaW59XG4gKi9cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5DaGFpbihiYXNlLCBjaGFpbikge1xuICB2YXIgcG9zID0gY2hhaW4uaW5kZXhPZignLicpO1xuXG4gIGlmIChwb3MgPT09IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGJhc2UsXG4gICAgICBwcm9wOiBjaGFpblxuICAgIH07XG4gIH1cblxuICB2YXIgcHJvcCA9IGNoYWluLnNsaWNlKDAsIHBvcyk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMjhcblxuICBpZiAoYmFzZSA9PT0gbnVsbCkge1xuICAgIC8vIGlmIGJhc2UgaXMgbnVsbCwgcmV0dXJuICdudWxsJyBhcyBiYXNlLlxuICAgIC8vIGl0J3MgbmVlZGVkIGZvciB0cmlnZ2VyaW5nIHRoZSByZWFzb24gbG9nZ2luZyB3aGlsZSBkZWJ1Z2dpbmdcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogYmFzZSxcbiAgICAgIHByb3A6IHByb3AsXG4gICAgICBjaGFpbjogY2hhaW5cbiAgICB9O1xuICB9XG5cbiAgdmFyIG5leHRCYXNlID0gYmFzZVtwcm9wXTtcbiAgY2hhaW4gPSBjaGFpbi5zbGljZShwb3MgKyAxKTtcblxuICBpZiAobmV4dEJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRQcm9wZXJ0eUluQ2hhaW4obmV4dEJhc2UsIGNoYWluKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYXNlLCBwcm9wLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGJhc2U6IG5leHRCYXNlLFxuICAgIHByb3A6IHByb3AsXG4gICAgY2hhaW46IGNoYWluXG4gIH07XG59XG5cbi8qKlxuICogQHR5cGVkZWYgQ2hhaW5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBiYXNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJvcFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjaGFpbl1cbiAqL1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMgaW4gdGhlIGJhc2Ugb2JqZWN0IChyZWN1cnNpdmVseSkuXG4gKiBTaW1pbGFyIHRvIGdldFByb3BlcnR5SW5DaGFpbiBidXQgdXBncmFkZWQgZm9yIGpzb24tcHJ1bmU6XG4gKiBoYW5kbGUgd2lsZGNhcmQgcHJvcGVydGllcyBhbmQgZG9lcyBub3QgZGVmaW5lIG5vbmV4aXN0ZW50IGJhc2UgcHJvcGVydHkgYXMgJ3VuZGVmaW5lZCdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYmFzZVxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29rVGhyb3VnaD1mYWxzZV1cbiAqIHNob3VsZCB0aGUgbWV0aG9kIGxvb2sgdGhyb3VnaCBpdCdzIHByb3BzIGluIG9yZGVyIHRvIHdpbGRjYXJkXG4gKiBAcGFyYW0ge0FycmF5fSBbb3V0cHV0PVtdXSByZXN1bHQgYWNjXG4gKiBAcmV0dXJucyB7Q2hhaW5bXX0gYXJyYXkgb2Ygb2JqZWN0c1xuICovXG5cbmZ1bmN0aW9uIGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluKGJhc2UsIGNoYWluKSB7XG4gIHZhciBsb29rVGhyb3VnaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBvdXRwdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICB2YXIgcG9zID0gY2hhaW4uaW5kZXhPZignLicpO1xuXG4gIGlmIChwb3MgPT09IC0xKSB7XG4gICAgLy8gZm9yIHBhdGhzIGxpa2UgJ2EuYi4qJyBldmVyeSBmaW5hbCBuZXN0ZWQgcHJvcCBzaG91bGQgYmUgcHJvY2Vzc2VkXG4gICAgaWYgKGNoYWluID09PSBnZXRXaWxkY2FyZFN5bWJvbCgpIHx8IGNoYWluID09PSAnW10nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIGZvciAodmFyIGtleSBpbiBiYXNlKSB7XG4gICAgICAgIC8vIHRvIHByb2Nlc3MgZWFjaCBrZXkgaW4gYmFzZSBleGNlcHQgaW5oZXJpdGVkIG9uZXNcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiYXNlLCBrZXkpKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goe1xuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIHByb3A6IGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgcHJvcDogY2hhaW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICB2YXIgcHJvcCA9IGNoYWluLnNsaWNlKDAsIHBvcyk7XG4gIHZhciBzaG91bGRMb29rVGhyb3VnaCA9IHByb3AgPT09ICdbXScgJiYgQXJyYXkuaXNBcnJheShiYXNlKSB8fCBwcm9wID09PSBnZXRXaWxkY2FyZFN5bWJvbCgpICYmIGJhc2UgaW5zdGFuY2VvZiBPYmplY3Q7XG5cbiAgaWYgKHNob3VsZExvb2tUaHJvdWdoKSB7XG4gICAgdmFyIG5leHRQcm9wID0gY2hhaW4uc2xpY2UocG9zICsgMSk7XG4gICAgdmFyIGJhc2VLZXlzID0gT2JqZWN0LmtleXMoYmFzZSk7IC8vIGlmIHRoZXJlIGlzIGEgd2lsZGNhcmQgcHJvcCBpbiBpbnB1dCBjaGFpbiAoZS5nLiAnYWQuKi5zcmMnIGZvciAnYWQuMC5zcmMgYWQuMS5zcmMnKSxcbiAgICAvLyBlYWNoIG9uZSBvZiBiYXNlIGtleXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgY2hhaW4gcHJvcCBpbiBmaW5hbCBwYXRoXG5cbiAgICBiYXNlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBpdGVtID0gYmFzZVtrZXldO1xuICAgICAgZ2V0V2lsZGNhcmRQcm9wZXJ0eUluQ2hhaW4oaXRlbSwgbmV4dFByb3AsIGxvb2tUaHJvdWdoLCBvdXRwdXQpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIG5leHRCYXNlID0gYmFzZVtwcm9wXTtcbiAgY2hhaW4gPSBjaGFpbi5zbGljZShwb3MgKyAxKTtcblxuICBpZiAobmV4dEJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluKG5leHRCYXNlLCBjaGFpbiwgbG9va1Rocm91Z2gsIG91dHB1dCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIE5hTlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzTmFOXG4gKiBAcGFyYW0geyp9IG51bVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBuYXRpdmVJc05hTiA9IGZ1bmN0aW9uIG5hdGl2ZUlzTmFOKG51bSkge1xuICB2YXIgbmF0aXZlID0gTnVtYmVyLmlzTmFOIHx8IHdpbmRvdy5pc05hTjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb21wYXQvY29tcGF0XG5cbiAgcmV0dXJuIG5hdGl2ZShudW0pO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBmaW5pdGUgbnVtYmVyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNGaW5pdGVcbiAqIEBwYXJhbSB7Kn0gbnVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgbmF0aXZlSXNGaW5pdGUgPSBmdW5jdGlvbiBuYXRpdmVJc0Zpbml0ZShudW0pIHtcbiAgdmFyIG5hdGl2ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCB3aW5kb3cuaXNGaW5pdGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuXG4gIHJldHVybiBuYXRpdmUobnVtKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgb2JqZWN0IHRvIGFycmF5IG9mIHBhaXJzLlxuICogT2JqZWN0LmVudHJpZXMoKSBwb2x5ZmlsbCBiZWNhdXNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUVcbiAqIGh0dHBzOi8vY2FuaXVzZS5jb20vP3NlYXJjaD1PYmplY3QuZW50cmllc1xuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fSBhcnJheSBvZiBwYWlyc1xuICovXG52YXIgZ2V0T2JqZWN0RW50cmllcyA9IGZ1bmN0aW9uIGdldE9iamVjdEVudHJpZXMob2JqZWN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgdmFyIGVudHJpZXMgPSBbXTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZW50cmllcy5wdXNoKFtrZXksIG9iamVjdFtrZXldXSk7XG4gIH0pO1xuICByZXR1cm4gZW50cmllcztcbn07XG4vKipcbiAqIENvbnZlcnRzIGFycmF5IG9mIHBhaXJzIHRvIG9iamVjdC5cbiAqIE9iamVjdC5mcm9tRW50cmllcygpIHBvbHlmaWxsIGJlY2F1c2UgaXQgaXMgbm90IHN1cHBvcnRlZCBieSBJRVxuICogaHR0cHM6Ly9jYW5pdXNlLmNvbS8/c2VhcmNoPU9iamVjdC5mcm9tRW50cmllc1xuICogQHBhcmFtIHtBcnJheX0gZW50cmllcyAtIGFycmF5IG9mIHBhaXJzXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5cbnZhciBnZXRPYmplY3RGcm9tRW50cmllcyA9IGZ1bmN0aW9uIGdldE9iamVjdEZyb21FbnRyaWVzKGVudHJpZXMpIHtcbiAgdmFyIG91dHB1dCA9IGVudHJpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGVsKSB7XG4gICAgdmFyIGtleSA9IGVsWzBdO1xuICAgIHZhciB2YWx1ZSA9IGVsWzFdO1xuICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gb3V0cHV0O1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIG9iaiBpcyBhbiBlbXB0eSBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKiBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwgcG9saWZpbGxcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBpbnB1dCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWJzdHIgdG8gbG9vayBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTdWJzdHIgcmVwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIHJlcGxhY2VBbGwgPSBmdW5jdGlvbiByZXBsYWNlQWxsKGlucHV0LCBzdWJzdHIsIG5ld1N1YnN0cikge1xuICByZXR1cm4gaW5wdXQuc3BsaXQoc3Vic3RyKS5qb2luKG5ld1N1YnN0cik7XG59O1xuLyoqXG4gKiBFc2NhcGVzIHNwZWNpYWwgY2hhcnMgaW4gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHNlYXJjaCBzdHJpbmcgdG8gdGhlIHJlZ2V4cFxuICogVE9ETyB0aGluayBhYm91dCBuZXN0ZWQgZGVwZW5kZW5jaWVzLCBidXQgYmUgY2FyZWZ1bCB3aXRoIGRlcGVuZGVuY3kgbG9vcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc2VhcmNoIHN0cmluZ1xuICogQHJldHVybnMge1JlZ0V4cH1cbiAqL1xuXG52YXIgdG9SZWdFeHAgPSBmdW5jdGlvbiB0b1JlZ0V4cChzdHIpIHtcbiAgaWYgKCFzdHIgfHwgc3RyID09PSAnJykge1xuICAgIHZhciBERUZBVUxUX1ZBTFVFID0gJy4/JztcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChERUZBVUxUX1ZBTFVFKTtcbiAgfVxuXG4gIGlmIChzdHJbMF0gPT09ICcvJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnLycpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzdHIuc2xpY2UoMSwgLTEpKTtcbiAgfVxuXG4gIHZhciBlc2NhcGVkID0gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGVzY2FwZWQpO1xufTtcbi8qKlxuICogR2V0IHN0cmluZyBiZWZvcmUgcmVnZXhwIGZpcnN0IG1hdGNoXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcnhcbiAqL1xuXG52YXIgZ2V0QmVmb3JlUmVnRXhwID0gZnVuY3Rpb24gZ2V0QmVmb3JlUmVnRXhwKHN0ciwgcngpIHtcbiAgdmFyIGluZGV4ID0gc3RyLnNlYXJjaChyeCk7XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIGluZGV4KTtcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggdGhlIHN1YnN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBmdWxsIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBzdWJzdHJpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkge1xuICAvLyBpZiBzdHIgPT09ICcnLCAoc3RyICYmIGZhbHNlKSB3aWxsIHJldHVybiAnJ1xuICAvLyB0aGF0J3Mgd2h5IGl0IGhhcyB0byBiZSAhIXN0clxuICByZXR1cm4gISFzdHIgJiYgc3RyLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgZnVsbCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRpbmcgc3Vic3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgZW5kc1dpdGggPSBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIGVuZGluZykge1xuICAvLyBpZiBzdHIgPT09ICcnLCAoc3RyICYmIGZhbHNlKSB3aWxsIHJldHVybiAnJ1xuICAvLyB0aGF0J3Mgd2h5IGl0IGhhcyB0byBiZSAhIXN0clxuICByZXR1cm4gISFzdHIgJiYgc3RyLmluZGV4T2YoZW5kaW5nKSA9PT0gc3RyLmxlbmd0aCAtIGVuZGluZy5sZW5ndGg7XG59O1xudmFyIHN1YnN0cmluZ0FmdGVyID0gZnVuY3Rpb24gc3Vic3RyaW5nQWZ0ZXIoc3RyLCBzZXBhcmF0b3IpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/ICcnIDogc3RyLnN1YnN0cmluZyhpbmRleCArIHNlcGFyYXRvci5sZW5ndGgpO1xufTtcbnZhciBzdWJzdHJpbmdCZWZvcmUgPSBmdW5jdGlvbiBzdWJzdHJpbmdCZWZvcmUoc3RyLCBzZXBhcmF0b3IpIHtcbiAgaWYgKCFzdHIgfHwgIXNlcGFyYXRvcikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZihzZXBhcmF0b3IpO1xuICByZXR1cm4gaW5kZXggPCAwID8gc3RyIDogc3RyLnN1YnN0cmluZygwLCBpbmRleCk7XG59O1xuLyoqXG4gKiBXcmFwIHN0ciBpbiBzaW5nbGUgcW91dGVzIGFuZCByZXBsYWNlcyBzaW5nbGUgcXVvdGVzIHRvIGRvdWRsZSBvbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuXG52YXIgd3JhcEluU2luZ2xlUXVvdGVzID0gZnVuY3Rpb24gd3JhcEluU2luZ2xlUXVvdGVzKHN0cikge1xuICBpZiAoc3RyWzBdID09PSAnXFwnJyAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnXFwnJyB8fCBzdHJbMF0gPT09ICdcIicgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSwgc3RyLmxlbmd0aCAtIDEpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG5cbiAgc3RyID0gc3RyLnJlcGxhY2UoL1xcJy9nLCAnXCInKTtcbiAgcmV0dXJuIFwiJ1wiLmNvbmNhdChzdHIsIFwiJ1wiKTtcbn07XG4vKipcbiAqIFJldHVybnMgc3Vic3RyaW5nIGVuY2xvc2VkIGluIHRoZSB3aWRlc3QgYnJhY2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cblxudmFyIGdldFN0cmluZ0luQnJhY2VzID0gZnVuY3Rpb24gZ2V0U3RyaW5nSW5CcmFjZXMoc3RyKSB7XG4gIHZhciBmaXJzdEluZGV4ID0gc3RyLmluZGV4T2YoJygnKTtcbiAgdmFyIGxhc3RJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignKScpO1xuICByZXR1cm4gc3RyLnN1YnN0cmluZyhmaXJzdEluZGV4ICsgMSwgbGFzdEluZGV4KTtcbn07XG4vKipcbiAqIFByZXBhcmVzIFJUQ1BlZXJDb25uZWN0aW9uIGNvbmZpZyBhcyBzdHJpbmcgZm9yIHByb3BlciBsb2dnaW5nXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xuICogQHJldHVybnMge3N0cmluZ30gc3RyaW5naWZpZWQgY29uZmlnXG4qL1xuXG52YXIgY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nID0gZnVuY3Rpb24gY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nKGNvbmZpZykge1xuICB2YXIgVU5ERUZfU1RSID0gJ3VuZGVmaW5lZCc7XG4gIHZhciBzdHIgPSBVTkRFRl9TVFI7XG5cbiAgaWYgKGNvbmZpZyA9PT0gbnVsbCkge1xuICAgIHN0ciA9ICdudWxsJztcbiAgfSBlbHNlIGlmIChjb25maWcgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgU0VSVkVSU19QUk9QX05BTUUgPSAnaWNlU2VydmVycyc7XG4gICAgdmFyIFVSTFNfUFJPUF9OQU1FID0gJ3VybHMnO1xuICAgIC8qXG4gICAgICAgIGNvbnN0IGV4YW1wbGVDb25maWcgPSB7XG4gICAgICAgICAgICAnaWNlU2VydmVycyc6IFtcbiAgICAgICAgICAgICAgICAndXJscyc6IFsnc3R1bjozNS42Ni4yMDYuMTg4OjQ0MyddLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAqL1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFNFUlZFUlNfUFJPUF9OQU1FKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnW1NFUlZFUlNfUFJPUF9OQU1FXVswXSwgVVJMU19QUk9QX05BTUUpICYmICEhY29uZmlnW1NFUlZFUlNfUFJPUF9OQU1FXVswXVtVUkxTX1BST1BfTkFNRV0pIHtcbiAgICAgIHN0ciA9IGNvbmZpZ1tTRVJWRVJTX1BST1BfTkFNRV1bMF1bVVJMU19QUk9QX05BTUVdLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hdGNoRGF0YVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0ludmVydGVkTWF0Y2hcbiAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBtYXRjaFJlZ2V4cFxuICovXG5cbi8qKlxuICogUGFyc2VzIG1hdGNoIGFyZyB3aXRoIHBvc3NpYmxlIG5lZ2F0aW9uIGZvciBubyBtYXRjaGluZy5cbiAqIE5lZWRlZCBmb3IgcHJldmVudC1zZXRUaW1lb3V0LCBwcmV2ZW50LXNldEludGVydmFsLFxuICogcHJldmVudC1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYW5kIHByZXZlbnQtd2luZG93LW9wZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFxuICogQHJldHVybnMge01hdGNoRGF0YX1cbiAqL1xuXG52YXIgcGFyc2VNYXRjaEFyZyA9IGZ1bmN0aW9uIHBhcnNlTWF0Y2hBcmcobWF0Y2gpIHtcbiAgdmFyIElOVkVSVF9NQVJLRVIgPSAnISc7XG4gIHZhciBpc0ludmVydGVkTWF0Y2ggPSBzdGFydHNXaXRoKG1hdGNoLCBJTlZFUlRfTUFSS0VSKTtcbiAgdmFyIG1hdGNoVmFsdWUgPSBpc0ludmVydGVkTWF0Y2ggPyBtYXRjaC5zbGljZSgxKSA6IG1hdGNoO1xuICB2YXIgbWF0Y2hSZWdleHAgPSB0b1JlZ0V4cChtYXRjaFZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICBpc0ludmVydGVkTWF0Y2g6IGlzSW52ZXJ0ZWRNYXRjaCxcbiAgICBtYXRjaFJlZ2V4cDogbWF0Y2hSZWdleHBcbiAgfTtcbn07XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlbGF5RGF0YVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0ludmVydGVkRGVsYXlNYXRjaFxuICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gZGVsYXlNYXRjaFxuICovXG5cbi8qKlxuICogUGFyc2VzIGRlbGF5IGFyZyB3aXRoIHBvc3NpYmxlIG5lZ2F0aW9uIGZvciBubyBtYXRjaGluZy5cbiAqIE5lZWRlZCBmb3IgcHJldmVudC1zZXRUaW1lb3V0IGFuZCBwcmV2ZW50LXNldEludGVydmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVsYXlcbiAqIEByZXR1cm5zIHtEZWxheURhdGF9XG4gKi9cblxudmFyIHBhcnNlRGVsYXlBcmcgPSBmdW5jdGlvbiBwYXJzZURlbGF5QXJnKGRlbGF5KSB7XG4gIHZhciBJTlZFUlRfTUFSS0VSID0gJyEnO1xuICB2YXIgaXNJbnZlcnRlZERlbGF5TWF0Y2ggPSBzdGFydHNXaXRoKGRlbGF5LCBJTlZFUlRfTUFSS0VSKTtcbiAgdmFyIGRlbGF5VmFsdWUgPSBpc0ludmVydGVkRGVsYXlNYXRjaCA/IGRlbGF5LnNsaWNlKDEpIDogZGVsYXk7XG4gIGRlbGF5VmFsdWUgPSBwYXJzZUludChkZWxheVZhbHVlLCAxMCk7XG4gIHZhciBkZWxheU1hdGNoID0gbmF0aXZlSXNOYU4oZGVsYXlWYWx1ZSkgPyBudWxsIDogZGVsYXlWYWx1ZTtcbiAgcmV0dXJuIHtcbiAgICBpc0ludmVydGVkRGVsYXlNYXRjaDogaXNJbnZlcnRlZERlbGF5TWF0Y2gsXG4gICAgZGVsYXlNYXRjaDogZGVsYXlNYXRjaFxuICB9O1xufTtcbi8qKlxuICogQ29udmVydHMgb2JqZWN0IHRvIHN0cmluZyBmb3IgbG9nZ2luZ1xuICogQHBhcmFtIHtPYmplY3R9IG9iaiBkYXRhIG9iamVjdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIGlzRW1wdHlPYmplY3Qob2JqKSA/ICd7fScgOiBnZXRPYmplY3RFbnRyaWVzKG9iaikubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgdmFyIGtleSA9IHBhaXJbMF07XG4gICAgdmFyIHZhbHVlID0gcGFpclsxXTtcbiAgICB2YXIgcmVjb3JkVmFsdWVTdHIgPSB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgcmVjb3JkVmFsdWVTdHIgPSBcInsgXCIuY29uY2F0KG9iamVjdFRvU3RyaW5nKHZhbHVlKSwgXCIgfVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIjpcXFwiXCIpLmNvbmNhdChyZWNvcmRWYWx1ZVN0ciwgXCJcXFwiXCIpO1xuICB9KS5qb2luKCcgJyk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0eXBlcyBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBjb252ZXJ0VHlwZVRvU3RyaW5nID0gZnVuY3Rpb24gY29udmVydFR5cGVUb1N0cmluZyh2YWx1ZSkge1xuICB2YXIgb3V0cHV0O1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3V0cHV0ID0gJ3VuZGVmaW5lZCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgb3V0cHV0ID0gJ251bGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQgPSBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgZnVuY3Rpb24gd2hpY2ggc2lsZW50cyBnbG9iYWwgZXJyb3JzIG9uIHBhZ2UgZ2VuZXJhdGVkIGJ5IHNjcmlwdGxldFxuICogSWYgZXJyb3IgZG9lc24ndCBiZWxvbmcgdG8gb3VyIGVycm9yIHdlIHRyYW5zZmVyIGl0IHRvIHRoZSBuYXRpdmUgb25FcnJvciBoYW5kbGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmlkIC0gdW5pcXVlIGlkZW50aWZpZXIgb2Ygc2NyaXB0bGV0XG4gKiBAcmV0dXJuIHtvbkVycm9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIHZhciBuYXRpdmVPbkVycm9yID0gd2luZG93Lm9uZXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgJiYgZXJyb3IuaW5kZXhPZihyaWQpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5hdGl2ZU9uRXJyb3IgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZU9uRXJyb3IuYXBwbHkodGhpcywgW2Vycm9yXS5jb25jYXQoYXJncykpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBOb29wIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG52YXIgbm9vcEZ1bmMgPSBmdW5jdGlvbiBub29wRnVuYygpIHt9O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIG51bGxcbiAqIEByZXR1cm4ge251bGx9IG51bGxcbiAqL1xuXG52YXIgbm9vcE51bGwgPSBmdW5jdGlvbiBub29wTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIHRydWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWVcbiAqL1xuXG52YXIgdHJ1ZUZ1bmMgPSBmdW5jdGlvbiB0cnVlRnVuYygpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIGZhbHNlXG4gKiBAcmV0dXJuIHtib29sZWFufSBmYWxzZVxuICovXG5cbnZhciBmYWxzZUZ1bmMgPSBmdW5jdGlvbiBmYWxzZUZ1bmMoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybnMgdGhpc1xuICovXG5cbmZ1bmN0aW9uIG5vb3BUaGlzKCkge1xuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyBlbXB0eSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ30gZW1wdHkgc3RyaW5nXG4gKi9cblxudmFyIG5vb3BTdHIgPSBmdW5jdGlvbiBub29wU3RyKCkge1xuICByZXR1cm4gJyc7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIGVtcHR5IGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheX0gZW1wdHkgYXJyYXlcbiAqL1xuXG52YXIgbm9vcEFycmF5ID0gZnVuY3Rpb24gbm9vcEFycmF5KCkge1xuICByZXR1cm4gW107XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIGVtcHR5IG9iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSBlbXB0eSBvYmplY3RcbiAqL1xuXG52YXIgbm9vcE9iamVjdCA9IGZ1bmN0aW9uIG5vb3BPYmplY3QoKSB7XG4gIHJldHVybiB7fTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybnMgUHJvbWlzZS5yZWplY3QoKVxuICovXG5cbnZhciBub29wUHJvbWlzZVJlamVjdCA9IGZ1bmN0aW9uIG5vb3BQcm9taXNlUmVqZWN0KCkge1xuICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuXG4vKipcbiAqIFJldHVybnMgUHJvbWlzZSBvYmplY3QgdGhhdCBpcyByZXNvbHZlZCB3aXRoIGFuIGVtcHR5IHJlc3BvbnNlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG5cbnZhciBub29wUHJvbWlzZVJlc29sdmUgPSBmdW5jdGlvbiBub29wUHJvbWlzZVJlc29sdmUoKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFJlc3BvbnNlKCkpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSwgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxuLyoqXG4gKiBIaXQgdXNlZCBvbmx5IGZvciBkZWJ1ZyBwdXJwb3NlcyBub3dcbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gLSBvcHRpb25hbCBtZXNzYWdlO1xuICogdXNlIExPR19NQVJLRVIgPSAnbG9nOiAnIGF0IHRoZSBzdGFydCBvZiBhIG1lc3NhZ2VcbiAqIGZvciBsb2dnaW5nIHNjcmlwdGxldHNcbiAqL1xudmFyIGhpdCA9IGZ1bmN0aW9uIGhpdChzb3VyY2UsIG1lc3NhZ2UpIHtcbiAgaWYgKHNvdXJjZS52ZXJib3NlICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgbG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICB2YXIgdHJhY2UgPSBjb25zb2xlLnRyYWNlLmJpbmQoY29uc29sZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuXG4gICAgdmFyIHByZWZpeCA9IHNvdXJjZS5ydWxlVGV4dCB8fCAnJztcblxuICAgIGlmIChzb3VyY2UuZG9tYWluTmFtZSkge1xuICAgICAgdmFyIEFHX1NDUklQVExFVF9NQVJLRVIgPSAnIyUjLy8nO1xuICAgICAgdmFyIFVCT19TQ1JJUFRMRVRfTUFSS0VSID0gJyMjK2pzJztcbiAgICAgIHZhciBydWxlU3RhcnRJbmRleDtcblxuICAgICAgaWYgKHNvdXJjZS5ydWxlVGV4dC5pbmRleE9mKEFHX1NDUklQVExFVF9NQVJLRVIpID4gLTEpIHtcbiAgICAgICAgcnVsZVN0YXJ0SW5kZXggPSBzb3VyY2UucnVsZVRleHQuaW5kZXhPZihBR19TQ1JJUFRMRVRfTUFSS0VSKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlLnJ1bGVUZXh0LmluZGV4T2YoVUJPX1NDUklQVExFVF9NQVJLRVIpID4gLTEpIHtcbiAgICAgICAgcnVsZVN0YXJ0SW5kZXggPSBzb3VyY2UucnVsZVRleHQuaW5kZXhPZihVQk9fU0NSSVBUTEVUX01BUktFUik7XG4gICAgICB9IC8vIGRlbGV0ZSBhbGwgZG9tYWlucyBmcm9tIHJ1bGVUZXh0IGFuZCBsZWF2ZSBqdXN0IHJ1bGUgcGFydFxuXG5cbiAgICAgIHZhciBydWxlUGFydCA9IHNvdXJjZS5ydWxlVGV4dC5zbGljZShydWxlU3RhcnRJbmRleCk7IC8vIHByZXBhcmUgYXBwbGllZCBzY3JpcHRsZXQgcnVsZSBmb3Igc3BlY2lmaWMgZG9tYWluXG5cbiAgICAgIHByZWZpeCA9IFwiXCIuY29uY2F0KHNvdXJjZS5kb21haW5OYW1lKS5jb25jYXQocnVsZVBhcnQpO1xuICAgIH0gLy8gVXNlZCB0byBjaGVjayBpZiBzY3JpcHRsZXQgdXNlcyAnaGl0JyBmdW5jdGlvbiBmb3IgbG9nZ2luZ1xuXG5cbiAgICB2YXIgTE9HX01BUktFUiA9ICdsb2c6ICc7XG5cbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgaWYgKG1lc3NhZ2UuaW5kZXhPZihMT0dfTUFSS0VSKSA9PT0gLTEpIHtcbiAgICAgICAgbG9nKFwiXCIuY29uY2F0KHByZWZpeCwgXCIgbWVzc2FnZTpcXG5cIikuY29uY2F0KG1lc3NhZ2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyhtZXNzYWdlLnNsaWNlKExPR19NQVJLRVIubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nKFwiXCIuY29uY2F0KHByZWZpeCwgXCIgdHJhY2Ugc3RhcnRcIikpO1xuXG4gICAgaWYgKHRyYWNlKSB7XG4gICAgICB0cmFjZSgpO1xuICAgIH1cblxuICAgIGxvZyhcIlwiLmNvbmNhdChwcmVmaXgsIFwiIHRyYWNlIGVuZFwiKSk7XG4gIH0gY2F0Y2ggKGUpIHsvLyB0cnkgY2F0Y2ggZm9yIEVkZ2UgMTVcbiAgICAvLyBJbiBhY2NvcmRpbmcgdG8gdGhpcyBpc3N1ZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xNDQ5NTIyMC9cbiAgICAvLyBjb25zb2xlLmxvZyB0aHJvd3MgYW4gZXJyb3JcbiAgfSAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdW5pdC10ZXN0cyBvbmx5IVxuXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cuX19kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdpbmRvdy5fX2RlYnVnKHNvdXJjZSk7XG4gIH1cbn07XG5cbi8qKlxuICogRE9NIHRyZWUgY2hhbmdlcyBvYnNlcnZlci4gVXNlZCBmb3IgJ3JlbW92ZS1hdHRyJyBhbmQgJ3JlbW92ZS1jbGFzcycgc2NyaXB0bGV0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb2JzZXJ2ZUF0dHJzIC0gb3B0aW9uYWwgcGFyYW1ldGVyIC0gc2hvdWxkIG9ic2VydmVyIGNoZWNrIGF0dGlidXRlcyBjaGFuZ2VzXG4gKi9cbnZhciBvYnNlcnZlRE9NQ2hhbmdlcyA9IGZ1bmN0aW9uIG9ic2VydmVET01DaGFuZ2VzKGNhbGxiYWNrKSB7XG4gIHZhciBvYnNlcnZlQXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgYXR0cnNUb09ic2VydiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyLCBwYXNzaW5nIHRoZSBjYWxsIHRvICdtZXRob2QnIGF0IG1heGltdW0gb25jZSBwZXIgJ2RlbGF5JyBtaWxsaXNlY29uZHMuXG4gICAqIFRob3NlIGNhbGxzIHRoYXQgZmFsbCBpbnRvIHRoZSBcImNvb2xkb3duXCIgcGVyaW9kLCBhcmUgaWdub3JlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IC0gbWlsbGlzZWNvbmRzXG4gICAqL1xuICB2YXIgdGhyb3R0bGUgPSBmdW5jdGlvbiB0aHJvdHRsZShtZXRob2QsIGRlbGF5KSB7XG4gICAgdmFyIHdhaXQgPSBmYWxzZTtcbiAgICB2YXIgc2F2ZWRBcmdzO1xuXG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmICh3YWl0KSB7XG4gICAgICAgIHNhdmVkQXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWV0aG9kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB3YWl0ID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB3YWl0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNhdmVkQXJncykge1xuICAgICAgICAgIHdyYXBwZXIoc2F2ZWRBcmdzKTtcbiAgICAgICAgICBzYXZlZEFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfTtcblxuICAgIHJldHVybiB3cmFwcGVyO1xuICB9O1xuICAvKipcbiAgICogJ2RlbGF5JyBpbiBtaWxsaXNlY29uZHMgZm9yICd0aHJvdHRsZScgbWV0aG9kXG4gICAqL1xuXG5cbiAgdmFyIFRIUk9UVExFX0RFTEFZX01TID0gMjA7XG4gIC8qKlxuICAgKiBVc2VkIGZvciByZW1vdmUtY2xhc3NcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZSwgY29tcGF0L2NvbXBhdFxuXG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRocm90dGxlKGNhbGxiYWNrV3JhcHBlciwgVEhST1RUTEVfREVMQVlfTVMpKTtcblxuICB2YXIgY29ubmVjdCA9IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgaWYgKGF0dHJzVG9PYnNlcnYubGVuZ3RoID4gMCkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiBvYnNlcnZlQXR0cnMsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogYXR0cnNUb09ic2VydlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogb2JzZXJ2ZUF0dHJzXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRpc2Nvbm5lY3QgPSBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjYWxsYmFja1dyYXBwZXIoKSB7XG4gICAgZGlzY29ubmVjdCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgY29ubmVjdCgpO1xuICB9XG5cbiAgY29ubmVjdCgpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHN0YWNrVHJhY2UgY29udGFpbnMgc3RhY2tSZWdleHBcbiAqIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy84MlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzdGFja01hdGNoIC0gaW5wdXQgc3RhY2sgdmFsdWUgdG8gbWF0Y2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja1RyYWNlIC0gc2NyaXB0IGVycm9yIHN0YWNrIHRyYWNlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgbWF0Y2hTdGFja1RyYWNlID0gZnVuY3Rpb24gbWF0Y2hTdGFja1RyYWNlKHN0YWNrTWF0Y2gsIHN0YWNrVHJhY2UpIHtcbiAgaWYgKCFzdGFja01hdGNoIHx8IHN0YWNrTWF0Y2ggPT09ICcnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgc3RhY2tSZWdleHAgPSB0b1JlZ0V4cChzdGFja01hdGNoKTtcbiAgdmFyIHJlZmluZWRTdGFja1RyYWNlID0gc3RhY2tUcmFjZS5zcGxpdCgnXFxuJykuc2xpY2UoMikgLy8gZ2V0IHJpZCBvZiBvdXIgb3duIGZ1bmN0aW9ucyBpbiB0aGUgc3RhY2sgdHJhY2VcbiAgLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgfSkgLy8gdHJpbSB0aGUgbGluZXNcbiAgLmpvaW4oJ1xcbicpO1xuICByZXR1cm4gc3RhY2tSZWdleHAudGVzdChyZWZpbmVkU3RhY2tUcmFjZSk7XG59O1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgQXJyYXkucHJvdG90eXBlLmZsYXQoKVxuICogZm9yIGV4YW1wbGUsIE9wZXJhIDQyIHdoaWNoIGlzIHVzZWQgZm9yIGJyb3dzZXJzdGFjayB0ZXN0c1xuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmxhdFxuICogQHBhcmFtIHtBcnJheX0gaW5wdXRcbiAqL1xudmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuKGlucHV0KSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBpbnB1dC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBzdGFjay5wdXNoKGVsKTtcbiAgfSk7XG4gIHZhciByZXMgPSBbXTtcblxuICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgLy8gcG9wIHZhbHVlIGZyb20gc3RhY2tcbiAgICB2YXIgbmV4dCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIC8vIHB1c2ggYmFjayBhcnJheSBpdGVtcywgd29uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBpbnB1dFxuICAgICAgbmV4dC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gc3RhY2sucHVzaChlbCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnB1c2gobmV4dCk7XG4gICAgfVxuICB9IC8vIHJldmVyc2UgdG8gcmVzdG9yZSBpbnB1dCBvcmRlclxuXG5cbiAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59O1xuXG4vKipcbiAqIEZpbmRzIHNoYWRvdy1kb20gaG9zdCAoZWxlbWVudHMgd2l0aCBzaGFkb3dSb290IHByb3BlcnR5KSBpbiBET00gb2Ygcm9vdEVsZW1lbnQuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290RWxlbWVudFxuICogQHJldHVybnMge0hUTUxFbGVtZW50W119IHNoYWRvdy1kb20gaG9zdHNcbiAqL1xuXG52YXIgZmluZEhvc3RFbGVtZW50cyA9IGZ1bmN0aW9uIGZpbmRIb3N0RWxlbWVudHMocm9vdEVsZW1lbnQpIHtcbiAgdmFyIGhvc3RzID0gW107IC8vIEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgpIHJldHVybnMgbGlzdCBvZiBlbGVtZW50c1xuICAvLyB3aGljaCBhcmUgZGVmaW5lZCBpbiBET00gb2YgRWxlbWVudC5cbiAgLy8gTWVhbndoaWxlLCBpbm5lciBET00gb2YgdGhlIGVsZW1lbnQgd2l0aCBzaGFkb3dSb290IHByb3BlcnR5XG4gIC8vIGlzIGFic29sdXRlbHkgYW5vdGhlciBET00gYW5kIHdoaWNoIGNhbiBub3QgYmUgcmVhY2hlZCBieSBxdWVyeVNlbGVjdG9yQWxsKCcqJylcblxuICB2YXIgZG9tRWxlbXMgPSByb290RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG4gIGRvbUVsZW1zLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLnNoYWRvd1Jvb3QpIHtcbiAgICAgIGhvc3RzLnB1c2goZWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBob3N0cztcbn07XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBub2Rlcy5cbiAqXG4gKiBAZXh0ZXJuYWwgTm9kZUxpc3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlTGlzdCBOb2RlTGlzdH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBpZXJjZURhdGFcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gdGFyZ2V0cyBmb3VuZCBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3JcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gaW5uZXJIb3N0cyBpbm5lciBzaGFkb3ctZG9tIGhvc3RzXG4gKi9cblxuLyoqXG4gKiBQaWVyY2VzIG9wZW4gc2hhZG93LWRvbSBpbiBvcmRlciB0byBmaW5kOlxuICogLSBlbGVtZW50cyBieSAnc2VsZWN0b3InIG1hdGNoaW5nXG4gKiAtIGlubmVyIHNoYWRvdy1kb20gaG9zdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfGV4dGVybmFsOk5vZGVMaXN0fSBob3N0RWxlbWVudHNcbiAqIEByZXR1cm5zIHtQaWVyY2VEYXRhfVxuICovXG5cbnZhciBwaWVyY2VTaGFkb3dEb20gPSBmdW5jdGlvbiBwaWVyY2VTaGFkb3dEb20oc2VsZWN0b3IsIGhvc3RFbGVtZW50cykge1xuICB2YXIgdGFyZ2V0cyA9IFtdO1xuICB2YXIgaW5uZXJIb3N0c0FjYyA9IFtdOyAvLyBpdCdzIHBvc3NpYmxlIHRvIGdldCBhIGZldyBob3N0RWxlbWVudHMgZm91bmQgYnkgYmFzZVNlbGVjdG9yIG9uIHRoZSBwYWdlXG5cbiAgaG9zdEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAvLyBjaGVjayBwcmVzZW5jZSBvZiBzZWxlY3RvciBlbGVtZW50IGluc2lkZSBiYXNlIGVsZW1lbnQgaWYgaXQncyBub3QgaW4gc2hhZG93LWRvbVxuICAgIHZhciBzaW1wbGVFbGVtcyA9IGhvc3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KFtdLnNsaWNlLmNhbGwoc2ltcGxlRWxlbXMpKTtcbiAgICB2YXIgc2hhZG93Um9vdEVsZW0gPSBob3N0LnNoYWRvd1Jvb3Q7XG4gICAgdmFyIHNoYWRvd0NoaWxkcmVuID0gc2hhZG93Um9vdEVsZW0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KFtdLnNsaWNlLmNhbGwoc2hhZG93Q2hpbGRyZW4pKTsgLy8gZmluZCBpbm5lciBzaGFkb3ctZG9tIGhvc3RzIGluc2lkZSBwcm9jZXNzaW5nIHNoYWRvdy1kb21cblxuICAgIGlubmVySG9zdHNBY2MucHVzaChmaW5kSG9zdEVsZW1lbnRzKHNoYWRvd1Jvb3RFbGVtKSk7XG4gIH0pOyAvLyBpZiB0aGVyZSB3ZXJlIG1vcmUgdGhhbiBvbmUgaG9zdCBlbGVtZW50LFxuICAvLyBpbm5lckhvc3RzQWNjIGlzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgc2hvdWxkIGJlIGZsYXR0ZW5cblxuICB2YXIgaW5uZXJIb3N0cyA9IGZsYXR0ZW4oaW5uZXJIb3N0c0FjYyk7XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0czogdGFyZ2V0cyxcbiAgICBpbm5lckhvc3RzOiBpbm5lckhvc3RzXG4gIH07XG59O1xuXG4vKipcbiAqIFByZXBhcmVzIGNvb2tpZSBzdHJpbmcgaWYgZ2l2ZW4gcGFyYW1ldGVycyBhcmUgb2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvb2tpZSBuYW1lIHRvIHNldFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIGNvb2tpZSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gY29va2llIHN0cmluZyBpZiBvayBPUiBudWxsIGlmIG5vdFxuICovXG5cbnZhciBwcmVwYXJlQ29va2llID0gZnVuY3Rpb24gcHJlcGFyZUNvb2tpZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIW5hbWUgfHwgIXZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgdmFsdWVUb1NldDtcblxuICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIHZhbHVlVG9TZXQgPSAndHJ1ZSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdUcnVlJykge1xuICAgIHZhbHVlVG9TZXQgPSAnVHJ1ZSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ2ZhbHNlJztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ0ZhbHNlJykge1xuICAgIHZhbHVlVG9TZXQgPSAnRmFsc2UnO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAneWVzJykge1xuICAgIHZhbHVlVG9TZXQgPSAneWVzJztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ1llcycpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ1llcyc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdZJykge1xuICAgIHZhbHVlVG9TZXQgPSAnWSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdubycpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ25vJztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ29rJykge1xuICAgIHZhbHVlVG9TZXQgPSAnb2snO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnT0snKSB7XG4gICAgdmFsdWVUb1NldCA9ICdPSyc7XG4gIH0gZWxzZSBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICB2YWx1ZVRvU2V0ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICBpZiAobmF0aXZlSXNOYU4odmFsdWVUb1NldCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh2YWx1ZVRvU2V0KSA8IDAgfHwgTWF0aC5hYnModmFsdWVUb1NldCkgPiAxNSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhdGhUb1NldCA9ICdwYXRoPS87JztcbiAgdmFyIGNvb2tpZURhdGEgPSBcIlwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQobmFtZSksIFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlVG9TZXQpLCBcIjsgXCIpLmNvbmNhdChwYXRoVG9TZXQpO1xuICByZXR1cm4gY29va2llRGF0YTtcbn07XG5cbnZhciBzaG91bGRNYXRjaEFueURlbGF5ID0gZnVuY3Rpb24gc2hvdWxkTWF0Y2hBbnlEZWxheShkZWxheSkge1xuICByZXR1cm4gZGVsYXkgPT09IGdldFdpbGRjYXJkU3ltYm9sKCk7XG59O1xuLyoqXG4gKiBIYW5kbGVzIGlucHV0IGRlbGF5IHZhbHVlXG4gKiBAcGFyYW0geyp9IGRlbGF5XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBwcm9wZXIgbnVtYmVyIGRlbGF5IHZhbHVlXG4gKi9cblxudmFyIGdldE1hdGNoRGVsYXkgPSBmdW5jdGlvbiBnZXRNYXRjaERlbGF5KGRlbGF5KSB7XG4gIHZhciBERUZBVUxUX0RFTEFZID0gMTAwMDtcbiAgdmFyIHBhcnNlZERlbGF5ID0gcGFyc2VJbnQoZGVsYXksIDEwKTtcbiAgdmFyIGRlbGF5TWF0Y2ggPSBuYXRpdmVJc05hTihwYXJzZWREZWxheSkgPyBERUZBVUxUX0RFTEFZIC8vIGRlZmF1bHQgc2NyaXB0bGV0IHZhbHVlXG4gIDogcGFyc2VkRGVsYXk7XG4gIHJldHVybiBkZWxheU1hdGNoO1xufTtcbi8qKlxuICogQ2hlY2tzIGRlbGF5IG1hdGNoIGNvbmRpdGlvblxuICogQHBhcmFtIHsqfSBpbnB1dERlbGF5XG4gKiBAcGFyYW0ge251bWJlcn0gcmVhbERlbGF5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgaXNEZWxheU1hdGNoZWQgPSBmdW5jdGlvbiBpc0RlbGF5TWF0Y2hlZChpbnB1dERlbGF5LCByZWFsRGVsYXkpIHtcbiAgcmV0dXJuIHNob3VsZE1hdGNoQW55RGVsYXkoaW5wdXREZWxheSkgfHwgcmVhbERlbGF5ID09PSBnZXRNYXRjaERlbGF5KGlucHV0RGVsYXkpO1xufTtcbi8qKlxuICogSGFuZGxlcyBpbnB1dCBib29zdCB2YWx1ZVxuICogQHBhcmFtIHsqfSBib29zdFxuICogQHJldHVybnMge251bWJlcn0gcHJvcGVyIG51bWJlciBib29zdCBtdWx0aXBsaWVyIHZhbHVlXG4gKi9cblxudmFyIGdldEJvb3N0TXVsdGlwbGllciA9IGZ1bmN0aW9uIGdldEJvb3N0TXVsdGlwbGllcihib29zdCkge1xuICB2YXIgREVGQVVMVF9NVUxUSVBMSUVSID0gMC4wNTtcbiAgdmFyIE1JTl9NVUxUSVBMSUVSID0gMC4wMjtcbiAgdmFyIE1BWF9NVUxUSVBMSUVSID0gNTA7XG4gIHZhciBwYXJzZWRCb29zdCA9IHBhcnNlRmxvYXQoYm9vc3QpO1xuICB2YXIgYm9vc3RNdWx0aXBsaWVyID0gbmF0aXZlSXNOYU4ocGFyc2VkQm9vc3QpIHx8ICFuYXRpdmVJc0Zpbml0ZShwYXJzZWRCb29zdCkgPyBERUZBVUxUX01VTFRJUExJRVIgLy8gZGVmYXVsdCBzY3JpcHRsZXQgdmFsdWVcbiAgOiBwYXJzZWRCb29zdDtcblxuICBpZiAoYm9vc3RNdWx0aXBsaWVyIDwgTUlOX01VTFRJUExJRVIpIHtcbiAgICBib29zdE11bHRpcGxpZXIgPSBNSU5fTVVMVElQTElFUjtcbiAgfVxuXG4gIGlmIChib29zdE11bHRpcGxpZXIgPiBNQVhfTVVMVElQTElFUikge1xuICAgIGJvb3N0TXVsdGlwbGllciA9IE1BWF9NVUxUSVBMSUVSO1xuICB9XG5cbiAgcmV0dXJuIGJvb3N0TXVsdGlwbGllcjtcbn07XG5cbi8qKlxuICogQ29sbGVjdHMgUmVxdWVzdCBvcHRpb25zIHRvIG9iamVjdFxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkYXRhIG9iamVjdFxuICovXG5cbnZhciBnZXRSZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uIGdldFJlcXVlc3REYXRhKHJlcXVlc3QpIHtcbiAgdmFyIFJFUVVFU1RfSU5JVF9PUFRJT05TID0gWyd1cmwnLCAnbWV0aG9kJywgJ2hlYWRlcnMnLCAnYm9keScsICdtb2RlJywgJ2NyZWRlbnRpYWxzJywgJ2NhY2hlJywgJ3JlZGlyZWN0JywgJ3JlZmVycmVyJywgJ2ludGVncml0eSddO1xuICB2YXIgZW50cmllcyA9IFJFUVVFU1RfSU5JVF9PUFRJT05TLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgLy8gaWYgcmVxdWVzdCBoYXMgbm8gc3VjaCBvcHRpb24sIHZhbHVlIHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgdmFyIHZhbHVlID0gcmVxdWVzdFtrZXldO1xuICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gZ2V0T2JqZWN0RnJvbUVudHJpZXMoZW50cmllcyk7XG59O1xuLyoqXG4gKiBDb2xsZWN0cyBmZXRjaCBhcmdzIHRvIG9iamVjdFxuICogQHBhcmFtIHsqfSBhcmdzIGZldGNoIGFyZ3NcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRhdGEgb2JqZWN0XG4gKi9cblxudmFyIGdldEZldGNoRGF0YSA9IGZ1bmN0aW9uIGdldEZldGNoRGF0YShhcmdzKSB7XG4gIHZhciBmZXRjaFByb3BzT2JqID0ge307XG4gIHZhciBmZXRjaFVybDtcbiAgdmFyIGZldGNoSW5pdDtcblxuICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAvLyBpZiBSZXF1ZXN0IHBhc3NlZCB0byBmZXRjaCwgaXQgd2lsbCBiZSBpbiBhcnJheVxuICAgIHZhciByZXF1ZXN0RGF0YSA9IGdldFJlcXVlc3REYXRhKGFyZ3NbMF0pO1xuICAgIGZldGNoVXJsID0gcmVxdWVzdERhdGEudXJsO1xuICAgIGZldGNoSW5pdCA9IHJlcXVlc3REYXRhO1xuICB9IGVsc2Uge1xuICAgIGZldGNoVXJsID0gYXJnc1swXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gICAgZmV0Y2hJbml0ID0gYXJnc1sxXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICB9XG5cbiAgZmV0Y2hQcm9wc09iai51cmwgPSBmZXRjaFVybDtcblxuICBpZiAoZmV0Y2hJbml0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgT2JqZWN0LmtleXMoZmV0Y2hJbml0KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBmZXRjaFByb3BzT2JqW3Byb3BdID0gZmV0Y2hJbml0W3Byb3BdO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZldGNoUHJvcHNPYmo7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBwcmV2ZW50LWZldGNoIHByb3BzVG9NYXRjaCBpbnB1dCBzdHJpbmcgdG8gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHNUb01hdGNoU3RyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2hlcmUgJ2tleScgaXMgcHJvcCBuYW1lIGFuZCAndmFsdWUnIGlzIHByb3AgdmFsdWVcbiAqL1xuXG52YXIgY29udmVydE1hdGNoUHJvcHNUb09iaiA9IGZ1bmN0aW9uIGNvbnZlcnRNYXRjaFByb3BzVG9PYmoocHJvcHNUb01hdGNoU3RyKSB7XG4gIHZhciBQUk9QU19ESVZJREVSID0gJyAnO1xuICB2YXIgUEFJUlNfTUFSS0VSID0gJzonO1xuICB2YXIgcHJvcHNPYmogPSB7fTtcbiAgdmFyIHByb3BzID0gcHJvcHNUb01hdGNoU3RyLnNwbGl0KFBST1BTX0RJVklERVIpO1xuICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIGRpdmlkZXJJbmQgPSBwcm9wLmluZGV4T2YoUEFJUlNfTUFSS0VSKTtcblxuICAgIGlmIChkaXZpZGVySW5kID09PSAtMSkge1xuICAgICAgcHJvcHNPYmoudXJsID0gdG9SZWdFeHAocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wLnNsaWNlKDAsIGRpdmlkZXJJbmQpO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcC5zbGljZShkaXZpZGVySW5kICsgMSk7XG4gICAgICBwcm9wc09ialtrZXldID0gdG9SZWdFeHAodmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm9wc09iajtcbn07XG5cbnZhciBoYW5kbGVPbGRSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGhhbmRsZU9sZFJlcGxhY2VtZW50KHJlcGxhY2VtZW50KSB7XG4gIHZhciByZXN1bHQ7IC8vIGRlZmF1bHRzIHRvIHJldHVybiBub29wRnVuYyBpbnN0ZWFkIG9mIHdpbmRvdy5vcGVuXG5cbiAgaWYgKCFyZXBsYWNlbWVudCkge1xuICAgIHJlc3VsdCA9IG5vb3BGdW5jO1xuICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSAndHJ1ZUZ1bmMnKSB7XG4gICAgcmVzdWx0ID0gdHJ1ZUZ1bmM7XG4gIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQuaW5kZXhPZignPScpID4gLTEpIHtcbiAgICAvLyBXZSBzaG91bGQgcmV0dXJuIG5vb3BGdW5jIGluc3RlYWQgb2Ygd2luZG93Lm9wZW5cbiAgICAvLyBidXQgd2l0aCBzb21lIHByb3BlcnR5IGlmIHdlYnNpdGUgY2hlY2tzIGl0IChleGFtcGxlcyA1LCA2KVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy83MVxuICAgIHZhciBpc1Byb3AgPSBzdGFydHNXaXRoKHJlcGxhY2VtZW50LCAneycpICYmIGVuZHNXaXRoKHJlcGxhY2VtZW50LCAnfScpO1xuXG4gICAgaWYgKGlzUHJvcCkge1xuICAgICAgdmFyIHByb3BlcnR5UGFydCA9IHJlcGxhY2VtZW50LnNsaWNlKDEsIC0xKTtcbiAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBzdWJzdHJpbmdCZWZvcmUocHJvcGVydHlQYXJ0LCAnPScpO1xuICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSBzdWJzdHJpbmdBZnRlcihwcm9wZXJ0eVBhcnQsICc9Jyk7XG5cbiAgICAgIGlmIChwcm9wZXJ0eVZhbHVlID09PSAnbm9vcEZ1bmMnKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbcHJvcGVydHlOYW1lXSA9IG5vb3BGdW5jO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIGNyZWF0ZURlY295ID0gZnVuY3Rpb24gY3JlYXRlRGVjb3koYXJncykge1xuICB2YXIgT0JKRUNUX1RBR19OQU1FID0gJ29iamVjdCc7XG4gIHZhciBPQkpFQ1RfVVJMX1BST1BfTkFNRSA9ICdkYXRhJztcbiAgdmFyIElGUkFNRV9UQUdfTkFNRSA9ICdpZnJhbWUnO1xuICB2YXIgSUZSQU1FX1VSTF9QUk9QX05BTUUgPSAnc3JjJztcbiAgdmFyIHJlcGxhY2VtZW50ID0gYXJncy5yZXBsYWNlbWVudCxcbiAgICAgIHVybCA9IGFyZ3MudXJsLFxuICAgICAgZGVsYXkgPSBhcmdzLmRlbGF5O1xuICB2YXIgdGFnO1xuICB2YXIgdXJsUHJvcDtcblxuICBpZiAocmVwbGFjZW1lbnQgPT09ICdvYmonKSB7XG4gICAgdGFnID0gT0JKRUNUX1RBR19OQU1FO1xuICAgIHVybFByb3AgPSBPQkpFQ1RfVVJMX1BST1BfTkFNRTtcbiAgfSBlbHNlIHtcbiAgICB0YWcgPSBJRlJBTUVfVEFHX05BTUU7XG4gICAgdXJsUHJvcCA9IElGUkFNRV9VUkxfUFJPUF9OQU1FO1xuICB9XG5cbiAgdmFyIGRlY295ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBkZWNveVt1cmxQcm9wXSA9IHVybDtcbiAgZGVjb3kuc3R5bGUuc2V0UHJvcGVydHkoJ2hlaWdodCcsICcxcHgnLCAnaW1wb3J0YW50Jyk7XG4gIGRlY295LnN0eWxlLnNldFByb3BlcnR5KCdwb3NpdGlvbicsICdmaXhlZCcsICdpbXBvcnRhbnQnKTtcbiAgZGVjb3kuc3R5bGUuc2V0UHJvcGVydHkoJ3RvcCcsICctMXB4JywgJ2ltcG9ydGFudCcpO1xuICBkZWNveS5zdHlsZS5zZXRQcm9wZXJ0eSgnd2lkdGgnLCAnMXB4JywgJ2ltcG9ydGFudCcpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRlY295KTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlY295LnJlbW92ZSgpO1xuICB9LCBkZWxheSAqIDEwMDApO1xuICByZXR1cm4gZGVjb3k7XG59O1xudmFyIGdldFByZXZlbnRHZXR0ZXIgPSBmdW5jdGlvbiBnZXRQcmV2ZW50R2V0dGVyKG5hdGl2ZUdldHRlcikge1xuICB2YXIgcHJldmVudEdldHRlciA9IGZ1bmN0aW9uIHByZXZlbnRHZXR0ZXIodGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKHByb3AgJiYgcHJvcCA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUdldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5vb3BGdW5jO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wICYmIHRhcmdldFtwcm9wXTtcbiAgfTtcblxuICByZXR1cm4gcHJldmVudEdldHRlcjtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciB2YWxpZGF0ZVR5cGUgPSBmdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTI1XG4gIHJldHVybiB0eXBlb2YgdHlwZSAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgZXZlbnQgbGlzdGVuZXJcbiAqIEBwYXJhbSB7Kn0gbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbnZhciB2YWxpZGF0ZUxpc3RlbmVyID0gZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNwYXJhbWV0ZXJzXG4gIHJldHVybiB0eXBlb2YgbGlzdGVuZXIgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvNzZcbiAgJiYgbGlzdGVuZXIgIT09IG51bGwgJiYgdHlwZW9mIGxpc3RlbmVyLmhhbmRsZUV2ZW50ID09PSAnZnVuY3Rpb24nKTtcbn07XG4vKipcbiAqIFNlcmlhbGl6ZSB2YWxpZCBldmVudCBsaXN0ZW5lclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50TGlzdGVuZXJcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gbGlzdGVuZXIgdmFsaWQgbGlzdGVuZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIGxpc3RlbmVyVG9TdHJpbmcgPSBmdW5jdGlvbiBsaXN0ZW5lclRvU3RyaW5nKGxpc3RlbmVyKSB7XG4gIHJldHVybiB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicgPyBsaXN0ZW5lci50b1N0cmluZygpIDogbGlzdGVuZXIuaGFuZGxlRXZlbnQudG9TdHJpbmcoKTtcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIG11c3QgZXhwb3J0IGFsbCB1c2VkIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBkZXBlbmRlbmNpZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldFdpbGRjYXJkU3ltYm9sOiBnZXRXaWxkY2FyZFN5bWJvbCxcbiAgICByYW5kb21JZDogcmFuZG9tSWQsXG4gICAgc2V0UHJvcGVydHlBY2Nlc3M6IHNldFByb3BlcnR5QWNjZXNzLFxuICAgIGdldFByb3BlcnR5SW5DaGFpbjogZ2V0UHJvcGVydHlJbkNoYWluLFxuICAgIGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluOiBnZXRXaWxkY2FyZFByb3BlcnR5SW5DaGFpbixcbiAgICByZXBsYWNlQWxsOiByZXBsYWNlQWxsLFxuICAgIGVzY2FwZVJlZ0V4cDogZXNjYXBlUmVnRXhwLFxuICAgIHRvUmVnRXhwOiB0b1JlZ0V4cCxcbiAgICBnZXRCZWZvcmVSZWdFeHA6IGdldEJlZm9yZVJlZ0V4cCxcbiAgICBzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuICAgIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgICBzdWJzdHJpbmdBZnRlcjogc3Vic3RyaW5nQWZ0ZXIsXG4gICAgc3Vic3RyaW5nQmVmb3JlOiBzdWJzdHJpbmdCZWZvcmUsXG4gICAgd3JhcEluU2luZ2xlUXVvdGVzOiB3cmFwSW5TaW5nbGVRdW90ZXMsXG4gICAgZ2V0U3RyaW5nSW5CcmFjZXM6IGdldFN0cmluZ0luQnJhY2VzLFxuICAgIGNvbnZlcnRSdGNDb25maWdUb1N0cmluZzogY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nLFxuICAgIHBhcnNlTWF0Y2hBcmc6IHBhcnNlTWF0Y2hBcmcsXG4gICAgcGFyc2VEZWxheUFyZzogcGFyc2VEZWxheUFyZyxcbiAgICBvYmplY3RUb1N0cmluZzogb2JqZWN0VG9TdHJpbmcsXG4gICAgY29udmVydFR5cGVUb1N0cmluZzogY29udmVydFR5cGVUb1N0cmluZyxcbiAgICBjcmVhdGVPbkVycm9ySGFuZGxlcjogY3JlYXRlT25FcnJvckhhbmRsZXIsXG4gICAgbm9vcEZ1bmM6IG5vb3BGdW5jLFxuICAgIG5vb3BOdWxsOiBub29wTnVsbCxcbiAgICB0cnVlRnVuYzogdHJ1ZUZ1bmMsXG4gICAgZmFsc2VGdW5jOiBmYWxzZUZ1bmMsXG4gICAgbm9vcFRoaXM6IG5vb3BUaGlzLFxuICAgIG5vb3BTdHI6IG5vb3BTdHIsXG4gICAgbm9vcEFycmF5OiBub29wQXJyYXksXG4gICAgbm9vcE9iamVjdDogbm9vcE9iamVjdCxcbiAgICBub29wUHJvbWlzZVJlamVjdDogbm9vcFByb21pc2VSZWplY3QsXG4gICAgbm9vcFByb21pc2VSZXNvbHZlOiBub29wUHJvbWlzZVJlc29sdmUsXG4gICAgaGl0OiBoaXQsXG4gICAgb2JzZXJ2ZURPTUNoYW5nZXM6IG9ic2VydmVET01DaGFuZ2VzLFxuICAgIG1hdGNoU3RhY2tUcmFjZTogbWF0Y2hTdGFja1RyYWNlLFxuICAgIGZpbmRIb3N0RWxlbWVudHM6IGZpbmRIb3N0RWxlbWVudHMsXG4gICAgcGllcmNlU2hhZG93RG9tOiBwaWVyY2VTaGFkb3dEb20sXG4gICAgZmxhdHRlbjogZmxhdHRlbixcbiAgICBwcmVwYXJlQ29va2llOiBwcmVwYXJlQ29va2llLFxuICAgIG5hdGl2ZUlzTmFOOiBuYXRpdmVJc05hTixcbiAgICBuYXRpdmVJc0Zpbml0ZTogbmF0aXZlSXNGaW5pdGUsXG4gICAgc2hvdWxkTWF0Y2hBbnlEZWxheTogc2hvdWxkTWF0Y2hBbnlEZWxheSxcbiAgICBnZXRNYXRjaERlbGF5OiBnZXRNYXRjaERlbGF5LFxuICAgIGlzRGVsYXlNYXRjaGVkOiBpc0RlbGF5TWF0Y2hlZCxcbiAgICBnZXRCb29zdE11bHRpcGxpZXI6IGdldEJvb3N0TXVsdGlwbGllcixcbiAgICBnZXRSZXF1ZXN0RGF0YTogZ2V0UmVxdWVzdERhdGEsXG4gICAgZ2V0RmV0Y2hEYXRhOiBnZXRGZXRjaERhdGEsXG4gICAgY29udmVydE1hdGNoUHJvcHNUb09iajogY29udmVydE1hdGNoUHJvcHNUb09iaixcbiAgICBnZXRPYmplY3RFbnRyaWVzOiBnZXRPYmplY3RFbnRyaWVzLFxuICAgIGdldE9iamVjdEZyb21FbnRyaWVzOiBnZXRPYmplY3RGcm9tRW50cmllcyxcbiAgICBpc0VtcHR5T2JqZWN0OiBpc0VtcHR5T2JqZWN0LFxuICAgIGhhbmRsZU9sZFJlcGxhY2VtZW50OiBoYW5kbGVPbGRSZXBsYWNlbWVudCxcbiAgICBjcmVhdGVEZWNveTogY3JlYXRlRGVjb3ksXG4gICAgZ2V0UHJldmVudEdldHRlcjogZ2V0UHJldmVudEdldHRlcixcbiAgICB2YWxpZGF0ZVR5cGU6IHZhbGlkYXRlVHlwZSxcbiAgICB2YWxpZGF0ZUxpc3RlbmVyOiB2YWxpZGF0ZUxpc3RlbmVyLFxuICAgIGxpc3RlbmVyVG9TdHJpbmc6IGxpc3RlbmVyVG9TdHJpbmdcbn0pO1xuXG4vKipcbiAqIENvbmNhdCBkZXBlbmRlbmNpZXMgdG8gc2NyaXB0bGV0IGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRsZXQgc3RyaW5nIHZpZXcgb2Ygc2NyaXB0bGV0XG4gKi9cblxuZnVuY3Rpb24gYXR0YWNoRGVwZW5kZW5jaWVzKHNjcmlwdGxldCkge1xuICB2YXIgX3NjcmlwdGxldCRpbmplY3Rpb25zID0gc2NyaXB0bGV0LmluamVjdGlvbnMsXG4gICAgICBpbmplY3Rpb25zID0gX3NjcmlwdGxldCRpbmplY3Rpb25zID09PSB2b2lkIDAgPyBbXSA6IF9zY3JpcHRsZXQkaW5qZWN0aW9ucztcbiAgcmV0dXJuIGluamVjdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgZGVwKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGFjY3VtLCBcIlxcblwiKS5jb25jYXQoZGVwZW5kZW5jaWVzW2RlcC5uYW1lXSk7XG4gIH0sIHNjcmlwdGxldC50b1N0cmluZygpKTtcbn1cbi8qKlxuICogQWRkIHNjcmlwdGxldCBjYWxsIHRvIGV4aXN0aW5nIGNvZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNjcmlwdGxldFxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqL1xuXG5mdW5jdGlvbiBhZGRDYWxsKHNjcmlwdGxldCwgY29kZSkge1xuICByZXR1cm4gXCJcIi5jb25jYXQoY29kZSwgXCI7XFxuICAgICAgICBjb25zdCB1cGRhdGVkQXJncyA9IGFyZ3MgPyBbXS5jb25jYXQoc291cmNlKS5jb25jYXQoYXJncykgOiBbc291cmNlXTtcXG4gICAgICAgIFwiKS5jb25jYXQoc2NyaXB0bGV0Lm5hbWUsIFwiLmFwcGx5KHRoaXMsIHVwZGF0ZWRBcmdzKTtcXG4gICAgXCIpO1xufVxuLyoqXG4gKiBXcmFwIGZ1bmN0aW9uIGludG8gSUlGRSAoSW1tZWRpYXRlbHkgaW52b2tlZCBmdW5jdGlvbiBleHByZXNzaW9uKVxuICpcbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2UgLSBvYmplY3Qgd2l0aCBzY3JpcHRsZXQgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgLSBzY3JpcHRsZXQgc291cmNlIGNvZGUgd2l0aCBkZXBlbmRlbmNpZXNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBmdWxsIHNjcmlwdGxldCBjb2RlXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNvdXJjZSA9IHtcbiAqICAgICAgYXJnczogW1wiYWFhXCIsIFwiYmJiXCJdLFxuICogICAgICBuYW1lOiAnbm9ldmFsJyxcbiAqIH07XG4gKiBjb25zdCBjb2RlID0gXCJmdW5jdGlvbiBub2V2YWwoc291cmNlLCBhcmdzKSB7IGFsZXJ0KHNvdXJjZSk7IH0gbm9ldmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1wiXG4gKiBjb25zdCByZXN1bHQgPSB3cmFwSW5JSUZFKHNvdXJjZSwgY29kZSk7XG4gKlxuICogLy8gcmVzdWx0XG4gKiBgKGZ1bmN0aW9uKHNvdXJjZSwgYXJncykge1xuICogICAgICBmdW5jdGlvbiBub2V2YWwoc291cmNlKSB7IGFsZXJ0KHNvdXJjZSk7IH1cbiAqICAgICAgbm9ldmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICogKSh7XCJhcmdzXCI6IFtcImFhYVwiLCBcImJiYlwiXSwgXCJuYW1lXCI6XCJub2V2YWxcIn0sIFtcImFhYVwiLCBcImJiYlwiXSlgXG4gKi9cblxuZnVuY3Rpb24gcGFzc1NvdXJjZUFuZFByb3BzKHNvdXJjZSwgY29kZSkge1xuICBpZiAoc291cmNlLmhpdCkge1xuICAgIHNvdXJjZS5oaXQgPSBzb3VyY2UuaGl0LnRvU3RyaW5nKCk7XG4gIH1cblxuICB2YXIgc291cmNlU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoc291cmNlKTtcbiAgdmFyIGFyZ3NTdHJpbmcgPSBzb3VyY2UuYXJncyA/IFwiW1wiLmNvbmNhdChzb3VyY2UuYXJncy5tYXAoSlNPTi5zdHJpbmdpZnkpLCBcIl1cIikgOiB1bmRlZmluZWQ7XG4gIHZhciBwYXJhbXMgPSBhcmdzU3RyaW5nID8gXCJcIi5jb25jYXQoc291cmNlU3RyaW5nLCBcIiwgXCIpLmNvbmNhdChhcmdzU3RyaW5nKSA6IHNvdXJjZVN0cmluZztcbiAgcmV0dXJuIFwiKGZ1bmN0aW9uKHNvdXJjZSwgYXJncyl7XFxuXCIuY29uY2F0KGNvZGUsIFwiXFxufSkoXCIpLmNvbmNhdChwYXJhbXMsIFwiKTtcIik7XG59XG4vKipcbiAqIFdyYXAgY29kZSBpbiBubyBuYW1lIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSB3aGljaCBtdXN0IGJlIHdyYXBwZWRcbiAqL1xuXG5mdW5jdGlvbiB3cmFwSW5Ob25hbWVGdW5jKGNvZGUpIHtcbiAgcmV0dXJuIFwiZnVuY3Rpb24oc291cmNlLCBhcmdzKXtcXG5cIi5jb25jYXQoY29kZSwgXCJcXG59XCIpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGRlZmluZVByb3BlcnR5ID0gX2RlZmluZVByb3BlcnR5O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBpdGVyYWJsZSBhcmd1bWVudCBhbmQgZXZhbHVhdGUgY3VycmVudCBzdGF0ZSB3aXRoIHRyYW5zaXRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5pdCBmaXJzdCB0cmFuc2l0aW9uIG5hbWVcbiAqIEBwYXJhbSB7QXJyYXl8Q29sbGVjdGlvbnxzdHJpbmd9IGl0ZXJhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbnMgdHJhbnN0aW9uIGZ1bmN0aW9uc1xuICogQHBhcmFtIHthbnl9IGFyZ3MgYXJndW1lbnRzIHdoaWNoIHNob3VsZCBiZSBwYXNzZWQgdG8gdHJhbnNpdGlvbiBmdW5jdGlvbnNcbiAqL1xuZnVuY3Rpb24gaXRlcmF0ZVdpdGhUcmFuc2l0aW9ucyhpdGVyYWJsZSwgdHJhbnNpdGlvbnMsIGluaXQsIGFyZ3MpIHtcbiAgdmFyIHN0YXRlID0gaW5pdCB8fCBPYmplY3Qua2V5cyh0cmFuc2l0aW9ucylbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHN0YXRlID0gdHJhbnNpdGlvbnNbc3RhdGVdKGl0ZXJhYmxlLCBpLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cbi8qKlxuICogQWRHdWFyZCBzY3JpcHRsZXQgcnVsZSBtYXNrXG4gKi9cblxuXG52YXIgQURHX1NDUklQVExFVF9NQVNLID0gJyMvL3NjcmlwdGxldCc7XG4vKipcbiAqIEhlbHBlciB0byBhY2N1bXVsYXRlIGFuIGFycmF5IG9mIHN0cmluZ3MgY2hhciBieSBjaGFyXG4gKi9cblxudmFyIHdvcmRTYXZlciA9IGZ1bmN0aW9uIHdvcmRTYXZlcigpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgc3RycyA9IFtdO1xuXG4gIHZhciBzYXZlU3ltYiA9IGZ1bmN0aW9uIHNhdmVTeW1iKHMpIHtcbiAgICBzdHIgKz0gcztcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHZhciBzYXZlU3RyID0gZnVuY3Rpb24gc2F2ZVN0cigpIHtcbiAgICBzdHJzLnB1c2goc3RyKTtcbiAgICBzdHIgPSAnJztcbiAgfTtcblxuICB2YXIgZ2V0QWxsID0gZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoc3Rycyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzYXZlU3ltYjogc2F2ZVN5bWIsXG4gICAgc2F2ZVN0cjogc2F2ZVN0cixcbiAgICBnZXRBbGw6IGdldEFsbFxuICB9O1xufTtcblxudmFyIHN1YnN0cmluZ0FmdGVyJDEgPSBmdW5jdGlvbiBzdWJzdHJpbmdBZnRlcihzdHIsIHNlcGFyYXRvcikge1xuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZihzZXBhcmF0b3IpO1xuICByZXR1cm4gaW5kZXggPCAwID8gJycgOiBzdHIuc3Vic3RyaW5nKGluZGV4ICsgc2VwYXJhdG9yLmxlbmd0aCk7XG59O1xuLyoqXG4gKiBQYXJzZSBhbmQgdmFsaWRhdGUgc2NyaXB0bGV0IHJ1bGVcbiAqIEBwYXJhbSB7Kn0gcnVsZVRleHRcbiAqIEByZXR1cm5zIHt7bmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxzdHJpbmc+fX1cbiAqL1xuXG5cbnZhciBwYXJzZVJ1bGUgPSBmdW5jdGlvbiBwYXJzZVJ1bGUocnVsZVRleHQpIHtcbiAgdmFyIF90cmFuc2l0aW9ucztcblxuICBydWxlVGV4dCA9IHN1YnN0cmluZ0FmdGVyJDEocnVsZVRleHQsIEFER19TQ1JJUFRMRVRfTUFTSyk7XG4gIC8qKlxuICAgKiBUcmFuc2l0aW9uIG5hbWVzXG4gICAqL1xuXG4gIHZhciBUUkFOU0lUSU9OID0ge1xuICAgIE9QRU5FRDogJ29wZW5lZCcsXG4gICAgUEFSQU06ICdwYXJhbScsXG4gICAgQ0xPU0VEOiAnY2xvc2VkJ1xuICB9O1xuICAvKipcbiAgICogVHJhbnNpdGlvbiBmdW5jdGlvbjogdGhlIGN1cnJlbnQgaW5kZXggcG9zaXRpb24gaW4gc3RhcnQsIGVuZCBvciBiZXR3ZWVuIHBhcmFtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IE9iamVjdFxuICAgKiBAcHJvcGVydHkge09iamVjdH0gT2JqZWN0LnNlcCBjb250YWlucyBwcm9wIHN5bWIgd2l0aCBjdXJyZW50IHNlcGFyYXRvciBjaGFyXG4gICAqL1xuXG4gIHZhciBvcGVuZWQgPSBmdW5jdGlvbiBvcGVuZWQocnVsZSwgaW5kZXgsIF9yZWYpIHtcbiAgICB2YXIgc2VwID0gX3JlZi5zZXA7XG4gICAgdmFyIGNoYXIgPSBydWxlW2luZGV4XTtcbiAgICB2YXIgdHJhbnNpdGlvbjtcblxuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSAnICc6XG4gICAgICBjYXNlICcoJzpcbiAgICAgIGNhc2UgJywnOlxuICAgICAgICB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IFRSQU5TSVRJT04uT1BFTkVEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ1xcJyc6XG4gICAgICBjYXNlICdcIic6XG4gICAgICAgIHtcbiAgICAgICAgICBzZXAuc3ltYiA9IGNoYXI7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IFRSQU5TSVRJT04uUEFSQU07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gaW5kZXggPT09IHJ1bGUubGVuZ3RoIC0gMSA/IFRSQU5TSVRJT04uQ0xPU0VEIDogVFJBTlNJVElPTi5PUEVORUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJ1bGUgaXMgbm90IGEgc2NyaXB0bGV0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNpdGlvbjtcbiAgfTtcbiAgLyoqXG4gICAqIFRyYW5zaXRpb24gZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4IHBvc2l0aW9uIGluc2lkZSBwYXJhbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IE9iamVjdFxuICAgKiBAcHJvcGVydHkge09iamVjdH0gT2JqZWN0LnNlcCBjb250YWlucyBwcm9wIGBzeW1iYCB3aXRoIGN1cnJlbnQgc2VwYXJhdG9yIGNoYXJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IE9iamVjdC5zYXZlciBoZWxwZXIgd2hpY2ggYWxsb3cgdG8gc2F2ZSBzdHJpbmdzIGJ5IGNhciBieSBjaGFyXG4gICAqL1xuXG5cbiAgdmFyIHBhcmFtID0gZnVuY3Rpb24gcGFyYW0ocnVsZSwgaW5kZXgsIF9yZWYyKSB7XG4gICAgdmFyIHNhdmVyID0gX3JlZjIuc2F2ZXIsXG4gICAgICAgIHNlcCA9IF9yZWYyLnNlcDtcbiAgICB2YXIgY2hhciA9IHJ1bGVbaW5kZXhdO1xuXG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlICdcXCcnOlxuICAgICAgY2FzZSAnXCInOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZUluZGV4ID0gaW5kZXggLSAxO1xuICAgICAgICAgIHZhciBiZWZvcmUgPSBydWxlW3ByZUluZGV4XTtcblxuICAgICAgICAgIGlmIChjaGFyID09PSBzZXAuc3ltYiAmJiBiZWZvcmUgIT09ICdcXFxcJykge1xuICAgICAgICAgICAgc2VwLnN5bWIgPSBudWxsO1xuICAgICAgICAgICAgc2F2ZXIuc2F2ZVN0cigpO1xuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT04uT1BFTkVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYXZlci5zYXZlU3ltYihjaGFyKTtcbiAgICAgICAgICByZXR1cm4gVFJBTlNJVElPTi5QQVJBTTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbnMgPSAoX3RyYW5zaXRpb25zID0ge30sIGRlZmluZVByb3BlcnR5KF90cmFuc2l0aW9ucywgVFJBTlNJVElPTi5PUEVORUQsIG9wZW5lZCksIGRlZmluZVByb3BlcnR5KF90cmFuc2l0aW9ucywgVFJBTlNJVElPTi5QQVJBTSwgcGFyYW0pLCBkZWZpbmVQcm9wZXJ0eShfdHJhbnNpdGlvbnMsIFRSQU5TSVRJT04uQ0xPU0VELCBmdW5jdGlvbiAoKSB7fSksIF90cmFuc2l0aW9ucyk7XG4gIHZhciBzZXAgPSB7XG4gICAgc3ltYjogbnVsbFxuICB9O1xuICB2YXIgc2F2ZXIgPSB3b3JkU2F2ZXIoKTtcbiAgdmFyIHN0YXRlID0gaXRlcmF0ZVdpdGhUcmFuc2l0aW9ucyhydWxlVGV4dCwgdHJhbnNpdGlvbnMsIFRSQU5TSVRJT04uT1BFTkVELCB7XG4gICAgc2VwOiBzZXAsXG4gICAgc2F2ZXI6IHNhdmVyXG4gIH0pO1xuXG4gIGlmIChzdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNjcmlwdGxldCBydWxlIFwiLmNvbmNhdChydWxlVGV4dCkpO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSBzYXZlci5nZXRBbGwoKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBhcmdzWzBdLFxuICAgIGFyZ3M6IGFyZ3Muc2xpY2UoMSlcbiAgfTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGFib3J0LW9uLXByb3BlcnR5LXJlYWRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFib3J0cyBhIHNjcmlwdCB3aGVuIGl0IGF0dGVtcHRzIHRvICoqcmVhZCoqIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjYWJvcnQtb24tcHJvcGVydHktcmVhZGpzLVxuICpcbiAqIFJlbGF0ZWQgQUJQIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hZGJsb2NrcGx1cy9hZGJsb2NrcGx1c2NvcmUvYmxvYi82YjJhMzA5MDU0Y2MyMzQzMjEwMmI4NWQxM2YxMjU1OTYzOWVmNDk1L2xpYi9jb250ZW50L3NuaXBwZXRzLmpzI0w4NjRcbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXJlYWQnLCBwcm9wZXJ0eVssIHN0YWNrXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BlcnR5YCAtIHJlcXVpcmVkLCBwYXRoIHRvIGEgcHJvcGVydHkgKGpvaW5lZCB3aXRoIGAuYCBpZiBuZWVkZWQpLiBUaGUgcHJvcGVydHkgbXVzdCBiZSBhdHRhY2hlZCB0byBgd2luZG93YFxuICogLSBgc3RhY2tgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtdXN0IG1hdGNoIHRoZSBjdXJyZW50IGZ1bmN0aW9uIGNhbGwgc3RhY2sgdHJhY2VcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gYWNjZXNzIGB3aW5kb3cuYWxlcnRgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkJywgJ2FsZXJ0JylcbiAqXG4gKiAhIEFib3J0cyBzY3JpcHQgd2hlbiBpdCB0cmllcyB0byBhY2Nlc3MgYG5hdmlnYXRvci5sYW5ndWFnZWBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXJlYWQnLCAnbmF2aWdhdG9yLmxhbmd1YWdlJylcbiAqXG4gKiAhIEFib3J0cyBzY3JpcHQgd2hlbiBpdCB0cmllcyB0byBhY2Nlc3MgYHdpbmRvdy5hZGJsb2NrYCBhbmQgaXQncyBlcnJvciBzdGFjayB0cmFjZSBjb250YWlucyBgdGVzdC5qc2BcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXJlYWQnLCAnYWRibG9jaycsICd0ZXN0LmpzJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBhYm9ydE9uUHJvcGVydHlSZWFkKHNvdXJjZSwgcHJvcGVydHksIHN0YWNrKSB7XG4gIGlmICghcHJvcGVydHkgfHwgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJpZCA9IHJhbmRvbUlkKCk7XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKHJpZCk7XG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjtcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgZ2V0OiBhYm9ydCxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge31cbiAgICB9KTtcbiAgfTtcblxuICBzZXRDaGFpblByb3BBY2Nlc3Mod2luZG93LCBwcm9wZXJ0eSk7XG4gIHdpbmRvdy5vbmVycm9yID0gY3JlYXRlT25FcnJvckhhbmRsZXIocmlkKS5iaW5kKCk7XG59XG5hYm9ydE9uUHJvcGVydHlSZWFkLm5hbWVzID0gWydhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2Fib3J0LW9uLXByb3BlcnR5LXJlYWQuanMnLCAndWJvLWFib3J0LW9uLXByb3BlcnR5LXJlYWQuanMnLCAnYW9wci5qcycsICd1Ym8tYW9wci5qcycsICd1Ym8tYWJvcnQtb24tcHJvcGVydHktcmVhZCcsICd1Ym8tYW9wcicsICdhYnAtYWJvcnQtb24tcHJvcGVydHktcmVhZCddO1xuYWJvcnRPblByb3BlcnR5UmVhZC5pbmplY3Rpb25zID0gW3JhbmRvbUlkLCB0b1JlZ0V4cCwgc2V0UHJvcGVydHlBY2Nlc3MsIGdldFByb3BlcnR5SW5DaGFpbiwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdCwgbWF0Y2hTdGFja1RyYWNlXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgYWJvcnQtb24tcHJvcGVydHktd3JpdGVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFib3J0cyBhIHNjcmlwdCB3aGVuIGl0IGF0dGVtcHRzIHRvICoqd3JpdGUqKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlanMtXG4gKlxuICogUmVsYXRlZCBBQlAgc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FkYmxvY2twbHVzL2FkYmxvY2twbHVzY29yZS9ibG9iLzZiMmEzMDkwNTRjYzIzNDMyMTAyYjg1ZDEzZjEyNTU5NjM5ZWY0OTUvbGliL2NvbnRlbnQvc25pcHBldHMuanMjTDg5NlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWJvcnQtb24tcHJvcGVydHktd3JpdGUnLCBwcm9wZXJ0eVssIHN0YWNrXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BlcnR5YCAtIHJlcXVpcmVkLCBwYXRoIHRvIGEgcHJvcGVydHkgKGpvaW5lZCB3aXRoIGAuYCBpZiBuZWVkZWQpLiBUaGUgcHJvcGVydHkgbXVzdCBiZSBhdHRhY2hlZCB0byBgd2luZG93YFxuICogLSBgc3RhY2tgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtdXN0IG1hdGNoIHRoZSBjdXJyZW50IGZ1bmN0aW9uIGNhbGwgc3RhY2sgdHJhY2VcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gc2V0IGB3aW5kb3cuYWRibG9ja2AgdmFsdWVcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlJywgJ2FkYmxvY2snKVxuICpcbiAqICEgQWJvcnRzIHNjcmlwdCB3aGVuIGl0IHRyaWVzIHRvIHNldCBgd2luZG93LmFkYmxvY2tgIHZhbHVlIGFuZCBpdCdzIGVycm9yIHN0YWNrIHRyYWNlIGNvbnRhaW5zIGBjaGVja2luZy5qc2BcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlJywgJ2FkYmxvY2snLCAnY2hlY2tpbmcuanMnKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIGFib3J0T25Qcm9wZXJ0eVdyaXRlKHNvdXJjZSwgcHJvcGVydHksIHN0YWNrKSB7XG4gIGlmICghcHJvcGVydHkgfHwgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJpZCA9IHJhbmRvbUlkKCk7XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKHJpZCk7XG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjtcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgc2V0OiBhYm9ydFxuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbiAgd2luZG93Lm9uZXJyb3IgPSBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpLmJpbmQoKTtcbn1cbmFib3J0T25Qcm9wZXJ0eVdyaXRlLm5hbWVzID0gWydhYm9ydC1vbi1wcm9wZXJ0eS13cml0ZScsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidhYm9ydC1vbi1wcm9wZXJ0eS13cml0ZS5qcycsICd1Ym8tYWJvcnQtb24tcHJvcGVydHktd3JpdGUuanMnLCAnYW9wdy5qcycsICd1Ym8tYW9wdy5qcycsICd1Ym8tYWJvcnQtb24tcHJvcGVydHktd3JpdGUnLCAndWJvLWFvcHcnLCAnYWJwLWFib3J0LW9uLXByb3BlcnR5LXdyaXRlJ107XG5hYm9ydE9uUHJvcGVydHlXcml0ZS5pbmplY3Rpb25zID0gW3JhbmRvbUlkLCBzZXRQcm9wZXJ0eUFjY2VzcywgZ2V0UHJvcGVydHlJbkNoYWluLCBjcmVhdGVPbkVycm9ySGFuZGxlciwgaGl0LCB0b1JlZ0V4cCwgbWF0Y2hTdGFja1RyYWNlXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1zZXRUaW1lb3V0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBhIGBzZXRUaW1lb3V0YCBjYWxsIGlmOlxuICogMSkgdGhlIHRleHQgb2YgdGhlIGNhbGxiYWNrIGlzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgc2VhcmNoIHN0cmluZy9yZWdleHAgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCBgIWA7XG4gKiBvdGhlcndpc2UgbWlzbWF0Y2hlZCBjYWxscyBzaG91bGQgYmUgZGVmdXNlZDtcbiAqIDIpIHRoZSB0aW1lb3V0IGlzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXk7IG90aGVyd2lzZSBtaXNtYXRjaGVkIGNhbGxzIHNob3VsZCBiZSBkZWZ1c2VkLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vLXNldHRpbWVvdXQtaWZqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0VGltZW91dCdbLCBzZWFyY2hbLCBkZWxheV1dKVxuICogYGBgXG4gKlxuICogQ2FsbCB3aXRoIG5vIGFyZ3VtZW50cyB3aWxsIGxvZyBjYWxscyB0byBzZXRUaW1lb3V0IHdoaWxlIGRlYnVnZ2luZyAoYGxvZy1zZXRUaW1lb3V0YCBzdXBlcnNlZGluZyksXG4gKiBzbyBwcm9kdWN0aW9uIGZpbHRlciBsaXN0cycgcnVsZXMgZGVmaW5pdGVseSByZXF1aXJlIGF0IGxlYXN0IG9uZSBvZiB0aGUgcGFyYW1ldGVyczpcbiAqIC0gYHNlYXJjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIElmIHN0YXJ0cyB3aXRoIGAhYCwgc2NyaXB0bGV0IHdpbGwgbm90IG1hdGNoIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayBidXQgYWxsIG90aGVyIHdpbGwgYmUgZGVmdXNlZC5cbiAqIElmIGRvIG5vdCBzdGFydCB3aXRoIGAhYCwgdGhlIHN0cmluZ2lmaWVkIGNhbGxiYWNrIHdpbGwgYmUgbWF0Y2hlZC5cbiAqIElmIG5vdCBzZXQsIHByZXZlbnRzIGFsbCBgc2V0VGltZW91dGAgY2FsbHMgZHVlIHRvIHNwZWNpZmllZCBgZGVsYXlgLlxuICogLSBgZGVsYXlgIC0gb3B0aW9uYWwsIG11c3QgYmUgYW4gaW50ZWdlci5cbiAqIElmIHN0YXJ0cyB3aXRoIGAhYCwgc2NyaXB0bGV0IHdpbGwgbm90IG1hdGNoIHRoZSBkZWxheSBidXQgYWxsIG90aGVyIHdpbGwgYmUgZGVmdXNlZC5cbiAqIElmIGRvIG5vdCBzdGFydCB3aXRoIGAhYCwgdGhlIGRlbGF5IHBhc3NlZCB0byB0aGUgYHNldFRpbWVvdXRgIGNhbGwgd2lsbCBiZSBtYXRjaGVkLlxuICpcbiAqID4gSWYgYHByZXZlbnQtc2V0VGltZW91dGAgd2l0aG91dCBwYXJhbWV0ZXJzIGxvZ3Mgc210aCBsaWtlIGBzZXRUaW1lb3V0KHVuZGVmaW5lZCwgMTAwMClgLFxuICogaXQgbWVhbnMgdGhhdCBubyBjYWxsYmFjayB3YXMgcGFzc2VkIHRvIHNldFRpbWVvdXQoKSBhbmQgdGhhdCdzIG5vdCBzY3JpcHRsZXQgaXNzdWVcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIFByZXZlbnRzIGBzZXRUaW1lb3V0YCBjYWxscyBpZiB0aGUgY2FsbGJhY2sgbWF0Y2hlcyBgL1xcLnRlc3QvYCByZWdhcmRsZXNzIG9mIHRoZSBkZWxheS5cbiAqICAgICBgYGBiYXNoXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRUaW1lb3V0JywgJy9cXC50ZXN0LycpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBjYWxsIHdpbGwgYmUgcHJldmVudGVkOlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlXCI7XG4gKiAgICAgfSwgMTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBQcmV2ZW50cyBgc2V0VGltZW91dGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGRvZXMgbm90IGNvbnRhaW4gYHZhbHVlYC5cbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldFRpbWVvdXQnLCAnIXZhbHVlJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBmaXJzdCBvZiB0aGUgZm9sbG93aW5nIGNhbGxzIHdpbGwgYmUgcHJldmVudGVkOlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInRlc3QgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnZhbHVlID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiAzLiBQcmV2ZW50cyBgc2V0VGltZW91dGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGNvbnRhaW5zIGB2YWx1ZWAgYW5kIHRoZSBkZWxheSBpcyBub3Qgc2V0IHRvIGAzMDBgLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0VGltZW91dCcsICd2YWx1ZScsICchMzAwJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBmaXJzdCBvZiB0aGUgZm9sbG93aW5nIGNhbGxzIHdpbGwgbm90IGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZSAxIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIDIgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIDMgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiA0LiBQcmV2ZW50cyBgc2V0VGltZW91dGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGRvZXMgbm90IGNvbnRhaW4gYHZhbHVlYCBhbmQgdGhlIGRlbGF5IGlzIG5vdCBzZXQgdG8gYDMwMGAuXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRUaW1lb3V0JywgJyF2YWx1ZScsICchMzAwJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBzZWNvbmQgb2YgdGhlIGZvbGxvd2luZyBjYWxscyB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInRlc3QgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnZhbHVlID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcHJldmVudFNldFRpbWVvdXQoc291cmNlLCBtYXRjaCwgZGVsYXkpIHtcbiAgdmFyIG5hdGl2ZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcbiAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAvLyBsb2dzIHNldFRpbWVvdXRzIHRvIGNvbnNvbGUgaWYgbm8gYXJndW1lbnRzIGhhdmUgYmVlbiBzcGVjaWZpZWRcblxuICB2YXIgc2hvdWxkTG9nID0gdHlwZW9mIG1hdGNoID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZGVsYXkgPT09ICd1bmRlZmluZWQnO1xuXG4gIHZhciBfcGFyc2VNYXRjaEFyZyA9IHBhcnNlTWF0Y2hBcmcobWF0Y2gpLFxuICAgICAgaXNJbnZlcnRlZE1hdGNoID0gX3BhcnNlTWF0Y2hBcmcuaXNJbnZlcnRlZE1hdGNoLFxuICAgICAgbWF0Y2hSZWdleHAgPSBfcGFyc2VNYXRjaEFyZy5tYXRjaFJlZ2V4cDtcblxuICB2YXIgX3BhcnNlRGVsYXlBcmcgPSBwYXJzZURlbGF5QXJnKGRlbGF5KSxcbiAgICAgIGlzSW52ZXJ0ZWREZWxheU1hdGNoID0gX3BhcnNlRGVsYXlBcmcuaXNJbnZlcnRlZERlbGF5TWF0Y2gsXG4gICAgICBkZWxheU1hdGNoID0gX3BhcnNlRGVsYXlBcmcuZGVsYXlNYXRjaDtcblxuICB2YXIgdGltZW91dFdyYXBwZXIgPSBmdW5jdGlvbiB0aW1lb3V0V3JhcHBlcihjYWxsYmFjaywgdGltZW91dCkge1xuICAgIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMDVcblxuICAgIHZhciBjYlN0cmluZyA9IFN0cmluZyhjYWxsYmFjayk7XG5cbiAgICBpZiAoc2hvdWxkTG9nKSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIGxvZyhcInNldFRpbWVvdXQoXCIuY29uY2F0KGNiU3RyaW5nLCBcIiwgXCIpLmNvbmNhdCh0aW1lb3V0LCBcIilcIikpO1xuICAgIH0gZWxzZSBpZiAoIWRlbGF5TWF0Y2gpIHtcbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KGNiU3RyaW5nKSAhPT0gaXNJbnZlcnRlZE1hdGNoO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gdGltZW91dCA9PT0gZGVsYXlNYXRjaCAhPT0gaXNJbnZlcnRlZERlbGF5TWF0Y2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KGNiU3RyaW5nKSAhPT0gaXNJbnZlcnRlZE1hdGNoICYmIHRpbWVvdXQgPT09IGRlbGF5TWF0Y2ggIT09IGlzSW52ZXJ0ZWREZWxheU1hdGNoO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHJldHVybiBuYXRpdmVUaW1lb3V0KG5vb3BGdW5jLCB0aW1lb3V0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlVGltZW91dC5hcHBseSh3aW5kb3csIFtjYWxsYmFjaywgdGltZW91dF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0VGltZW91dCA9IHRpbWVvdXRXcmFwcGVyO1xufVxucHJldmVudFNldFRpbWVvdXQubmFtZXMgPSBbJ3ByZXZlbnQtc2V0VGltZW91dCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbiduby1zZXRUaW1lb3V0LWlmLmpzJywgLy8gbmV3IGltcGxlbWVudGF0aW9uIG9mIHNldFRpbWVvdXQtZGVmdXNlci5qc1xuJ3Viby1uby1zZXRUaW1lb3V0LWlmLmpzJywgJ25vc3RpZi5qcycsIC8vIG5ldyBzaG9ydCBuYW1lIG9mIG5vLXNldFRpbWVvdXQtaWZcbid1Ym8tbm9zdGlmLmpzJywgJ3Viby1uby1zZXRUaW1lb3V0LWlmJywgJ3Viby1ub3N0aWYnLCAvLyBvbGQgc2NyaXB0bGV0IG5hbWVzIHdoaWNoIHNob3VsZCBiZSBzdXBwb3J0ZWQgYXMgd2VsbC5cbi8vIHNob3VsZCBiZSByZW1vdmVkIGV2ZW50dWFsbHkuXG4vLyBkbyBub3QgcmVtb3ZlIHVudGlsIG90aGVyIGZpbHRlciBsaXN0cyBtYWludGFpbmVycyB1c2UgdGhlbVxuJ3NldFRpbWVvdXQtZGVmdXNlci5qcycsICd1Ym8tc2V0VGltZW91dC1kZWZ1c2VyLmpzJywgJ3Viby1zZXRUaW1lb3V0LWRlZnVzZXInLCAnc3RkLmpzJywgJ3Viby1zdGQuanMnLCAndWJvLXN0ZCddO1xucHJldmVudFNldFRpbWVvdXQuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BGdW5jLCBwYXJzZU1hdGNoQXJnLCBwYXJzZURlbGF5QXJnLCB0b1JlZ0V4cCwgc3RhcnRzV2l0aCwgbmF0aXZlSXNOYU5dO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBwcmV2ZW50LXNldEludGVydmFsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBhIGBzZXRJbnRlcnZhbGAgY2FsbCBpZjpcbiAqIDEpIHRoZSB0ZXh0IG9mIHRoZSBjYWxsYmFjayBpcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGBzZWFyY2hgIHN0cmluZy9yZWdleHAgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCBgIWA7XG4gKiBvdGhlcndpc2UgbWlzbWF0Y2hlZCBjYWxscyBzaG91bGQgYmUgZGVmdXNlZDtcbiAqIDIpIHRoZSBpbnRlcnZhbCBpcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGBkZWxheWA7IG90aGVyd2lzZSBtaXNtYXRjaGVkIGNhbGxzIHNob3VsZCBiZSBkZWZ1c2VkLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vLXNldGludGVydmFsLWlmanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldEludGVydmFsJ1ssIHNlYXJjaFssIGRlbGF5XV0pXG4gKiBgYGBcbiAqXG4gKiBDYWxsIHdpdGggbm8gYXJndW1lbnRzIHdpbGwgbG9nIGNhbGxzIHRvIHNldEludGVydmFsIHdoaWxlIGRlYnVnZ2luZyAoYGxvZy1zZXRJbnRlcnZhbGAgc3VwZXJzZWRpbmcpLFxuICogc28gcHJvZHVjdGlvbiBmaWx0ZXIgbGlzdHMnIHJ1bGVzIGRlZmluaXRlbHkgcmVxdWlyZSBhdCBsZWFzdCBvbmUgb2YgdGhlIHBhcmFtZXRlcnM6XG4gKiAtIGBzZWFyY2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBJZiBzdGFydHMgd2l0aCBgIWAsIHNjcmlwdGxldCB3aWxsIG5vdCBtYXRjaCB0aGUgc3RyaW5naWZpZWQgY2FsbGJhY2sgYnV0IGFsbCBvdGhlciB3aWxsIGJlIGRlZnVzZWQuXG4gKiBJZiBkbyBub3Qgc3RhcnQgd2l0aCBgIWAsIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayB3aWxsIGJlIG1hdGNoZWQuXG4gKiBJZiBub3Qgc2V0LCBwcmV2ZW50cyBhbGwgYHNldEludGVydmFsYCBjYWxscyBkdWUgdG8gc3BlY2lmaWVkIGBkZWxheWAuXG4gKiAtIGBkZWxheWAgLSBvcHRpb25hbCwgbXVzdCBiZSBhbiBpbnRlZ2VyLlxuICogSWYgc3RhcnRzIHdpdGggYCFgLCBzY3JpcHRsZXQgd2lsbCBub3QgbWF0Y2ggdGhlIGRlbGF5IGJ1dCBhbGwgb3RoZXIgd2lsbCBiZSBkZWZ1c2VkLlxuICogSWYgZG8gbm90IHN0YXJ0IHdpdGggYCFgLCB0aGUgZGVsYXkgcGFzc2VkIHRvIHRoZSBgc2V0SW50ZXJ2YWxgIGNhbGwgd2lsbCBiZSBtYXRjaGVkLlxuICpcbiAqID4gSWYgYHByZXZlbnQtc2V0SW50ZXJ2YWxgIHdpdGhvdXQgcGFyYW1ldGVycyBsb2dzIHNtdGggbGlrZSBgc2V0SW50ZXJ2YWwodW5kZWZpbmVkLCAxMDAwKWAsXG4gKiBpdCBtZWFucyB0aGF0IG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQgdG8gc2V0SW50ZXJ2YWwoKSBhbmQgdGhhdCdzIG5vdCBzY3JpcHRsZXQgaXNzdWVcblxuICogICoqRXhhbXBsZXMqKlxuICogMS4gUHJldmVudHMgYHNldEludGVydmFsYCBjYWxscyBpZiB0aGUgY2FsbGJhY2sgbWF0Y2hlcyBgL1xcLnRlc3QvYCByZWdhcmRsZXNzIG9mIHRoZSBkZWxheS5cbiAqICAgICBgYGBiYXNoXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRJbnRlcnZhbCcsICcvXFwudGVzdC8nKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgY2FsbCB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWVcIjtcbiAqICAgICB9LCAxMDApO1xuICogICAgIGBgYFxuICpcbiAqIDIuIFByZXZlbnRzIGBzZXRJbnRlcnZhbGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGRvZXMgbm90IGNvbnRhaW4gYHZhbHVlYC5cbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldEludGVydmFsJywgJyF2YWx1ZScpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgb25seSB0aGUgZmlyc3Qgb2YgdGhlIGZvbGxvd2luZyBjYWxscyB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidGVzdCAtLSBwcmV2ZW50ZWRcIjtcbiAqICAgICB9LCAzMDApO1xuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy52YWx1ZSA9IFwidGVzdCAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDUwMCk7XG4gKiAgICAgYGBgXG4gKlxuICogMy4gUHJldmVudHMgYHNldEludGVydmFsYCBjYWxscyBpZiB0aGUgY2FsbGJhY2sgY29udGFpbnMgYHZhbHVlYCBhbmQgdGhlIGRlbGF5IGlzIG5vdCBzZXQgdG8gYDMwMGAuXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRJbnRlcnZhbCcsICd2YWx1ZScsICchMzAwJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBmaXJzdCBvZiB0aGUgZm9sbG93aW5nIGNhbGxzIHdpbGwgbm90IGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWUgMSAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDMwMCk7XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWUgMiAtLSBwcmV2ZW50ZWRcIjtcbiAqICAgICB9LCA0MDApO1xuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIDMgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiA0LiBQcmV2ZW50cyBgc2V0SW50ZXJ2YWxgIGNhbGxzIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCBjb250YWluIGB2YWx1ZWAgYW5kIHRoZSBkZWxheSBpcyBub3Qgc2V0IHRvIGAzMDBgLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0SW50ZXJ2YWwnLCAnIXZhbHVlJywgJyEzMDAnKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIG9ubHkgdGhlIHNlY29uZCBvZiB0aGUgZm9sbG93aW5nIGNhbGxzIHdpbGwgYmUgcHJldmVudGVkOlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ0ZXN0IC0tIHByZXZlbnRlZFwiO1xuICogICAgIH0sIDQwMCk7XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWUgLS0gZXhlY3V0ZWRcIjtcbiAqICAgICB9LCA0MDApO1xuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnZhbHVlID0gXCJ0ZXN0IC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNTAwKTtcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcHJldmVudFNldEludGVydmFsKHNvdXJjZSwgbWF0Y2gsIGRlbGF5KSB7XG4gIHZhciBuYXRpdmVJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbDtcbiAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAvLyBsb2dzIHNldEludGVydmFscyB0byBjb25zb2xlIGlmIG5vIGFyZ3VtZW50cyBoYXZlIGJlZW4gc3BlY2lmaWVkXG5cbiAgdmFyIHNob3VsZExvZyA9IHR5cGVvZiBtYXRjaCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlbGF5ID09PSAndW5kZWZpbmVkJztcblxuICB2YXIgX3BhcnNlTWF0Y2hBcmcgPSBwYXJzZU1hdGNoQXJnKG1hdGNoKSxcbiAgICAgIGlzSW52ZXJ0ZWRNYXRjaCA9IF9wYXJzZU1hdGNoQXJnLmlzSW52ZXJ0ZWRNYXRjaCxcbiAgICAgIG1hdGNoUmVnZXhwID0gX3BhcnNlTWF0Y2hBcmcubWF0Y2hSZWdleHA7XG5cbiAgdmFyIF9wYXJzZURlbGF5QXJnID0gcGFyc2VEZWxheUFyZyhkZWxheSksXG4gICAgICBpc0ludmVydGVkRGVsYXlNYXRjaCA9IF9wYXJzZURlbGF5QXJnLmlzSW52ZXJ0ZWREZWxheU1hdGNoLFxuICAgICAgZGVsYXlNYXRjaCA9IF9wYXJzZURlbGF5QXJnLmRlbGF5TWF0Y2g7XG5cbiAgdmFyIGludGVydmFsV3JhcHBlciA9IGZ1bmN0aW9uIGludGVydmFsV3JhcHBlcihjYWxsYmFjaywgaW50ZXJ2YWwpIHtcbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlOyAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTA1XG5cbiAgICB2YXIgY2JTdHJpbmcgPSBTdHJpbmcoY2FsbGJhY2spO1xuXG4gICAgaWYgKHNob3VsZExvZykge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICBsb2coXCJzZXRJbnRlcnZhbChcIi5jb25jYXQoY2JTdHJpbmcsIFwiLCBcIikuY29uY2F0KGludGVydmFsLCBcIilcIikpO1xuICAgIH0gZWxzZSBpZiAoIWRlbGF5TWF0Y2gpIHtcbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KGNiU3RyaW5nKSAhPT0gaXNJbnZlcnRlZE1hdGNoO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gaW50ZXJ2YWwgPT09IGRlbGF5TWF0Y2ggIT09IGlzSW52ZXJ0ZWREZWxheU1hdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gbWF0Y2hSZWdleHAudGVzdChjYlN0cmluZykgIT09IGlzSW52ZXJ0ZWRNYXRjaCAmJiBpbnRlcnZhbCA9PT0gZGVsYXlNYXRjaCAhPT0gaXNJbnZlcnRlZERlbGF5TWF0Y2g7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgcmV0dXJuIG5hdGl2ZUludGVydmFsKG5vb3BGdW5jLCBpbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZUludGVydmFsLmFwcGx5KHdpbmRvdywgW2NhbGxiYWNrLCBpbnRlcnZhbF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0SW50ZXJ2YWwgPSBpbnRlcnZhbFdyYXBwZXI7XG59XG5wcmV2ZW50U2V0SW50ZXJ2YWwubmFtZXMgPSBbJ3ByZXZlbnQtc2V0SW50ZXJ2YWwnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm8tc2V0SW50ZXJ2YWwtaWYuanMnLCAvLyBuZXcgaW1wbGVtZW50YXRpb24gb2Ygc2V0SW50ZXJ2YWwtZGVmdXNlci5qc1xuJ3Viby1uby1zZXRJbnRlcnZhbC1pZi5qcycsICdzZXRJbnRlcnZhbC1kZWZ1c2VyLmpzJywgLy8gb2xkIG5hbWUgc2hvdWxkIGJlIHN1cHBvcnRlZCBhcyB3ZWxsXG4ndWJvLXNldEludGVydmFsLWRlZnVzZXIuanMnLCAnbm9zaWlmLmpzJywgLy8gbmV3IHNob3J0IG5hbWUgb2Ygbm8tc2V0SW50ZXJ2YWwtaWZcbid1Ym8tbm9zaWlmLmpzJywgJ3NpZC5qcycsIC8vIG9sZCBzaG9ydCBzY3JpcHRsZXQgbmFtZVxuJ3Viby1zaWQuanMnLCAndWJvLW5vLXNldEludGVydmFsLWlmJywgJ3Viby1zZXRJbnRlcnZhbC1kZWZ1c2VyJywgJ3Viby1ub3NpaWYnLCAndWJvLXNpZCddO1xucHJldmVudFNldEludGVydmFsLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgcGFyc2VNYXRjaEFyZywgcGFyc2VEZWxheUFyZywgdG9SZWdFeHAsIHN0YXJ0c1dpdGgsIG5hdGl2ZUlzTmFOXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC13aW5kb3ctb3BlblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgYHdpbmRvdy5vcGVuYCBjYWxscyB3aGVuIFVSTCBlaXRoZXIgbWF0Y2hlcyBvciBub3QgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHN0cmluZy9yZWdleHAuIFVzaW5nIGl0IHdpdGhvdXQgcGFyYW1ldGVycyBwcmV2ZW50cyBhbGwgYHdpbmRvdy5vcGVuYCBjYWxscy5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSN3aW5kb3dvcGVuLWRlZnVzZXJqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtd2luZG93LW9wZW4nWywgbWF0Y2hbLCBkZWxheVssIHJlcGxhY2VtZW50XV1dKVxuICogYGBgXG4gKlxuICogLSBgbWF0Y2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uIElmIG5vdCBzZXQsIGFsbCB3aW5kb3cub3BlbiBjYWxscyB3aWxsIGJlIG1hdGNoZWQuXG4gKiBJZiBzdGFydHMgd2l0aCBgIWAsIHNjcmlwdGxldCB3aWxsIG5vdCBtYXRjaCB0aGUgc3RyaW5naWZpZWQgY2FsbGJhY2sgYnV0IGFsbCBvdGhlciB3aWxsIGJlIGRlZnVzZWQuXG4gKiBJZiBkbyBub3Qgc3RhcnQgd2l0aCBgIWAsIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayB3aWxsIGJlIG1hdGNoZWQuXG4gKiAtIGBkZWxheWAgLSBvcHRpb25hbCwgbnVtYmVyIG9mIHNlY29uZHMuIElmIG5vdCBzZXQsIHNjcmlwdGxldCB3aWxsIHJldHVybiBgbnVsbGAsXG4gKiBvdGhlcndpc2UgdmFsaWQgc2hhbSB3aW5kb3cgb2JqZWN0IGFzIGluamVjdGVkIGBpZnJhbWVgIHdpbGwgYmUgcmV0dXJuZWRcbiAqIGZvciBhY2Nlc3NpbmcgaXQncyBtZXRob2RzIChibHVyKCksIGZvY3VzKCkgZXRjLikgYW5kIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciB0aGUgZGVsYXkuXG4gKiAtIGByZXBsYWNlbWVudGAgLSBvcHRpb25hbCwgc3RyaW5nOyBvbmUgb2YgdGhlIHByZWRlZmluZWQgY29uc3RhbnRzOlxuICogICAgIC0gYG9iamAgLSBmb3IgcmV0dXJuaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGRlZmF1bHQgaWZyYW1lO1xuICogICAgICAgIGZvciBjYXNlcyB3aGVuIHRoZSBwYWdlIHJlcXVpcmVzIGEgdmFsaWQgYHdpbmRvd2AgaW5zdGFuY2UgdG8gYmUgcmV0dXJuZWRcbiAqICAgICAtIGBsb2dgIC0gZm9yIGxvZ2dpbmcgd2luZG93Lm9wZW4gY2FsbHM7IHBlcm1pdHRlZCBmb3IgcHJvZHVjdGlvbiBmaWx0ZXIgbGlzdHMuXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBQcmV2ZW50IGFsbCBgd2luZG93Lm9wZW5gIGNhbGxzOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicpXG4gKiBgYGBcbiAqXG4gKiAyLiBQcmV2ZW50IGB3aW5kb3cub3BlbmAgZm9yIGFsbCBVUkxzIGNvbnRhaW5pbmcgYGV4YW1wbGVgOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICdleGFtcGxlJylcbiAqIGBgYFxuICpcbiAqIDMuIFByZXZlbnQgYHdpbmRvdy5vcGVuYCBmb3IgYWxsIFVSTHMgbWF0Y2hpbmcgUmVnRXhwIGAvZXhhbXBsZVxcLi9gOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICcvZXhhbXBsZVxcLi8nKVxuICogYGBgXG4gKlxuICogNC4gUHJldmVudCBgd2luZG93Lm9wZW5gIGZvciBhbGwgVVJMcyAqKk5PVCoqIGNvbnRhaW5pbmcgYGV4YW1wbGVgOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICchZXhhbXBsZScpXG4gKiBgYGBcbiAqXG4gKiBPbGQgc3ludGF4IG9mIHByZXZlbnQtd2luZG93LW9wZW4gcGFyYW1ldGVyczpcbiAqIC0gYG1hdGNoYCAtIG9wdGlvbmFsLCBkZWZhdWx0cyB0byBcIm1hdGNoaW5nXCIsIGFueSBwb3NpdGl2ZSBudW1iZXIgb3Igbm90aGluZyBmb3IgXCJtYXRjaGluZ1wiLCAwIG9yIGVtcHR5IHN0cmluZyBmb3IgXCJub3QgbWF0Y2hpbmdcIlxuICogLSBgc2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVnZXhwIGZvciBtYXRjaGluZyB0aGUgVVJMIHBhc3NlZCB0byBgd2luZG93Lm9wZW5gIGNhbGw7IGRlZmF1bHRzIHRvIHNlYXJjaCBhbGwgYHdpbmRvdy5vcGVuYCBjYWxsXG4gKiAtIGByZXBsYWNlbWVudGAgLSBvcHRpb25hbCwgc3RyaW5nIHRvIHJldHVybiBwcm9wIHZhbHVlIG9yIHByb3BlcnR5IGluc3RlYWQgb2Ygd2luZG93Lm9wZW47IGRlZmF1bHRzIHRvIHJldHVybiBub29wRnVuYy5cbiAqICoqRXhhbXBsZXMqKlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICcxJywgJy9leGFtcGxlXFwuLydcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXdpbmRvdy1vcGVuJywgJzAnLCAnZXhhbXBsZScpXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICcnLCAnJywgJ3RydWVGdW5jJylcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXdpbmRvdy1vcGVuJywgJzEnLCAnJywgJ3twcm9wTmFtZT1ub29wRnVuY30nKVxuICogYGBgXG4gKlxuICogPiBGb3IgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCB1Qk8sIG9sZCBzeW50YXggaXMgbm90IHJlY29tbWVuZGVkIHRvIHVzZS5cbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcHJldmVudFdpbmRvd09wZW4oc291cmNlKSB7XG4gIHZhciBtYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZ2V0V2lsZGNhcmRTeW1ib2woKTtcbiAgdmFyIGRlbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciByZXBsYWNlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAvLyBkZWZhdWx0IG1hdGNoIHZhbHVlIGlzIG5lZWRlZCBmb3IgcHJldmVudGluZyBhbGwgd2luZG93Lm9wZW4gY2FsbHNcbiAgLy8gaWYgc2NyaXB0bGV0IHJ1bnMgd2l0aG91dCBhcmdzXG4gIHZhciBuYXRpdmVPcGVuID0gd2luZG93Lm9wZW47XG4gIHZhciBpc05ld1N5bnRheCA9IG1hdGNoICE9PSAnMCcgJiYgbWF0Y2ggIT09ICcxJztcblxuICB2YXIgb2xkT3BlbldyYXBwZXIgPSBmdW5jdGlvbiBvbGRPcGVuV3JhcHBlcihzdHIpIHtcbiAgICBtYXRjaCA9IE51bWJlcihtYXRjaCkgPiAwOyAvLyAnZGVsYXknIHdhcyAnc2VhcmNoJyBwcm9wIGZvciBtYXRjaGluZyBpbiBvbGQgc3ludGF4XG5cbiAgICB2YXIgc2VhcmNoUmVnZXhwID0gdG9SZWdFeHAoZGVsYXkpO1xuXG4gICAgaWYgKG1hdGNoICE9PSBzZWFyY2hSZWdleHAudGVzdChzdHIpKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlT3Blbi5hcHBseSh3aW5kb3csIFtzdHJdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuXG4gICAgaGl0KHNvdXJjZSk7XG4gICAgcmV0dXJuIGhhbmRsZU9sZFJlcGxhY2VtZW50KHJlcGxhY2VtZW50KTtcbiAgfTtcblxuICB2YXIgbmV3T3BlbldyYXBwZXIgPSBmdW5jdGlvbiBuZXdPcGVuV3JhcHBlcih1cmwpIHtcbiAgICB2YXIgc2hvdWxkTG9nID0gcmVwbGFjZW1lbnQgJiYgcmVwbGFjZW1lbnQuaW5kZXhPZignbG9nJykgPiAtMTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRMb2cpIHtcbiAgICAgIHZhciBhcmdzU3RyID0gYXJncyAmJiBhcmdzLmxlbmd0aCA+IDAgPyBcIiwgXCIuY29uY2F0KGFyZ3Muam9pbignLCAnKSkgOiAnJztcbiAgICAgIHZhciBsb2dNZXNzYWdlID0gXCJsb2c6IHdpbmRvdy1vcGVuOiBcIi5jb25jYXQodXJsKS5jb25jYXQoYXJnc1N0cik7XG4gICAgICBoaXQoc291cmNlLCBsb2dNZXNzYWdlKTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xuXG4gICAgaWYgKG1hdGNoID09PSBnZXRXaWxkY2FyZFN5bWJvbCgpKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9wYXJzZU1hdGNoQXJnID0gcGFyc2VNYXRjaEFyZyhtYXRjaCksXG4gICAgICAgICAgaXNJbnZlcnRlZE1hdGNoID0gX3BhcnNlTWF0Y2hBcmcuaXNJbnZlcnRlZE1hdGNoLFxuICAgICAgICAgIG1hdGNoUmVnZXhwID0gX3BhcnNlTWF0Y2hBcmcubWF0Y2hSZWdleHA7XG5cbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KHVybCkgIT09IGlzSW52ZXJ0ZWRNYXRjaDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgdmFyIHBhcnNlZERlbGF5ID0gcGFyc2VJbnQoZGVsYXksIDEwKTtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmIChuYXRpdmVJc05hTihwYXJzZWREZWxheSkpIHtcbiAgICAgICAgcmVzdWx0ID0gbm9vcE51bGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWNveUFyZ3MgPSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQ6IHJlcGxhY2VtZW50LFxuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIGRlbGF5OiBwYXJzZWREZWxheVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVjb3kgPSBjcmVhdGVEZWNveShkZWNveUFyZ3MpO1xuICAgICAgICB2YXIgcG9wdXAgPSBkZWNveS5jb250ZW50V2luZG93O1xuXG4gICAgICAgIGlmICh0eXBlb2YgcG9wdXAgPT09ICdvYmplY3QnICYmIHBvcHVwICE9PSBudWxsKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBvcHVwLCAnY2xvc2VkJywge1xuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZUdldHRlciA9IGRlY295LmNvbnRlbnRXaW5kb3cgJiYgZGVjb3kuY29udGVudFdpbmRvdy5nZXQ7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY295LCAnY29udGVudFdpbmRvdycsIHtcbiAgICAgICAgICAgIGdldDogZ2V0UHJldmVudEdldHRlcihuYXRpdmVHZXR0ZXIpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9wdXAgPSBkZWNveS5jb250ZW50V2luZG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcG9wdXA7XG4gICAgICB9XG5cbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlT3Blbi5hcHBseSh3aW5kb3csIFt1cmxdLmNvbmNhdChhcmdzKSk7XG4gIH07XG5cbiAgd2luZG93Lm9wZW4gPSBpc05ld1N5bnRheCA/IG5ld09wZW5XcmFwcGVyIDogb2xkT3BlbldyYXBwZXI7XG59XG5wcmV2ZW50V2luZG93T3Blbi5uYW1lcyA9IFsncHJldmVudC13aW5kb3ctb3BlbicsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbid3aW5kb3cub3Blbi1kZWZ1c2VyLmpzJywgJ3Viby13aW5kb3cub3Blbi1kZWZ1c2VyLmpzJywgJ3Viby13aW5kb3cub3Blbi1kZWZ1c2VyJywgJ25vd29pZi5qcycsICd1Ym8tbm93b2lmLmpzJywgJ3Viby1ub3dvaWYnXTtcbnByZXZlbnRXaW5kb3dPcGVuLmluamVjdGlvbnMgPSBbaGl0LCB0b1JlZ0V4cCwgbmF0aXZlSXNOYU4sIHBhcnNlTWF0Y2hBcmcsIGhhbmRsZU9sZFJlcGxhY2VtZW50LCBjcmVhdGVEZWNveSwgZ2V0UHJldmVudEdldHRlciwgbm9vcE51bGwsIGdldFdpbGRjYXJkU3ltYm9sLCBub29wRnVuYywgdHJ1ZUZ1bmMsIHN0YXJ0c1dpdGgsIGVuZHNXaXRoLCBzdWJzdHJpbmdCZWZvcmUsIHN1YnN0cmluZ0FmdGVyXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBYm9ydHMgYW4gaW5saW5lIHNjcmlwdCB3aGVuIGl0IGF0dGVtcHRzIHRvICoqcmVhZCoqIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAqIEFORCB3aGVuIHRoZSBjb250ZW50cyBvZiB0aGUgYDxzY3JpcHQ+YCBlbGVtZW50IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWRcbiAqIHRleHQgb3IgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdGpzLVxuICpcbiAqIFJlbGF0ZWQgQUJQIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hZGJsb2NrcGx1cy9hZGJsb2NrcGx1c2NvcmUvYmxvYi82YjJhMzA5MDU0Y2MyMzQzMjEwMmI4NWQxM2YxMjU1OTYzOWVmNDk1L2xpYi9jb250ZW50L3NuaXBwZXRzLmpzI0w5MjhcbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCcsIHByb3BlcnR5Wywgc2VhcmNoXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BlcnR5YCAtIHJlcXVpcmVkLCBwYXRoIHRvIGEgcHJvcGVydHkgKGpvaW5lZCB3aXRoIGAuYCBpZiBuZWVkZWQpLiBUaGUgcHJvcGVydHkgbXVzdCBiZSBhdHRhY2hlZCB0byBgd2luZG93YFxuICogLSBgc2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbXVzdCBtYXRjaCB0aGUgaW5saW5lIHNjcmlwdCBjb250ZW50cy4gSWYgbm90IHNldCwgYWJvcnQgYWxsIGlubGluZSBzY3JpcHRzIHdoaWNoIGFyZSB0cnlpbmcgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAqXG4gKiA+IE5vdGUgcGxlYXNlIHRoYXQgZm9yIGlubGluZSBzY3JpcHQgd2l0aCBhZGRFdmVudExpc3RlbmVyIGluIGl0XG4gKiBgcHJvcGVydHlgIHNob3VsZCBiZSBzZXQgYXMgYEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyYCxcbiAqIG5vdCBqdXN0IGBhZGRFdmVudExpc3RlbmVyYC5cbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIEFib3J0cyBhbGwgaW5saW5lIHNjcmlwdHMgdHJ5aW5nIHRvIGFjY2VzcyBgd2luZG93LmFsZXJ0YFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCcsICdhbGVydCcpXG4gKiAgICAgYGBgXG4gKlxuICogMi4gQWJvcnRzIGlubGluZSBzY3JpcHRzIHdoaWNoIGFyZSB0cnlpbmcgdG8gYWNjZXNzIGB3aW5kb3cuYWxlcnRgIGFuZCBjb250YWluIGBIZWxsbywgd29ybGRgLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCcsICdhbGVydCcsICdIZWxsbywgd29ybGQnKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgc2NyaXB0IHdpbGwgYmUgYWJvcnRlZFxuICogICAgIGBgYGh0bWxcbiAqICAgICA8c2NyaXB0PmFsZXJ0KFwiSGVsbG8sIHdvcmxkXCIpOzwvc2NyaXB0PlxuICogICAgIGBgYFxuICpcbiAqIDMuIEFib3J0cyBpbmxpbmUgc2NyaXB0cyB3aGljaCBhcmUgdHJ5aW5nIHRvIGFjY2VzcyBgd2luZG93LmFsZXJ0YCBhbmQgbWF0Y2ggdGhpcyByZWdleHA6IGAvSGVsbG8uK3dvcmxkL2AuXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0JywgJ2FsZXJ0JywgJy9IZWxsby4rd29ybGQvJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCB0aGUgZm9sbG93aW5nIHNjcmlwdHMgd2lsbCBiZSBhYm9ydGVkOlxuICogICAgIGBgYGh0bWxcbiAqICAgICA8c2NyaXB0PmFsZXJ0KFwiSGVsbG8sIGJpZyB3b3JsZFwiKTs8L3NjcmlwdD5cbiAqICAgICBgYGBcbiAqICAgICBgYGBodG1sXG4gKiAgICAgPHNjcmlwdD5hbGVydChcIkhlbGxvLCBsaXR0bGUgd29ybGRcIik7PC9zY3JpcHQ+XG4gKiAgICAgYGBgXG4gKlxuICogICAgIFRoaXMgc2NyaXB0IHdpbGwgbm90IGJlIGFib3J0ZWQ6XG4gKiAgICAgYGBgaHRtbFxuICogICAgIDxzY3JpcHQ+YWxlcnQoXCJIaSwgbGl0dGxlIHdvcmxkXCIpOzwvc2NyaXB0PlxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBhYm9ydEN1cnJlbnRJbmxpbmVTY3JpcHQoc291cmNlLCBwcm9wZXJ0eSwgc2VhcmNoKSB7XG4gIHZhciBzZWFyY2hSZWdleHAgPSB0b1JlZ0V4cChzZWFyY2gpO1xuICB2YXIgcmlkID0gcmFuZG9tSWQoKTtcblxuICB2YXIgZ2V0Q3VycmVudFNjcmlwdCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHQoKSB7XG4gICAgaWYgKCdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIH1cblxuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHJldHVybiBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV07XG4gIH07XG5cbiAgdmFyIG91clNjcmlwdCA9IGdldEN1cnJlbnRTY3JpcHQoKTtcblxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB2YXIgc2NyaXB0RWwgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG5cbiAgICBpZiAoIXNjcmlwdEVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBzY3JpcHRFbC50ZXh0Q29udGVudDsgLy8gV2UgYXJlIHVzaW5nIE5vZGUucHJvdG90eXBlLnRleHRDb250ZW50IHByb3BlcnR5IGRlc2NyaXB0b3JcbiAgICAvLyB0byBnZXQgdGhlIHJlYWwgc2NyaXB0IGNvbnRlbnRcbiAgICAvLyBldmVuIHdoZW4gZG9jdW1lbnQuY3VycmVudFNjcmlwdC50ZXh0Q29udGVudCBpcyByZXBsYWNlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvNTcjaXNzdWVjb21tZW50LTU5MzYzODk5MVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciB0ZXh0Q29udGVudEdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsICd0ZXh0Q29udGVudCcpLmdldDtcbiAgICAgIGNvbnRlbnQgPSB0ZXh0Q29udGVudEdldHRlci5jYWxsKHNjcmlwdEVsKTtcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cblxuICAgIGlmIChzY3JpcHRFbCBpbnN0YW5jZW9mIEhUTUxTY3JpcHRFbGVtZW50ICYmIGNvbnRlbnQubGVuZ3RoID4gMCAmJiBzY3JpcHRFbCAhPT0gb3VyU2NyaXB0ICYmIHNlYXJjaFJlZ2V4cC50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihyaWQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0Q2hhaW5Qcm9wQWNjZXNzID0gZnVuY3Rpb24gc2V0Q2hhaW5Qcm9wQWNjZXNzKG93bmVyLCBwcm9wZXJ0eSkge1xuICAgIHZhciBjaGFpbkluZm8gPSBnZXRQcm9wZXJ0eUluQ2hhaW4ob3duZXIsIHByb3BlcnR5KTtcbiAgICB2YXIgYmFzZSA9IGNoYWluSW5mby5iYXNlO1xuICAgIHZhciBwcm9wID0gY2hhaW5JbmZvLnByb3AsXG4gICAgICAgIGNoYWluID0gY2hhaW5JbmZvLmNoYWluOyAvLyBUaGUgc2NyaXB0bGV0IG1pZ2h0IGJlIGV4ZWN1dGVkIGJlZm9yZSB0aGUgY2hhaW4gcHJvcGVydHkgaGFzIGJlZW4gY3JlYXRlZFxuICAgIC8vIChmb3IgaW5zdGFuY2UsIGRvY3VtZW50LmJvZHkgYmVmb3JlIHRoZSBIVE1MIGJvZHkgd2FzIGxvYWRlZCkuXG4gICAgLy8gSW4gdGhpcyBjYXNlIHdlJ3JlIGNoZWNraW5nIHdoZXRoZXIgdGhlIGJhc2UgZWxlbWVudCBleGlzdHMgb3Igbm90XG4gICAgLy8gYW5kIGlmIG5vdCwgd2Ugc2ltcGx5IGV4aXQgd2l0aG91dCBvdmVycmlkaW5nIGFueXRoaW5nLlxuICAgIC8vIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzU3I2lzc3VlY29tbWVudC01NzU4NDEwOTJcblxuICAgIGlmIChiYXNlIGluc3RhbmNlb2YgT2JqZWN0ID09PSBmYWxzZSAmJiBiYXNlID09PSBudWxsKSB7XG4gICAgICB2YXIgcHJvcHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgICAgdmFyIHByb3BJbmRleCA9IHByb3BzLmluZGV4T2YocHJvcCk7XG4gICAgICB2YXIgYmFzZU5hbWUgPSBwcm9wc1twcm9wSW5kZXggLSAxXTtcbiAgICAgIGNvbnNvbGUubG9nKFwiVGhlIHNjcmlwdGxldCBoYWQgYmVlbiBleGVjdXRlZCBiZWZvcmUgdGhlIFwiLmNvbmNhdChiYXNlTmFtZSwgXCIgd2FzIGxvYWRlZC5cIikpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGJhc2VbcHJvcF07XG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgc2V0Q2hhaW5Qcm9wQWNjZXNzKHdpbmRvdywgcHJvcGVydHkpO1xuICB3aW5kb3cub25lcnJvciA9IGNyZWF0ZU9uRXJyb3JIYW5kbGVyKHJpZCkuYmluZCgpO1xufVxuYWJvcnRDdXJyZW50SW5saW5lU2NyaXB0Lm5hbWVzID0gWydhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0LmpzJywgJ3Viby1hYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQuanMnLCAnYWNpcy5qcycsICd1Ym8tYWNpcy5qcycsICd1Ym8tYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0JywgJ3Viby1hY2lzJywgJ2FicC1hYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQnXTtcbmFib3J0Q3VycmVudElubGluZVNjcmlwdC5pbmplY3Rpb25zID0gW3JhbmRvbUlkLCBzZXRQcm9wZXJ0eUFjY2VzcywgZ2V0UHJvcGVydHlJbkNoYWluLCB0b1JlZ0V4cCwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IHNldC1jb25zdGFudFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIGNvbnN0YW50IHByb3BlcnR5IGFuZCBhc3NpZ25zIGl0IG9uZSBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIHByZWRlZmluZWQgbGlzdC5cbiAqXG4gKiA+IEFjdHVhbGx5LCBpdCdzIG5vdCBhIGNvbnN0YW50LiBQbGVhc2Ugbm90ZSwgdGhhdCBpdCBjYW4gYmUgcmV3cml0dGVuIHdpdGggYSB2YWx1ZSBvZiBhIGRpZmZlcmVudCB0eXBlLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I3NldC1jb25zdGFudGpzLVxuICpcbiAqIFJlbGF0ZWQgQUJQIHNuaXBwZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWRibG9ja3BsdXMvYWRibG9ja3BsdXNjb3JlL2Jsb2IvYWRibG9ja3BsdXNjaHJvbWUtMy45LjQvbGliL2NvbnRlbnQvc25pcHBldHMuanMjTDEzNjFcbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb25zdGFudCcsIHByb3BlcnR5LCB2YWx1ZVssIHN0YWNrXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BlcnR5YCAtIHJlcXVpcmVkLCBwYXRoIHRvIGEgcHJvcGVydHkgKGpvaW5lZCB3aXRoIGAuYCBpZiBuZWVkZWQpLiBUaGUgcHJvcGVydHkgbXVzdCBiZSBhdHRhY2hlZCB0byBgd2luZG93YC5cbiAqIC0gYHZhbHVlYCAtIHJlcXVpcmVkLiBQb3NzaWJsZSB2YWx1ZXM6XG4gKiAgICAgLSBwb3NpdGl2ZSBkZWNpbWFsIGludGVnZXIgYDw9IDMyNzY3YFxuICogICAgIC0gb25lIG9mIHRoZSBwcmVkZWZpbmVkIGNvbnN0YW50czpcbiAqICAgICAgICAgLSBgdW5kZWZpbmVkYFxuICogICAgICAgICAtIGBmYWxzZWBcbiAqICAgICAgICAgLSBgdHJ1ZWBcbiAqICAgICAgICAgLSBgbnVsbGBcbiAqICAgICAgICAgLSBgZW1wdHlPYmpgIC0gZW1wdHkgb2JqZWN0XG4gKiAgICAgICAgIC0gYGVtcHR5QXJyYCAtIGVtcHR5IGFycmF5XG4gKiAgICAgICAgIC0gYG5vb3BGdW5jYCAtIGZ1bmN0aW9uIHdpdGggZW1wdHkgYm9keVxuICogICAgICAgICAtIGB0cnVlRnVuY2AgLSBmdW5jdGlvbiByZXR1cm5pbmcgdHJ1ZVxuICogICAgICAgICAtIGBmYWxzZUZ1bmNgIC0gZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlXG4gKiAgICAgICAgIC0gYCcnYCAtIGVtcHR5IHN0cmluZ1xuICogICAgICAgICAtIGAtMWAgLSBudW1iZXIgdmFsdWUgYC0xYFxuICogLSBgc3RhY2tgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtdXN0IG1hdGNoIHRoZSBjdXJyZW50IGZ1bmN0aW9uIGNhbGwgc3RhY2sgdHJhY2VcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogISB3aW5kb3cuZmlyc3RDb25zdCA9PT0gZmFsc2UgLy8gdGhpcyBjb21wYXJpc2lvbiB3aWxsIHJldHVybiBmYWxzZVxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvbnN0YW50JywgJ2ZpcnN0Q29uc3QnLCAnZmFsc2UnKVxuICpcbiAqICEgd2luZG93LnNlY29uZCgpID09PSB0cnVlRnVuYyAvLyAnc2Vjb25kJyBjYWxsIHdpbGwgcmV0dXJuIHRydWVcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb25zdGFudCcsICdzZWNvbmRDb25zdCcsICd0cnVlRnVuYycpXG4gKlxuICogISBkb2N1bWVudC50aGlyZCgpID09PSBmYWxzZUZ1bmMgIC8vICd0aGlyZCcgY2FsbCB3aWxsIHJldHVybiBmYWxzZSBpZiB0aGUgbWV0aG9kIGlzIHJlbGF0ZWQgdG8gY2hlY2tpbmcuanNcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb25zdGFudCcsICdzZWNvbmRDb25zdCcsICd0cnVlRnVuYycsICdjaGVja2luZy5qcycpXG4gKiBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gc2V0Q29uc3RhbnQoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YWNrKSB7XG4gIGlmICghcHJvcGVydHkgfHwgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVtcHR5QXJyID0gbm9vcEFycmF5KCk7XG4gIHZhciBlbXB0eU9iaiA9IG5vb3BPYmplY3QoKTtcbiAgdmFyIGNvbnN0YW50VmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICBjb25zdGFudFZhbHVlID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnbnVsbCcpIHtcbiAgICBjb25zdGFudFZhbHVlID0gbnVsbDtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2VtcHR5QXJyJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSBlbXB0eUFycjtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2VtcHR5T2JqJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSBlbXB0eU9iajtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ25vb3BGdW5jJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSBub29wRnVuYztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3RydWVGdW5jJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSB0cnVlRnVuYztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlRnVuYycpIHtcbiAgICBjb25zdGFudFZhbHVlID0gZmFsc2VGdW5jO1xuICB9IGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgY29uc3RhbnRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgaWYgKG5hdGl2ZUlzTmFOKGNvbnN0YW50VmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGNvbnN0YW50VmFsdWUpID4gMHg3RkZGKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLTEnKSB7XG4gICAgY29uc3RhbnRWYWx1ZSA9IC0xO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2FuY2VsZWQgPSBmYWxzZTtcblxuICB2YXIgbXVzdENhbmNlbCA9IGZ1bmN0aW9uIG11c3RDYW5jZWwodmFsdWUpIHtcbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBjYW5jZWxlZDtcbiAgICB9XG5cbiAgICBjYW5jZWxlZCA9IHZhbHVlICE9PSB1bmRlZmluZWQgJiYgY29uc3RhbnRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gdHlwZW9mIGNvbnN0YW50VmFsdWU7XG4gICAgcmV0dXJuIGNhbmNlbGVkO1xuICB9O1xuXG4gIHZhciBzZXRDaGFpblByb3BBY2Nlc3MgPSBmdW5jdGlvbiBzZXRDaGFpblByb3BBY2Nlc3Mob3duZXIsIHByb3BlcnR5KSB7XG4gICAgdmFyIGNoYWluSW5mbyA9IGdldFByb3BlcnR5SW5DaGFpbihvd25lciwgcHJvcGVydHkpO1xuICAgIHZhciBiYXNlID0gY2hhaW5JbmZvLmJhc2U7XG4gICAgdmFyIHByb3AgPSBjaGFpbkluZm8ucHJvcCxcbiAgICAgICAgY2hhaW4gPSBjaGFpbkluZm8uY2hhaW47IC8vIFRoZSBzY3JpcHRsZXQgbWlnaHQgYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBjaGFpbiBwcm9wZXJ0eSBoYXMgYmVlbiBjcmVhdGVkLlxuICAgIC8vIEluIHRoaXMgY2FzZSB3ZSdyZSBjaGVja2luZyB3aGV0aGVyIHRoZSBiYXNlIGVsZW1lbnQgZXhpc3RzIG9yIG5vdFxuICAgIC8vIGFuZCBpZiBub3QsIHdlIHNpbXBseSBleGl0IHdpdGhvdXQgb3ZlcnJpZGluZyBhbnl0aGluZ1xuXG4gICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBPYmplY3QgPT09IGZhbHNlICYmIGJhc2UgPT09IG51bGwpIHtcbiAgICAgIC8vIGxvZyB0aGUgcmVhc29uIG9ubHkgd2hpbGUgZGVidWdnaW5nXG4gICAgICBpZiAoc291cmNlLnZlcmJvc2UpIHtcbiAgICAgICAgdmFyIHByb3BzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIHByb3BJbmRleCA9IHByb3BzLmluZGV4T2YocHJvcCk7XG4gICAgICAgIHZhciBiYXNlTmFtZSA9IHByb3BzW3Byb3BJbmRleCAtIDFdO1xuICAgICAgICBjb25zb2xlLmxvZyhcInNldC1jb25zdGFudCBmYWlsZWQgYmVjYXVzZSB0aGUgcHJvcGVydHkgJ1wiLmNvbmNhdChiYXNlTmFtZSwgXCInIGRvZXMgbm90IGV4aXN0XCIpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2hhaW4pIHtcbiAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIoYSkge1xuICAgICAgICBiYXNlID0gYTtcblxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHNldENoYWluUHJvcEFjY2VzcyhhLCBjaGFpbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgcHJvcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtdXN0Q2FuY2VsKGJhc2VbcHJvcF0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGl0KHNvdXJjZSk7XG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGEpIHtcbiAgICAgICAgaWYgKG11c3RDYW5jZWwoYSkpIHtcbiAgICAgICAgICBjb25zdGFudFZhbHVlID0gYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbn1cbnNldENvbnN0YW50Lm5hbWVzID0gWydzZXQtY29uc3RhbnQnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nc2V0LWNvbnN0YW50LmpzJywgJ3Viby1zZXQtY29uc3RhbnQuanMnLCAnc2V0LmpzJywgJ3Viby1zZXQuanMnLCAndWJvLXNldC1jb25zdGFudCcsICd1Ym8tc2V0JywgJ2FicC1vdmVycmlkZS1wcm9wZXJ0eS1yZWFkJ107XG5zZXRDb25zdGFudC5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEFycmF5LCBub29wT2JqZWN0LCBub29wRnVuYywgdHJ1ZUZ1bmMsIGZhbHNlRnVuYywgZ2V0UHJvcGVydHlJbkNoYWluLCBzZXRQcm9wZXJ0eUFjY2VzcywgdG9SZWdFeHAsIG1hdGNoU3RhY2tUcmFjZSwgbmF0aXZlSXNOYU5dO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCByZW1vdmUtY29va2llXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZW1vdmVzIGN1cnJlbnQgcGFnZSBjb29raWVzIGJ5IHBhc3NlZCBzdHJpbmcgbWF0Y2hpbmcgd2l0aCBuYW1lLiBGb3IgY3VycmVudCBkb21haW4gYW5kIHN1YmRvbWFpbnMuIFJ1bnMgb24gbG9hZCBhbmQgYmVmb3JlIHVubG9hZC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNjb29raWUtcmVtb3ZlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWNvb2tpZSdbLCBtYXRjaF0pXG4gKiBgYGBcbiAqXG4gKiAtIGBtYXRjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ2V4IG1hdGNoaW5nIHRoZSBjb29raWUgbmFtZS4gSWYgbm90IHNwZWNpZmllZCBhbGwgYWNjZXNzaWJsZSBjb29raWVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIFJlbW92ZXMgYWxsIGNvb2tpZXM6XG4gKiBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtY29va2llJylcbiAqIGBgYFxuICpcbiAqIDIuIFJlbW92ZXMgY29va2llcyB3aGljaCBuYW1lIGNvbnRhaW5zIGBleGFtcGxlYCBzdHJpbmcuXG4gKiBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtY29va2llJywgJ2V4YW1wbGUnKVxuICogYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSB0aGlzIGNvb2tpZSB3aWxsIGJlIHJlbW92ZWRcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgZG9jdW1lbnQuY29va2llID0gJ19fZXhhbXBsZT1yYW5kb21WYWx1ZSc7XG4gKiAgICAgYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUNvb2tpZShzb3VyY2UsIG1hdGNoKSB7XG4gIHZhciBtYXRjaFJlZ2V4cCA9IHRvUmVnRXhwKG1hdGNoKTtcblxuICB2YXIgcmVtb3ZlQ29va2llRnJvbUhvc3QgPSBmdW5jdGlvbiByZW1vdmVDb29raWVGcm9tSG9zdChjb29raWVOYW1lLCBob3N0TmFtZSkge1xuICAgIHZhciBjb29raWVTcGVjID0gXCJcIi5jb25jYXQoY29va2llTmFtZSwgXCI9XCIpO1xuICAgIHZhciBkb21haW4xID0gXCI7IGRvbWFpbj1cIi5jb25jYXQoaG9zdE5hbWUpO1xuICAgIHZhciBkb21haW4yID0gXCI7IGRvbWFpbj0uXCIuY29uY2F0KGhvc3ROYW1lKTtcbiAgICB2YXIgcGF0aCA9ICc7IHBhdGg9Lyc7XG4gICAgdmFyIGV4cGlyYXRpb24gPSAnOyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UJztcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVTcGVjICsgZXhwaXJhdGlvbjtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVTcGVjICsgZG9tYWluMSArIGV4cGlyYXRpb247XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llU3BlYyArIGRvbWFpbjIgKyBleHBpcmF0aW9uO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZVNwZWMgKyBwYXRoICsgZXhwaXJhdGlvbjtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVTcGVjICsgZG9tYWluMSArIHBhdGggKyBleHBpcmF0aW9uO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZVNwZWMgKyBkb21haW4yICsgcGF0aCArIGV4cGlyYXRpb247XG4gICAgaGl0KHNvdXJjZSk7XG4gIH07XG5cbiAgdmFyIHJtQ29va2llID0gZnVuY3Rpb24gcm1Db29raWUoKSB7XG4gICAgZG9jdW1lbnQuY29va2llLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoY29va2llU3RyKSB7XG4gICAgICB2YXIgcG9zID0gY29va2llU3RyLmluZGV4T2YoJz0nKTtcblxuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29va2llTmFtZSA9IGNvb2tpZVN0ci5zbGljZSgwLCBwb3MpLnRyaW0oKTtcblxuICAgICAgaWYgKCFtYXRjaFJlZ2V4cC50ZXN0KGNvb2tpZU5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvc3RQYXJ0cyA9IGRvY3VtZW50LmxvY2F0aW9uLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGhvc3RQYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGhvc3ROYW1lID0gaG9zdFBhcnRzLnNsaWNlKGkpLmpvaW4oJy4nKTtcblxuICAgICAgICBpZiAoaG9zdE5hbWUpIHtcbiAgICAgICAgICByZW1vdmVDb29raWVGcm9tSG9zdChjb29raWVOYW1lLCBob3N0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBybUNvb2tpZSgpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgcm1Db29raWUpO1xufVxucmVtb3ZlQ29va2llLm5hbWVzID0gWydyZW1vdmUtY29va2llJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2Nvb2tpZS1yZW1vdmVyLmpzJywgJ3Viby1jb29raWUtcmVtb3Zlci5qcycsICd1Ym8tY29va2llLXJlbW92ZXInXTtcbnJlbW92ZUNvb2tpZS5pbmplY3Rpb25zID0gW3RvUmVnRXhwLCBoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGFkZGluZyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBjYWxsYmFja3MuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjYWRkZXZlbnRsaXN0ZW5lci1kZWZ1c2VyanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXInWywgZXZlbnRTZWFyY2hbLCBmdW5jdGlvblNlYXJjaF1dKVxuICogYGBgXG4gKlxuICogLSBgZXZlbnRTZWFyY2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWdleCBtYXRjaGluZyB0aGUgZXZlbnQgbmFtZS4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHNjcmlwdGxldHMgcHJldmVudHMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICogLSBgZnVuY3Rpb25TZWFyY2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWdleCBtYXRjaGluZyB0aGUgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gYm9keS4gSWYgbm90IHNldCwgdGhlIHNjcmlwdGxldCBwcmV2ZW50cyBhbGwgZXZlbnQgbGlzdGVuZXJzIHdpdGggZXZlbnQgbmFtZSBtYXRjaGluZyBgZXZlbnRTZWFyY2hgXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBQcmV2ZW50IGFsbCBgY2xpY2tgIGxpc3RlbmVyczpcbiAqIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtYWRkRXZlbnRMaXN0ZW5lcicsICdjbGljaycpXG4gKiBgYGBcblxuMi4gUHJldmVudCAnY2xpY2snIGxpc3RlbmVycyB3aXRoIHRoZSBjYWxsYmFjayBib2R5IGNvbnRhaW5pbmcgYHNlYXJjaFN0cmluZ2AuXG4gKiBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXInLCAnY2xpY2snLCAnc2VhcmNoU3RyaW5nJylcbiAqIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoaXMgbGlzdGVuZXIgd2lsbCBub3QgYmUgY2FsbGVkOlxuICogYGBgamF2YXNjcmlwdFxuICogICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9ICdzZWFyY2hTdHJpbmcnO1xuICogICAgIH0pO1xuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRBZGRFdmVudExpc3RlbmVyKHNvdXJjZSwgZXZlbnRTZWFyY2gsIGZ1bmNTZWFyY2gpIHtcbiAgdmFyIGV2ZW50U2VhcmNoUmVnZXhwID0gdG9SZWdFeHAoZXZlbnRTZWFyY2gpO1xuICB2YXIgZnVuY1NlYXJjaFJlZ2V4cCA9IHRvUmVnRXhwKGZ1bmNTZWFyY2gpO1xuICB2YXIgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblxuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyV3JhcHBlcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG5cbiAgICBpZiAodmFsaWRhdGVUeXBlKHR5cGUpICYmIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gZXZlbnRTZWFyY2hSZWdleHAudGVzdCh0eXBlLnRvU3RyaW5nKCkpICYmIGZ1bmNTZWFyY2hSZWdleHAudGVzdChsaXN0ZW5lclRvU3RyaW5nKGxpc3RlbmVyKSk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbdHlwZSwgbGlzdGVuZXJdLmNvbmNhdChhcmdzKSk7XG4gIH1cblxuICB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyV3JhcHBlcjtcbn1cbnByZXZlbnRBZGRFdmVudExpc3RlbmVyLm5hbWVzID0gWydwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXInLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nYWRkRXZlbnRMaXN0ZW5lci1kZWZ1c2VyLmpzJywgJ3Viby1hZGRFdmVudExpc3RlbmVyLWRlZnVzZXIuanMnLCAnYWVsZC5qcycsICd1Ym8tYWVsZC5qcycsICd1Ym8tYWRkRXZlbnRMaXN0ZW5lci1kZWZ1c2VyJywgJ3Viby1hZWxkJ107XG5wcmV2ZW50QWRkRXZlbnRMaXN0ZW5lci5pbmplY3Rpb25zID0gW2hpdCwgdG9SZWdFeHAsIHZhbGlkYXRlVHlwZSwgdmFsaWRhdGVMaXN0ZW5lciwgbGlzdGVuZXJUb1N0cmluZ107XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuLCBuby1ldmFsICovXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1iYWJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIEJsb2NrQWRibG9jayBzY3JpcHQgZnJvbSBkZXRlY3RpbmcgYW4gYWQgYmxvY2tlci5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNiYWItZGVmdXNlcmpzLVxuICpcbiAqIEl0IGFsc28gY2FuIGJlIHVzZWQgYXMgYCRyZWRpcmVjdGAgc29tZXRpbWVzLlxuICogU2VlIFtyZWRpcmVjdCBkZXNjcmlwdGlvbl0oLi4vd2lraS9hYm91dC1yZWRpcmVjdHMubWQjcHJldmVudC1iYWIpLlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1iYWInKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcHJldmVudEJhYihzb3VyY2UpIHtcbiAgdmFyIG5hdGl2ZVNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcbiAgdmFyIGJhYlJlZ2V4ID0gL1xcLmJhYl9lbGVtZW50aWQuJC87XG5cbiAgdmFyIHRpbWVvdXRXcmFwcGVyID0gZnVuY3Rpb24gdGltZW91dFdyYXBwZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnc3RyaW5nJyB8fCAhYmFiUmVnZXgudGVzdChjYWxsYmFjaykpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVTZXRUaW1lb3V0LmFwcGx5KHdpbmRvdywgW2NhbGxiYWNrXS5jb25jYXQoYXJncykpO1xuICAgIH1cblxuICAgIGhpdChzb3VyY2UpO1xuICB9O1xuXG4gIHdpbmRvdy5zZXRUaW1lb3V0ID0gdGltZW91dFdyYXBwZXI7XG4gIHZhciBzaWduYXR1cmVzID0gW1snYmxvY2thZGJsb2NrJ10sIFsnYmFiYXNibSddLCBbL2dldEl0ZW1cXCgnYmFibidcXCkvXSwgWydnZXRFbGVtZW50QnlJZCcsICdTdHJpbmcuZnJvbUNoYXJDb2RlJywgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JywgJ2NoYXJBdCcsICdET01Db250ZW50TG9hZGVkJywgJ0FkQmxvY2snLCAnYWRkRXZlbnRMaXN0ZW5lcicsICdkb1Njcm9sbCcsICdmcm9tQ2hhckNvZGUnLCAnPDwyfHI+PjQnLCAnc2Vzc2lvblN0b3JhZ2UnLCAnY2xpZW50V2lkdGgnLCAnbG9jYWxTdG9yYWdlJywgJ01hdGgnLCAncmFuZG9tJ11dO1xuXG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKHN0cikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIHRva2VucyA9IHNpZ25hdHVyZXNbaV07XG4gICAgICB2YXIgbWF0Y2ggPSAwO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbal07XG4gICAgICAgIHZhciBmb3VuZCA9IHRva2VuIGluc3RhbmNlb2YgUmVnRXhwID8gdG9rZW4udGVzdChzdHIpIDogc3RyLmluZGV4T2YodG9rZW4pID4gLTE7XG5cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgbWF0Y2ggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggLyB0b2tlbnMubGVuZ3RoID49IDAuOCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdmFyIG5hdGl2ZUV2YWwgPSB3aW5kb3cuZXZhbDtcblxuICB2YXIgZXZhbFdyYXBwZXIgPSBmdW5jdGlvbiBldmFsV3JhcHBlcihzdHIpIHtcbiAgICBpZiAoIWNoZWNrKHN0cikpIHtcbiAgICAgIHJldHVybiBuYXRpdmVFdmFsKHN0cik7XG4gICAgfVxuXG4gICAgaGl0KHNvdXJjZSk7XG4gICAgdmFyIGJvZHlFbCA9IGRvY3VtZW50LmJvZHk7XG5cbiAgICBpZiAoYm9keUVsKSB7XG4gICAgICBib2R5RWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ3Zpc2liaWxpdHknKTtcbiAgICB9XG5cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFiYXNibXNneCcpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG4gIH07XG5cbiAgd2luZG93LmV2YWwgPSBldmFsV3JhcHBlci5iaW5kKHdpbmRvdyk7XG59XG5wcmV2ZW50QmFiLm5hbWVzID0gWydwcmV2ZW50LWJhYicsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidub2JhYi5qcycsICd1Ym8tbm9iYWIuanMnLCAnYmFiLWRlZnVzZXIuanMnLCAndWJvLWJhYi1kZWZ1c2VyLmpzJywgJ3Viby1ub2JhYicsICd1Ym8tYmFiLWRlZnVzZXInXTtcbnByZXZlbnRCYWIuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tZXh0cmEtYmluZCwgZnVuYy1uYW1lcyAqL1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgbm93ZWJydGNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERpc2FibGVzIFdlYlJUQyBieSBvdmVycmlkaW5nIGBSVENQZWVyQ29ubmVjdGlvbmAuIFRoZSBvdmVycmlkZW4gZnVuY3Rpb24gd2lsbCBsb2cgZXZlcnkgYXR0ZW1wdCB0byBjcmVhdGUgYSBuZXcgY29ubmVjdGlvbi5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNub3dlYnJ0Y2pzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnbm93ZWJydGMnKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIG5vd2VicnRjKHNvdXJjZSkge1xuICB2YXIgcHJvcGVydHlOYW1lID0gJyc7XG5cbiAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHByb3BlcnR5TmFtZSA9ICdSVENQZWVyQ29ubmVjdGlvbic7XG4gIH0gZWxzZSBpZiAod2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcHJvcGVydHlOYW1lID0gJ3dlYmtpdFJUQ1BlZXJDb25uZWN0aW9uJztcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eU5hbWUgPT09ICcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJ0Y1JlcGxhY2VtZW50ID0gZnVuY3Rpb24gcnRjUmVwbGFjZW1lbnQoY29uZmlnKSB7XG4gICAgaGl0KHNvdXJjZSwgXCJEb2N1bWVudCB0cmllZCB0byBjcmVhdGUgYW4gUlRDUGVlckNvbm5lY3Rpb246IFwiLmNvbmNhdChjb252ZXJ0UnRjQ29uZmlnVG9TdHJpbmcoY29uZmlnKSkpO1xuICB9O1xuXG4gIHJ0Y1JlcGxhY2VtZW50LnByb3RvdHlwZSA9IHtcbiAgICBjbG9zZTogbm9vcEZ1bmMsXG4gICAgY3JlYXRlRGF0YUNoYW5uZWw6IG5vb3BGdW5jLFxuICAgIGNyZWF0ZU9mZmVyOiBub29wRnVuYyxcbiAgICBzZXRSZW1vdGVEZXNjcmlwdGlvbjogbm9vcEZ1bmNcbiAgfTtcbiAgdmFyIHJ0YyA9IHdpbmRvd1twcm9wZXJ0eU5hbWVdO1xuICB3aW5kb3dbcHJvcGVydHlOYW1lXSA9IHJ0Y1JlcGxhY2VtZW50O1xuXG4gIGlmIChydGMucHJvdG90eXBlKSB7XG4gICAgcnRjLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZTogbm9vcEZ1bmMsXG4gICAgICAgIHNlbmQ6IG5vb3BGdW5jXG4gICAgICB9O1xuICAgIH0uYmluZChudWxsKTtcbiAgfVxufVxubm93ZWJydGMubmFtZXMgPSBbJ25vd2VicnRjJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25vd2VicnRjLmpzJywgJ3Viby1ub3dlYnJ0Yy5qcycsICd1Ym8tbm93ZWJydGMnXTtcbm5vd2VicnRjLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IGxvZy1hZGRFdmVudExpc3RlbmVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBMb2dzIGFsbCBhZGRFdmVudExpc3RlbmVyIGNhbGxzIHRvIHRoZSBjb25zb2xlLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2FkZGV2ZW50bGlzdGVuZXItbG9nZ2VyanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdsb2ctYWRkRXZlbnRMaXN0ZW5lcicpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBsb2dBZGRFdmVudExpc3RlbmVyKHNvdXJjZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICB2YXIgbG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgdmFyIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcldyYXBwZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodmFsaWRhdGVUeXBlKHR5cGUpICYmIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpKSB7XG4gICAgICB2YXIgbG9nTWVzc2FnZSA9IFwibG9nOiBhZGRFdmVudExpc3RlbmVyKFxcXCJcIi5jb25jYXQodHlwZSwgXCJcXFwiLCBcIikuY29uY2F0KGxpc3RlbmVyVG9TdHJpbmcobGlzdGVuZXIpLCBcIilcIik7XG4gICAgICBoaXQoc291cmNlLCBsb2dNZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZS52ZXJib3NlKSB7XG4gICAgICAvLyBsb2dnaW5nIHdoaWxlIGRlYnVnZ2luZ1xuICAgICAgdmFyIF9sb2dNZXNzYWdlID0gXCJJbnZhbGlkIGV2ZW50IHR5cGUgb3IgbGlzdGVuZXIgcGFzc2VkIHRvIGFkZEV2ZW50TGlzdGVuZXI6XFxudHlwZTogXCIuY29uY2F0KGNvbnZlcnRUeXBlVG9TdHJpbmcodHlwZSksIFwiXFxubGlzdGVuZXI6IFwiKS5jb25jYXQoY29udmVydFR5cGVUb1N0cmluZyhsaXN0ZW5lcikpO1xuXG4gICAgICBsb2coX2xvZ01lc3NhZ2UpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFt0eXBlLCBsaXN0ZW5lcl0uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG4gIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXJXcmFwcGVyO1xufVxubG9nQWRkRXZlbnRMaXN0ZW5lci5uYW1lcyA9IFsnbG9nLWFkZEV2ZW50TGlzdGVuZXInLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nYWRkRXZlbnRMaXN0ZW5lci1sb2dnZXIuanMnLCAndWJvLWFkZEV2ZW50TGlzdGVuZXItbG9nZ2VyLmpzJywgJ2FlbGwuanMnLCAndWJvLWFlbGwuanMnLCAndWJvLWFkZEV2ZW50TGlzdGVuZXItbG9nZ2VyJywgJ3Viby1hZWxsJ107XG5sb2dBZGRFdmVudExpc3RlbmVyLmluamVjdGlvbnMgPSBbaGl0LCB2YWxpZGF0ZVR5cGUsIHZhbGlkYXRlTGlzdGVuZXIsIGxpc3RlbmVyVG9TdHJpbmcsIGNvbnZlcnRUeXBlVG9TdHJpbmcsIG9iamVjdFRvU3RyaW5nLCBpc0VtcHR5T2JqZWN0LCBnZXRPYmplY3RFbnRyaWVzXTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSwgbm8tZXZhbCAqL1xuLyoqXG4gKiBAc2NyaXB0bGV0IGxvZy1ldmFsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBMb2dzIGFsbCBgZXZhbCgpYCBvciBgbmV3IEZ1bmN0aW9uKClgIGNhbGxzIHRvIHRoZSBjb25zb2xlLlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnbG9nLWV2YWwnKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gbG9nRXZhbChzb3VyY2UpIHtcbiAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7IC8vIHdyYXAgZXZhbCBmdW5jdGlvblxuXG4gIHZhciBuYXRpdmVFdmFsID0gd2luZG93LmV2YWw7XG5cbiAgZnVuY3Rpb24gZXZhbFdyYXBwZXIoc3RyKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgbG9nKFwiZXZhbChcXFwiXCIuY29uY2F0KHN0ciwgXCJcXFwiKVwiKSk7XG4gICAgcmV0dXJuIG5hdGl2ZUV2YWwoc3RyKTtcbiAgfVxuXG4gIHdpbmRvdy5ldmFsID0gZXZhbFdyYXBwZXI7IC8vIHdyYXAgbmV3IEZ1bmN0aW9uXG5cbiAgdmFyIG5hdGl2ZUZ1bmN0aW9uID0gd2luZG93LkZ1bmN0aW9uO1xuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uV3JhcHBlcigpIHtcbiAgICBoaXQoc291cmNlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsb2coXCJuZXcgRnVuY3Rpb24oXCIuY29uY2F0KGFyZ3Muam9pbignLCAnKSwgXCIpXCIpKTtcbiAgICByZXR1cm4gbmF0aXZlRnVuY3Rpb24uYXBwbHkodGhpcywgW10uY29uY2F0KGFyZ3MpKTtcbiAgfVxuXG4gIEZ1bmN0aW9uV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hdGl2ZUZ1bmN0aW9uLnByb3RvdHlwZSk7XG4gIEZ1bmN0aW9uV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGdW5jdGlvbldyYXBwZXI7XG4gIHdpbmRvdy5GdW5jdGlvbiA9IEZ1bmN0aW9uV3JhcHBlcjtcbn1cbmxvZ0V2YWwubmFtZXMgPSBbJ2xvZy1ldmFsJ107XG5sb2dFdmFsLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IGxvZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBzaW1wbGUgc2NyaXB0bGV0IHdoaWNoIG9ubHkgcHVycG9zZSBpcyB0byBwcmludCBhcmd1bWVudHMgdG8gY29uc29sZS5cbiAqIFRoaXMgc2NyaXB0bGV0IGNhbiBiZSBoZWxwZnVsIGZvciBkZWJ1Z2dpbmcgYW5kIHRyb3VibGVzaG9vdGluZyBvdGhlciBzY3JpcHRsZXRzLlxuICpcbiAqICoqRXhhbXBsZSoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2xvZycsICdhcmcxJywgJ2FyZzInKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKGFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cbmxvZy5uYW1lcyA9IFsnbG9nJ107XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWV2YWwsIG5vLWV4dHJhLWJpbmQgKi9cbi8qKlxuICogQHNjcmlwdGxldCBub2V2YWxcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIHBhZ2UgdG8gdXNlIGV2YWwuXG4gKiBOb3RpZmllcyBhYm91dCBhdHRlbXB0cyBpbiB0aGUgY29uc29sZVxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vZXZhbGpzLVxuICpcbiAqIEl0IGFsc28gY2FuIGJlIHVzZWQgYXMgYCRyZWRpcmVjdGAgcnVsZXMgc29tZXRpbWVzLlxuICogU2VlIFtyZWRpcmVjdCBkZXNjcmlwdGlvbl0oLi4vd2lraS9hYm91dC1yZWRpcmVjdHMubWQjbm9ldmFsKS5cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ25vZXZhbCcpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBub2V2YWwoc291cmNlKSB7XG4gIHdpbmRvdy5ldmFsID0gZnVuY3Rpb24gZXZhbFdyYXBwZXIocykge1xuICAgIGhpdChzb3VyY2UsIFwiQWRHdWFyZCBoYXMgcHJldmVudGVkIGV2YWw6XFxuXCIuY29uY2F0KHMpKTtcbiAgfS5iaW5kKCk7XG59XG5ub2V2YWwubmFtZXMgPSBbJ25vZXZhbCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidub2V2YWwuanMnLCAnc2lsZW50LW5vZXZhbC5qcycsICd1Ym8tbm9ldmFsLmpzJywgJ3Viby1zaWxlbnQtbm9ldmFsLmpzJywgJ3Viby1ub2V2YWwnLCAndWJvLXNpbGVudC1ub2V2YWwnXTtcbm5vZXZhbC5pbmplY3Rpb25zID0gW2hpdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWV2YWwsIG5vLWV4dHJhLWJpbmQsIGZ1bmMtbmFtZXMgKi9cbi8qKlxuICogQHNjcmlwdGxldCBwcmV2ZW50LWV2YWwtaWZcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIHBhZ2UgdG8gdXNlIGV2YWwgbWF0Y2hpbmcgcGF5bG9hZC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNub2V2YWwtaWZqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZXZhbC1pZidbLCBzZWFyY2hdKVxuICogYGBgXG4gKlxuICogLSBgc2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVnZXhwIGZvciBtYXRjaGluZyBzdHJpbmdpZmllZCBldmFsIHBheWxvYWQuXG4gKiBJZiAnc2VhcmNoIGlzIG5vdCBzcGVjaWZpZWQg4oCUIGFsbCBzdHJpbmdpZmllZCBldmFsIHBheWxvYWQgd2lsbCBiZSBtYXRjaGVkXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiBgYGBcbiAqICEgUHJldmVudHMgZXZhbCBpZiBpdCBtYXRjaGVzICd0ZXN0J1xuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1ldmFsLWlmJywgJ3Rlc3QnKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBbc2VhcmNoXSBzdHJpbmcgb3IgcmVnZXhwIG1hdGNoaW5nIHN0cmluZ2lmaWVkIGV2YWwgcGF5bG9hZFxuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRFdmFsSWYoc291cmNlLCBzZWFyY2gpIHtcbiAgdmFyIHNlYXJjaFJlZ2V4cCA9IHRvUmVnRXhwKHNlYXJjaCk7XG4gIHZhciBuYXRpdmVFdmFsID0gd2luZG93LmV2YWw7XG5cbiAgd2luZG93LmV2YWwgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgIGlmICghc2VhcmNoUmVnZXhwLnRlc3QocGF5bG9hZC50b1N0cmluZygpKSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUV2YWwuY2FsbCh3aW5kb3csIHBheWxvYWQpO1xuICAgIH1cblxuICAgIGhpdChzb3VyY2UsIHBheWxvYWQpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0uYmluZCh3aW5kb3cpO1xufVxucHJldmVudEV2YWxJZi5uYW1lcyA9IFsncHJldmVudC1ldmFsLWlmJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25vZXZhbC1pZi5qcycsICd1Ym8tbm9ldmFsLWlmLmpzJywgJ3Viby1ub2V2YWwtaWYnXTtcbnByZXZlbnRFdmFsSWYuaW5qZWN0aW9ucyA9IFt0b1JlZ0V4cCwgaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSwgZnVuYy1uYW1lcywgbm8tbXVsdGktYXNzaWduICovXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1mYWItMy4yLjBcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGV4ZWN1dGlvbiBvZiB0aGUgRkFCIHNjcmlwdCB2My4yLjAuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjZnVja2FkYmxvY2tqcy0zMjAtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWZhYi0zLjIuMCcpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50RmFiKHNvdXJjZSkge1xuICBoaXQoc291cmNlKTsgLy8gcmVkZWZpbmVzIEZhYiBmdW5jdGlvbiBmb3IgYWRibG9jayBkZXRlY3Rpb25cblxuICB2YXIgRmFiID0gZnVuY3Rpb24gRmFiKCkge307XG5cbiAgRmFiLnByb3RvdHlwZS5jaGVjayA9IG5vb3BGdW5jO1xuICBGYWIucHJvdG90eXBlLmNsZWFyRXZlbnQgPSBub29wRnVuYztcbiAgRmFiLnByb3RvdHlwZS5lbWl0RXZlbnQgPSBub29wRnVuYztcblxuICBGYWIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoIWEpIHtcbiAgICAgIGIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBGYWIucHJvdG90eXBlLm9uRGV0ZWN0ZWQgPSBub29wVGhpcztcblxuICBGYWIucHJvdG90eXBlLm9uTm90RGV0ZWN0ZWQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGEoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBGYWIucHJvdG90eXBlLnNldE9wdGlvbiA9IG5vb3BGdW5jO1xuICBGYWIucHJvdG90eXBlLm9wdGlvbnMgPSB7XG4gICAgc2V0OiBub29wRnVuYyxcbiAgICBnZXQ6IG5vb3BGdW5jXG4gIH07XG4gIHZhciBmYWIgPSBuZXcgRmFiKCk7XG4gIHZhciBnZXRTZXRGYWIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gRmFiO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7fVxuICB9O1xuICB2YXIgZ2V0c2V0ZmFiID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZhYjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KCkge31cbiAgfTsgLy8gcmVkZWZpbmVkIEZhYiBkYXRhIHByb3BlcnRpZXMgd2hpY2ggaWYgJ0Z1Y2tBZEJsb2NrJyB2YXJpYWJsZSBleGlzdHNcblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdpbmRvdywgJ0Z1Y2tBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuRnVja0FkQmxvY2sgPSBGYWI7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3IgcmVkZWZpbmVkIEZhYiBhY2Nlc3NvciBwcm9wZXJ0aWVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ0Z1Y2tBZEJsb2NrJywgZ2V0U2V0RmFiKTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2luZG93LCAnQmxvY2tBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuQmxvY2tBZEJsb2NrID0gRmFiO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdCbG9ja0FkQmxvY2snLCBnZXRTZXRGYWIpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3aW5kb3csICdTbmlmZkFkQmxvY2snKSkge1xuICAgIHdpbmRvdy5TbmlmZkFkQmxvY2sgPSBGYWI7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ1NuaWZmQWRCbG9jaycsIGdldFNldEZhYik7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdpbmRvdywgJ2Z1Y2tBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuZnVja0FkQmxvY2sgPSBmYWI7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2Z1Y2tBZEJsb2NrJywgZ2V0c2V0ZmFiKTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2luZG93LCAnYmxvY2tBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuYmxvY2tBZEJsb2NrID0gZmFiO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdibG9ja0FkQmxvY2snLCBnZXRzZXRmYWIpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3aW5kb3csICdzbmlmZkFkQmxvY2snKSkge1xuICAgIHdpbmRvdy5zbmlmZkFkQmxvY2sgPSBmYWI7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ3NuaWZmQWRCbG9jaycsIGdldHNldGZhYik7XG4gIH1cbn1cbnByZXZlbnRGYWIubmFtZXMgPSBbJ3ByZXZlbnQtZmFiLTMuMi4wJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25vZmFiLmpzJywgJ3Viby1ub2ZhYi5qcycsICdmdWNrYWRibG9jay5qcy0zLjIuMCcsICd1Ym8tZnVja2FkYmxvY2suanMtMy4yLjAnLCAndWJvLW5vZmFiJ107XG5wcmV2ZW50RmFiLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgbm9vcFRoaXNdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlLCBmdW5jLW5hbWVzLCBuby1tdWx0aS1hc3NpZ24gKi9cbi8qKlxuICogQHNjcmlwdGxldCBzZXQtcG9wYWRzLWR1bW15XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXRzIHN0YXRpYyBwcm9wZXJ0aWVzIFBvcEFkcyBhbmQgcG9wbnMuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjcG9wYWRzLWR1bW15anMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtcG9wYWRzLWR1bW15JylcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHNldFBvcGFkc0R1bW15KHNvdXJjZSkge1xuICBkZWxldGUgd2luZG93LlBvcEFkcztcbiAgZGVsZXRlIHdpbmRvdy5wb3BucztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod2luZG93LCB7XG4gICAgUG9wQWRzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBvcG5zOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuc2V0UG9wYWRzRHVtbXkubmFtZXMgPSBbJ3NldC1wb3BhZHMtZHVtbXknLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4ncG9wYWRzLWR1bW15LmpzJywgJ3Viby1wb3BhZHMtZHVtbXkuanMnLCAndWJvLXBvcGFkcy1kdW1teSddO1xuc2V0UG9wYWRzRHVtbXkuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1wb3BhZHMtbmV0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBYm9ydHMgb24gcHJvcGVydHkgd3JpdGUgKFBvcEFkcywgcG9wbnMpLCB0aHJvd3MgcmVmZXJlbmNlIGVycm9yIHdpdGggcmFuZG9tIGlkLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I3BvcGFkc25ldGpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1wb3BhZHMtbmV0JylcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRQb3BhZHNOZXQoc291cmNlKSB7XG4gIHZhciByaWQgPSByYW5kb21JZCgpO1xuXG4gIHZhciB0aHJvd0Vycm9yID0gZnVuY3Rpb24gdGhyb3dFcnJvcigpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IocmlkKTtcbiAgfTtcblxuICBkZWxldGUgd2luZG93LlBvcEFkcztcbiAgZGVsZXRlIHdpbmRvdy5wb3BucztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod2luZG93LCB7XG4gICAgUG9wQWRzOiB7XG4gICAgICBzZXQ6IHRocm93RXJyb3JcbiAgICB9LFxuICAgIHBvcG5zOiB7XG4gICAgICBzZXQ6IHRocm93RXJyb3JcbiAgICB9XG4gIH0pO1xuICB3aW5kb3cub25lcnJvciA9IGNyZWF0ZU9uRXJyb3JIYW5kbGVyKHJpZCkuYmluZCgpO1xuICBoaXQoc291cmNlKTtcbn1cbnByZXZlbnRQb3BhZHNOZXQubmFtZXMgPSBbJ3ByZXZlbnQtcG9wYWRzLW5ldCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidwb3BhZHMubmV0LmpzJywgJ3Viby1wb3BhZHMubmV0LmpzJywgJ3Viby1wb3BhZHMubmV0J107XG5wcmV2ZW50UG9wYWRzTmV0LmluamVjdGlvbnMgPSBbY3JlYXRlT25FcnJvckhhbmRsZXIsIHJhbmRvbUlkLCBoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmdW5jLW5hbWVzICovXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1hZGZseVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgYW50aS1hZGJsb2NrIHNjcmlwdHMgb24gYWRmbHkgc2hvcnQgbGlua3MuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjYWRmbHktZGVmdXNlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1hZGZseScpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50QWRmbHkoc291cmNlKSB7XG4gIHZhciBpc0RpZ2l0ID0gZnVuY3Rpb24gaXNEaWdpdChkYXRhKSB7XG4gICAgcmV0dXJuIC9eXFxkJC8udGVzdChkYXRhKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZW5jb2RlZFVSTCkge1xuICAgIHZhciBldmVuQ2hhcnMgPSAnJztcbiAgICB2YXIgb2RkQ2hhcnMgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgIGV2ZW5DaGFycyArPSBlbmNvZGVkVVJMLmNoYXJBdChpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9kZENoYXJzID0gZW5jb2RlZFVSTC5jaGFyQXQoaSkgKyBvZGRDaGFycztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IChldmVuQ2hhcnMgKyBvZGRDaGFycykuc3BsaXQoJycpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRhdGEubGVuZ3RoOyBfaSArPSAxKSB7XG4gICAgICBpZiAoaXNEaWdpdChkYXRhW19pXSkpIHtcbiAgICAgICAgZm9yICh2YXIgaWkgPSBfaSArIDE7IGlpIDwgZGF0YS5sZW5ndGg7IGlpICs9IDEpIHtcbiAgICAgICAgICBpZiAoaXNEaWdpdChkYXRhW2lpXSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB2YXIgdGVtcCA9IHBhcnNlSW50KGRhdGFbX2ldLCAxMCkgXiBwYXJzZUludChkYXRhW2lpXSwgMTApO1xuXG4gICAgICAgICAgICBpZiAodGVtcCA8IDEwKSB7XG4gICAgICAgICAgICAgIGRhdGFbX2ldID0gdGVtcC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaSA9IGlpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEuam9pbignJyk7XG4gICAgdmFyIGRlY29kZWRVUkwgPSB3aW5kb3cuYXRvYihkYXRhKS5zbGljZSgxNiwgLTE2KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wYXQvY29tcGF0ICovXG5cbiAgICBpZiAod2luZG93LnN0b3ApIHtcbiAgICAgIHdpbmRvdy5zdG9wKCk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgY29tcGF0L2NvbXBhdCAqL1xuXG5cbiAgICB3aW5kb3cub25iZWZvcmV1bmxvYWQgPSBudWxsO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVjb2RlZFVSTDtcbiAgfTtcblxuICB2YXIgdmFsOyAvLyBEbyBub3QgYXBwbHkgaGFuZGxlciBtb3JlIHRoYW4gb25lIHRpbWVcblxuICB2YXIgYXBwbHlIYW5kbGVyID0gdHJ1ZTtcbiAgdmFyIHJlc3VsdCA9IHNldFByb3BlcnR5QWNjZXNzKHdpbmRvdywgJ3lzbW0nLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKGFwcGx5SGFuZGxlcikge1xuICAgICAgICBhcHBseUhhbmRsZXIgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXG4gICAgICB9XG5cbiAgICAgIHZhbCA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIGhpdChzb3VyY2UpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2V0IHVwIHByZXZlbnQtYWRmbHkgc2NyaXB0bGV0Jyk7XG4gIH1cbn1cbnByZXZlbnRBZGZseS5uYW1lcyA9IFsncHJldmVudC1hZGZseScsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidhZGZseS1kZWZ1c2VyLmpzJywgJ3Viby1hZGZseS1kZWZ1c2VyLmpzJywgJ3Viby1hZGZseS1kZWZ1c2VyJ107XG5wcmV2ZW50QWRmbHkuaW5qZWN0aW9ucyA9IFtzZXRQcm9wZXJ0eUFjY2VzcywgaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgZGVidWctb24tcHJvcGVydHktcmVhZFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzY3JpcHRsZXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIFthYm9ydC1vbi1wcm9wZXJ0eS1yZWFkXSgjYWJvcnQtb24tcHJvcGVydHktcmVhZCksIGJ1dCBpbnN0ZWFkIG9mIGFib3J0aW5nIGl0IHN0YXJ0cyB0aGUgZGVidWdnZXIuXG4gKlxuICogKipJdCBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBwcm9kdWN0aW9uIGZpbHRlciBsaXN0cyEqKlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogISBEZWJ1ZyBzY3JpcHQgaWYgaXQgdHJpZXMgdG8gYWNjZXNzIGB3aW5kb3cuYWxlcnRgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkZWJ1Zy1vbi1wcm9wZXJ0eS1yZWFkJywgJ2FsZXJ0JylcbiAqICEgb2YgYHdpbmRvdy5vcGVuYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnZGVidWctb24tcHJvcGVydHktcmVhZCcsICdvcGVuJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBkZWJ1Z09uUHJvcGVydHlSZWFkKHNvdXJjZSwgcHJvcGVydHksIHN0YWNrKSB7XG4gIGlmICghcHJvcGVydHkgfHwgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJpZCA9IHJhbmRvbUlkKCk7XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgfTtcblxuICB2YXIgc2V0Q2hhaW5Qcm9wQWNjZXNzID0gZnVuY3Rpb24gc2V0Q2hhaW5Qcm9wQWNjZXNzKG93bmVyLCBwcm9wZXJ0eSkge1xuICAgIHZhciBjaGFpbkluZm8gPSBnZXRQcm9wZXJ0eUluQ2hhaW4ob3duZXIsIHByb3BlcnR5KTtcbiAgICB2YXIgYmFzZSA9IGNoYWluSW5mby5iYXNlO1xuICAgIHZhciBwcm9wID0gY2hhaW5JbmZvLnByb3AsXG4gICAgICAgIGNoYWluID0gY2hhaW5JbmZvLmNoYWluO1xuXG4gICAgaWYgKGNoYWluKSB7XG4gICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKGEpIHtcbiAgICAgICAgYmFzZSA9IGE7XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBzZXRDaGFpblByb3BBY2Nlc3MoYSwgY2hhaW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3duZXIsIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogc2V0dGVyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRQcm9wZXJ0eUFjY2VzcyhiYXNlLCBwcm9wLCB7XG4gICAgICBnZXQ6IGFib3J0LFxuICAgICAgc2V0OiBub29wRnVuY1xuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbiAgd2luZG93Lm9uZXJyb3IgPSBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpLmJpbmQoKTtcbn1cbmRlYnVnT25Qcm9wZXJ0eVJlYWQubmFtZXMgPSBbJ2RlYnVnLW9uLXByb3BlcnR5LXJlYWQnXTtcbmRlYnVnT25Qcm9wZXJ0eVJlYWQuaW5qZWN0aW9ucyA9IFtyYW5kb21JZCwgc2V0UHJvcGVydHlBY2Nlc3MsIGdldFByb3BlcnR5SW5DaGFpbiwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdCwgdG9SZWdFeHAsIG1hdGNoU3RhY2tUcmFjZSwgbm9vcEZ1bmNdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBkZWJ1Zy1vbi1wcm9wZXJ0eS13cml0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzY3JpcHRsZXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIFthYm9ydC1vbi1wcm9wZXJ0eS13cml0ZV0oI2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlKSwgYnV0IGluc3RlYWQgb2YgYWJvcnRpbmcgaXQgc3RhcnRzIHRoZSBkZWJ1Z2dlci5cbiAqXG4gKiAqKkl0IGlzIG5vdCBzdXBwb3NlZCB0byBiZSB1c2VkIGluIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzISoqXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiAhIEFib3J0cyBzY3JpcHQgd2hlbiBpdCB0cmllcyB0byB3cml0ZSBpbiBwcm9wZXJ0eSBgd2luZG93LnRlc3RgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkZWJ1Zy1vbi1wcm9wZXJ0eS13cml0ZScsICd0ZXN0JylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBkZWJ1Z09uUHJvcGVydHlXcml0ZShzb3VyY2UsIHByb3BlcnR5LCBzdGFjaykge1xuICBpZiAoIXByb3BlcnR5IHx8ICFtYXRjaFN0YWNrVHJhY2Uoc3RhY2ssIG5ldyBFcnJvcigpLnN0YWNrKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByaWQgPSByYW5kb21JZCgpO1xuXG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGhpdChzb3VyY2UpO1xuICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjtcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgc2V0OiBhYm9ydFxuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbiAgd2luZG93Lm9uZXJyb3IgPSBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpLmJpbmQoKTtcbn1cbmRlYnVnT25Qcm9wZXJ0eVdyaXRlLm5hbWVzID0gWydkZWJ1Zy1vbi1wcm9wZXJ0eS13cml0ZSddO1xuZGVidWdPblByb3BlcnR5V3JpdGUuaW5qZWN0aW9ucyA9IFtyYW5kb21JZCwgc2V0UHJvcGVydHlBY2Nlc3MsIGdldFByb3BlcnR5SW5DaGFpbiwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdCwgdG9SZWdFeHAsIG1hdGNoU3RhY2tUcmFjZV07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGRlYnVnLWN1cnJlbnQtaW5saW5lLXNjcmlwdFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBzY3JpcHRsZXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIFthYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHRdKCNhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQpLCBidXQgaW5zdGVhZCBvZiBhYm9ydGluZyBpdCBzdGFydHMgdGhlIGRlYnVnZ2VyLlxuICpcbiAqICoqSXQgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gcHJvZHVjdGlvbiBmaWx0ZXIgbGlzdHMhKipcbiAqXG4gKiAqKlN5bnRheCoqXG4gKmBgYFxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gYWNjZXNzIGB3aW5kb3cuYWxlcnRgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkZWJ1Zy1jdXJyZW50LWlubGluZS1zY3JpcHQnLCAnYWxlcnQnKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIGRlYnVnQ3VycmVudElubGluZVNjcmlwdChzb3VyY2UsIHByb3BlcnR5KSB7XG4gIHZhciBzZWFyY2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gIHZhciBzZWFyY2hSZWdleHAgPSB0b1JlZ0V4cChzZWFyY2gpO1xuICB2YXIgcmlkID0gcmFuZG9tSWQoKTtcblxuICB2YXIgZ2V0Q3VycmVudFNjcmlwdCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHQoKSB7XG4gICAgaWYgKCdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIH1cblxuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHJldHVybiBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV07XG4gIH07XG5cbiAgdmFyIG91clNjcmlwdCA9IGdldEN1cnJlbnRTY3JpcHQoKTtcblxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB2YXIgc2NyaXB0RWwgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG5cbiAgICBpZiAoc2NyaXB0RWwgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCAmJiBzY3JpcHRFbC50ZXh0Q29udGVudC5sZW5ndGggPiAwICYmIHNjcmlwdEVsICE9PSBvdXJTY3JpcHQgJiYgKCFzZWFyY2ggfHwgc2VhcmNoUmVnZXhwLnRlc3Qoc2NyaXB0RWwudGV4dENvbnRlbnQpKSkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgIH1cbiAgfTtcblxuICB2YXIgc2V0Q2hhaW5Qcm9wQWNjZXNzID0gZnVuY3Rpb24gc2V0Q2hhaW5Qcm9wQWNjZXNzKG93bmVyLCBwcm9wZXJ0eSkge1xuICAgIHZhciBjaGFpbkluZm8gPSBnZXRQcm9wZXJ0eUluQ2hhaW4ob3duZXIsIHByb3BlcnR5KTtcbiAgICB2YXIgYmFzZSA9IGNoYWluSW5mby5iYXNlO1xuICAgIHZhciBwcm9wID0gY2hhaW5JbmZvLnByb3AsXG4gICAgICAgIGNoYWluID0gY2hhaW5JbmZvLmNoYWluO1xuXG4gICAgaWYgKGNoYWluKSB7XG4gICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKGEpIHtcbiAgICAgICAgYmFzZSA9IGE7XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBzZXRDaGFpblByb3BBY2Nlc3MoYSwgY2hhaW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3duZXIsIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogc2V0dGVyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFZhbHVlID0gYmFzZVtwcm9wXTtcbiAgICBzZXRQcm9wZXJ0eUFjY2VzcyhiYXNlLCBwcm9wLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBzZXRDaGFpblByb3BBY2Nlc3Mod2luZG93LCBwcm9wZXJ0eSk7XG4gIHdpbmRvdy5vbmVycm9yID0gY3JlYXRlT25FcnJvckhhbmRsZXIocmlkKS5iaW5kKCk7XG59XG5kZWJ1Z0N1cnJlbnRJbmxpbmVTY3JpcHQubmFtZXMgPSBbJ2RlYnVnLWN1cnJlbnQtaW5saW5lLXNjcmlwdCddO1xuZGVidWdDdXJyZW50SW5saW5lU2NyaXB0LmluamVjdGlvbnMgPSBbcmFuZG9tSWQsIHNldFByb3BlcnR5QWNjZXNzLCBnZXRQcm9wZXJ0eUluQ2hhaW4sIHRvUmVnRXhwLCBjcmVhdGVPbkVycm9ySGFuZGxlciwgaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcmVtb3ZlLWF0dHJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzIGZyb20gRE9NIG5vZGVzLiBUaGlzIHNjcmlwdGxldCBydW5zIG9uY2Ugd2hlbiB0aGUgcGFnZSBsb2Fkc1xuICogYW5kIGFmdGVyIHRoYXQgcGVyaW9kaWNhbGx5IGluIG9yZGVyIHRvIERPTSB0cmVlIGNoYW5nZXMuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjcmVtb3ZlLWF0dHJqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3JlbW92ZS1hdHRyJywgYXR0cnNbLCBzZWxlY3Rvcl0pXG4gKiBgYGBcbiAqXG4gKiAtIGBhdHRyc2Ag4oCUIHJlcXVpcmVkLCBhdHRyaWJ1dGUgb3IgbGlzdCBvZiBhdHRyaWJ1dGVzIGpvaW5lZCBieSAnfCdcbiAqIC0gYHNlbGVjdG9yYCDigJQgb3B0aW9uYWwsIENTUyBzZWxlY3Rvciwgc3BlY2lmaWVzIERPTSBub2RlcyBmcm9tIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHdpbGwgYmUgcmVtb3ZlZFxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gIFJlbW92ZXMgYnkgYXR0cmlidXRlXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWF0dHInLCAnZXhhbXBsZXx0ZXN0JylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDwhLS0gYmVmb3JlICAtLT5cbiAqICAgICA8ZGl2IGV4YW1wbGU9XCJ0cnVlXCIgdGVzdD1cInRydWVcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqXG4gKiAgICAgPCEtLSBhZnRlciAtLT5cbiAqICAgICA8ZGl2PlNvbWUgdGV4dDwvZGl2PlxuICogICAgIGBgYFxuICpcbiAqIDIuIFJlbW92ZXMgd2l0aCBzcGVjaWZpZWQgc2VsZWN0b3JcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtYXR0cicsICdleGFtcGxlJywgJ2RpdltjbGFzcz1cImlubmVyXCJdJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDwhLS0gYmVmb3JlIC0tPlxuICogICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyXCIgZXhhbXBsZT1cInRydWVcIj5cbiAqICAgICAgICAgPGRpdiBjbGFzcz1cImlubmVyXCIgZXhhbXBsZT1cInRydWVcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgPCEtLSBhZnRlciAtLT5cbiAqICAgICA8ZGl2IGNsYXNzPVwid3JhcHBlclwiIGV4YW1wbGU9XCJ0cnVlXCI+XG4gKiAgICAgICAgIDxkaXYgY2xhc3M9XCJpbm5lclwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDwvZGl2PlxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVBdHRyKHNvdXJjZSwgYXR0cnMsIHNlbGVjdG9yKSB7XG4gIGlmICghYXR0cnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhdHRycyA9IGF0dHJzLnNwbGl0KC9cXHMqXFx8XFxzKi8pO1xuXG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICBzZWxlY3RvciA9IFwiW1wiLmNvbmNhdChhdHRycy5qb2luKCddLFsnKSwgXCJdXCIpO1xuICB9XG5cbiAgdmFyIHJtYXR0ciA9IGZ1bmN0aW9uIHJtYXR0cigpIHtcbiAgICB2YXIgbm9kZXMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgfVxuICB9O1xuXG4gIHJtYXR0cigpOyAvLyAndHJ1ZScgZm9yIG9ic2VydmluZyBhdHRyaWJ1dGVzXG5cbiAgb2JzZXJ2ZURPTUNoYW5nZXMocm1hdHRyLCB0cnVlKTtcbn1cbnJlbW92ZUF0dHIubmFtZXMgPSBbJ3JlbW92ZS1hdHRyJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ3JlbW92ZS1hdHRyLmpzJywgJ3Viby1yZW1vdmUtYXR0ci5qcycsICdyYS5qcycsICd1Ym8tcmEuanMnLCAndWJvLXJlbW92ZS1hdHRyJywgJ3Viby1yYSddO1xucmVtb3ZlQXR0ci5pbmplY3Rpb25zID0gW2hpdCwgb2JzZXJ2ZURPTUNoYW5nZXNdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCByZW1vdmUtY2xhc3NcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjbGFzc2VzIGZyb20gRE9NIG5vZGVzLiBUaGlzIHNjcmlwdGxldCBydW5zIG9uY2UgYWZ0ZXIgdGhlIHBhZ2UgbG9hZHNcbiAqIGFuZCBhZnRlciB0aGF0IHBlcmlvZGljYWxseSBpbiBvcmRlciB0byBET00gdHJlZSBjaGFuZ2VzLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I3JlbW92ZS1jbGFzc2pzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWNsYXNzJywgY2xhc3Nlc1ssIHNlbGVjdG9yXSlcbiAqIGBgYFxuICpcbiAqIC0gYGNsYXNzZXNgIOKAlCByZXF1aXJlZCwgY2xhc3Mgb3IgbGlzdCBvZiBjbGFzc2VzIHNlcGFyYXRlZCBieSAnfCdcbiAqIC0gYHNlbGVjdG9yYCDigJQgb3B0aW9uYWwsIENTUyBzZWxlY3Rvciwgc3BlY2lmaWVzIERPTSBub2RlcyBmcm9tIHdoaWNoIHRoZSBjbGFzc2VzIHdpbGwgYmUgcmVtb3ZlZC5cbiAqIElmIHRoZXJlIGlzIG5vIGBzZWxlY3RvcmAsIGVhY2ggY2xhc3Mgb2YgYGNsYXNzZXNgIGluZGVwZW5kZW50bHkgd2lsbCBiZSByZW1vdmVkIGZyb20gYWxsIG5vZGVzIHdoaWNoIGhhcyBvbmVcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuICBSZW1vdmVzIGJ5IGNsYXNzZXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtY2xhc3MnLCAnZXhhbXBsZXx0ZXN0JylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDwhLS0gYmVmb3JlICAtLT5cbiAqICAgICA8ZGl2IGlkPVwiZmlyc3RcIiBjbGFzcz1cIm5pY2UgdGVzdFwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDxkaXYgaWQ9XCJzZWNvbmRcIiBjbGFzcz1cInJhcmUgZXhhbXBsZSBmb3IgdGVzdFwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDxkaXYgaWQ9XCJ0aGlyZFwiIGNsYXNzPVwidGVzdGluZyBiZXR0ZXIgZXhhbXBsZVwiPlNvbWUgdGV4dDwvZGl2PlxuICpcbiAqICAgICA8IS0tIGFmdGVyIC0tPlxuICogICAgIDxkaXYgaWQ9XCJmaXJzdFwiIGNsYXNzPVwibmljZVwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDxkaXYgaWQ9XCJzZWNvbmRcIiBjbGFzcz1cInJhcmUgZm9yXCI+U29tZSB0ZXh0PC9kaXY+XG4gKiAgICAgPGRpdiBpZD1cInRoaXJkXCIgY2xhc3M9XCJ0ZXN0aW5nIGJldHRlclwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIGBgYFxuICpcbiAqIDIuIFJlbW92ZXMgd2l0aCBzcGVjaWZpZWQgc2VsZWN0b3JcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtY2xhc3MnLCAnYnJhbmRpbmcnLCAnZGl2W2NsYXNzXj1cImlubmVyXCJdJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDwhLS0gYmVmb3JlIC0tPlxuICogICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyIHRydWUgYnJhbmRpbmdcIj5cbiAqICAgICAgICAgPGRpdiBjbGFzcz1cImlubmVyIGJhZCBicmFuZGluZ1wiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDwvZGl2PlxuICpcbiAqICAgICA8IS0tIGFmdGVyIC0tPlxuICogICAgIDxkaXYgY2xhc3M9XCJ3cmFwcGVyIHRydWUgYnJhbmRpbmdcIj5cbiAqICAgICAgICAgPGRpdiBjbGFzcz1cImlubmVyIGJhZFwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDwvZGl2PlxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhzb3VyY2UsIGNsYXNzTmFtZXMsIHNlbGVjdG9yKSB7XG4gIGlmICghY2xhc3NOYW1lcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLnNwbGl0KC9cXHMqXFx8XFxzKi8pO1xuICB2YXIgc2VsZWN0b3JzID0gW107XG5cbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHNlbGVjdG9ycyA9IGNsYXNzTmFtZXMubWFwKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBcIi5cIi5jb25jYXQoY2xhc3NOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciByZW1vdmVDbGFzc0hhbmRsZXIgPSBmdW5jdGlvbiByZW1vdmVDbGFzc0hhbmRsZXIoKSB7XG4gICAgdmFyIG5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZm91bmRlZE5vZGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICBmb3VuZGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbm9kZXMuYWRkKG4pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzZWxlY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICBub2Rlcy5hZGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciByZW1vdmVkID0gZmFsc2U7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbW92ZUNsYXNzSGFuZGxlcigpO1xuICB2YXIgQ0xBU1NfQVRUUl9OQU1FID0gWydjbGFzcyddOyAvLyAndHJ1ZScgZm9yIG9ic2VydmluZyBhdHRyaWJ1dGVzXG4gIC8vICdjbGFzcycgZm9yIG9ic2VydmluZyBvbmx5IGNsYXNzZXNcblxuICBvYnNlcnZlRE9NQ2hhbmdlcyhyZW1vdmVDbGFzc0hhbmRsZXIsIHRydWUsIENMQVNTX0FUVFJfTkFNRSk7XG59XG5yZW1vdmVDbGFzcy5uYW1lcyA9IFsncmVtb3ZlLWNsYXNzJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ3JlbW92ZS1jbGFzcy5qcycsICd1Ym8tcmVtb3ZlLWNsYXNzLmpzJywgJ3JjLmpzJywgJ3Viby1yYy5qcycsICd1Ym8tcmVtb3ZlLWNsYXNzJywgJ3Viby1yYyddO1xucmVtb3ZlQ2xhc3MuaW5qZWN0aW9ucyA9IFtoaXQsIG9ic2VydmVET01DaGFuZ2VzXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IGRpc2FibGUtbmV3dGFiLWxpbmtzXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBvcGVuaW5nIG5ldyB0YWJzIGFuZCB3aW5kb3dzIGlmIHRoZXJlIGlzIGB0YXJnZXRgIGF0dHJpYnV0ZSBpbiBlbGVtZW50LlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2Rpc2FibGUtbmV3dGFiLWxpbmtzanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkaXNhYmxlLW5ld3RhYi1saW5rcycpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlTmV3dGFiTGlua3Moc291cmNlKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcblxuICAgIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgIGlmICh0YXJnZXQubG9jYWxOYW1lID09PSAnYScgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgndGFyZ2V0JykpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgfVxuICB9KTtcbn1cbmRpc2FibGVOZXd0YWJMaW5rcy5uYW1lcyA9IFsnZGlzYWJsZS1uZXd0YWItbGlua3MnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nZGlzYWJsZS1uZXd0YWItbGlua3MuanMnLCAndWJvLWRpc2FibGUtbmV3dGFiLWxpbmtzLmpzJywgJ3Viby1kaXNhYmxlLW5ld3RhYi1saW5rcyddO1xuZGlzYWJsZU5ld3RhYkxpbmtzLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgYWRqdXN0LXNldEludGVydmFsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGp1c3RzIGludGVydmFsIGZvciBzcGVjaWZpZWQgc2V0SW50ZXJ2YWwoKSBjYWxsYmFja3MuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjbmFuby1zZXRpbnRlcnZhbC1ib29zdGVyanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnWywgbWF0Y2ggWywgaW50ZXJ2YWxbLCBib29zdF1dXSlcbiAqIGBgYFxuICpcbiAqIC0gYG1hdGNoYCAtIG9wdGlvbmFsLCBzdHJpbmcvcmVndWxhciBleHByZXNzaW9uLCBtYXRjaGluZyBpbiBzdHJpbmdpZmllZCBjYWxsYmFjayBmdW5jdGlvblxuICogLSBgaW50ZXJ2YWxgIC0gb3B0aW9uYWwsIGRlZmF1bHRzIHRvIDEwMDAsIG1hdGNoaW5nIHNldEludGVydmFsIGRlbGF5OyBkZWNpbWFsIGludGVnZXIgT1IgJyonIGZvciBhbnkgZGVsYXlcbiAqIC0gYGJvb3N0YCAtIG9wdGlvbmFsLCBkZWZhdWx0IHRvIDAuMDUsIGZsb2F0LCBjYXBwZWQgYXQgNTAgdGltZXMgZm9yIHVwIGFuZCBkb3duICgwLjAyLi4uNTApLCBpbnRlcnZhbCBtdWx0aXBsaWVyXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBBZGp1c3QgYWxsIHNldEludGVydmFsKCkgeDIwIHRpbWVzIHdoZXJlIGludGVydmFsIGVxdWFsIDEwMDBtczpcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnKVxuICogICAgIGBgYFxuICpcbiAqIDIuIEFkanVzdCBhbGwgc2V0SW50ZXJ2YWwoKSB4MjAgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0aGVkIHdpdGggYGV4YW1wbGVgIGFuZCBpbnRlcnZhbCBlcXVhbCAxMDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnLCAnZXhhbXBsZScpXG4gKiAgICAgYGBgXG4gKlxuICogMy4gQWRqdXN0IGFsbCBzZXRJbnRlcnZhbCgpIHgyMCB0aW1lcyB3aGVyZSBjYWxsYmFjayBtYXRoZWQgd2l0aCBgZXhhbXBsZWAgYW5kIGludGVydmFsIGVxdWFsIDQwMG1zXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldEludGVydmFsJywgJ2V4YW1wbGUnLCAnNDAwJylcbiAqICAgICBgYGBcbiAqXG4gKiA0LiBTbG93IGRvd24gc2V0SW50ZXJ2YWwoKSB4MiB0aW1lcyB3aGVyZSBjYWxsYmFjayBtYXRjaGVkIHdpdGggYGV4YW1wbGVgIGFuZCBpbnRlcnZhbCBlcXVhbCAxMDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnLCAnZXhhbXBsZScsICcnLCAnMicpXG4gKiAgICAgYGBgXG4gKiA1LiBBZGp1c3QgYWxsIHNldEludGVydmFsKCkgeDUwIHRpbWVzIHdoZXJlIGludGVydmFsIGVxdWFsIDIwMDBtc1xuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRJbnRlcnZhbCcsICcnLCAnMjAwMCcsICcwLjAyJylcbiAqICAgICBgYGBcbiAqIDYuIEFkanVzdCBhbGwgc2V0SW50ZXJ2YWwoKSB4NTAgdGltZXMgd2hlcmUgaW50ZXJ2YWwgaXMgcmFuZG9taXplZFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRJbnRlcnZhbCcsICcnLCAnKicsICcwLjAyJylcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gYWRqdXN0U2V0SW50ZXJ2YWwoc291cmNlLCBtYXRjaCwgaW50ZXJ2YWwsIGJvb3N0KSB7XG4gIHZhciBuYXRpdmVTZXRJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbDtcbiAgdmFyIG1hdGNoUmVnZXhwID0gdG9SZWdFeHAobWF0Y2gpO1xuXG4gIHZhciBpbnRlcnZhbFdyYXBwZXIgPSBmdW5jdGlvbiBpbnRlcnZhbFdyYXBwZXIoY2IsIGQpIHtcbiAgICBpZiAobWF0Y2hSZWdleHAudGVzdChjYi50b1N0cmluZygpKSAmJiBpc0RlbGF5TWF0Y2hlZChpbnRlcnZhbCwgZCkpIHtcbiAgICAgIGQgKj0gZ2V0Qm9vc3RNdWx0aXBsaWVyKGJvb3N0KTtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVTZXRJbnRlcnZhbC5hcHBseSh3aW5kb3csIFtjYiwgZF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0SW50ZXJ2YWwgPSBpbnRlcnZhbFdyYXBwZXI7XG59XG5hZGp1c3RTZXRJbnRlcnZhbC5uYW1lcyA9IFsnYWRqdXN0LXNldEludGVydmFsJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25hbm8tc2V0SW50ZXJ2YWwtYm9vc3Rlci5qcycsICd1Ym8tbmFuby1zZXRJbnRlcnZhbC1ib29zdGVyLmpzJywgJ25hbm8tc2liLmpzJywgJ3Viby1uYW5vLXNpYi5qcycsICd1Ym8tbmFuby1zZXRJbnRlcnZhbC1ib29zdGVyJywgJ3Viby1uYW5vLXNpYiddO1xuYWRqdXN0U2V0SW50ZXJ2YWwuaW5qZWN0aW9ucyA9IFtoaXQsIHRvUmVnRXhwLCBnZXRCb29zdE11bHRpcGxpZXIsIGlzRGVsYXlNYXRjaGVkLCBuYXRpdmVJc05hTiwgbmF0aXZlSXNGaW5pdGUsIGdldE1hdGNoRGVsYXksIGdldFdpbGRjYXJkU3ltYm9sLCBzaG91bGRNYXRjaEFueURlbGF5XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgYWRqdXN0LXNldFRpbWVvdXRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFkanVzdHMgdGltZW91dCBmb3Igc3BlY2lmaWVkIHNldFRpbW91dCgpIGNhbGxiYWNrcy5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNuYW5vLXNldHRpbWVvdXQtYm9vc3RlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldFRpbWVvdXQnWywgbWF0Y2ggWywgdGltZW91dFssIGJvb3N0XV1dKVxuICogYGBgXG4gKlxuICogLSBgbWF0Y2hgIC0gb3B0aW9uYWwsIHN0cmluZy9yZWd1bGFyIGV4cHJlc3Npb24sIG1hdGNoaW5nIGluIHN0cmluZ2lmaWVkIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAtIGB0aW1lb3V0YCAtIG9wdGlvbmFsLCBkZWZhdWx0cyB0byAxMDAwLCBtYXRjaGluZyBzZXRUaW1vdXQgZGVsYXk7IGRlY2ltYWwgaW50ZWdlciBPUiAnKicgZm9yIGFueSBkZWxheVxuICogLSBgYm9vc3RgIC0gb3B0aW9uYWwsIGRlZmF1bHQgdG8gMC4wNSwgZmxvYXQsIGNhcHBlZCBhdCA1MCB0aW1lcyBmb3IgdXAgYW5kIGRvd24gKDAuMDIuLi41MCksIHRpbWVvdXQgbXVsdGlwbGllclxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gQWRqdXN0IGFsbCBzZXRUaW1lb3V0KCkgeDIwIHRpbWVzIHdoZXJlIHRpbWVvdXQgZXF1YWwgMTAwMG1zOlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRUaW1lb3V0JylcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBBZGp1c3QgYWxsIHNldFRpbWVvdXQoKSB4MjAgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0aGVkIHdpdGggYGV4YW1wbGVgIGFuZCB0aW1lb3V0IGVxdWFsIDEwMDBtc1xuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRUaW1lb3V0JywgJ2V4YW1wbGUnKVxuICogICAgIGBgYFxuICpcbiAqIDMuIEFkanVzdCBhbGwgc2V0VGltZW91dCgpIHgyMCB0aW1lcyB3aGVyZSBjYWxsYmFjayBtYXRoZWQgd2l0aCBgZXhhbXBsZWAgYW5kIHRpbWVvdXQgZXF1YWwgNDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0VGltZW91dCcsICdleGFtcGxlJywgJzQwMCcpXG4gKiAgICAgYGBgXG4gKlxuICogNC4gU2xvdyBkb3duIHNldFRpbWVvdXQoKSB4MiB0aW1lcyB3aGVyZSBjYWxsYmFjayBtYXRjaGVkIHdpdGggYGV4YW1wbGVgIGFuZCB0aW1lb3V0IGVxdWFsIDEwMDBtc1xuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRUaW1lb3V0JywgJ2V4YW1wbGUnLCAnJywgJzInKVxuICogICAgIGBgYFxuICogNS4gQWRqdXN0IGFsbCBzZXRUaW1lb3V0KCkgeDUwIHRpbWVzIHdoZXJlIHRpbWVvdXQgZXF1YWwgMjAwMG1zXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldFRpbWVvdXQnLCAnJywgJzIwMDAnLCAnMC4wMicpXG4gKiAgICAgYGBgXG4gKiA2LiBBZGp1c3QgYWxsIHNldFRpbWVvdXQoKSB4MjAgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0aGVkIHdpdGggYHRlc3RgIGFuZCB0aW1lb3V0IGlzIHJhbmRvbWl6ZWRcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0VGltZW91dCcsICd0ZXN0JywgJyonKVxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBhZGp1c3RTZXRUaW1lb3V0KHNvdXJjZSwgbWF0Y2gsIHRpbWVvdXQsIGJvb3N0KSB7XG4gIHZhciBuYXRpdmVTZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG4gIHZhciBtYXRjaFJlZ2V4cCA9IHRvUmVnRXhwKG1hdGNoKTtcblxuICB2YXIgdGltZW91dFdyYXBwZXIgPSBmdW5jdGlvbiB0aW1lb3V0V3JhcHBlcihjYiwgZCkge1xuICAgIGlmIChtYXRjaFJlZ2V4cC50ZXN0KGNiLnRvU3RyaW5nKCkpICYmIGlzRGVsYXlNYXRjaGVkKHRpbWVvdXQsIGQpKSB7XG4gICAgICBkICo9IGdldEJvb3N0TXVsdGlwbGllcihib29zdCk7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlU2V0VGltZW91dC5hcHBseSh3aW5kb3csIFtjYiwgZF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0VGltZW91dCA9IHRpbWVvdXRXcmFwcGVyO1xufVxuYWRqdXN0U2V0VGltZW91dC5uYW1lcyA9IFsnYWRqdXN0LXNldFRpbWVvdXQnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbmFuby1zZXRUaW1lb3V0LWJvb3N0ZXIuanMnLCAndWJvLW5hbm8tc2V0VGltZW91dC1ib29zdGVyLmpzJywgJ25hbm8tc3RiLmpzJywgJ3Viby1uYW5vLXN0Yi5qcycsICd1Ym8tbmFuby1zZXRUaW1lb3V0LWJvb3N0ZXInLCAndWJvLW5hbm8tc3RiJ107XG5hZGp1c3RTZXRUaW1lb3V0LmluamVjdGlvbnMgPSBbaGl0LCB0b1JlZ0V4cCwgZ2V0Qm9vc3RNdWx0aXBsaWVyLCBpc0RlbGF5TWF0Y2hlZCwgbmF0aXZlSXNOYU4sIG5hdGl2ZUlzRmluaXRlLCBnZXRNYXRjaERlbGF5LCBnZXRXaWxkY2FyZFN5bWJvbCwgc2hvdWxkTWF0Y2hBbnlEZWxheV07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGRpci1zdHJpbmdcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFdyYXBzIHRoZSBgY29uc29sZS5kaXJgIEFQSSB0byBjYWxsIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiB0aGUgYXJndW1lbnQuXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBhZGJsb2NrIGNpcmN1bXZlbnRpb24gc3lzdGVtcyB0aGF0IGRldGVjdCBicm93c2VyIGRldnRvb2xzXG4gKiBhbmQgaGlkZSB0aGVtc2VsdmVzLiBUaGVyZWZvcmUsIGlmIHdlIGZvcmNlIHRoZW0gdG8gdGhpbmtcbiAqIHRoYXQgZGV2dG9vbHMgYXJlIG9wZW4gKHVzaW5nIHRoaXMgc2NyY2lwdGxldCksXG4gKiBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzYWJsZSB0aGUgYWRibG9jayBjaXJjdW12ZW50aW9uIHNjcmlwdC5cbiAqXG4gKiBSZWxhdGVkIEFCUCBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWRibG9ja3BsdXMvYWRibG9ja3BsdXNjb3JlL2Jsb2IvNmIyYTMwOTA1NGNjMjM0MzIxMDJiODVkMTNmMTI1NTk2MzllZjQ5NS9saWIvY29udGVudC9zbmlwcGV0cy5qcyNMNzY2XG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkaXItc3RyaW5nJ1ssIHRpbWVzXSlcbiAqIGBgYFxuICogLSBgdGltZXNgIC0gb3B0aW9uYWwsIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gY2FsbCB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgdGhlIGFyZ3VtZW50IHRvIGBjb25zb2xlLmRpcmBcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiAhIFJ1biAyIHRpbWVzXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdkaXItc3RyaW5nJywgJzInKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIGRpclN0cmluZyhzb3VyY2UsIHRpbWVzKSB7XG4gIHZhciBfY29uc29sZSA9IGNvbnNvbGUsXG4gICAgICBkaXIgPSBfY29uc29sZS5kaXI7XG4gIHRpbWVzID0gcGFyc2VJbnQodGltZXMsIDEwKTtcblxuICBmdW5jdGlvbiBkaXJXcmFwcGVyKG9iamVjdCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciB0ZW1wO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aW1lczsgaSArPSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICB0ZW1wID0gXCJcIi5jb25jYXQob2JqZWN0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRpciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGlyLmNhbGwodGhpcywgb2JqZWN0KTtcbiAgICB9XG5cbiAgICBoaXQoc291cmNlLCB0ZW1wKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG5cbiAgY29uc29sZS5kaXIgPSBkaXJXcmFwcGVyO1xufVxuZGlyU3RyaW5nLm5hbWVzID0gWydkaXItc3RyaW5nJywgJ2FicC1kaXItc3RyaW5nJ107XG5kaXJTdHJpbmcuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBqc29uLXBydW5lXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZW1vdmVzIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGZyb20gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIEpTT04ucGFyc2UgYW5kIHJldHVybnMgdGhlIGNhbGxlclxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2pzb24tcHJ1bmVqcy1cbiAqXG4gKiBSZWxhdGVkIEFCUCBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWRibG9ja3BsdXMvYWRibG9ja3BsdXNjb3JlL2Jsb2IvbWFzdGVyL2xpYi9jb250ZW50L3NuaXBwZXRzLmpzI0wxMjg1XG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJ1ssIHByb3BzVG9SZW1vdmUgWywgb2JsaWdhdG9yeVByb3BzIFssIHN0YWNrXV1dKVxuICogYGBgXG4gKlxuICogLSBgcHJvcHNUb1JlbW92ZWAgLSBvcHRpb25hbCwgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCBwcm9wZXJ0aWVzIHRvIHJlbW92ZVxuICogLSBgb2JsaWdhdG9yeVByb3BzYCAtIG9wdGlvbmFsLCBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHByb3BlcnRpZXMgd2hpY2ggbXVzdCBiZSBhbGwgcHJlc2VudCBmb3IgdGhlIHBydW5pbmcgdG8gb2NjdXJcbiAqIC0gYHN0YWNrYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbXVzdCBtYXRjaCB0aGUgY3VycmVudCBmdW5jdGlvbiBjYWxsIHN0YWNrIHRyYWNlXG4gKlxuICogPiBOb3RlIHBsZWFzZSB0aGF0IHlvdSBjYW4gdXNlIHdpbGRjYXJkIGAqYCBmb3IgY2hhaW4gcHJvcGVydHkgbmFtZS5cbiAqIGUuZy4gJ2FkLiouc3JjJyBpbnN0ZWFkIG9mICdhZC4wLnNyYyBhZC4xLnNyYyBhZC4yLnNyYyAuLi4nXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBSZW1vdmVzIHByb3BlcnR5IGBleGFtcGxlYCBmcm9tIHRoZSByZXN1bHRzIG9mIEpTT04ucGFyc2UgY2FsbFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2pzb24tcHJ1bmUnLCAnZXhhbXBsZScpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBjYWxsIHdpbGwgcmV0dXJuIGB7IG9uZTogMX1gXG4gKlxuICogICAgIGBgYGh0bWxcbiAqICAgICBKU09OLnBhcnNlKCd7XCJvbmVcIjoxLFwiZXhhbXBsZVwiOnRydWV9JylcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBJZiB0aGVyZSBhcmUgbm8gc3BlY2lmaWVkIHByb3BlcnRpZXMgaW4gdGhlIHJlc3VsdCBvZiBKU09OLnBhcnNlIGNhbGwsIHBydW5pbmcgd2lsbCBOT1Qgb2NjdXJcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJywgJ29uZScsICdvYmxpZ2F0b3J5UHJvcCcpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBjYWxsIHdpbGwgcmV0dXJuIGB7IG9uZTogMSwgdHdvOiAyfWBcbiAqXG4gKiAgICAgYGBgaHRtbFxuICogICAgIEpTT04ucGFyc2UoJ3tcIm9uZVwiOjEsXCJ0d29cIjoyfScpXG4gKiAgICAgYGBgXG4gKlxuICogMy4gQSBwcm9wZXJ0eSBpbiBhIGxpc3Qgb2YgcHJvcGVydGllcyBjYW4gYmUgYSBjaGFpbiBvZiBwcm9wZXJ0aWVzXG4gKlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2pzb24tcHJ1bmUnLCAnYS5iJywgJ2FkcGF0aC51cmwuZmlyc3QnKVxuICogICAgIGBgYFxuICpcbiAqIDQuIFJlbW92ZXMgcHJvcGVydHkgYGNvbnRlbnQuYWRgIGZyb20gdGhlIHJlc3VsdHMgb2YgSlNPTi5wYXJzZSBjYWxsIGl0J3MgZXJyb3Igc3RhY2sgdHJhY2UgY29udGFpbnMgYHRlc3QuanNgXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnanNvbi1wcnVuZScsICdjb250ZW50LmFkJywgJycsICd0ZXN0LmpzJylcbiAqICAgICBgYGBcbiAqXG4gKiA1LiBBIHByb3BlcnR5IGluIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGNhbiBiZSBhIGNoYWluIG9mIHByb3BlcnRpZXMgd2l0aCB3aWxkY2FyZCBpbiBpdFxuICpcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJywgJ2NvbnRlbnQuKi5tZWRpYS5zcmMnLCAnY29udGVudC4qLm1lZGlhLnByZXJvbGwnKVxuICogICAgIGBgYFxuICpcbiAqIDYuIENhbGwgd2l0aCBubyBhcmd1bWVudHMgd2lsbCBsb2cgdGhlIGN1cnJlbnQgaG9zdG5hbWUgYW5kIGpzb24gcGF5bG9hZCBhdCB0aGUgY29uc29sZVxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2pzb24tcHJ1bmUnKVxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBqc29uUHJ1bmUoc291cmNlLCBwcm9wc1RvUmVtb3ZlLCByZXF1aXJlZEluaXRpYWxQcm9wcywgc3RhY2spIHtcbiAgaWYgKCEhc3RhY2sgJiYgIW1hdGNoU3RhY2tUcmFjZShzdGFjaywgbmV3IEVycm9yKCkuc3RhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cblxuICB2YXIgbG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgdmFyIHBydW5lUGF0aHMgPSBwcm9wc1RvUmVtb3ZlICE9PSB1bmRlZmluZWQgJiYgcHJvcHNUb1JlbW92ZSAhPT0gJycgPyBwcm9wc1RvUmVtb3ZlLnNwbGl0KC8gKy8pIDogW107XG4gIHZhciByZXF1aXJlZFBhdGhzID0gcmVxdWlyZWRJbml0aWFsUHJvcHMgIT09IHVuZGVmaW5lZCAmJiByZXF1aXJlZEluaXRpYWxQcm9wcyAhPT0gJycgPyByZXF1aXJlZEluaXRpYWxQcm9wcy5zcGxpdCgvICsvKSA6IFtdO1xuXG4gIGZ1bmN0aW9uIGlzUHJ1bmluZ05lZWRlZChyb290KSB7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFByb2Nlc3M7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVpcmVkUGF0aHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciByZXF1aXJlZFBhdGggPSByZXF1aXJlZFBhdGhzW2ldO1xuICAgICAgdmFyIGxhc3ROZXN0ZWRQcm9wTmFtZSA9IHJlcXVpcmVkUGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICAgICAgdmFyIGhhc1dpbGRjYXJkID0gcmVxdWlyZWRQYXRoLmluZGV4T2YoJy4qLicpID4gLTEgfHwgcmVxdWlyZWRQYXRoLmluZGV4T2YoJyouJykgPiAtMSB8fCByZXF1aXJlZFBhdGguaW5kZXhPZignLionKSA+IC0xIHx8IHJlcXVpcmVkUGF0aC5pbmRleE9mKCcuW10uJykgPiAtMSB8fCByZXF1aXJlZFBhdGguaW5kZXhPZignW10uJykgPiAtMSB8fCByZXF1aXJlZFBhdGguaW5kZXhPZignLltdJykgPiAtMTsgLy8gaWYgdGhlIHBhdGggaGFzIHdpbGRjYXJkLCBnZXRQcm9wZXJ0eUluQ2hhaW4gc2hvdWxkICdsb29rIHRocm91Z2gnIGNoYWluIHByb3BzXG5cbiAgICAgIHZhciBkZXRhaWxzID0gZ2V0V2lsZGNhcmRQcm9wZXJ0eUluQ2hhaW4ocm9vdCwgcmVxdWlyZWRQYXRoLCBoYXNXaWxkY2FyZCk7IC8vIHN0YXJ0IHZhbHVlIG9mICdzaG91bGRQcm9jZXNzJyBkdWUgdG8gY2hlY2tpbmcgYmVsb3dcblxuICAgICAgc2hvdWxkUHJvY2VzcyA9ICFoYXNXaWxkY2FyZDtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRldGFpbHMubGVuZ3RoOyBfaSArPSAxKSB7XG4gICAgICAgIGlmIChoYXNXaWxkY2FyZCkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgd2lsZGNhcmQsXG4gICAgICAgICAgLy8gYXQgbGVhc3Qgb25lICh8fCkgb2YgcHJvcHMgY2hhaW4gc2hvdWxkIGJlIHByZXNlbnQgaW4gb2JqZWN0XG4gICAgICAgICAgc2hvdWxkUHJvY2VzcyA9ICEoZGV0YWlsc1tfaV0uYmFzZVtsYXN0TmVzdGVkUHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHx8IHNob3VsZFByb2Nlc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGVhY2ggb25lICgmJikgb2YgdGhlbSBzaG91bGQgYmUgdGhlcmVcbiAgICAgICAgICBzaG91bGRQcm9jZXNzID0gIShkZXRhaWxzW19pXS5iYXNlW2xhc3ROZXN0ZWRQcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkgJiYgc2hvdWxkUHJvY2VzcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaG91bGRQcm9jZXNzO1xuICB9XG4gIC8qKlxuICAgKiBQcnVuZXMgcHJvcGVydGllcyBvZiAncm9vdCcgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSByb290XG4gICAqL1xuXG5cbiAgdmFyIGpzb25QcnVuZXIgPSBmdW5jdGlvbiBqc29uUHJ1bmVyKHJvb3QpIHtcbiAgICBpZiAocHJ1bmVQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZyh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIHJvb3QpO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc1BydW5pbmdOZWVkZWQocm9vdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByb290O1xuICAgICAgfSAvLyBpZiBwcnVuaW5nIGlzIG5lZWRlZCwgd2UgY2hlY2sgZXZlcnkgaW5wdXQgcGF0aFRvUmVtb3ZlXG4gICAgICAvLyBhbmQgZGVsZXRlIGl0IGlmIHJvb3QgaGFzIGl0XG5cblxuICAgICAgcHJ1bmVQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBvd25lck9iakFyciA9IGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluKHJvb3QsIHBhdGgsIHRydWUpO1xuICAgICAgICBvd25lck9iakFyci5mb3JFYWNoKGZ1bmN0aW9uIChvd25lck9iaikge1xuICAgICAgICAgIGlmIChvd25lck9iaiAhPT0gdW5kZWZpbmVkICYmIG93bmVyT2JqLmJhc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvd25lck9iai5iYXNlW293bmVyT2JqLnByb3BdO1xuICAgICAgICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZyhlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHJldHVybiByb290O1xuICB9O1xuXG4gIHZhciBuYXRpdmVKU09OUGFyc2UgPSBKU09OLnBhcnNlO1xuXG4gIHZhciBqc29uUGFyc2VXcmFwcGVyID0gZnVuY3Rpb24ganNvblBhcnNlV3JhcHBlcigpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgLy8gZGVhbGluZyB3aXRoIHN0cmluZ2lmaWVkIGpzb24gaW4gYXJncywgd2hpY2ggc2hvdWxkIGJlIHBhcnNlZC5cbiAgICAvLyBzbyB3ZSBjYWxsIG5hdGl2ZUpTT05QYXJzZSBhcyBKU09OLnBhcnNlIHdoaWNoIGlzIGJvdW5kIHRvIEpTT04gb2JqZWN0XG4gICAgdmFyIHJvb3QgPSBuYXRpdmVKU09OUGFyc2UuYXBwbHkoSlNPTiwgYXJncyk7XG4gICAgcmV0dXJuIGpzb25QcnVuZXIocm9vdCk7XG4gIH07IC8vIEpTT04ucGFyc2UgbW9ja2luZ1xuXG5cbiAganNvblBhcnNlV3JhcHBlci50b1N0cmluZyA9IG5hdGl2ZUpTT05QYXJzZS50b1N0cmluZy5iaW5kKG5hdGl2ZUpTT05QYXJzZSk7XG4gIEpTT04ucGFyc2UgPSBqc29uUGFyc2VXcmFwcGVyOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXG4gIHZhciBuYXRpdmVSZXNwb25zZUpzb24gPSBSZXNwb25zZS5wcm90b3R5cGUuanNvbjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuICB2YXIgcmVzcG9uc2VKc29uV3JhcHBlciA9IGZ1bmN0aW9uIHJlc3BvbnNlSnNvbldyYXBwZXIoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuYXRpdmVSZXNwb25zZUpzb24uYXBwbHkodGhpcyk7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4ganNvblBydW5lcihvYmopO1xuICAgIH0pO1xuICB9OyAvLyBkbyBub3RoaW5nIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBSZXNwb25zZSAoZS5nLiBJbnRlcm5ldCBFeHBsb3JlcilcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc3BvbnNlXG5cblxuICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmpzb24gPSByZXNwb25zZUpzb25XcmFwcGVyO1xufVxuanNvblBydW5lLm5hbWVzID0gWydqc29uLXBydW5lJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2pzb24tcHJ1bmUuanMnLCAndWJvLWpzb24tcHJ1bmUuanMnLCAndWJvLWpzb24tcHJ1bmUnLCAnYWJwLWpzb24tcHJ1bmUnXTtcbmpzb25QcnVuZS5pbmplY3Rpb25zID0gW2hpdCwgbWF0Y2hTdGFja1RyYWNlLCBnZXRXaWxkY2FyZFByb3BlcnR5SW5DaGFpbiwgdG9SZWdFeHAsIGdldFdpbGRjYXJkU3ltYm9sXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbFxuICogaWYgdGhlIHRleHQgb2YgdGhlIGNhbGxiYWNrIGlzIG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgc2VhcmNoIHN0cmluZyB3aGljaCBkb2VzIG5vdCBzdGFydCB3aXRoIGAhYDtcbiAqIG90aGVyd2lzZSBtaXNtYXRjaGVkIGNhbGxzIHNob3VsZCBiZSBkZWZ1c2VkLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vLXJlcXVlc3RhbmltYXRpb25mcmFtZS1pZmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnWywgc2VhcmNoXSlcbiAqIGBgYFxuICpcbiAqIC0gYHNlYXJjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqIElmIHN0YXJ0cyB3aXRoIGAhYCwgc2NyaXB0bGV0IHdpbGwgbm90IG1hdGNoIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayBidXQgYWxsIG90aGVyIHdpbGwgYmUgZGVmdXNlZC5cbiAqIElmIGRvIG5vdCBzdGFydCB3aXRoIGAhYCwgdGhlIHN0cmluZ2lmaWVkIGNhbGxiYWNrIHdpbGwgYmUgbWF0Y2hlZC5cbiAqXG4gKiBDYWxsIHdpdGggbm8gYXJndW1lbnQgd2lsbCBsb2cgYWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjYWxscyB3aGlsZSBkZWJ1Z2dpbmcuXG4gKiBTbyBkbyBub3QgdXNlIHRoZSBzY3JpcHRsZXQgd2l0aG91dCBhbnkgcGFyYW1ldGVyIGluIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzLlxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gUHJldmVudHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIG1hdGNoZXMgYC9cXC50ZXN0L2AuXG4gKiAgICAgYGBgYmFzaFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtcmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgJy9cXC50ZXN0LycpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBjYWxsIHdpbGwgYmUgcHJldmVudGVkOlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICB2YXIgdGltZXMgPSAwO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBjaGFuZ2UoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gJ25ldyB2YWx1ZSc7XG4gKiAgICAgICAgIGlmICh0aW1lcyA8IDIpIHtcbiAqICAgICAgICAgICAgIHRpbWVzICs9IDE7XG4gKiAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2hhbmdlKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGBgYFxuICogMi4gUHJldmVudHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgY2FsbHMgaWYgKipkb2VzIG5vdCBtYXRjaCoqICdjaGVjaycuXG4gKiAgICAgYGBgYmFzaFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtcmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgJyFjaGVjaycpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgb25seSB0aGUgZmlyc3QgY2FsbCB3aWxsIGJlIHByZXZlbnRlZDpcbiAqXG4gKiAgICAgYGBgamF2YXNjcmlwdFxuICogICAgIHZhciB0aW1lc0ZpcnN0ID0gMDtcbiAqICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gY2hhbmdlRmlyc3QoKSB7XG4gKiAgICAgICAgIHdpbmRvdy5jaGVjayA9ICdzaG91bGQgbm90IGJlIHByZXZlbnRlZCc7XG4gKiAgICAgICAgIGlmICh0aW1lc0ZpcnN0IDwgMikge1xuICogICAgICAgICAgICAgdGltZXNGaXJzdCArPSAxO1xuICogICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNoYW5nZUZpcnN0KTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqICAgICB2YXIgdGltZXNTZWNvbmQgPSAwO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBjaGFuZ2VTZWNvbmQoKSB7XG4gKiAgICAgICAgIHdpbmRvdy5zZWNvbmQgPSAnc2hvdWxkIGJlIHByZXZlbnRlZCc7XG4gKiAgICAgICAgIGlmICh0aW1lc1NlY29uZCA8IDIpIHtcbiAqICAgICAgICAgICAgIHRpbWVzU2Vjb25kICs9IDE7XG4gKiAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2hhbmdlU2Vjb25kKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50UmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNvdXJjZSwgbWF0Y2gpIHtcbiAgdmFyIG5hdGl2ZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7IC8vIGxvZ3MgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIGNvbnNvbGUgaWYgbm8gYXJndW1lbnRzIGhhdmUgYmVlbiBzcGVjaWZpZWRcblxuICB2YXIgc2hvdWxkTG9nID0gdHlwZW9mIG1hdGNoID09PSAndW5kZWZpbmVkJztcblxuICB2YXIgX3BhcnNlTWF0Y2hBcmcgPSBwYXJzZU1hdGNoQXJnKG1hdGNoKSxcbiAgICAgIGlzSW52ZXJ0ZWRNYXRjaCA9IF9wYXJzZU1hdGNoQXJnLmlzSW52ZXJ0ZWRNYXRjaCxcbiAgICAgIG1hdGNoUmVnZXhwID0gX3BhcnNlTWF0Y2hBcmcubWF0Y2hSZWdleHA7XG5cbiAgdmFyIHJhZldyYXBwZXIgPSBmdW5jdGlvbiByYWZXcmFwcGVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcblxuICAgIGlmIChzaG91bGRMb2cpIHtcbiAgICAgIHZhciBsb2dNZXNzYWdlID0gXCJsb2c6IHJlcXVlc3RBbmltYXRpb25GcmFtZShcXFwiXCIuY29uY2F0KGNhbGxiYWNrLnRvU3RyaW5nKCksIFwiXFxcIilcIik7XG4gICAgICBoaXQoc291cmNlLCBsb2dNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkUHJldmVudCA9IG1hdGNoUmVnZXhwLnRlc3QoY2FsbGJhY2sudG9TdHJpbmcoKSkgIT09IGlzSW52ZXJ0ZWRNYXRjaDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICByZXR1cm4gbmF0aXZlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5vb3BGdW5jKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmFwcGx5KHdpbmRvdywgW2NhbGxiYWNrXS5jb25jYXQoYXJncykpO1xuICB9O1xuXG4gIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByYWZXcmFwcGVyO1xufVxucHJldmVudFJlcXVlc3RBbmltYXRpb25GcmFtZS5uYW1lcyA9IFsncHJldmVudC1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm8tcmVxdWVzdEFuaW1hdGlvbkZyYW1lLWlmLmpzJywgJ3Viby1uby1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUtaWYuanMnLCAnbm9yYWZpZi5qcycsICd1Ym8tbm9yYWZpZi5qcycsICd1Ym8tbm8tcmVxdWVzdEFuaW1hdGlvbkZyYW1lLWlmJywgJ3Viby1ub3JhZmlmJ107XG5wcmV2ZW50UmVxdWVzdEFuaW1hdGlvbkZyYW1lLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgcGFyc2VNYXRjaEFyZywgdG9SZWdFeHAsIHN0YXJ0c1dpdGhdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBzZXQtY29va2llXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXRzIGEgY29va2llIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGFuZCB2YWx1ZS4gQ29va2llIHBhdGggZGVmYXVsdHMgdG8gcm9vdC5cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb29raWUnLCBuYW1lLCB2YWx1ZSlcbiAqIGBgYFxuICpcbiAqIC0gYG5hbWVgIC0gcmVxdWlyZWQsIGNvb2tpZSBuYW1lIHRvIGJlIHNldFxuICogLSBgdmFsdWVgIC0gcmVxdWlyZWQsIGNvb2tpZSB2YWx1ZTsgcG9zc2libGUgdmFsdWVzOlxuICogICAgIC0gbnVtYmVyIGA+PSAwICYmIDw9IDE1YFxuICogICAgIC0gb25lIG9mIHRoZSBwcmVkZWZpbmVkIGNvbnN0YW50czpcbiAqICAgICAgICAgLSBgdHJ1ZWAgLyBgVHJ1ZWBcbiAqICAgICAgICAgLSBgZmFsc2VgIC8gYEZhbHNlYFxuICogICAgICAgICAtIGB5ZXNgIC8gYFllc2AgLyBgWWBcbiAqICAgICAgICAgLSBgbm9gXG4gKiAgICAgICAgIC0gYG9rYCAvIGBPS2BcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvb2tpZScsICdSZWFkbHlDb29raWVDb25zZW50JywgJzEnXG4gKlxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvb2tpZScsICdnZHByLXNldHRpbmdzLWNvb2tpZScsICd0cnVlJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBzZXRDb29raWUoc291cmNlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgY29va2llRGF0YSA9IHByZXBhcmVDb29raWUobmFtZSwgdmFsdWUpO1xuXG4gIGlmIChjb29raWVEYXRhKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llRGF0YTtcbiAgfVxufVxuc2V0Q29va2llLm5hbWVzID0gWydzZXQtY29va2llJ107XG5zZXRDb29raWUuaW5qZWN0aW9ucyA9IFtoaXQsIG5hdGl2ZUlzTmFOLCBwcmVwYXJlQ29va2llXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IHNldC1jb29raWUtcmVsb2FkXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXRzIGEgY29va2llIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGFuZCB2YWx1ZSwgYW5kIHRoZW4gcmVsb2FkcyB0aGUgY3VycmVudCBwYWdlLlxuICogSWYgcmVsb2FkaW5nIG9wdGlvbiBpcyBub3QgbmVlZGVkLCB1c2UgW3NldC1jb29raWVdKCNzZXQtY29va2llKSBzY3JpcHRsZXQuXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtY29va2llLXJlbG9hZCcsIG5hbWUsIHZhbHVlKVxuICogYGBgXG4gKlxuICogLSBgbmFtZWAgLSByZXF1aXJlZCwgY29va2llIG5hbWUgdG8gYmUgc2V0XG4gKiAtIGB2YWx1ZWAgLSByZXF1aXJlZCwgY29va2llIHZhbHVlOyBwb3NzaWJsZSB2YWx1ZXM6XG4gKiAgICAgLSBudW1iZXIgYD49IDAgJiYgPD0gMTVgXG4gKiAgICAgLSBvbmUgb2YgdGhlIHByZWRlZmluZWQgY29uc3RhbnRzOlxuICogICAgICAgICAtIGB0cnVlYCAvIGBUcnVlYFxuICogICAgICAgICAtIGBmYWxzZWAgLyBgRmFsc2VgXG4gKiAgICAgICAgIC0gYHllc2AgLyBgWWVzYCAvIGBZYFxuICogICAgICAgICAtIGBub2BcbiAqICAgICAgICAgLSBgb2tgIC8gYE9LYFxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtY29va2llLXJlbG9hZCcsICdjaGVja2luZycsICdvaycpXG4gKlxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvb2tpZS1yZWxvYWQnLCAnZ2Rwci1zZXR0aW5ncy1jb29raWUnLCAnMScpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBzZXRDb29raWVSZWxvYWQoc291cmNlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgaXNDb29raWVBbHJlYWR5U2V0ID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jykuc29tZShmdW5jdGlvbiAoY29va2llU3RyKSB7XG4gICAgdmFyIHBvcyA9IGNvb2tpZVN0ci5pbmRleE9mKCc9Jyk7XG5cbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjb29raWVOYW1lID0gY29va2llU3RyLnNsaWNlKDAsIHBvcykudHJpbSgpO1xuICAgIHZhciBjb29raWVWYWx1ZSA9IGNvb2tpZVN0ci5zbGljZShwb3MgKyAxKS50cmltKCk7XG4gICAgcmV0dXJuIG5hbWUgPT09IGNvb2tpZU5hbWUgJiYgdmFsdWUgPT09IGNvb2tpZVZhbHVlO1xuICB9KTtcbiAgdmFyIHNob3VsZFJlbG9hZCA9ICFpc0Nvb2tpZUFscmVhZHlTZXQ7XG4gIHZhciBjb29raWVEYXRhID0gcHJlcGFyZUNvb2tpZShuYW1lLCB2YWx1ZSk7XG5cbiAgaWYgKGNvb2tpZURhdGEpIHtcbiAgICBoaXQoc291cmNlKTtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVEYXRhO1xuXG4gICAgaWYgKHNob3VsZFJlbG9hZCkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgfVxufVxuc2V0Q29va2llUmVsb2FkLm5hbWVzID0gWydzZXQtY29va2llLXJlbG9hZCddO1xuc2V0Q29va2llUmVsb2FkLmluamVjdGlvbnMgPSBbaGl0LCBuYXRpdmVJc05hTiwgcHJlcGFyZUNvb2tpZV07XG5cbi8qKlxuICogQHNjcmlwdGxldCBoaWRlLWluLXNoYWRvdy1kb21cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEhpZGVzIGVsZW1lbnRzIGluc2lkZSBvcGVuIHNoYWRvdyBET00gZWxlbWVudHMuXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdoaWRlLWluLXNoYWRvdy1kb20nLCBzZWxlY3RvclssIGJhc2VTZWxlY3Rvcl0pXG4gKiBgYGBcbiAqXG4gKiAtIGBzZWxlY3RvcmAg4oCUIHJlcXVpcmVkLCBDU1Mgc2VsZWN0b3Igb2YgZWxlbWVudCBpbiBzaGFkb3ctZG9tIHRvIGhpZGVcbiAqIC0gYGJhc2VTZWxlY3RvcmAg4oCUIG9wdGlvbmFsLCBzZWxlY3RvciBvZiBzcGVjaWZpYyBwYWdlIERPTSBlbGVtZW50LFxuICogbmFycm93cyBkb3duIHRoZSBwYXJ0IG9mIHRoZSBwYWdlIERPTSB3aGVyZSBzaGFkb3ctZG9tIGhvc3Qgc3VwcG9zZWQgdG8gYmUsXG4gKiBkZWZhdWx0cyB0byBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAqXG4gKiA+IGBiYXNlU2VsZWN0b3JgIHNob3VsZCBtYXRjaCBlbGVtZW50IG9mIHRoZSBwYWdlIERPTSwgYnV0IG5vdCBvZiBzaGFkb3cgRE9NXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiBgYGBcbiAqICEgaGlkZXMgbWVudSBiYXJcbiAqIHZpcnVzdG90YWwuY29tIyUjLy9zY3JpcHRsZXQoJ2hpZGUtaW4tc2hhZG93LWRvbScsICdpcm9uLXBhZ2VzJywgJ3Z0LXZpcnVzdG90YWwtYXBwJylcbiAqXG4gKiAhIGhpZGVzIGZsb2F0aW5nIGVsZW1lbnRcbiAqIHZpcnVzdG90YWwuY29tIyUjLy9zY3JpcHRsZXQoJ2hpZGUtaW4tc2hhZG93LWRvbScsICd2dC11aS1jb250YWN0LWZhYicpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBoaWRlSW5TaGFkb3dEb20oc291cmNlLCBzZWxlY3RvciwgYmFzZVNlbGVjdG9yKSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFNoYWRvd1Jvb3RcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NoYWRvd1Jvb3RcbiAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGlkZUVsZW1lbnQgPSBmdW5jdGlvbiBoaWRlRWxlbWVudCh0YXJnZXRFbGVtZW50KSB7XG4gICAgdmFyIERJU1BMQVlfTk9ORV9DU1MgPSAnZGlzcGxheTpub25lIWltcG9ydGFudDsnO1xuICAgIHRhcmdldEVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IERJU1BMQVlfTk9ORV9DU1M7XG4gIH07XG4gIC8qKlxuICAgKiBIYW5kbGVzIHNoYWRvdy1kb20gcGllcmNpbmcgYW5kIGhpZGluZyBvZiBmb3VuZCBlbGVtZW50c1xuICAgKi9cblxuXG4gIHZhciBoaWRlSGFuZGxlciA9IGZ1bmN0aW9uIGhpZGVIYW5kbGVyKCkge1xuICAgIC8vIHN0YXJ0IHZhbHVlIG9mIHNoYWRvdy1kb20gaG9zdHMgZm9yIHRoZSBwYWdlIGRvbVxuICAgIHZhciBob3N0RWxlbWVudHMgPSAhYmFzZVNlbGVjdG9yID8gZmluZEhvc3RFbGVtZW50cyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChiYXNlU2VsZWN0b3IpOyAvLyBpZiB0aGVyZSBpcyBzaGFkb3ctZG9tIGhvc3QsIHRoZXkgc2hvdWxkIGJlIGV4cGxvcmVkXG5cbiAgICB3aGlsZSAoaG9zdEVsZW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIGlzSGlkZGVuID0gZmFsc2U7XG5cbiAgICAgIHZhciBfcGllcmNlU2hhZG93RG9tID0gcGllcmNlU2hhZG93RG9tKHNlbGVjdG9yLCBob3N0RWxlbWVudHMpLFxuICAgICAgICAgIHRhcmdldHMgPSBfcGllcmNlU2hhZG93RG9tLnRhcmdldHMsXG4gICAgICAgICAgaW5uZXJIb3N0cyA9IF9waWVyY2VTaGFkb3dEb20uaW5uZXJIb3N0cztcblxuICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICAgICAgICBoaWRlRWxlbWVudCh0YXJnZXRFbCk7XG4gICAgICAgIGlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICB9IC8vIGNvbnRpbnVlIHRvIHBpZXJjZSBmb3IgaW5uZXIgc2hhZG93LWRvbSBob3N0c1xuICAgICAgLy8gYW5kIHNlYXJjaCBpbnNpZGUgdGhlbSB3aGlsZSB0aGUgbmV4dCBpdGVyYXRpb25cblxuXG4gICAgICBob3N0RWxlbWVudHMgPSBpbm5lckhvc3RzO1xuICAgIH1cbiAgfTtcblxuICBoaWRlSGFuZGxlcigpO1xuICBvYnNlcnZlRE9NQ2hhbmdlcyhoaWRlSGFuZGxlciwgdHJ1ZSk7XG59XG5oaWRlSW5TaGFkb3dEb20ubmFtZXMgPSBbJ2hpZGUtaW4tc2hhZG93LWRvbSddO1xuaGlkZUluU2hhZG93RG9tLmluamVjdGlvbnMgPSBbaGl0LCBvYnNlcnZlRE9NQ2hhbmdlcywgZmxhdHRlbiwgZmluZEhvc3RFbGVtZW50cywgcGllcmNlU2hhZG93RG9tXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IHJlbW92ZS1pbi1zaGFkb3ctZG9tXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZW1vdmVzIGVsZW1lbnRzIGluc2lkZSBvcGVuIHNoYWRvdyBET00gZWxlbWVudHMuXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtaW4tc2hhZG93LWRvbScsIHNlbGVjdG9yWywgYmFzZVNlbGVjdG9yXSlcbiAqIGBgYFxuICpcbiAqIC0gYHNlbGVjdG9yYCDigJQgcmVxdWlyZWQsIENTUyBzZWxlY3RvciBvZiBlbGVtZW50IGluIHNoYWRvdy1kb20gdG8gcmVtb3ZlXG4gKiAtIGBiYXNlU2VsZWN0b3JgIOKAlCBvcHRpb25hbCwgc2VsZWN0b3Igb2Ygc3BlY2lmaWMgcGFnZSBET00gZWxlbWVudCxcbiAqIG5hcnJvd3MgZG93biB0aGUgcGFydCBvZiB0aGUgcGFnZSBET00gd2hlcmUgc2hhZG93LWRvbSBob3N0IHN1cHBvc2VkIHRvIGJlLFxuICogZGVmYXVsdHMgdG8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gKlxuICogPiBgYmFzZVNlbGVjdG9yYCBzaG91bGQgbWF0Y2ggZWxlbWVudCBvZiB0aGUgcGFnZSBET00sIGJ1dCBub3Qgb2Ygc2hhZG93IERPTVxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogYGBgXG4gKiAhIHJlbW92ZXMgbWVudSBiYXJcbiAqIHZpcnVzdG90YWwuY29tIyUjLy9zY3JpcHRsZXQoJ3JlbW92ZS1pbi1zaGFkb3ctZG9tJywgJ2lyb24tcGFnZXMnLCAndnQtdmlydXN0b3RhbC1hcHAnKVxuICpcbiAqICEgcmVtb3ZlcyBmbG9hdGluZyBlbGVtZW50XG4gKiB2aXJ1c3RvdGFsLmNvbSMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtaW4tc2hhZG93LWRvbScsICd2dC11aS1jb250YWN0LWZhYicpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVJblNoYWRvd0RvbShzb3VyY2UsIHNlbGVjdG9yLCBiYXNlU2VsZWN0b3IpIHtcbiAgLy8gZG8gbm90aGluZyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgU2hhZG93Um9vdFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2hhZG93Um9vdFxuICBpZiAoIUVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCh0YXJnZXRFbGVtZW50KSB7XG4gICAgdGFyZ2V0RWxlbWVudC5yZW1vdmUoKTtcbiAgfTtcbiAgLyoqXG4gICAqIEhhbmRsZXMgc2hhZG93LWRvbSBwaWVyY2luZyBhbmQgcmVtb3Zpbmcgb2YgZm91bmQgZWxlbWVudHNcbiAgICovXG5cblxuICB2YXIgcmVtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoKSB7XG4gICAgLy8gc3RhcnQgdmFsdWUgb2Ygc2hhZG93LWRvbSBob3N0cyBmb3IgdGhlIHBhZ2UgZG9tXG4gICAgdmFyIGhvc3RFbGVtZW50cyA9ICFiYXNlU2VsZWN0b3IgPyBmaW5kSG9zdEVsZW1lbnRzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGJhc2VTZWxlY3Rvcik7IC8vIGlmIHRoZXJlIGlzIHNoYWRvdy1kb20gaG9zdCwgdGhleSBzaG91bGQgYmUgZXhwbG9yZWRcblxuICAgIHdoaWxlIChob3N0RWxlbWVudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgaXNSZW1vdmVkID0gZmFsc2U7XG5cbiAgICAgIHZhciBfcGllcmNlU2hhZG93RG9tID0gcGllcmNlU2hhZG93RG9tKHNlbGVjdG9yLCBob3N0RWxlbWVudHMpLFxuICAgICAgICAgIHRhcmdldHMgPSBfcGllcmNlU2hhZG93RG9tLnRhcmdldHMsXG4gICAgICAgICAgaW5uZXJIb3N0cyA9IF9waWVyY2VTaGFkb3dEb20uaW5uZXJIb3N0cztcblxuICAgICAgdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRFbCkge1xuICAgICAgICByZW1vdmVFbGVtZW50KHRhcmdldEVsKTtcbiAgICAgICAgaXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNSZW1vdmVkKSB7XG4gICAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgfSAvLyBjb250aW51ZSB0byBwaWVyY2UgZm9yIGlubmVyIHNoYWRvdy1kb20gaG9zdHNcbiAgICAgIC8vIGFuZCBzZWFyY2ggaW5zaWRlIHRoZW0gd2hpbGUgdGhlIG5leHQgaXRlcmF0aW9uXG5cblxuICAgICAgaG9zdEVsZW1lbnRzID0gaW5uZXJIb3N0cztcbiAgICB9XG4gIH07XG5cbiAgcmVtb3ZlSGFuZGxlcigpO1xuICBvYnNlcnZlRE9NQ2hhbmdlcyhyZW1vdmVIYW5kbGVyLCB0cnVlKTtcbn1cbnJlbW92ZUluU2hhZG93RG9tLm5hbWVzID0gWydyZW1vdmUtaW4tc2hhZG93LWRvbSddO1xucmVtb3ZlSW5TaGFkb3dEb20uaW5qZWN0aW9ucyA9IFtoaXQsIG9ic2VydmVET01DaGFuZ2VzLCBmbGF0dGVuLCBmaW5kSG9zdEVsZW1lbnRzLCBwaWVyY2VTaGFkb3dEb21dO1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgbm8tZmxvY1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgdXNpbmcgR29vZ2xlIENocm9tZSB0cmFja2luZyBmZWF0dXJlIGNhbGxlZCBGZWRlcmF0ZWQgTGVhcm5pbmcgb2YgQ29ob3J0cyAoYWthIFwiRkxvQ1wiKVxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25vLWZsb2Nqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ25vLWZsb2MnKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gbm9GbG9jKHNvdXJjZSkge1xuICB2YXIgRkxPQ19QUk9QRVJUWV9OQU1FID0gJ2ludGVyZXN0Q29ob3J0JztcblxuICBpZiAoRG9jdW1lbnQgaW5zdGFuY2VvZiBPYmplY3QgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoRG9jdW1lbnQucHJvdG90eXBlLCBGTE9DX1BST1BFUlRZX05BTUUpIHx8IERvY3VtZW50LnByb3RvdHlwZVtGTE9DX1BST1BFUlRZX05BTUVdIGluc3RhbmNlb2YgRnVuY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGRvY3VtZW50LmludGVyZXN0Q29ob3J0KCkgaXMgYXN5bmMgZnVuY3Rpb24gc28gaXQncyBiZXR0ZXIgdG8gcmV0dXJuIFByb21pc2UucmVqZWN0KClcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvZmxvYy9ibG9iL2RjZDRjMDQyZmE2YTgxYjA0OGUwNGE3OGIxODRlYTQyMDNhNzUyMTkvUkVBRE1FLm1kXG5cblxuICBEb2N1bWVudC5wcm90b3R5cGVbRkxPQ19QUk9QRVJUWV9OQU1FXSA9IG5vb3BQcm9taXNlUmVqZWN0O1xuICBoaXQoc291cmNlKTtcbn1cbm5vRmxvYy5uYW1lcyA9IFsnbm8tZmxvYycsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbiduby1mbG9jLmpzJywgJ3Viby1uby1mbG9jLmpzJywgJ3Viby1uby1mbG9jJ107XG5ub0Zsb2MuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BQcm9taXNlUmVqZWN0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1mZXRjaFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgYGZldGNoYCBjYWxscyBpZiAqKmFsbCoqIGdpdmVuIHBhcmFtZXRlcnMgbWF0Y2hcbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNuby1mZXRjaC1pZmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1mZXRjaCdbLCBwcm9wc1RvTWF0Y2hdKVxuICogYGBgXG4gKlxuICogLSBgcHJvcHNUb01hdGNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHByb3BlcnRpZXMgdG8gbWF0Y2g7IHBvc3NpYmxlIHByb3BzOlxuICogICAtIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHRoZSBVUkwgcGFzc2VkIHRvIGZldGNoIGNhbGw7IGVtcHR5IHN0cmluZyBvciB3aWxkY2FyZCBgKmAgZm9yIGFsbCBmZXRjaCBjYWxscyBtYXRjaFxuICogICAtIGNvbG9uLXNlcGFyYXRlZCBwYWlycyBgbmFtZTp2YWx1ZWAgd2hlcmVcbiAqICAgICAtIGBuYW1lYCBpcyBbYGluaXRgIG9wdGlvbiBuYW1lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaCNwYXJhbWV0ZXJzKVxuICogICAgIC0gYHZhbHVlYCBpcyBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBwYXNzZWQgdG8gZmV0Y2ggY2FsbFxuICpcbiAqID4gVXNhZ2Ugd2l0aCBubyBhcmd1bWVudHMgd2lsbCBsb2cgZmV0Y2ggY2FsbHMgdG8gYnJvd3NlciBjb25zb2xlO1xuICogd2hpY2ggaXMgdXNlZnVsbCBmb3IgZGVidWdnaW5nIGJ1dCBwZXJtaXR0ZWQgZm9yIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzLlxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gUHJldmVudCBhbGwgZmV0Y2ggY2FsbHNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWZldGNoJywgJyonKVxuICogICAgIGBgYFxuICpcbiAqIDIuIFByZXZlbnQgZmV0Y2ggY2FsbCBmb3Igc3BlY2lmaWMgdXJsXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1mZXRjaCcsICcvdXJsXFxcXC5wYXJ0LycpXG4gKiAgICAgYGBgXG4gKlxuICogMy4gUHJldmVudCBmZXRjaCBjYWxsIGZvciBzcGVjaWZpYyByZXF1ZXN0IG1ldGhvZFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZmV0Y2gnLCAnbWV0aG9kOkhFQUQnKVxuICogICAgIGBgYFxuICpcbiAqIDQuIFByZXZlbnQgZmV0Y2ggY2FsbCBmb3Igc3BlY2lmaWMgdXJsIGFuZCByZXF1ZXN0IG1ldGhvZFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZmV0Y2gnLCAnL3NwZWNpZmllZF91cmxfcGFydC8gbWV0aG9kOi9IRUFEfEdFVC8nKVxuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50RmV0Y2goc291cmNlLCBwcm9wc1RvTWF0Y2gpIHtcbiAgLy8gZG8gbm90aGluZyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgZmV0Y2ggb3IgUHJveHkgKGUuZy4gSW50ZXJuZXQgRXhwbG9yZXIpXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dPcldvcmtlckdsb2JhbFNjb3BlL2ZldGNoXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGFuZGxlcldyYXBwZXIgPSBmdW5jdGlvbiBoYW5kbGVyV3JhcHBlcih0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xuICAgIHZhciBmZXRjaERhdGEgPSBnZXRGZXRjaERhdGEoYXJncyk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzVG9NYXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGxvZyBpZiBubyBwcm9wc1RvTWF0Y2ggZ2l2ZW5cbiAgICAgIHZhciBsb2dNZXNzYWdlID0gXCJsb2c6IGZldGNoKCBcIi5jb25jYXQob2JqZWN0VG9TdHJpbmcoZmV0Y2hEYXRhKSwgXCIgKVwiKTtcbiAgICAgIGhpdChzb3VyY2UsIGxvZ01lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAocHJvcHNUb01hdGNoID09PSAnJyB8fCBwcm9wc1RvTWF0Y2ggPT09IGdldFdpbGRjYXJkU3ltYm9sKCkpIHtcbiAgICAgIC8vIHByZXZlbnQgYWxsIGZldGNoIGNhbGxzXG4gICAgICBzaG91bGRQcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hdGNoRGF0YSA9IGNvbnZlcnRNYXRjaFByb3BzVG9PYmoocHJvcHNUb01hdGNoKTsgLy8gcHJldmVudCBvbmx5IGlmIGFsbCBwcm9wcyBtYXRjaFxuXG4gICAgICBzaG91bGRQcmV2ZW50ID0gT2JqZWN0LmtleXMobWF0Y2hEYXRhKS5ldmVyeShmdW5jdGlvbiAobWF0Y2hLZXkpIHtcbiAgICAgICAgdmFyIG1hdGNoVmFsdWUgPSBtYXRjaERhdGFbbWF0Y2hLZXldO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZldGNoRGF0YSwgbWF0Y2hLZXkpICYmIG1hdGNoVmFsdWUudGVzdChmZXRjaERhdGFbbWF0Y2hLZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHJldHVybiBub29wUHJvbWlzZVJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xuXG4gIHZhciBmZXRjaEhhbmRsZXIgPSB7XG4gICAgYXBwbHk6IGhhbmRsZXJXcmFwcGVyXG4gIH07XG4gIGZldGNoID0gbmV3IFByb3h5KGZldGNoLCBmZXRjaEhhbmRsZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWdsb2JhbC1hc3NpZ25cbn1cbnByZXZlbnRGZXRjaC5uYW1lcyA9IFsncHJldmVudC1mZXRjaCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbiduby1mZXRjaC1pZi5qcycsICd1Ym8tbm8tZmV0Y2gtaWYuanMnLCAndWJvLW5vLWZldGNoLWlmJ107XG5wcmV2ZW50RmV0Y2guaW5qZWN0aW9ucyA9IFtoaXQsIGdldEZldGNoRGF0YSwgb2JqZWN0VG9TdHJpbmcsIGNvbnZlcnRNYXRjaFByb3BzVG9PYmosIG5vb3BQcm9taXNlUmVzb2x2ZSwgZ2V0V2lsZGNhcmRTeW1ib2wsIHRvUmVnRXhwLCBpc0VtcHR5T2JqZWN0LCBnZXRSZXF1ZXN0RGF0YSwgZ2V0T2JqZWN0RW50cmllcywgZ2V0T2JqZWN0RnJvbUVudHJpZXNdO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBtdXN0IGV4cG9ydCBhbGwgc2NyaXB0bGV0cyB3aGljaCBzaG91bGQgYmUgYWNjZXNzaWJsZVxuICovXG5cbnZhciBzY3JpcHRsZXRMaXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBhYm9ydE9uUHJvcGVydHlSZWFkOiBhYm9ydE9uUHJvcGVydHlSZWFkLFxuICAgIGFib3J0T25Qcm9wZXJ0eVdyaXRlOiBhYm9ydE9uUHJvcGVydHlXcml0ZSxcbiAgICBwcmV2ZW50U2V0VGltZW91dDogcHJldmVudFNldFRpbWVvdXQsXG4gICAgcHJldmVudFNldEludGVydmFsOiBwcmV2ZW50U2V0SW50ZXJ2YWwsXG4gICAgcHJldmVudFdpbmRvd09wZW46IHByZXZlbnRXaW5kb3dPcGVuLFxuICAgIGFib3J0Q3VycmVudElubGluZVNjcmlwdDogYWJvcnRDdXJyZW50SW5saW5lU2NyaXB0LFxuICAgIHNldENvbnN0YW50OiBzZXRDb25zdGFudCxcbiAgICByZW1vdmVDb29raWU6IHJlbW92ZUNvb2tpZSxcbiAgICBwcmV2ZW50QWRkRXZlbnRMaXN0ZW5lcjogcHJldmVudEFkZEV2ZW50TGlzdGVuZXIsXG4gICAgcHJldmVudEJhYjogcHJldmVudEJhYixcbiAgICBub3dlYnJ0Yzogbm93ZWJydGMsXG4gICAgbG9nQWRkRXZlbnRMaXN0ZW5lcjogbG9nQWRkRXZlbnRMaXN0ZW5lcixcbiAgICBsb2dFdmFsOiBsb2dFdmFsLFxuICAgIGxvZzogbG9nLFxuICAgIG5vZXZhbDogbm9ldmFsLFxuICAgIHByZXZlbnRFdmFsSWY6IHByZXZlbnRFdmFsSWYsXG4gICAgcHJldmVudEZhYjogcHJldmVudEZhYixcbiAgICBzZXRQb3BhZHNEdW1teTogc2V0UG9wYWRzRHVtbXksXG4gICAgcHJldmVudFBvcGFkc05ldDogcHJldmVudFBvcGFkc05ldCxcbiAgICBwcmV2ZW50QWRmbHk6IHByZXZlbnRBZGZseSxcbiAgICBkZWJ1Z09uUHJvcGVydHlSZWFkOiBkZWJ1Z09uUHJvcGVydHlSZWFkLFxuICAgIGRlYnVnT25Qcm9wZXJ0eVdyaXRlOiBkZWJ1Z09uUHJvcGVydHlXcml0ZSxcbiAgICBkZWJ1Z0N1cnJlbnRJbmxpbmVTY3JpcHQ6IGRlYnVnQ3VycmVudElubGluZVNjcmlwdCxcbiAgICByZW1vdmVBdHRyOiByZW1vdmVBdHRyLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICBkaXNhYmxlTmV3dGFiTGlua3M6IGRpc2FibGVOZXd0YWJMaW5rcyxcbiAgICBhZGp1c3RTZXRJbnRlcnZhbDogYWRqdXN0U2V0SW50ZXJ2YWwsXG4gICAgYWRqdXN0U2V0VGltZW91dDogYWRqdXN0U2V0VGltZW91dCxcbiAgICBkaXJTdHJpbmc6IGRpclN0cmluZyxcbiAgICBqc29uUHJ1bmU6IGpzb25QcnVuZSxcbiAgICBwcmV2ZW50UmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBwcmV2ZW50UmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuICAgIHNldENvb2tpZTogc2V0Q29va2llLFxuICAgIHNldENvb2tpZVJlbG9hZDogc2V0Q29va2llUmVsb2FkLFxuICAgIGhpZGVJblNoYWRvd0RvbTogaGlkZUluU2hhZG93RG9tLFxuICAgIHJlbW92ZUluU2hhZG93RG9tOiByZW1vdmVJblNoYWRvd0RvbSxcbiAgICBub0Zsb2M6IG5vRmxvYyxcbiAgICBwcmV2ZW50RmV0Y2g6IHByZXZlbnRGZXRjaFxufSk7XG5cbi8qKlxuICogU3RvcmUgb2YgQURHIHJlZGlyZWN0cyBuYW1lcyBhbmQgdGhpZXIgYW5hbG9ncy5cbiAqIEFzIGl0IGlzIG5vdCBhIGNvbXBhdGliaWxpdHkgdGFibGUsIG5vIG5lZWQgdG8ga2VlcCBpbiByZWRpcmVjdHMgYXJyYXkgdGhpcmQtcGFydHkgcmVkaXJlY3RzLlxuICpcbiAqIE5lZWRlZCBvbmx5IGZvciBjb252ZXJpb24gcHVycG9zZXMuXG4gKiBlLmcuIGdvb2dsZXRhZ21hbmFnZXItZ3RtIGlzIHJlbW92ZWQgYW5kIHNob3VsZCBiZSByZW1vdmVkIGZyb20gY29tcGF0aWJpbGl0eSB0YWJsZSBhcyB3ZWxsXG4gKiBidXQgbm93IGl0IHdvcmtzIGFzIGFsaWFzIGZvciBnb29nbGUtYW5hbHl0aWNzIHNvIGl0IHNob3VsZCBzdGF5IHZhbGlkIGZvciBjb21waWxlclxuICovXG52YXIgcmVkaXJlY3RzID0gW3tcbiAgYWRnOiAnMXgxLXRyYW5zcGFyZW50LmdpZicsXG4gIHVibzogJzF4MS5naWYnLFxuICBhYnA6ICcxeDEtdHJhbnNwYXJlbnQtZ2lmJ1xufSwge1xuICBhZGc6ICcyeDItdHJhbnNwYXJlbnQucG5nJyxcbiAgdWJvOiAnMngyLnBuZycsXG4gIGFicDogJzJ4Mi10cmFuc3BhcmVudC1wbmcnXG59LCB7XG4gIGFkZzogJzN4Mi10cmFuc3BhcmVudC5wbmcnLFxuICB1Ym86ICczeDIucG5nJyxcbiAgYWJwOiAnM3gyLXRyYW5zcGFyZW50LXBuZydcbn0sIHtcbiAgYWRnOiAnMzJ4MzItdHJhbnNwYXJlbnQucG5nJyxcbiAgdWJvOiAnMzJ4MzIucG5nJyxcbiAgYWJwOiAnMzJ4MzItdHJhbnNwYXJlbnQtcG5nJ1xufSwge1xuICBhZGc6ICdhbWF6b24tYXBzdGFnJyxcbiAgdWJvOiAnYW1hem9uX2Fwc3RhZy5qcydcbn0sIHtcbiAgYWRnOiAnZ29vZ2xlLWFuYWx5dGljcycsXG4gIHVibzogJ2dvb2dsZS1hbmFseXRpY3NfYW5hbHl0aWNzLmpzJ1xufSwge1xuICBhZGc6ICdnb29nbGUtYW5hbHl0aWNzLWdhJyxcbiAgdWJvOiAnZ29vZ2xlLWFuYWx5dGljc19nYS5qcydcbn0sIHtcbiAgYWRnOiAnZ29vZ2xlc3luZGljYXRpb24tYWRzYnlnb29nbGUnLFxuICB1Ym86ICdnb29nbGVzeW5kaWNhdGlvbl9hZHNieWdvb2dsZS5qcydcbn0sIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzEyN1xuICBhZGc6ICdnb29nbGV0YWdtYW5hZ2VyLWd0bScsXG4gIHVibzogJ2dvb2dsZS1hbmFseXRpY3NfZ2EuanMnXG59LCB7XG4gIGFkZzogJ2dvb2dsZXRhZ3NlcnZpY2VzLWdwdCcsXG4gIHVibzogJ2dvb2dsZXRhZ3NlcnZpY2VzX2dwdC5qcydcbn0sIHtcbiAgYWRnOiAnbWV0cmlrYS15YW5kZXgtd2F0Y2gnXG59LCB7XG4gIGFkZzogJ21ldHJpa2EteWFuZGV4LXRhZydcbn0sIHtcbiAgYWRnOiAnbm9ldmFsJyxcbiAgdWJvOiAnbm9ldmFsLXNpbGVudC5qcydcbn0sIHtcbiAgYWRnOiAnbm9vcGNzcycsXG4gIGFicDogJ2JsYW5rLWNzcydcbn0sIHtcbiAgYWRnOiAnbm9vcGZyYW1lJyxcbiAgdWJvOiAnbm9vcC5odG1sJyxcbiAgYWJwOiAnYmxhbmstaHRtbCdcbn0sIHtcbiAgYWRnOiAnbm9vcGpzJyxcbiAgdWJvOiAnbm9vcC5qcycsXG4gIGFicDogJ2JsYW5rLWpzJ1xufSwge1xuICBhZGc6ICdub29wdGV4dCcsXG4gIHVibzogJ25vb3AudHh0JyxcbiAgYWJwOiAnYmxhbmstdGV4dCdcbn0sIHtcbiAgYWRnOiAnbm9vcG1wMy0wLjFzJyxcbiAgdWJvOiAnbm9vcC0wLjFzLm1wMycsXG4gIGFicDogJ2JsYW5rLW1wMydcbn0sIHtcbiAgYWRnOiAnbm9vcG1wNC0xcycsXG4gIHVibzogJ25vb3AtMXMubXA0JyxcbiAgYWJwOiAnYmxhbmstbXA0J1xufSwge1xuICBhZGc6ICdub29wdm1hcC0xLjAnLFxuICB1Ym86ICdub29wLXZtYXAxLjAueG1sJ1xufSwge1xuICBhZGc6ICdub29wdmFzdC0yLjAnXG59LCB7XG4gIGFkZzogJ25vb3B2YXN0LTMuMCdcbn0sIHtcbiAgYWRnOiAncHJldmVudC1iYWInLFxuICB1Ym86ICdub2JhYi5qcydcbn0sIHtcbiAgYWRnOiAncHJldmVudC1mYWItMy4yLjAnLFxuICB1Ym86ICdub2ZhYi5qcydcbn0sIHtcbiAgYWRnOiAncHJldmVudC1wb3BhZHMtbmV0JyxcbiAgdWJvOiAncG9wYWRzLmpzJ1xufSwge1xuICBhZGc6ICdzY29yZWNhcmRyZXNlYXJjaC1iZWFjb24nLFxuICB1Ym86ICdzY29yZWNhcmRyZXNlYXJjaF9iZWFjb24uanMnXG59LCB7XG4gIGFkZzogJ3NldC1wb3BhZHMtZHVtbXknLFxuICB1Ym86ICdwb3BhZHMtZHVtbXkuanMnXG59LCB7XG4gIGFkZzogJ2VtcHR5JyxcbiAgdWJvOiAnZW1wdHknXG59XTtcblxudmFyIEpTX1JVTEVfTUFSS0VSID0gJyMlIyc7XG52YXIgQ09NTUVOVF9NQVJLRVIgPSAnISc7XG4vKipcbiAqIENoZWNrcyBpZiBydWxlIHRleHQgaXMgY29tbWVudCBlLmcuICEhZXhhbXBsZS5vcmcjIytqcyhzZXQtY29uc3RhbnQuanMsIHRlc3QsIGZhbHNlKVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxudmFyIGlzQ29tbWVudCA9IGZ1bmN0aW9uIGlzQ29tbWVudChydWxlKSB7XG4gIHJldHVybiBzdGFydHNXaXRoKHJ1bGUsIENPTU1FTlRfTUFSS0VSKTtcbn07XG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXG4gKiBTY3JpcHRsZXRzXG4gKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qKlxuICogdUJsb2NrIHNjcmlwdGxldCBydWxlIG1hc2tcbiAqL1xuXG5cbnZhciBVQk9fU0NSSVBUTEVUX01BU0tfUkVHID0gLyNAPyNzY3JpcHQ6aW5qZWN0fCNAPyNcXHMqXFwranMvO1xudmFyIFVCT19TQ1JJUFRMRVRfTUFTS18xID0gJyMjK2pzJztcbnZhciBVQk9fU0NSSVBUTEVUX01BU0tfMiA9ICcjI3NjcmlwdDppbmplY3QnO1xudmFyIFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0tfMSA9ICcjQCMranMnO1xudmFyIFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0tfMiA9ICcjQCNzY3JpcHQ6aW5qZWN0Jztcbi8qKlxuICogQWRCbG9jayBQbHVzIHNuaXBwZXQgcnVsZSBtYXNrXG4gKi9cblxudmFyIEFCUF9TQ1JJUFRMRVRfTUFTSyA9ICcjJCMnO1xudmFyIEFCUF9TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0sgPSAnI0AkIyc7XG4vKipcbiAqIEFkR3VhcmQgQ1NTIHJ1bGUgbWFza1xuICovXG5cbnZhciBBREdfQ1NTX01BU0tfUkVHID0gLyNAP1xcJCMuKz9cXHMqXFx7LipcXH1cXHMqJC9nO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBydWxlYCBpcyBBZEd1YXJkIHNjcmlwdGxldCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIHJ1bGUgdGV4dFxuICovXG5cbnZhciBpc0FkZ1NjcmlwdGxldFJ1bGUgPSBmdW5jdGlvbiBpc0FkZ1NjcmlwdGxldFJ1bGUocnVsZSkge1xuICByZXR1cm4gIWlzQ29tbWVudChydWxlKSAmJiBydWxlLmluZGV4T2YoQURHX1NDUklQVExFVF9NQVNLKSA+IC0xO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBgcnVsZWAgaXMgdUJPIHNjcmlwdGxldCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBydWxlIHRleHRcbiAqL1xuXG5cbnZhciBpc1Vib1NjcmlwdGxldFJ1bGUgPSBmdW5jdGlvbiBpc1Vib1NjcmlwdGxldFJ1bGUocnVsZSkge1xuICByZXR1cm4gKHJ1bGUuaW5kZXhPZihVQk9fU0NSSVBUTEVUX01BU0tfMSkgPiAtMSB8fCBydWxlLmluZGV4T2YoVUJPX1NDUklQVExFVF9NQVNLXzIpID4gLTEgfHwgcnVsZS5pbmRleE9mKFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0tfMSkgPiAtMSB8fCBydWxlLmluZGV4T2YoVUJPX1NDUklQVExFVF9FWENFUFRJT05fTUFTS18yKSA+IC0xKSAmJiBVQk9fU0NSSVBUTEVUX01BU0tfUkVHLnRlc3QocnVsZSkgJiYgIWlzQ29tbWVudChydWxlKTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYHJ1bGVgIGlzIEFkQmxvY2sgUGx1cyBzbmlwcGV0XG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBydWxlIHRleHRcbiAqL1xuXG5cbnZhciBpc0FicFNuaXBwZXRSdWxlID0gZnVuY3Rpb24gaXNBYnBTbmlwcGV0UnVsZShydWxlKSB7XG4gIHJldHVybiAocnVsZS5pbmRleE9mKEFCUF9TQ1JJUFRMRVRfTUFTSykgPiAtMSB8fCBydWxlLmluZGV4T2YoQUJQX1NDUklQVExFVF9FWENFUFRJT05fTUFTSykgPiAtMSkgJiYgcnVsZS5zZWFyY2goQURHX0NTU19NQVNLX1JFRykgPT09IC0xICYmICFpc0NvbW1lbnQocnVsZSk7XG59O1xuLyoqXG4gKiBGaW5kcyBzY3JpcHRsZXQgYnkgaXQncyBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHNjcmlwdGxldCBuYW1lXG4gKi9cblxuXG52YXIgZ2V0U2NyaXB0bGV0QnlOYW1lID0gZnVuY3Rpb24gZ2V0U2NyaXB0bGV0QnlOYW1lKG5hbWUpIHtcbiAgdmFyIHNjcmlwdGxldHMgPSBPYmplY3Qua2V5cyhzY3JpcHRsZXRMaXN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBzY3JpcHRsZXRMaXN0W2tleV07XG4gIH0pO1xuICByZXR1cm4gc2NyaXB0bGV0cy5maW5kKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMubmFtZXMgLy8gZnVsbCBtYXRjaCBuYW1lIGNoZWNraW5nXG4gICAgJiYgKHMubmFtZXMuaW5kZXhPZihuYW1lKSA+IC0xIC8vIG9yIGNoZWNrIHVibyBhbGlhcyBuYW1lIHdpdGhvdXQgJy5qcycgYXQgdGhlIGVuZFxuICAgIHx8ICFlbmRzV2l0aChuYW1lLCAnLmpzJykgJiYgcy5uYW1lcy5pbmRleE9mKFwiXCIuY29uY2F0KG5hbWUsIFwiLmpzXCIpKSA+IC0xKTtcbiAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjcmlwdGxldCBuYW1lIGlzIHZhbGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFNjcmlwdGxldCBuYW1lXG4gKi9cblxuXG52YXIgaXNWYWxpZFNjcmlwdGxldE5hbWUgPSBmdW5jdGlvbiBpc1ZhbGlkU2NyaXB0bGV0TmFtZShuYW1lKSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzY3JpcHRsZXQgPSBnZXRTY3JpcHRsZXRCeU5hbWUobmFtZSk7XG5cbiAgaWYgKCFzY3JpcHRsZXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXG4gKiBSZWRpcmVjdHNcbiAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyoqXG4gKiBSZWRpcmVjdCByZXNvdXJjZXMgbWFya2Vyc1xuICovXG5cblxudmFyIEFER19VQk9fUkVESVJFQ1RfTUFSS0VSID0gJ3JlZGlyZWN0PSc7XG52YXIgQUJQX1JFRElSRUNUX01BUktFUiA9ICdyZXdyaXRlPWFicC1yZXNvdXJjZTonO1xudmFyIEVNUFRZX1JFRElSRUNUX01BUktFUiA9ICdlbXB0eSc7XG52YXIgVkFMSURfU09VUkNFX1RZUEVTID0gWydpbWFnZScsICdtZWRpYScsICdzdWJkb2N1bWVudCcsICdzdHlsZXNoZWV0JywgJ3NjcmlwdCcsICd4bWxodHRwcmVxdWVzdCcsICdvdGhlciddO1xuLyoqXG4gKiBTb3VyY2UgdHlwZXMgZm9yIHJlZGlyZWN0IHJ1bGVzIGlmIHRoZXJlIGlzIG5vIG9uZSBvZiB0aGVtLlxuICogVXNlZCBmb3IgQURHIC0+IFVCTyBjb252ZXJzaW9uLlxuICovXG5cbnZhciBBQlNFTlRfU09VUkNFX1RZUEVfUkVQTEFDRU1FTlQgPSBbe1xuICBOQU1FOiAnbm9vcHRleHQnLFxuICBUWVBFUzogVkFMSURfU09VUkNFX1RZUEVTXG59LCB7XG4gIE5BTUU6ICdub29wanMnLFxuICBUWVBFUzogWydzY3JpcHQnXVxufSwge1xuICBOQU1FOiAnbm9vcGZyYW1lJyxcbiAgVFlQRVM6IFsnc3ViZG9jdW1lbnQnXVxufSwge1xuICBOQU1FOiAnMXgxLXRyYW5zcGFyZW50LmdpZicsXG4gIFRZUEVTOiBbJ2ltYWdlJ11cbn0sIHtcbiAgTkFNRTogJ25vb3BtcDMtMC4xcycsXG4gIFRZUEVTOiBbJ21lZGlhJ11cbn0sIHtcbiAgTkFNRTogJ25vb3BtcDQtMXMnLFxuICBUWVBFUzogWydtZWRpYSddXG59LCB7XG4gIE5BTUU6ICdnb29nbGVzeW5kaWNhdGlvbi1hZHNieWdvb2dsZScsXG4gIFRZUEVTOiBbJ3htbGh0dHByZXF1ZXN0JywgJ3NjcmlwdCddXG59LCB7XG4gIE5BTUU6ICdnb29nbGUtYW5hbHl0aWNzJyxcbiAgVFlQRVM6IFsnc2NyaXB0J11cbn0sIHtcbiAgTkFNRTogJ2dvb2dsZXRhZ3NlcnZpY2VzLWdwdCcsXG4gIFRZUEVTOiBbJ3NjcmlwdCddXG59XTtcbnZhciB2YWxpZEFkZ1JlZGlyZWN0cyA9IHJlZGlyZWN0cy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBlbC5hZGc7XG59KTtcbi8qKlxuICogQ29tcGF0aWJpbGl0eSBvYmplY3Qgd2hlcmUgS0VZUyA9IFVCTyByZWRpcmVjdCBuYW1lcyBhbmQgVkFMVUVTID0gQURHIHJlZGlyZWN0IG5hbWVzXG4gKiBJdCdzIHVzZWQgZm9yIFVCTyAtPiBBREcgY29udmVydGluZ1xuICovXG5cbnZhciB1Ym9Ub0FkZ0NvbXBhdGliaWxpdHkgPSBnZXRPYmplY3RGcm9tRW50cmllcyh2YWxpZEFkZ1JlZGlyZWN0cy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBlbC51Ym87XG59KS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBbZWwudWJvLCBlbC5hZGddO1xufSkpO1xuLyoqXG4gKiBDb21wYXRpYmlsaXR5IG9iamVjdCB3aGVyZSBLRVlTID0gQUJQIHJlZGlyZWN0IG5hbWVzIGFuZCBWQUxVRVMgPSBBREcgcmVkaXJlY3QgbmFtZXNcbiAqIEl0J3MgdXNlZCBmb3IgQUJQIC0+IEFERyBjb252ZXJ0aW5nXG4gKi9cblxudmFyIGFicFRvQWRnQ29tcGF0aWJpbGl0eSA9IGdldE9iamVjdEZyb21FbnRyaWVzKHZhbGlkQWRnUmVkaXJlY3RzLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmFicDtcbn0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIFtlbC5hYnAsIGVsLmFkZ107XG59KSk7XG4vKipcbiAqIENvbXBhdGliaWxpdHkgb2JqZWN0IHdoZXJlIEtFWVMgPSBVQk8gcmVkaXJlY3QgbmFtZXMgYW5kIFZBTFVFUyA9IEFERyByZWRpcmVjdCBuYW1lc1xuICogSXQncyB1c2VkIGZvciBBREcgLT4gVUJPIGNvbnZlcnRpbmdcbiAqL1xuXG52YXIgYWRnVG9VYm9Db21wYXRpYmlsaXR5ID0gZ2V0T2JqZWN0RnJvbUVudHJpZXModmFsaWRBZGdSZWRpcmVjdHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZWwudWJvO1xufSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gW2VsLmFkZywgZWwudWJvXTtcbn0pKTtcbi8qKlxuICogTmVlZGVkIGZvciBBZEd1YXJkIHJlZGlyZWN0IG5hbWVzIHZhbGlkYXRpb24gd2hlcmUgS0VZUyA9ICoqdmFsaWQqKiBBZEd1YXJkIHJlZGlyZWN0IG5hbWVzXG4gKiAnYWRnVG9VYm9Db21wYXRpYmlsaXR5JyBpcyBzdGlsbCBuZWVkZWQgZm9yIEFERyAtPiBVQk8gY29udmVydGluZ1xuICovXG5cbnZhciB2YWxpZEFkZ0NvbXBhdGliaWxpdHkgPSBnZXRPYmplY3RGcm9tRW50cmllcyh2YWxpZEFkZ1JlZGlyZWN0cy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBbZWwuYWRnLCAndmFsaWQgYWRnIHJlZGlyZWN0J107XG59KSk7XG52YXIgUkVESVJFQ1RfUlVMRV9UWVBFUyA9IHtcbiAgVkFMSURfQURHOiB7XG4gICAgbWFya2VyOiBBREdfVUJPX1JFRElSRUNUX01BUktFUixcbiAgICBjb21wYXRpYmlsaXR5OiB2YWxpZEFkZ0NvbXBhdGliaWxpdHlcbiAgfSxcbiAgQURHOiB7XG4gICAgbWFya2VyOiBBREdfVUJPX1JFRElSRUNUX01BUktFUixcbiAgICBjb21wYXRpYmlsaXR5OiBhZGdUb1Vib0NvbXBhdGliaWxpdHlcbiAgfSxcbiAgVUJPOiB7XG4gICAgbWFya2VyOiBBREdfVUJPX1JFRElSRUNUX01BUktFUixcbiAgICBjb21wYXRpYmlsaXR5OiB1Ym9Ub0FkZ0NvbXBhdGliaWxpdHlcbiAgfSxcbiAgQUJQOiB7XG4gICAgbWFya2VyOiBBQlBfUkVESVJFQ1RfTUFSS0VSLFxuICAgIGNvbXBhdGliaWxpdHk6IGFicFRvQWRnQ29tcGF0aWJpbGl0eVxuICB9XG59O1xuLyoqXG4gKiBQYXJzZXMgcmVkaXJlY3QgcnVsZSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cblxudmFyIHBhcnNlTW9kaWZpZXJzID0gZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMocnVsZSkge1xuICByZXR1cm4gc3Vic3RyaW5nQWZ0ZXIocnVsZSwgJyQnKS5zcGxpdCgnLCcpO1xufTtcbi8qKlxuICogR2V0cyByZWRpcmVjdCByZXNvdXJjZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmtlciAtIHNwZWNpZmljIEFkZy9VYm8gb3IgQWJwIHJlZGlyZWN0IHJlc291cmNlcyBtYXJrZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gcmVkaXJlY3QgcmVzb3VyY2UgbmFtZVxuICovXG5cblxudmFyIGdldFJlZGlyZWN0TmFtZSA9IGZ1bmN0aW9uIGdldFJlZGlyZWN0TmFtZShydWxlLCBtYXJrZXIpIHtcbiAgdmFyIHJ1bGVNb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhydWxlKTtcbiAgdmFyIHJlZGlyZWN0TmFtZVBhcnQgPSBydWxlTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLmluZGV4T2YobWFya2VyKSA+IC0xO1xuICB9KTtcbiAgcmV0dXJuIHN1YnN0cmluZ0FmdGVyKHJlZGlyZWN0TmFtZVBhcnQsIG1hcmtlcik7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBydWxlYCBpcyBBZEd1YXJkIHJlZGlyZWN0IHJ1bGUuXG4gKiBEaXNjYXJkcyBjb21tZW50cyBhbmQgSlMgcnVsZXMgYW5kIGNoZWNrcyBpZiB0aGUgYHJ1bGVgIGhhcyAncmVkaXJlY3QnIG1vZGlmaWVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBydWxlIHRleHRcbiAqL1xuXG5cbnZhciBpc0FkZ1JlZGlyZWN0UnVsZSA9IGZ1bmN0aW9uIGlzQWRnUmVkaXJlY3RSdWxlKHJ1bGUpIHtcbiAgdmFyIE1BUktFUl9JTl9CQVNFX1BBUlRfTUFTSyA9ICcvKCg/IVxcXFwkfFxcXFwsKS57MX0pcmVkaXJlY3Q9KC57MCx9PylcXFxcJChwb3B1cCk/Lyc7XG4gIHJldHVybiAhaXNDb21tZW50KHJ1bGUpICYmIHJ1bGUuaW5kZXhPZihSRURJUkVDVF9SVUxFX1RZUEVTLkFERy5tYXJrZXIpID4gLTEgLy8gc29tZSBqcyBydWxlcyBtYXkgaGF2ZSAncmVkaXJlY3Q9JyBpbiBpdCwgc28gd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhlbVxuICAmJiBydWxlLmluZGV4T2YoSlNfUlVMRV9NQVJLRVIpID09PSAtMSAvLyBnZXQgcmlkIG9mIHJ1bGVzIGxpa2UgJ19yZWRpcmVjdD0qOi8vbG9vay4kcG9wdXAnXG4gICYmICF0b1JlZ0V4cChNQVJLRVJfSU5fQkFTRV9QQVJUX01BU0spLnRlc3QocnVsZSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBydWxlYCBzYXRpc2ZpZXMgdGhlIGB0eXBlYFxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBydWxlIHRleHRcbiAqIEBwYXJhbSB7J1ZBTElEX0FERyd8J0FERyd8J1VCTyd8J0FCUCd9IHR5cGUgLSB0eXBlIG9mIGEgcmVkaXJlY3QgcnVsZVxuICovXG5cblxudmFyIGlzUmVkaXJlY3RSdWxlQnlUeXBlID0gZnVuY3Rpb24gaXNSZWRpcmVjdFJ1bGVCeVR5cGUocnVsZSwgdHlwZSkge1xuICB2YXIgX1JFRElSRUNUX1JVTEVfVFlQRVMkID0gUkVESVJFQ1RfUlVMRV9UWVBFU1t0eXBlXSxcbiAgICAgIG1hcmtlciA9IF9SRURJUkVDVF9SVUxFX1RZUEVTJC5tYXJrZXIsXG4gICAgICBjb21wYXRpYmlsaXR5ID0gX1JFRElSRUNUX1JVTEVfVFlQRVMkLmNvbXBhdGliaWxpdHk7XG5cbiAgaWYgKHJ1bGUgJiYgIWlzQ29tbWVudChydWxlKSAmJiBydWxlLmluZGV4T2YobWFya2VyKSA+IC0xKSB7XG4gICAgdmFyIHJlZGlyZWN0TmFtZSA9IGdldFJlZGlyZWN0TmFtZShydWxlLCBtYXJrZXIpO1xuXG4gICAgaWYgKCFyZWRpcmVjdE5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkaXJlY3ROYW1lID09PSBPYmplY3Qua2V5cyhjb21wYXRpYmlsaXR5KS5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsID09PSByZWRpcmVjdE5hbWU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4qIENoZWNrcyBpZiB0aGUgYHJ1bGVgIGlzICoqdmFsaWQqKiBBZEd1YXJkIHJlZGlyZWN0IHJlc291cmNlIHJ1bGVcbiogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBydWxlIHRleHRcbiogQHJldHVybnMge2Jvb2xlYW59XG4qL1xuXG5cbnZhciBpc1ZhbGlkQWRnUmVkaXJlY3RSdWxlID0gZnVuY3Rpb24gaXNWYWxpZEFkZ1JlZGlyZWN0UnVsZShydWxlKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0UnVsZUJ5VHlwZShydWxlLCAnVkFMSURfQURHJyk7XG59O1xuLyoqXG4qIENoZWNrcyBpZiB0aGUgQWRHdWFyZCByZWRpcmVjdCBgcnVsZWAgaGFzIFVibyBhbmFsb2cuIE5lZWRlZCBmb3IgQWRnLT5VYm8gY29udmVyc2lvblxuKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIEFkR3VhcmQgcnVsZSB0ZXh0XG4qIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIHJ1bGUgY2FuIGJlIGNvbnZlcnRlZCB0byBVYm9cbiovXG5cblxudmFyIGlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibyA9IGZ1bmN0aW9uIGlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibyhydWxlKSB7XG4gIHJldHVybiBpc0FkZ1JlZGlyZWN0UnVsZShydWxlKSAmJiBpc1JlZGlyZWN0UnVsZUJ5VHlwZShydWxlLCAnQURHJyk7XG59O1xuLyoqXG4qIENoZWNrcyBpZiB0aGUgVWJvIHJlZGlyZWN0IGBydWxlYCBoYXMgQWRHdWFyZCBhbmFsb2cuIE5lZWRlZCBmb3IgVWJvLT5BZGcgY29udmVyc2lvblxuKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIFVibyBydWxlIHRleHRcbiogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgcnVsZSBjYW4gYmUgY29udmVydGVkIHRvIEFkR3VhcmRcbiovXG5cblxudmFyIGlzVWJvUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyA9IGZ1bmN0aW9uIGlzVWJvUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyhydWxlKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0UnVsZUJ5VHlwZShydWxlLCAnVUJPJyk7XG59O1xuLyoqXG4qIENoZWNrcyBpZiB0aGUgQWJwIHJlZGlyZWN0IGBydWxlYCBoYXMgQWRHdWFyZCBhbmFsb2cuIE5lZWRlZCBmb3IgQWJwLT5BZGcgY29udmVyc2lvblxuKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIEFicCBydWxlIHRleHRcbiogQHJldHVybnMge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgcnVsZSBjYW4gYmUgY29udmVydGVkIHRvIEFkR3VhcmRcbiovXG5cblxudmFyIGlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyA9IGZ1bmN0aW9uIGlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyhydWxlKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0UnVsZUJ5VHlwZShydWxlLCAnQUJQJyk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHJ1bGUgaGFzIHNwZWNpZmllZCBjb250ZW50IHR5cGUgYmVmb3JlIEFkZyAtPiBVYm8gY29udmVyc2lvbi5cbiAqXG4gKiBVc2VkIE9OTFkgZm9yIEFkZyAtPiBVYm8gY29udmVyc2lvblxuICogYmVjYXVzZSBVYm8gcmVkaXJlY3QgcnVsZXMgbXVzdCBjb250YWluIGNvbnRlbnQgdHlwZSwgYnV0IEFkZyBhbmQgQWJwIG11c3Qgbm90LlxuICpcbiAqIEFsc28gc291cmNlIHR5cGUgY2FuIG5vdCBiZSBhZGRlZCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugb2Ygc3VjaCB2YWxpZCBydWxlczpcbiAqICEgQWJwOlxuICogJHJld3JpdGU9YWJwLXJlc291cmNlOmJsYW5rLWpzLHhtbGh0dHByZXF1ZXN0XG4gKiAhIEFkZzpcbiAqICRzY3JpcHQscmVkaXJlY3Q9bm9vcHZhc3QtMi4wXG4gKiAkeG1saHR0cHJlcXVlc3QscmVkaXJlY3Q9bm9vcHZhc3QtMi4wXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxudmFyIGhhc1ZhbGlkQ29udGVudFR5cGUgPSBmdW5jdGlvbiBoYXNWYWxpZENvbnRlbnRUeXBlKHJ1bGUpIHtcbiAgdmFyIHJ1bGVNb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhydWxlKTsgLy8gcnVsZSBjYW4gaGF2ZSBtb3JlIHRoYW4gb25lIHNvdXJjZSB0eXBlIG1vZGlmaWVyXG5cbiAgdmFyIHNvdXJjZVR5cGVzID0gcnVsZU1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIFZBTElEX1NPVVJDRV9UWVBFUy5pbmRleE9mKGVsKSA+IC0xO1xuICB9KTtcbiAgdmFyIGlzU291cmNlVHlwZVNwZWNpZmllZCA9IHNvdXJjZVR5cGVzLmxlbmd0aCA+IDA7XG4gIHZhciBpc0VtcHR5UmVkaXJlY3QgPSBydWxlTW9kaWZpZXJzLmluZGV4T2YoXCJcIi5jb25jYXQoQURHX1VCT19SRURJUkVDVF9NQVJLRVIpLmNvbmNhdChFTVBUWV9SRURJUkVDVF9NQVJLRVIpKSA+IC0xO1xuXG4gIGlmIChpc0VtcHR5UmVkaXJlY3QpIHtcbiAgICAvLyBubyBzb3VyY2UgdHlwZSBmb3IgJ2VtcHR5JyBpcyBhbGxvd2VkXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gaXNTb3VyY2VUeXBlU3BlY2lmaWVkO1xufTtcblxudmFyIHZhbGlkYXRvciA9IHtcbiAgVUJPX1NDUklQVExFVF9NQVNLX1JFRzogVUJPX1NDUklQVExFVF9NQVNLX1JFRyxcbiAgQUJQX1NDUklQVExFVF9NQVNLOiBBQlBfU0NSSVBUTEVUX01BU0ssXG4gIEFCUF9TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0s6IEFCUF9TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0ssXG4gIGlzQ29tbWVudDogaXNDb21tZW50LFxuICBpc0FkZ1NjcmlwdGxldFJ1bGU6IGlzQWRnU2NyaXB0bGV0UnVsZSxcbiAgaXNVYm9TY3JpcHRsZXRSdWxlOiBpc1Vib1NjcmlwdGxldFJ1bGUsXG4gIGlzQWJwU25pcHBldFJ1bGU6IGlzQWJwU25pcHBldFJ1bGUsXG4gIGdldFNjcmlwdGxldEJ5TmFtZTogZ2V0U2NyaXB0bGV0QnlOYW1lLFxuICBpc1ZhbGlkU2NyaXB0bGV0TmFtZTogaXNWYWxpZFNjcmlwdGxldE5hbWUsXG4gIFJFRElSRUNUX1JVTEVfVFlQRVM6IFJFRElSRUNUX1JVTEVfVFlQRVMsXG4gIEFCU0VOVF9TT1VSQ0VfVFlQRV9SRVBMQUNFTUVOVDogQUJTRU5UX1NPVVJDRV9UWVBFX1JFUExBQ0VNRU5ULFxuICBpc0FkZ1JlZGlyZWN0UnVsZTogaXNBZGdSZWRpcmVjdFJ1bGUsXG4gIGlzVmFsaWRBZGdSZWRpcmVjdFJ1bGU6IGlzVmFsaWRBZGdSZWRpcmVjdFJ1bGUsXG4gIGlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibzogaXNBZGdSZWRpcmVjdENvbXBhdGlibGVXaXRoVWJvLFxuICBpc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGc6IGlzVWJvUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyxcbiAgaXNBYnBSZWRpcmVjdENvbXBhdGlibGVXaXRoQWRnOiBpc0FicFJlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcsXG4gIHBhcnNlTW9kaWZpZXJzOiBwYXJzZU1vZGlmaWVycyxcbiAgZ2V0UmVkaXJlY3ROYW1lOiBnZXRSZWRpcmVjdE5hbWUsXG4gIGhhc1ZhbGlkQ29udGVudFR5cGU6IGhhc1ZhbGlkQ29udGVudFR5cGVcbn07XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxudmFyIGFycmF5TGlrZVRvQXJyYXkgPSBfYXJyYXlMaWtlVG9BcnJheTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG52YXIgYXJyYXlXaXRob3V0SG9sZXMgPSBfYXJyYXlXaXRob3V0SG9sZXM7XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IF9pdGVyYWJsZVRvQXJyYXk7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTtcblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gX25vbkl0ZXJhYmxlU3ByZWFkO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gX3RvQ29uc3VtYWJsZUFycmF5O1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbnZhciBhcnJheVdpdGhIb2xlcyA9IF9hcnJheVdpdGhIb2xlcztcblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IF9ub25JdGVyYWJsZVJlc3Q7XG5cbmZ1bmN0aW9uIF90b0FycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG52YXIgdG9BcnJheSA9IF90b0FycmF5O1xuXG4vKipcbiAqIEFkR3VhcmQgc2NyaXB0bGV0IHJ1bGVcbiAqL1xuXG52YXIgQURHVUFSRF9TQ1JJUFRMRVRfTUFTS19SRUcgPSAvI0A/JSNcXC9cXC9zY3JpcHRsZXRcXCguK1xcKS87IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10ZW1wbGF0ZS1jdXJseS1pbi1zdHJpbmdcblxudmFyIEFER1VBUkRfU0NSSVBUTEVUX1RFTVBMQVRFID0gJyR7ZG9tYWluc30jJSMvL3NjcmlwdGxldCgke2FyZ3N9KSc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10ZW1wbGF0ZS1jdXJseS1pbi1zdHJpbmdcblxudmFyIEFER1VBUkRfU0NSSVBUTEVUX0VYQ0VQVElPTl9URU1QTEFURSA9ICcke2RvbWFpbnN9I0AlIy8vc2NyaXB0bGV0KCR7YXJnc30pJztcbi8qKlxuICogdUJsb2NrIHNjcmlwdGxldCBydWxlIG1hc2tcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRlbXBsYXRlLWN1cmx5LWluLXN0cmluZ1xuXG52YXIgVUJPX1NDUklQVExFVF9URU1QTEFURSA9ICcke2RvbWFpbnN9IyMranMoJHthcmdzfSknOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGVtcGxhdGUtY3VybHktaW4tc3RyaW5nXG5cbnZhciBVQk9fU0NSSVBUTEVUX0VYQ0VQVElPTl9URU1QTEFURSA9ICcke2RvbWFpbnN9I0AjK2pzKCR7YXJnc30pJztcbnZhciBVQk9fQUxJQVNfTkFNRV9NQVJLRVIgPSAndWJvLSc7XG52YXIgVUJPX1NDUklQVExFVF9KU19FTkRJTkcgPSAnLmpzJzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvU3RhdGljLWZpbHRlci1zeW50YXgjeGhyXG5cbnZhciBVQk9fWEhSX1RZUEUgPSAneGhyJztcbnZhciBBREdfWEhSX1RZUEUgPSAneG1saHR0cHJlcXVlc3QnO1xudmFyIEFER19TRVRfQ09OU1RBTlRfTkFNRSA9ICdzZXQtY29uc3RhbnQnO1xudmFyIEFER19TRVRfQ09OU1RBTlRfRU1QVFlfU1RSSU5HID0gJyc7XG52YXIgVUJPX1NFVF9DT05TVEFOVF9FTVBUWV9TVFJJTkcgPSAnXFwnXFwnJztcbnZhciBBREdfUFJFVkVOVF9GRVRDSF9OQU1FID0gJ3ByZXZlbnQtZmV0Y2gnO1xudmFyIEFER19QUkVWRU5UX0ZFVENIX0VNUFRZX1NUUklORyA9ICcnO1xudmFyIEFER19QUkVWRU5UX0ZFVENIX1dJTERDQVJEID0gZ2V0V2lsZGNhcmRTeW1ib2woKTtcbnZhciBVQk9fTk9fRkVUQ0hfSUZfV0lMRENBUkQgPSAnL14vJztcbnZhciBFU0NBUEVEX0NPTU1BX1NFUEFSQVRPUiA9ICdcXFxcLCc7XG52YXIgQ09NTUFfU0VQQVJBVE9SID0gJywnO1xudmFyIE1BWF9SRU1PVkVfQVRUUl9DTEFTU19BUkdTX0NPVU5UID0gMztcbnZhciBSRU1PVkVfQVRUUl9NRVRIT0QgPSAncmVtb3ZlQXR0cic7XG52YXIgUkVNT1ZFX0NMQVNTX01FVEhPRCA9ICdyZW1vdmVDbGFzcyc7XG52YXIgUkVNT1ZFX0FUVFJfQUxJQVNFUyA9IHNjcmlwdGxldExpc3RbUkVNT1ZFX0FUVFJfTUVUSE9EXS5uYW1lcztcbnZhciBSRU1PVkVfQ0xBU1NfQUxJQVNFUyA9IHNjcmlwdGxldExpc3RbUkVNT1ZFX0NMQVNTX01FVEhPRF0ubmFtZXM7XG52YXIgQURHX1JFTU9WRV9BVFRSX05BTUUgPSBSRU1PVkVfQVRUUl9BTElBU0VTWzBdO1xudmFyIEFER19SRU1PVkVfQ0xBU1NfTkFNRSA9IFJFTU9WRV9DTEFTU19BTElBU0VTWzBdO1xuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc2VwYXJhdGVkIGJ5IHNwYWNlIHdoaWNoIG5vdCBpbiBxdW90ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqL1xuXG52YXIgZ2V0U2VudGVuY2VzID0gZnVuY3Rpb24gZ2V0U2VudGVuY2VzKHN0cikge1xuICB2YXIgcmVnID0gLycuKj8nfFwiLio/XCJ8XFxTKy9nO1xuICByZXR1cm4gc3RyLm1hdGNoKHJlZyk7XG59O1xuLyoqXG4gKiBSZXBsYWNlcyBzdHJpbmcgd2l0aCBkYXRhIGJ5IHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSB3aGVyZSBrZXlzIGFyZSBwbGFjZWhvbGRlcnMgbmFtZXNcbiAqL1xuXG5cbnZhciByZXBsYWNlUGxhY2Vob2xkZXJzID0gZnVuY3Rpb24gcmVwbGFjZVBsYWNlaG9sZGVycyhzdHIsIGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIlxcXFwkXFxcXHtcIi5jb25jYXQoa2V5LCBcIlxcXFx9XCIpLCAnZycpO1xuICAgIGFjYyA9IGFjYy5yZXBsYWNlKHJlZywgZGF0YVtrZXldKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBzdHIpO1xufTtcbi8qKlxuICogQ29udmVydHMgc3RyaW5nIG9mIFVCTyBzY3JpcHRsZXQgcnVsZSB0byBBZEd1YXJkIHNjcml0bGV0IHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIC0gVUJPIHNjcmlwdGxldCBydWxlXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gYXJyYXkgd2l0aCBvbmUgQWRHdWFyZCBzY3JpcHRsZXQgcnVsZVxuICovXG5cblxudmFyIGNvbnZlcnRVYm9TY3JpcHRsZXRUb0FkZyA9IGZ1bmN0aW9uIGNvbnZlcnRVYm9TY3JpcHRsZXRUb0FkZyhydWxlKSB7XG4gIHZhciBkb21haW5zID0gZ2V0QmVmb3JlUmVnRXhwKHJ1bGUsIHZhbGlkYXRvci5VQk9fU0NSSVBUTEVUX01BU0tfUkVHKTtcbiAgdmFyIG1hc2sgPSBydWxlLm1hdGNoKHZhbGlkYXRvci5VQk9fU0NSSVBUTEVUX01BU0tfUkVHKVswXTtcbiAgdmFyIHRlbXBsYXRlO1xuXG4gIGlmIChtYXNrLmluZGV4T2YoJ0AnKSA+IC0xKSB7XG4gICAgdGVtcGxhdGUgPSBBREdVQVJEX1NDUklQVExFVF9FWENFUFRJT05fVEVNUExBVEU7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGUgPSBBREdVQVJEX1NDUklQVExFVF9URU1QTEFURTtcbiAgfVxuXG4gIHZhciBwYXJzZWRBcmdzID0gZ2V0U3RyaW5nSW5CcmFjZXMocnVsZSkuc3BsaXQoLyxcXHMvZyk7XG5cbiAgaWYgKHBhcnNlZEFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gTW9zdCBwcm9iYWJseSB0aGlzIGlzIG5vdCBjb3JyZWN0IHNlcGFyYXRvciwgaW4gdGhpcyBjYXNlIHdlIHVzZSAnLCdcbiAgICBwYXJzZWRBcmdzID0gZ2V0U3RyaW5nSW5CcmFjZXMocnVsZSkuc3BsaXQoLywvZyk7XG4gIH1cblxuICB2YXIgc2NyaXB0bGV0TmFtZSA9IHBhcnNlZEFyZ3NbMF0uaW5kZXhPZihVQk9fU0NSSVBUTEVUX0pTX0VORElORykgPiAtMSA/IFwidWJvLVwiLmNvbmNhdChwYXJzZWRBcmdzWzBdKSA6IFwidWJvLVwiLmNvbmNhdChwYXJzZWRBcmdzWzBdKS5jb25jYXQoVUJPX1NDUklQVExFVF9KU19FTkRJTkcpO1xuXG4gIGlmICgoUkVNT1ZFX0FUVFJfQUxJQVNFUy5pbmRleE9mKHNjcmlwdGxldE5hbWUpID4gLTEgfHwgUkVNT1ZFX0NMQVNTX0FMSUFTRVMuaW5kZXhPZihzY3JpcHRsZXROYW1lKSA+IC0xKSAmJiBwYXJzZWRBcmdzLmxlbmd0aCA+IE1BWF9SRU1PVkVfQVRUUl9DTEFTU19BUkdTX0NPVU5UKSB7XG4gICAgcGFyc2VkQXJncyA9IFtwYXJzZWRBcmdzWzBdLCBwYXJzZWRBcmdzWzFdLCAvLyBpZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDMgYXJncyBmb3IgcmVtb3ZlLWF0dHIvY2xhc3Mgc2NyaXB0bGV0LFxuICAgIC8vIHVibyBydWxlIGhhcyBtYWx0aXBsZSBzZWxlY3RvciBzZXBhcmF0ZWQgYnkgY29tbWEuIHNvIHdlIHNob3VsZDpcbiAgICAvLyAxLiBqb2luIHRoZW0gaW50byBhIHNpbmdsZSBzdHJpbmdcbiAgICAvLyAyLiByZXBsYWNlIGVzY2FwZWQgY29tbWFzIGJ5IHJlZ3VsYXIgb25lc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMzNcbiAgICByZXBsYWNlQWxsKHBhcnNlZEFyZ3Muc2xpY2UoMikuam9pbihcIlwiLmNvbmNhdChDT01NQV9TRVBBUkFUT1IsIFwiIFwiKSksIEVTQ0FQRURfQ09NTUFfU0VQQVJBVE9SLCBDT01NQV9TRVBBUkFUT1IpXTtcbiAgfVxuXG4gIHZhciBhcmdzID0gcGFyc2VkQXJncy5tYXAoZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0QXJnID0gYXJnO1xuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvdXRwdXRBcmcgPSBzY3JpcHRsZXROYW1lO1xuICAgIH0gLy8gZm9yIGV4YW1wbGU6IGRyYW1hc2VyaWFsLnh5eiMjK2pzKGFib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCwgJCwgcG9wdXApXG5cblxuICAgIGlmIChhcmcgPT09ICckJykge1xuICAgICAgb3V0cHV0QXJnID0gJyQkJztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0QXJnO1xuICB9KS5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB3cmFwSW5TaW5nbGVRdW90ZXMoYXJnKTtcbiAgfSkuam9pbihcIlwiLmNvbmNhdChDT01NQV9TRVBBUkFUT1IsIFwiIFwiKSk7XG4gIHZhciBhZGdSdWxlID0gcmVwbGFjZVBsYWNlaG9sZGVycyh0ZW1wbGF0ZSwge1xuICAgIGRvbWFpbnM6IGRvbWFpbnMsXG4gICAgYXJnczogYXJnc1xuICB9KTtcbiAgcmV0dXJuIFthZGdSdWxlXTtcbn07XG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIG9mIEFCUCBzbmlwcGV0IHJ1bGUgdG8gQWRHdWFyZCBzY3JpdGxldCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIEFCUCBzbmlwcGV0IHJ1bGVcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBhcnJheSBvZiBBZEd1YXJkIHNjcmlwdGxldCBydWxlcyAtXG4gKiBvbmUgb3IgZmV3IGl0ZW1zIGRlcGVuZHMgb24gQWJwLXJ1bGVcbiAqL1xuXG52YXIgY29udmVydEFicFNuaXBwZXRUb0FkZyA9IGZ1bmN0aW9uIGNvbnZlcnRBYnBTbmlwcGV0VG9BZGcocnVsZSkge1xuICB2YXIgU0VNSUNPTE9OX0RJVklERVIgPSAvOyg/PSg/Oig/OlteXCJdKlwiKXsyfSkqW15cIl0qJCkvZztcbiAgdmFyIG1hc2sgPSBydWxlLmluZGV4T2YodmFsaWRhdG9yLkFCUF9TQ1JJUFRMRVRfTUFTSykgPiAtMSA/IHZhbGlkYXRvci5BQlBfU0NSSVBUTEVUX01BU0sgOiB2YWxpZGF0b3IuQUJQX1NDUklQVExFVF9FWENFUFRJT05fTUFTSztcbiAgdmFyIHRlbXBsYXRlID0gbWFzayA9PT0gdmFsaWRhdG9yLkFCUF9TQ1JJUFRMRVRfTUFTSyA/IEFER1VBUkRfU0NSSVBUTEVUX1RFTVBMQVRFIDogQURHVUFSRF9TQ1JJUFRMRVRfRVhDRVBUSU9OX1RFTVBMQVRFO1xuICB2YXIgZG9tYWlucyA9IHN1YnN0cmluZ0JlZm9yZShydWxlLCBtYXNrKTtcbiAgdmFyIGFyZ3MgPSBzdWJzdHJpbmdBZnRlcihydWxlLCBtYXNrKTtcbiAgcmV0dXJuIGFyZ3Muc3BsaXQoU0VNSUNPTE9OX0RJVklERVIpLm1hcChmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBnZXRTZW50ZW5jZXMoYXJncykuZmlsdGVyKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChhcmcsIGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggPT09IDAgPyBcImFicC1cIi5jb25jYXQoYXJnKSA6IGFyZztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIHdyYXBJblNpbmdsZVF1b3RlcyhhcmcpO1xuICAgIH0pLmpvaW4oXCJcIi5jb25jYXQoQ09NTUFfU0VQQVJBVE9SLCBcIiBcIikpO1xuICB9KS5tYXAoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gcmVwbGFjZVBsYWNlaG9sZGVycyh0ZW1wbGF0ZSwge1xuICAgICAgZG9tYWluczogZG9tYWlucyxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcbiAgfSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBzY3JpcHRsZXQgcnVsZSB0byBBZEd1YXJkIG9uZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBhcnJheSBvZiBBZEd1YXJkIHNjcmlwdGxldCBydWxlcyAtXG4gKiBvbmUgaXRlbSBmb3IgQWRnIGFuZCBVYm8gb3IgZmV3IGl0ZW1zIGZvciBBYnBcbiAqL1xuXG52YXIgY29udmVydFNjcmlwdGxldFRvQWRnID0gZnVuY3Rpb24gY29udmVydFNjcmlwdGxldFRvQWRnKHJ1bGUpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodmFsaWRhdG9yLmlzVWJvU2NyaXB0bGV0UnVsZShydWxlKSkge1xuICAgIHJlc3VsdCA9IGNvbnZlcnRVYm9TY3JpcHRsZXRUb0FkZyhydWxlKTtcbiAgfSBlbHNlIGlmICh2YWxpZGF0b3IuaXNBYnBTbmlwcGV0UnVsZShydWxlKSkge1xuICAgIHJlc3VsdCA9IGNvbnZlcnRBYnBTbmlwcGV0VG9BZGcocnVsZSk7XG4gIH0gZWxzZSBpZiAodmFsaWRhdG9yLmlzQWRnU2NyaXB0bGV0UnVsZShydWxlKSB8fCB2YWxpZGF0b3IuaXNDb21tZW50KHJ1bGUpKSB7XG4gICAgcmVzdWx0ID0gW3J1bGVdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENvbnZlcnRzIFVCTyBzY3JpcHRsZXQgcnVsZSB0byBBZEd1YXJkIG9uZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBBZEd1YXJkIHNjcmlwdGxldCBydWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVCTyBzY3JpcHRsZXQgcnVsZVxuICovXG5cbnZhciBjb252ZXJ0QWRnU2NyaXB0bGV0VG9VYm8gPSBmdW5jdGlvbiBjb252ZXJ0QWRnU2NyaXB0bGV0VG9VYm8ocnVsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmICh2YWxpZGF0b3IuaXNBZGdTY3JpcHRsZXRSdWxlKHJ1bGUpKSB7XG4gICAgdmFyIF9wYXJzZVJ1bGUgPSBwYXJzZVJ1bGUocnVsZSksXG4gICAgICAgIHBhcnNlZE5hbWUgPSBfcGFyc2VSdWxlLm5hbWUsXG4gICAgICAgIHBhcnNlZFBhcmFtcyA9IF9wYXJzZVJ1bGUuYXJncztcblxuICAgIHZhciBwcmVwYXJlZFBhcmFtczsgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0ZpbHRlcnNDb21waWxlci9pc3N1ZXMvMTAyXG5cbiAgICBpZiAocGFyc2VkTmFtZSA9PT0gQURHX1NFVF9DT05TVEFOVF9OQU1FICYmIHBhcnNlZFBhcmFtc1sxXSA9PT0gQURHX1NFVF9DT05TVEFOVF9FTVBUWV9TVFJJTkcpIHtcbiAgICAgIHByZXBhcmVkUGFyYW1zID0gW3BhcnNlZFBhcmFtc1swXSwgVUJPX1NFVF9DT05TVEFOVF9FTVBUWV9TVFJJTkddO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkTmFtZSA9PT0gQURHX1BSRVZFTlRfRkVUQ0hfTkFNRSAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTA5XG4gICAgJiYgKHBhcnNlZFBhcmFtc1swXSA9PT0gQURHX1BSRVZFTlRfRkVUQ0hfV0lMRENBUkQgfHwgcGFyc2VkUGFyYW1zWzBdID09PSBBREdfUFJFVkVOVF9GRVRDSF9FTVBUWV9TVFJJTkcpKSB7XG4gICAgICBwcmVwYXJlZFBhcmFtcyA9IFtVQk9fTk9fRkVUQ0hfSUZfV0lMRENBUkRdO1xuICAgIH0gZWxzZSBpZiAoKHBhcnNlZE5hbWUgPT09IEFER19SRU1PVkVfQVRUUl9OQU1FIHx8IHBhcnNlZE5hbWUgPT09IEFER19SRU1PVkVfQ0xBU1NfTkFNRSkgJiYgcGFyc2VkUGFyYW1zWzFdICYmIHBhcnNlZFBhcmFtc1sxXS5pbmRleE9mKENPTU1BX1NFUEFSQVRPUikgPiAtMSkge1xuICAgICAgcHJlcGFyZWRQYXJhbXMgPSBbcGFyc2VkUGFyYW1zWzBdLCByZXBsYWNlQWxsKHBhcnNlZFBhcmFtc1sxXSwgQ09NTUFfU0VQQVJBVE9SLCBFU0NBUEVEX0NPTU1BX1NFUEFSQVRPUildO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVwYXJlZFBhcmFtcyA9IHBhcnNlZFBhcmFtcztcbiAgICB9IC8vIG9iamVjdCBvZiBuYW1lIGFuZCBhbGlhc2VzIGZvciB0aGUgQWRnLXNjcmlwdGxldFxuXG5cbiAgICB2YXIgYWRnU2NyaXB0bGV0T2JqZWN0ID0gT2JqZWN0LmtleXMoc2NyaXB0bGV0TGlzdCkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIHNjcmlwdGxldExpc3RbZWxdO1xuICAgIH0pLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgdmFyIF9zJG5hbWVzID0gdG9BcnJheShzLm5hbWVzKSxcbiAgICAgICAgICBuYW1lID0gX3MkbmFtZXNbMF0sXG4gICAgICAgICAgYWxpYXNlcyA9IF9zJG5hbWVzLnNsaWNlKDEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhbGlhc2VzOiBhbGlhc2VzXG4gICAgICB9O1xuICAgIH0pLmZpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwubmFtZSA9PT0gcGFyc2VkTmFtZSB8fCBlbC5hbGlhc2VzLmluZGV4T2YocGFyc2VkTmFtZSkgPj0gMDtcbiAgICB9KTtcbiAgICB2YXIgYWxpYXNlcyA9IGFkZ1NjcmlwdGxldE9iamVjdC5hbGlhc2VzO1xuXG4gICAgaWYgKGFsaWFzZXMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHVib0FsaWFzID0gYWRnU2NyaXB0bGV0T2JqZWN0LmFsaWFzZXMgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgLmZpbmQoZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBhbGlhcy5pbmNsdWRlcyhVQk9fQUxJQVNfTkFNRV9NQVJLRVIpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh1Ym9BbGlhcykge1xuICAgICAgICB2YXIgbWFzayA9IHJ1bGUubWF0Y2goQURHVUFSRF9TQ1JJUFRMRVRfTUFTS19SRUcpWzBdO1xuICAgICAgICB2YXIgdGVtcGxhdGU7XG5cbiAgICAgICAgaWYgKG1hc2suaW5kZXhPZignQCcpID4gLTEpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX1RFTVBMQVRFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBsYXRlID0gVUJPX1NDUklQVExFVF9URU1QTEFURTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb21haW5zID0gZ2V0QmVmb3JlUmVnRXhwKHJ1bGUsIEFER1VBUkRfU0NSSVBUTEVUX01BU0tfUkVHKTtcbiAgICAgICAgdmFyIHVib05hbWUgPSB1Ym9BbGlhcy5yZXBsYWNlKFVCT19BTElBU19OQU1FX01BUktFUiwgJycpIC8vICcuanMnIGluIHRoZSBVYm8gc2NyaXB0bGV0IG5hbWUgY2FuIGJlIG9taXR0ZWRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjZ2VuZXJhbC1wdXJwb3NlLXNjcmlwdGxldHNcbiAgICAgICAgLnJlcGxhY2UoVUJPX1NDUklQVExFVF9KU19FTkRJTkcsICcnKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBwcmVwYXJlZFBhcmFtcy5sZW5ndGggPiAwID8gXCJcIi5jb25jYXQodWJvTmFtZSwgXCIsIFwiKS5jb25jYXQocHJlcGFyZWRQYXJhbXMuam9pbihcIlwiLmNvbmNhdChDT01NQV9TRVBBUkFUT1IsIFwiIFwiKSkpIDogdWJvTmFtZTtcbiAgICAgICAgdmFyIHVib1J1bGUgPSByZXBsYWNlUGxhY2Vob2xkZXJzKHRlbXBsYXRlLCB7XG4gICAgICAgICAgZG9tYWluczogZG9tYWlucyxcbiAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgIH0pO1xuICAgICAgICByZXMgPSB1Ym9SdWxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgQURHIHNjcmlwdGxldCBleGlzdHMgb3IgVUJPL0FCUCBzY3JpcHRsZXQgaXMgY29tcGF0aWJsZSB0byBBREdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAtIGNhbiBiZSBBREcgb3IgVUJPIG9yIEFCUCBzY3JpcHRsZXQgcnVsZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxudmFyIGlzVmFsaWRTY3JpcHRsZXRSdWxlID0gZnVuY3Rpb24gaXNWYWxpZFNjcmlwdGxldFJ1bGUoaW5wdXQpIHtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBBQlAgJ2lucHV0JyBydWxlIG1heSBjb250YWluIG1vcmUgdGhhbiBvbmUgc25pcHBldFxuXG5cbiAgdmFyIHJ1bGVzQXJyYXkgPSBjb252ZXJ0U2NyaXB0bGV0VG9BZGcoaW5wdXQpOyAvLyBjaGVja2luZyBpZiBlYWNoIG9mIHBhcnNlZCBzY3JpcHRsZXRzIGlzIHZhbGlkXG4gIC8vIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzIG5vdCB2YWxpZCAtIHdob2xlICdpbnB1dCcgcnVsZSBpcyBub3QgdmFsaWQgdG9vXG5cbiAgdmFyIGlzVmFsaWQgPSBydWxlc0FycmF5LmV2ZXJ5KGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdmFyIHBhcnNlZFJ1bGUgPSBwYXJzZVJ1bGUocnVsZSk7XG4gICAgcmV0dXJuIHZhbGlkYXRvci5pc1ZhbGlkU2NyaXB0bGV0TmFtZShwYXJzZWRSdWxlLm5hbWUpO1xuICB9KTtcbiAgcmV0dXJuIGlzVmFsaWQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBVYm8gcmVkaXJlY3QgcnVsZSB0byBBZGcgb25lXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG52YXIgY29udmVydFVib1JlZGlyZWN0VG9BZGcgPSBmdW5jdGlvbiBjb252ZXJ0VWJvUmVkaXJlY3RUb0FkZyhydWxlKSB7XG4gIHZhciBmaXJzdFBhcnRPZlJ1bGUgPSBzdWJzdHJpbmdCZWZvcmUocnVsZSwgJyQnKTtcbiAgdmFyIHVib01vZGlmaWVycyA9IHZhbGlkYXRvci5wYXJzZU1vZGlmaWVycyhydWxlKTtcbiAgdmFyIGFkZ01vZGlmaWVycyA9IHVib01vZGlmaWVycy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLmluZGV4T2YodmFsaWRhdG9yLlJFRElSRUNUX1JVTEVfVFlQRVMuVUJPLm1hcmtlcikgPiAtMSkge1xuICAgICAgdmFyIHVib05hbWUgPSBzdWJzdHJpbmdBZnRlcihlbCwgdmFsaWRhdG9yLlJFRElSRUNUX1JVTEVfVFlQRVMuVUJPLm1hcmtlcik7XG4gICAgICB2YXIgYWRnTmFtZSA9IHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLlVCTy5jb21wYXRpYmlsaXR5W3Vib05hbWVdO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLkFERy5tYXJrZXIpLmNvbmNhdChhZGdOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZWwgPT09IFVCT19YSFJfVFlQRSkge1xuICAgICAgcmV0dXJuIEFER19YSFJfVFlQRTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG4gIH0pLmpvaW4oQ09NTUFfU0VQQVJBVE9SKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGZpcnN0UGFydE9mUnVsZSwgXCIkXCIpLmNvbmNhdChhZGdNb2RpZmllcnMpO1xufTtcbi8qKlxuICogQ29udmVydHMgQWJwIHJlZGlyZWN0IHJ1bGUgdG8gQWRnIG9uZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIGNvbnZlcnRBYnBSZWRpcmVjdFRvQWRnID0gZnVuY3Rpb24gY29udmVydEFicFJlZGlyZWN0VG9BZGcocnVsZSkge1xuICB2YXIgZmlyc3RQYXJ0T2ZSdWxlID0gc3Vic3RyaW5nQmVmb3JlKHJ1bGUsICckJyk7XG4gIHZhciBhYnBNb2RpZmllcnMgPSB2YWxpZGF0b3IucGFyc2VNb2RpZmllcnMocnVsZSk7XG4gIHZhciBhZGdNb2RpZmllcnMgPSBhYnBNb2RpZmllcnMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5pbmRleE9mKHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLkFCUC5tYXJrZXIpID4gLTEpIHtcbiAgICAgIHZhciBhYnBOYW1lID0gc3Vic3RyaW5nQWZ0ZXIoZWwsIHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLkFCUC5tYXJrZXIpO1xuICAgICAgdmFyIGFkZ05hbWUgPSB2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BQlAuY29tcGF0aWJpbGl0eVthYnBOYW1lXTtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcubWFya2VyKS5jb25jYXQoYWRnTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9KS5qb2luKENPTU1BX1NFUEFSQVRPUik7XG4gIHJldHVybiBcIlwiLmNvbmNhdChmaXJzdFBhcnRPZlJ1bGUsIFwiJFwiKS5jb25jYXQoYWRnTW9kaWZpZXJzKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHJlZGlyZWN0IHJ1bGUgdG8gQWRHdWFyZCBvbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBjb252ZXJ0UmVkaXJlY3RUb0FkZyA9IGZ1bmN0aW9uIGNvbnZlcnRSZWRpcmVjdFRvQWRnKHJ1bGUpIHtcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAodmFsaWRhdG9yLmlzVWJvUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyhydWxlKSkge1xuICAgIHJlc3VsdCA9IGNvbnZlcnRVYm9SZWRpcmVjdFRvQWRnKHJ1bGUpO1xuICB9IGVsc2UgaWYgKHZhbGlkYXRvci5pc0FicFJlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcocnVsZSkpIHtcbiAgICByZXN1bHQgPSBjb252ZXJ0QWJwUmVkaXJlY3RUb0FkZyhydWxlKTtcbiAgfSBlbHNlIGlmICh2YWxpZGF0b3IuaXNWYWxpZEFkZ1JlZGlyZWN0UnVsZShydWxlKSkge1xuICAgIHJlc3VsdCA9IHJ1bGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgQWRnIHJlZGlyZWN0IHJ1bGUgdG8gVWJvIG9uZVxuICogMS4gQ2hlY2tzIGlmIHRoZXJlIGlzIFVibyBhbmFsb2cgZm9yIEFkZyBydWxlXG4gKiAyLiBQYXJzZXMgdGhlIHJ1bGUgYW5kIGNoZWNocyBpZiB0aGVyZSBhcmUgYW55IHNvdXJjZSB0eXBlIG1vZGlmaWVycyB3aGljaCBhcmUgcmVxdWlyZWQgYnkgVWJvXG4gKiAgICBhbmQgaWYgdGhlcmUgYXJlIG5vIG9uZSB3ZSBhZGQgaXQgbWFudWFsbHkgdG8gdGhlIGVuZC5cbiAqICAgIFNvdXJjZSB0eXBlcyBhcmUgY2hvc2VuIGFjY29yZGluZyB0byByZWRpcmVjdCBuYW1lXG4gKiAgICBlLmcuIHx8YWQuY29tXiRyZWRpcmVjdD08bmFtZT4saW1wb3J0YW50ICAtPj4gIHx8YWQuY29tXiRyZWRpcmVjdD08bmFtZT4saW1wb3J0YW50LHNjcmlwdFxuICogMy4gUmVwbGFjZXMgQWRnIHJlZGlyZWN0IG5hbWUgYnkgVWJvIGFuYWxvZ1xuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIGNvbnZlcnRBZGdSZWRpcmVjdFRvVWJvID0gZnVuY3Rpb24gY29udmVydEFkZ1JlZGlyZWN0VG9VYm8ocnVsZSkge1xuICBpZiAoIXZhbGlkYXRvci5pc0FkZ1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhVYm8ocnVsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29udmVydCBmb3IgdUJPIC0gdW5zdXBwb3J0ZWQgcmVkaXJlY3QgaW4gcnVsZTogXCIuY29uY2F0KHJ1bGUpKTtcbiAgfVxuXG4gIHZhciBiYXNlUGFydCA9IHN1YnN0cmluZ0JlZm9yZShydWxlLCAnJCcpO1xuICB2YXIgYWRnTW9kaWZpZXJzID0gdmFsaWRhdG9yLnBhcnNlTW9kaWZpZXJzKHJ1bGUpO1xuICB2YXIgYWRnUmVkaXJlY3RNb2RpZmllciA9IGFkZ01vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5pbmRleE9mKHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLkFERy5tYXJrZXIpID4gLTE7XG4gIH0pO1xuICB2YXIgYWRnUmVkaXJlY3ROYW1lID0gYWRnUmVkaXJlY3RNb2RpZmllci5zbGljZSh2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcubWFya2VyLmxlbmd0aCk7XG4gIHZhciB1Ym9SZWRpcmVjdE5hbWUgPSB2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcuY29tcGF0aWJpbGl0eVthZGdSZWRpcmVjdE5hbWVdO1xuICB2YXIgdWJvUmVkaXJlY3RNb2RpZmllciA9IFwiXCIuY29uY2F0KHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLlVCTy5tYXJrZXIpLmNvbmNhdCh1Ym9SZWRpcmVjdE5hbWUpO1xuXG4gIGlmICghdmFsaWRhdG9yLmhhc1ZhbGlkQ29udGVudFR5cGUocnVsZSkpIHtcbiAgICAvLyBhZGQgbWlzc2VkIHNvdXJjZSB0eXBlcyBhcyBjb250ZW50IHR5cGUgbW9kaWZpZXJzXG4gICAgdmFyIHNvdXJjZVR5cGVzRGF0YSA9IHZhbGlkYXRvci5BQlNFTlRfU09VUkNFX1RZUEVfUkVQTEFDRU1FTlQuZmluZChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbC5OQU1FID09PSBhZGdSZWRpcmVjdE5hbWU7XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZVR5cGVzRGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb252ZXJ0IGZvciB1Qk8gLSBubyB0eXBlcyB0byBhZGQgZm9yIHNwZWNpZmljIHJlZGlyZWN0IGluIHJ1bGU6IFwiLmNvbmNhdChydWxlKSk7XG4gICAgfVxuXG4gICAgdmFyIGFkZGl0aW9uTW9kaWZpZXJzID0gc291cmNlVHlwZXNEYXRhLlRZUEVTO1xuICAgIGFkZ01vZGlmaWVycy5wdXNoLmFwcGx5KGFkZ01vZGlmaWVycywgdG9Db25zdW1hYmxlQXJyYXkoYWRkaXRpb25Nb2RpZmllcnMpKTtcbiAgfVxuXG4gIHZhciB1Ym9Nb2RpZmllcnMgPSBhZGdNb2RpZmllcnMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCA9PT0gYWRnUmVkaXJlY3RNb2RpZmllcikge1xuICAgICAgcmV0dXJuIHVib1JlZGlyZWN0TW9kaWZpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9KS5qb2luKENPTU1BX1NFUEFSQVRPUik7XG4gIHJldHVybiBcIlwiLmNvbmNhdChiYXNlUGFydCwgXCIkXCIpLmNvbmNhdCh1Ym9Nb2RpZmllcnMpO1xufTtcblxuLyoqXG4gKiBAcmVkaXJlY3QgZ29vZ2xlLWFuYWx5dGljc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3MgR29vZ2xlJ3MgQW5hbHl0aWNzIGFuZCBUYWcgTWFuYWdlciBBUElzLlxuICogW0NvdmVycyBvYnNvbGV0ZSBnb29nbGV0YWdtYW5hZ2VyLWd0bSByZWRpcmVjdCBmdW5jdGlvbmFsaXR5XShodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTI3KS5cbiAqXG4gKiBSZWxhdGVkIFVCTyByZWRpcmVjdCByZXNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9ibG9iLzhjZDJhMWQyNjNhOTY0MjE0ODdiMzkwNDBjMWQyM2ViMDExNjk0ODQvc3JjL3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy9nb29nbGUtYW5hbHl0aWNzX2FuYWx5dGljcy5qc1xuICpcbiAqICoqRXhhbXBsZSoqXG4gKiBgYGBcbiAqIHx8Z29vZ2xlLWFuYWx5dGljcy5jb20vYW5hbHl0aWNzLmpzJHNjcmlwdCxyZWRpcmVjdD1nb29nbGUtYW5hbHl0aWNzXG4gKiB8fGdvb2dsZXRhZ21hbmFnZXIuY29tL2d0bS5qcyRzY3JpcHQscmVkaXJlY3Q9Z29vZ2xldGFnbWFuYWdlci1ndG1cbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIEdvb2dsZUFuYWx5dGljcyhzb3VyY2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgdmFyIFRyYWNrZXIgPSBmdW5jdGlvbiBUcmFja2VyKCkge307IC8vIGNvbnN0cnVjdG9yXG5cblxuICB2YXIgcHJvdG8gPSBUcmFja2VyLnByb3RvdHlwZTtcbiAgcHJvdG8uZ2V0ID0gbm9vcEZ1bmM7XG4gIHByb3RvLnNldCA9IG5vb3BGdW5jO1xuICBwcm90by5zZW5kID0gbm9vcEZ1bmM7XG4gIHZhciBnb29nbGVBbmFseXRpY3NOYW1lID0gd2luZG93Lkdvb2dsZUFuYWx5dGljc09iamVjdCB8fCAnZ2EnOyAvLyBhIC0tIGZha2UgYXJnIGZvciAnZ2EubGVuZ3RoIDwgMScgYW50aWFkYmxvY2sgY2hlY2tpbmdcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZnVuY3Rpb24gZ2EoYSkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuXG5cbiAgICB2YXIgbGFzdEFyZyA9IGFyZ3VtZW50c1tsZW4gLSAxXTtcbiAgICB2YXIgcmVwbGFjZXI7XG5cbiAgICBpZiAobGFzdEFyZyBpbnN0YW5jZW9mIE9iamVjdCAmJiBsYXN0QXJnICE9PSBudWxsICYmIHR5cGVvZiBsYXN0QXJnLmhpdENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXBsYWNlciA9IGxhc3RBcmcuaGl0Q2FsbGJhY2s7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzk4XG4gICAgICByZXBsYWNlciA9IGZ1bmN0aW9uIHJlcGxhY2VyKCkge1xuICAgICAgICBsYXN0QXJnKGdhLmNyZWF0ZSgpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHNldFRpbWVvdXQocmVwbGFjZXIsIDEpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChleCkge31cbiAgfVxuXG4gIGdhLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFRyYWNrZXIoKTtcbiAgfTtcblxuICBnYS5nZXRCeU5hbWUgPSBub29wTnVsbDtcbiAgZ2EuZ2V0QWxsID0gbm9vcEFycmF5O1xuICBnYS5yZW1vdmUgPSBub29wRnVuYztcbiAgZ2EubG9hZGVkID0gdHJ1ZTtcbiAgd2luZG93W2dvb2dsZUFuYWx5dGljc05hbWVdID0gZ2E7XG4gIHZhciBfd2luZG93ID0gd2luZG93LFxuICAgICAgZGF0YUxheWVyID0gX3dpbmRvdy5kYXRhTGF5ZXIsXG4gICAgICBnb29nbGVfb3B0aW1pemUgPSBfd2luZG93Lmdvb2dsZV9vcHRpbWl6ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICBpZiAoZGF0YUxheWVyIGluc3RhbmNlb2YgT2JqZWN0ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhTGF5ZXIuaGlkZSBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgZGF0YUxheWVyLmhpZGUuZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YUxheWVyLmhpZGUuZW5kKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGRhdGFMYXllci5wdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGF0YUxheWVyLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIGRhdGEuZXZlbnRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzZXRUaW1lb3V0KGRhdGEuZXZlbnRDYWxsYmFjaywgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvODFcblxuXG4gIGlmIChnb29nbGVfb3B0aW1pemUgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIGdvb2dsZV9vcHRpbWl6ZS5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgIHZhciBnb29nbGVPcHRpbWl6ZVdyYXBwZXIgPSB7fTtcbiAgICBnb29nbGVPcHRpbWl6ZVdyYXBwZXIuZ2V0ID0gbm9vcEZ1bmM7XG4gICAgd2luZG93Lmdvb2dsZV9vcHRpbWl6ZSA9IGdvb2dsZU9wdGltaXplV3JhcHBlcjtcbiAgfVxuXG4gIGhpdChzb3VyY2UpO1xufVxuR29vZ2xlQW5hbHl0aWNzLm5hbWVzID0gWydnb29nbGUtYW5hbHl0aWNzJywgJ3Viby1nb29nbGUtYW5hbHl0aWNzX2FuYWx5dGljcy5qcycsICdnb29nbGUtYW5hbHl0aWNzX2FuYWx5dGljcy5qcycsIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMjdcbidnb29nbGV0YWdtYW5hZ2VyLWd0bScsICd1Ym8tZ29vZ2xldGFnbWFuYWdlcl9ndG0uanMnLCAnZ29vZ2xldGFnbWFuYWdlcl9ndG0uanMnXTtcbkdvb2dsZUFuYWx5dGljcy5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmMsIG5vb3BOdWxsLCBub29wQXJyYXldO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuLyoqXG4gKiBAcmVkaXJlY3QgZ29vZ2xlLWFuYWx5dGljcy1nYVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3Mgb2xkIEdvb2dsZSBBbmFseXRpY3MgQVBJLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHJlZGlyZWN0IHJlc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL2Jsb2IvYTk0ZGY3ZjNiMjcwODBhZTJkY2IzYjkxNGFjZTM5YzBjMjk0ZDJmNi9zcmMvd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzL2dvb2dsZS1hbmFseXRpY3NfZ2EuanNcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fGdvb2dsZS1hbmFseXRpY3MuY29tL2dhLmpzJHNjcmlwdCxyZWRpcmVjdD1nb29nbGUtYW5hbHl0aWNzLWdhXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBHb29nbGVBbmFseXRpY3NHYShzb3VyY2UpIHtcbiAgLy8gR2FxIGNvbnN0cnVjdG9yXG4gIGZ1bmN0aW9uIEdhcSgpIHt9XG5cbiAgR2FxLnByb3RvdHlwZS5OYSA9IG5vb3BGdW5jO1xuICBHYXEucHJvdG90eXBlLk8gPSBub29wRnVuYztcbiAgR2FxLnByb3RvdHlwZS5TYSA9IG5vb3BGdW5jO1xuICBHYXEucHJvdG90eXBlLlRhID0gbm9vcEZ1bmM7XG4gIEdhcS5wcm90b3R5cGUuVmEgPSBub29wRnVuYztcbiAgR2FxLnByb3RvdHlwZS5fY3JlYXRlQXN5bmNUcmFja2VyID0gbm9vcEZ1bmM7XG4gIEdhcS5wcm90b3R5cGUuX2dldEFzeW5jVHJhY2tlciA9IG5vb3BGdW5jO1xuICBHYXEucHJvdG90eXBlLl9nZXRQbHVnaW4gPSBub29wRnVuYztcblxuICBHYXEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGF0YSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vYW5hbHl0aWNzL2Rldmd1aWRlcy9jb2xsZWN0aW9uL2dhanMvbWV0aG9kcy9nYUpTQXBpRG9tYWluRGlyZWN0b3J5I19nYXQuR0FfVHJhY2tlcl8uX2xpbmtcblxuXG4gICAgaWYgKGRhdGFbMF0gPT09ICdfbGluaycgJiYgdHlwZW9mIGRhdGFbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGRhdGFbMV0pO1xuICAgIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL2lzc3Vlcy8yMTYyXG5cblxuICAgIGlmIChkYXRhWzBdID09PSAnX3NldCcgJiYgZGF0YVsxXSA9PT0gJ2hpdENhbGxiYWNrJyAmJiB0eXBlb2YgZGF0YVsyXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGF0YVsyXSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2FxID0gbmV3IEdhcSgpO1xuICB2YXIgYXN5bmNUcmFja2VycyA9IHdpbmRvdy5fZ2FxIHx8IFtdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGFzeW5jVHJhY2tlcnMpKSB7XG4gICAgd2hpbGUgKGFzeW5jVHJhY2tlcnNbMF0pIHtcbiAgICAgIGdhcS5wdXNoKGFzeW5jVHJhY2tlcnMuc2hpZnQoKSk7XG4gICAgfVxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cblxuXG4gIHdpbmRvdy5fZ2FxID0gZ2FxLnFmID0gZ2FxOyAvLyBHYXQgY29uc3RydWN0b3JcblxuICBmdW5jdGlvbiBHYXQoKSB7fSAvLyBNb2NrIHRyYWNrZXIgYXBpXG5cblxuICB2YXIgYXBpID0gWydfYWRkSWdub3JlZE9yZ2FuaWMnLCAnX2FkZElnbm9yZWRSZWYnLCAnX2FkZEl0ZW0nLCAnX2FkZE9yZ2FuaWMnLCAnX2FkZFRyYW5zJywgJ19jbGVhcklnbm9yZWRPcmdhbmljJywgJ19jbGVhcklnbm9yZWRSZWYnLCAnX2NsZWFyT3JnYW5pYycsICdfY29va2llUGF0aENvcHknLCAnX2RlbGV0ZUN1c3RvbVZhcicsICdfZ2V0TmFtZScsICdfc2V0QWNjb3VudCcsICdfZ2V0QWNjb3VudCcsICdfZ2V0Q2xpZW50SW5mbycsICdfZ2V0RGV0ZWN0Rmxhc2gnLCAnX2dldERldGVjdFRpdGxlJywgJ19nZXRMaW5rZXJVcmwnLCAnX2dldExvY2FsR2lmUGF0aCcsICdfZ2V0U2VydmljZU1vZGUnLCAnX2dldFZlcnNpb24nLCAnX2dldFZpc2l0b3JDdXN0b21WYXInLCAnX2luaXREYXRhJywgJ19saW5rJywgJ19saW5rQnlQb3N0JywgJ19zZXRBbGxvd0FuY2hvcicsICdfc2V0QWxsb3dIYXNoJywgJ19zZXRBbGxvd0xpbmtlcicsICdfc2V0Q2FtcENvbnRlbnRLZXknLCAnX3NldENhbXBNZWRpdW1LZXknLCAnX3NldENhbXBOYW1lS2V5JywgJ19zZXRDYW1wTk9LZXknLCAnX3NldENhbXBTb3VyY2VLZXknLCAnX3NldENhbXBUZXJtS2V5JywgJ19zZXRDYW1wYWlnbkNvb2tpZVRpbWVvdXQnLCAnX3NldENhbXBhaWduVHJhY2snLCAnX3NldENsaWVudEluZm8nLCAnX3NldENvb2tpZVBhdGgnLCAnX3NldENvb2tpZVBlcnNpc3RlbmNlJywgJ19zZXRDb29raWVUaW1lb3V0JywgJ19zZXRDdXN0b21WYXInLCAnX3NldERldGVjdEZsYXNoJywgJ19zZXREZXRlY3RUaXRsZScsICdfc2V0RG9tYWluTmFtZScsICdfc2V0TG9jYWxHaWZQYXRoJywgJ19zZXRMb2NhbFJlbW90ZVNlcnZlck1vZGUnLCAnX3NldExvY2FsU2VydmVyTW9kZScsICdfc2V0UmVmZXJyZXJPdmVycmlkZScsICdfc2V0UmVtb3RlU2VydmVyTW9kZScsICdfc2V0U2FtcGxlUmF0ZScsICdfc2V0U2Vzc2lvblRpbWVvdXQnLCAnX3NldFNpdGVTcGVlZFNhbXBsZVJhdGUnLCAnX3NldFNlc3Npb25Db29raWVUaW1lb3V0JywgJ19zZXRWYXInLCAnX3NldFZpc2l0b3JDb29raWVUaW1lb3V0JywgJ190cmFja0V2ZW50JywgJ190cmFja1BhZ2VMb2FkVGltZScsICdfdHJhY2tQYWdldmlldycsICdfdHJhY2tTb2NpYWwnLCAnX3RyYWNrVGltaW5nJywgJ190cmFja1RyYW5zJywgJ192aXNpdENvZGUnXTtcbiAgdmFyIHRyYWNrZXIgPSBhcGkucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGZ1bmNOYW1lKSB7XG4gICAgcmVzW2Z1bmNOYW1lXSA9IG5vb3BGdW5jO1xuICAgIHJldHVybiByZXM7XG4gIH0sIHt9KTtcblxuICB0cmFja2VyLl9nZXRMaW5rZXJVcmwgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIEdhdC5wcm90b3R5cGUuX2Fub255bWl6ZUlQID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUuX2NyZWF0ZVRyYWNrZXIgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5fZm9yY2VTU0wgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5fZ2V0UGx1Z2luID0gbm9vcEZ1bmM7XG5cbiAgR2F0LnByb3RvdHlwZS5fZ2V0VHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhY2tlcjtcbiAgfTtcblxuICBHYXQucHJvdG90eXBlLl9nZXRUcmFja2VyQnlOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cmFja2VyO1xuICB9O1xuXG4gIEdhdC5wcm90b3R5cGUuX2dldFRyYWNrZXJzID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUuYWEgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5hYiA9IG5vb3BGdW5jO1xuICBHYXQucHJvdG90eXBlLmhiID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUubGEgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5vYSA9IG5vb3BGdW5jO1xuICBHYXQucHJvdG90eXBlLnBhID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUudSA9IG5vb3BGdW5jO1xuICB2YXIgZ2F0ID0gbmV3IEdhdCgpO1xuICB3aW5kb3cuX2dhdCA9IGdhdDtcbiAgaGl0KHNvdXJjZSk7XG59XG5Hb29nbGVBbmFseXRpY3NHYS5uYW1lcyA9IFsnZ29vZ2xlLWFuYWx5dGljcy1nYScsICd1Ym8tZ29vZ2xlLWFuYWx5dGljc19nYS5qcycsICdnb29nbGUtYW5hbHl0aWNzX2dhLmpzJ107XG5Hb29nbGVBbmFseXRpY3NHYS5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmNdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHJlZGlyZWN0IGdvb2dsZXN5bmRpY2F0aW9uLWFkc2J5Z29vZ2xlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBHb29nbGUgQWRTZW5zZSBBUEkuXG4gKlxuICogUmVsYXRlZCBVQk8gcmVkaXJlY3QgcmVzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svYmxvYi9hOTRkZjdmM2IyNzA4MGFlMmRjYjNiOTE0YWNlMzljMGMyOTRkMmY2L3NyYy93ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMvZ29vZ2xlc3luZGljYXRpb25fYWRzYnlnb29nbGUuanNcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fHBhZ2VhZDIuZ29vZ2xlc3luZGljYXRpb24uY29tL3BhZ2VhZC9qcy9hZHNieWdvb2dsZS5qcyRzY3JpcHQscmVkaXJlY3Q9Z29vZ2xlc3luZGljYXRpb24tYWRzYnlnb29nbGVcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBHb29nbGVTeW5kaWNhdGlvbkFkc0J5R29vZ2xlKHNvdXJjZSkge1xuICB3aW5kb3cuYWRzYnlnb29nbGUgPSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzExM1xuICAgIC8vIGxlbmd0aDogMCxcbiAgICBsb2FkZWQ6IHRydWUsXG4gICAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5sZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBhZEVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFkc2J5Z29vZ2xlJyk7XG4gIHZhciBjc3MgPSAnaGVpZ2h0OjFweCFpbXBvcnRhbnQ7bWF4LWhlaWdodDoxcHghaW1wb3J0YW50O21heC13aWR0aDoxcHghaW1wb3J0YW50O3dpZHRoOjFweCFpbXBvcnRhbnQ7JztcbiAgdmFyIHN0YXR1c0F0dHJOYW1lID0gJ2RhdGEtYWRzYnlnb29nbGUtc3RhdHVzJztcbiAgdmFyIEFTV0lGVF9JRlJBTUVfTUFSS0VSID0gJ2Fzd2lmdF8nO1xuICB2YXIgR09PR0xFX0FEU19JRlJBTUVfTUFSS0VSID0gJ2dvb2dsZV9hZHNfaWZyYW1lXyc7XG4gIHZhciBleGVjdXRlZCA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRFbGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBhZEVsZW1DaGlsZE5vZGVzID0gYWRFbGVtc1tpXS5jaGlsZE5vZGVzO1xuICAgIHZhciBjaGlsZE5vZGVzUXVhbnRpdHkgPSBhZEVsZW1DaGlsZE5vZGVzLmxlbmd0aDsgLy8gY2hpbGROb2RlcyBvZiAuYWRzYnlnb29nbGUgY2FuIGJlIGRlZmluZWQgaWYgc2NyaXB0bGV0IHdhcyBleGVjdXRlZCBiZWZvcmVcbiAgICAvLyBzbyB3ZSBzaG91bGQgY2hlY2sgYXJlIHRoYXQgY2hpbGROb2RlcyBleGFjdGx5IGRlZmluZWQgYnkgdXNcbiAgICAvLyBUT0RPOiByZW1ha2UgYWZ0ZXIgc2NyaXB0bGV0cyBjb250ZXh0IGRldmVsb3BpbmcgaW4gMS4zXG5cbiAgICB2YXIgYXJlSWZyYW1lc0RlZmluZWQgPSBmYWxzZTtcblxuICAgIGlmIChjaGlsZE5vZGVzUXVhbnRpdHkgPiAwKSB7XG4gICAgICAvLyBpdCBzaG91bGQgYmUgb25seSAyIGNoaWxkIGlmcmFtZXMgaWYgc2NyaXB0bGV0IHdhcyBleGVjdXRlZFxuICAgICAgYXJlSWZyYW1lc0RlZmluZWQgPSBjaGlsZE5vZGVzUXVhbnRpdHkgPT09IDIgLy8gdGhlIGZpcnN0IG9mIGNoaWxkIG5vZGVzIHNob3VsZCBiZSBhc3dpZnQgaWZyYW1lXG4gICAgICAmJiBhZEVsZW1DaGlsZE5vZGVzWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lmcmFtZScgJiYgYWRFbGVtQ2hpbGROb2Rlc1swXS5pZC5pbmRleE9mKEFTV0lGVF9JRlJBTUVfTUFSS0VSKSA+IC0xIC8vIHRoZSBzZWNvbmQgb2YgY2hpbGQgbm9kZXMgc2hvdWxkIGJlIGdvb2dsZV9hZHMgaWZyYW1lXG4gICAgICAmJiBhZEVsZW1DaGlsZE5vZGVzWzFdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lmcmFtZScgJiYgYWRFbGVtQ2hpbGROb2Rlc1sxXS5pZC5pbmRleE9mKEdPT0dMRV9BRFNfSUZSQU1FX01BUktFUikgPiAtMTtcbiAgICB9XG5cbiAgICBpZiAoIWFyZUlmcmFtZXNEZWZpbmVkKSB7XG4gICAgICAvLyBoZXJlIHdlIGRvIHRoZSBqb2IgaWYgc2NyaXB0bGV0IGhhcyBub3QgYmVlbiBleGVjdXRlZCBlYXJsaWVyXG4gICAgICBhZEVsZW1zW2ldLnNldEF0dHJpYnV0ZShzdGF0dXNBdHRyTmFtZSwgJ2RvbmUnKTtcbiAgICAgIHZhciBhc3dpZnRJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGFzd2lmdElmcmFtZS5pZCA9IFwiXCIuY29uY2F0KEFTV0lGVF9JRlJBTUVfTUFSS0VSKS5jb25jYXQoaSk7XG4gICAgICBhc3dpZnRJZnJhbWUuc3R5bGUgPSBjc3M7XG4gICAgICBhZEVsZW1zW2ldLmFwcGVuZENoaWxkKGFzd2lmdElmcmFtZSk7XG4gICAgICB2YXIgaW5uZXJBc3dpZnRJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGFzd2lmdElmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5uZXJBc3dpZnRJZnJhbWUpO1xuICAgICAgdmFyIGdvb2dsZWFkc0lmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZ29vZ2xlYWRzSWZyYW1lLmlkID0gXCJcIi5jb25jYXQoR09PR0xFX0FEU19JRlJBTUVfTUFSS0VSKS5jb25jYXQoaSk7XG4gICAgICBnb29nbGVhZHNJZnJhbWUuc3R5bGUgPSBjc3M7XG4gICAgICBhZEVsZW1zW2ldLmFwcGVuZENoaWxkKGdvb2dsZWFkc0lmcmFtZSk7XG4gICAgICB2YXIgaW5uZXJHb29nbGVhZHNJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGdvb2dsZWFkc0lmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5uZXJHb29nbGVhZHNJZnJhbWUpO1xuICAgICAgZXhlY3V0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleGVjdXRlZCkge1xuICAgIGhpdChzb3VyY2UpO1xuICB9XG59XG5Hb29nbGVTeW5kaWNhdGlvbkFkc0J5R29vZ2xlLm5hbWVzID0gWydnb29nbGVzeW5kaWNhdGlvbi1hZHNieWdvb2dsZScsICd1Ym8tZ29vZ2xlc3luZGljYXRpb25fYWRzYnlnb29nbGUuanMnLCAnZ29vZ2xlc3luZGljYXRpb25fYWRzYnlnb29nbGUuanMnXTtcbkdvb2dsZVN5bmRpY2F0aW9uQWRzQnlHb29nbGUuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKipcbiAqIEByZWRpcmVjdCBnb29nbGV0YWdzZXJ2aWNlcy1ncHRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1vY2tzIEdvb2dsZSBQdWJsaXNoZXIgVGFnIEFQSS5cbiAqXG4gKiBSZWxhdGVkIFVCTyByZWRpcmVjdCByZXNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9ibG9iL2E5NGRmN2YzYjI3MDgwYWUyZGNiM2I5MTRhY2UzOWMwYzI5NGQyZjYvc3JjL3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy9nb29nbGV0YWdzZXJ2aWNlc19ncHQuanNcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fGdvb2dsZXRhZ3NlcnZpY2VzLmNvbS90YWcvanMvZ3B0LmpzJHNjcmlwdCxyZWRpcmVjdD1nb29nbGV0YWdzZXJ2aWNlcy1ncHRcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIEdvb2dsZVRhZ1NlcnZpY2VzR3B0KHNvdXJjZSkge1xuICB2YXIgY29tcGFuaW9uQWRzU2VydmljZSA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBub29wVGhpcyxcbiAgICBlbmFibGVTeW5jTG9hZGluZzogbm9vcEZ1bmMsXG4gICAgc2V0UmVmcmVzaFVuZmlsbGVkU2xvdHM6IG5vb3BGdW5jXG4gIH07XG4gIHZhciBjb250ZW50U2VydmljZSA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBub29wVGhpcyxcbiAgICBzZXRDb250ZW50OiBub29wRnVuY1xuICB9O1xuXG4gIGZ1bmN0aW9uIFBhc3NiYWNrU2xvdCgpIHt9IC8vIGNvbnN0cnVjdG9yXG5cblxuICBQYXNzYmFja1Nsb3QucHJvdG90eXBlLmRpc3BsYXkgPSBub29wRnVuYztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5nZXQgPSBub29wTnVsbDtcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5zZXQgPSBub29wVGhpcztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5zZXRDbGlja1VybCA9IG5vb3BUaGlzO1xuICBQYXNzYmFja1Nsb3QucHJvdG90eXBlLnNldFRhZ0ZvckNoaWxkRGlyZWN0ZWRUcmVhdG1lbnQgPSBub29wVGhpcztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5zZXRUYXJnZXRpbmcgPSBub29wVGhpcztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS51cGRhdGVUYXJnZXRpbmdGcm9tTWFwID0gbm9vcFRoaXM7XG5cbiAgZnVuY3Rpb24gU2l6ZU1hcHBpbmdCdWlsZGVyKCkge30gLy8gY29uc3RydWN0b3JcblxuXG4gIFNpemVNYXBwaW5nQnVpbGRlci5wcm90b3R5cGUuYWRkU2l6ZSA9IG5vb3BUaGlzO1xuICBTaXplTWFwcGluZ0J1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gbm9vcE51bGw7XG5cbiAgZnVuY3Rpb24gU2xvdCgpIHt9IC8vIGNvbnN0cnVjdG9yXG5cblxuICBTbG90LnByb3RvdHlwZS5hZGRTZXJ2aWNlID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLmNsZWFyQ2F0ZWdvcnlFeGNsdXNpb25zID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLmNsZWFyVGFyZ2V0aW5nID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLmRlZmluZVNpemVNYXBwaW5nID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLmdldCA9IG5vb3BOdWxsO1xuICBTbG90LnByb3RvdHlwZS5nZXRBZFVuaXRQYXRoID0gbm9vcEFycmF5O1xuICBTbG90LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVLZXlzID0gbm9vcEFycmF5O1xuICBTbG90LnByb3RvdHlwZS5nZXRDYXRlZ29yeUV4Y2x1c2lvbnMgPSBub29wQXJyYXk7XG4gIFNsb3QucHJvdG90eXBlLmdldERvbUlkID0gbm9vcFN0cjtcbiAgU2xvdC5wcm90b3R5cGUuZ2V0U2xvdEVsZW1lbnRJZCA9IG5vb3BTdHI7XG4gIFNsb3QucHJvdG90eXBlLmdldFNsb3RJZCA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5nZXRUYXJnZXRpbmcgPSBub29wQXJyYXk7XG4gIFNsb3QucHJvdG90eXBlLmdldFRhcmdldGluZ0tleXMgPSBub29wQXJyYXk7XG4gIFNsb3QucHJvdG90eXBlLnNldCA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5zZXRDYXRlZ29yeUV4Y2x1c2lvbiA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5zZXRDbGlja1VybCA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5zZXRDb2xsYXBzZUVtcHR5RGl2ID0gbm9vcFRoaXM7XG4gIFNsb3QucHJvdG90eXBlLnNldFRhcmdldGluZyA9IG5vb3BUaGlzO1xuICB2YXIgcHViQWRzU2VydmljZSA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBub29wVGhpcyxcbiAgICBjbGVhcjogbm9vcEZ1bmMsXG4gICAgY2xlYXJDYXRlZ29yeUV4Y2x1c2lvbnM6IG5vb3BUaGlzLFxuICAgIGNsZWFyVGFnRm9yQ2hpbGREaXJlY3RlZFRyZWF0bWVudDogbm9vcFRoaXMsXG4gICAgY2xlYXJUYXJnZXRpbmc6IG5vb3BUaGlzLFxuICAgIGNvbGxhcHNlRW1wdHlEaXZzOiBub29wRnVuYyxcbiAgICBkZWZpbmVPdXRPZlBhZ2VQYXNzYmFjazogZnVuY3Rpb24gZGVmaW5lT3V0T2ZQYWdlUGFzc2JhY2soKSB7XG4gICAgICByZXR1cm4gbmV3IFBhc3NiYWNrU2xvdCgpO1xuICAgIH0sXG4gICAgZGVmaW5lUGFzc2JhY2s6IGZ1bmN0aW9uIGRlZmluZVBhc3NiYWNrKCkge1xuICAgICAgcmV0dXJuIG5ldyBQYXNzYmFja1Nsb3QoKTtcbiAgICB9LFxuICAgIGRpc2FibGVJbml0aWFsTG9hZDogbm9vcEZ1bmMsXG4gICAgZGlzcGxheTogbm9vcEZ1bmMsXG4gICAgZW5hYmxlQXN5bmNSZW5kZXJpbmc6IG5vb3BGdW5jLFxuICAgIGVuYWJsZVNpbmdsZVJlcXVlc3Q6IG5vb3BGdW5jLFxuICAgIGVuYWJsZVN5bmNSZW5kZXJpbmc6IG5vb3BGdW5jLFxuICAgIGVuYWJsZVZpZGVvQWRzOiBub29wRnVuYyxcbiAgICBnZXQ6IG5vb3BOdWxsLFxuICAgIGdldEF0dHJpYnV0ZUtleXM6IG5vb3BBcnJheSxcbiAgICBnZXRUYXJnZXRpbmc6IG5vb3BGdW5jLFxuICAgIGdldFRhcmdldGluZ0tleXM6IG5vb3BBcnJheSxcbiAgICBnZXRTbG90czogbm9vcEFycmF5LFxuICAgIHJlZnJlc2g6IG5vb3BGdW5jLFxuICAgIHNldDogbm9vcFRoaXMsXG4gICAgc2V0Q2F0ZWdvcnlFeGNsdXNpb246IG5vb3BUaGlzLFxuICAgIHNldENlbnRlcmluZzogbm9vcEZ1bmMsXG4gICAgc2V0Q29va2llT3B0aW9uczogbm9vcFRoaXMsXG4gICAgc2V0Rm9yY2VTYWZlRnJhbWU6IG5vb3BUaGlzLFxuICAgIHNldExvY2F0aW9uOiBub29wVGhpcyxcbiAgICBzZXRQdWJsaXNoZXJQcm92aWRlZElkOiBub29wVGhpcyxcbiAgICBzZXRSZXF1ZXN0Tm9uUGVyc29uYWxpemVkQWRzOiBub29wVGhpcyxcbiAgICBzZXRTYWZlRnJhbWVDb25maWc6IG5vb3BUaGlzLFxuICAgIHNldFRhZ0ZvckNoaWxkRGlyZWN0ZWRUcmVhdG1lbnQ6IG5vb3BUaGlzLFxuICAgIHNldFRhcmdldGluZzogbm9vcFRoaXMsXG4gICAgc2V0VmlkZW9Db250ZW50OiBub29wVGhpcyxcbiAgICB1cGRhdGVDb3JyZWxhdG9yOiBub29wRnVuY1xuICB9O1xuICB2YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICAgIF93aW5kb3ckZ29vZ2xldGFnID0gX3dpbmRvdy5nb29nbGV0YWcsXG4gICAgICBnb29nbGV0YWcgPSBfd2luZG93JGdvb2dsZXRhZyA9PT0gdm9pZCAwID8ge30gOiBfd2luZG93JGdvb2dsZXRhZztcbiAgdmFyIF9nb29nbGV0YWckY21kID0gZ29vZ2xldGFnLmNtZCxcbiAgICAgIGNtZCA9IF9nb29nbGV0YWckY21kID09PSB2b2lkIDAgPyBbXSA6IF9nb29nbGV0YWckY21kO1xuICBnb29nbGV0YWcuYXBpUmVhZHkgPSB0cnVlO1xuICBnb29nbGV0YWcuY21kID0gW107XG5cbiAgZ29vZ2xldGFnLmNtZC5wdXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB0cnkge1xuICAgICAgYSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChleCkge31cblxuICAgIHJldHVybiAxO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5jb21wYW5pb25BZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbXBhbmlvbkFkc1NlcnZpY2U7XG4gIH07XG5cbiAgZ29vZ2xldGFnLmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRlbnRTZXJ2aWNlO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5kZWZpbmVPdXRPZlBhZ2VTbG90ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU2xvdCgpO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5kZWZpbmVTbG90ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU2xvdCgpO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5kZXN0cm95U2xvdHMgPSBub29wRnVuYztcbiAgZ29vZ2xldGFnLmRpc2FibGVQdWJsaXNoZXJDb25zb2xlID0gbm9vcEZ1bmM7XG4gIGdvb2dsZXRhZy5kaXNwbGF5ID0gbm9vcEZ1bmM7XG4gIGdvb2dsZXRhZy5lbmFibGVTZXJ2aWNlcyA9IG5vb3BGdW5jO1xuICBnb29nbGV0YWcuZ2V0VmVyc2lvbiA9IG5vb3BTdHI7XG5cbiAgZ29vZ2xldGFnLnB1YmFkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHViQWRzU2VydmljZTtcbiAgfTtcblxuICBnb29nbGV0YWcucHViYWRzUmVhZHkgPSB0cnVlO1xuICBnb29nbGV0YWcuc2V0QWRJZnJhbWVUaXRsZSA9IG5vb3BGdW5jO1xuXG4gIGdvb2dsZXRhZy5zaXplTWFwcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNpemVNYXBwaW5nQnVpbGRlcigpO1xuICB9O1xuXG4gIHdpbmRvdy5nb29nbGV0YWcgPSBnb29nbGV0YWc7XG5cbiAgd2hpbGUgKGNtZC5sZW5ndGggIT09IDApIHtcbiAgICBnb29nbGV0YWcuY21kLnB1c2goY21kLnNoaWZ0KCkpO1xuICB9XG5cbiAgaGl0KHNvdXJjZSk7XG59XG5Hb29nbGVUYWdTZXJ2aWNlc0dwdC5uYW1lcyA9IFsnZ29vZ2xldGFnc2VydmljZXMtZ3B0JywgJ3Viby1nb29nbGV0YWdzZXJ2aWNlc19ncHQuanMnLCAnZ29vZ2xldGFnc2VydmljZXNfZ3B0LmpzJ107XG5Hb29nbGVUYWdTZXJ2aWNlc0dwdC5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmMsIG5vb3BUaGlzLCBub29wTnVsbCwgbm9vcEFycmF5LCBub29wU3RyXTtcblxuLyoqXG4gKiBAcmVkaXJlY3Qgc2NvcmVjYXJkcmVzZWFyY2gtYmVhY29uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBTY29yZWNhcmQgUmVzZWFyY2ggQVBJLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHJlZGlyZWN0IHJlc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL2Jsb2IvYTk0ZGY3ZjNiMjcwODBhZTJkY2IzYjkxNGFjZTM5YzBjMjk0ZDJmNi9zcmMvd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzL3Njb3JlY2FyZHJlc2VhcmNoX2JlYWNvbi5qc1xuICpcbiAqICoqRXhhbXBsZSoqXG4gKiBgYGBcbiAqIHx8c2Iuc2NvcmVjYXJkcmVzZWFyY2guY29tL2JlYWNvbi5qcyRzY3JpcHQscmVkaXJlY3Q9c2NvcmVjYXJkcmVzZWFyY2gtYmVhY29uXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBTY29yZUNhcmRSZXNlYXJjaEJlYWNvbihzb3VyY2UpIHtcbiAgd2luZG93LkNPTVNDT1JFID0ge1xuICAgIHB1cmdlOiBmdW5jdGlvbiBwdXJnZSgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgd2luZG93Ll9jb21zY29yZSA9IFtdO1xuICAgIH0sXG4gICAgYmVhY29uOiBmdW5jdGlvbiBiZWFjb24oKSB7fVxuICB9O1xuICBoaXQoc291cmNlKTtcbn1cblNjb3JlQ2FyZFJlc2VhcmNoQmVhY29uLm5hbWVzID0gWydzY29yZWNhcmRyZXNlYXJjaC1iZWFjb24nLCAndWJvLXNjb3JlY2FyZHJlc2VhcmNoX2JlYWNvbi5qcycsICdzY29yZWNhcmRyZXNlYXJjaF9iZWFjb24uanMnXTtcblNjb3JlQ2FyZFJlc2VhcmNoQmVhY29uLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyoqXG4gKiBAcmVkaXJlY3QgbWV0cmlrYS15YW5kZXgtdGFnXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBZYW5kZXggTWV0cmlrYSBBUEkuXG4gKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9tZXRob2QtcmVmZXJlbmNlLmh0bWxcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fG1jLnlhbmRleC5ydS9tZXRyaWthL3RhZy5qcyRzY3JpcHQscmVkaXJlY3Q9bWV0cmlrYS15YW5kZXgtdGFnXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBtZXRyaWthWWFuZGV4VGFnKHNvdXJjZSkge1xuICB2YXIgYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zID0gZnVuY3Rpb24gYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zKHBhcmFtKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgdmFyIGN0eCA9IG9wdGlvbnMuY3R4O1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBjdHggIT09IHVuZGVmaW5lZCA/IGNhbGxiYWNrLmJpbmQoY3R4KSA6IGNhbGxiYWNrO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0ID0gbm9vcEZ1bmM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9hZGRmaWxlZXh0ZW5zaW9uLmh0bWxcbiAgICovXG5cbiAgdmFyIGFkZEZpbGVFeHRlbnNpb24gPSBub29wRnVuYztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL2V4dGxpbmsuaHRtbFxuICAgKi9cblxuICB2YXIgZXh0TGluayA9IGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL2ZpbGUuaHRtbFxuICAgKi9cblxuICB2YXIgZmlsZSA9IGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL2dldC1jbGllbnQtaWQuaHRtbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICB2YXIgZ2V0Q2xpZW50SUQgPSBmdW5jdGlvbiBnZXRDbGllbnRJRChjYikge1xuICAgIHNldFRpbWVvdXQoY2IobnVsbCkpO1xuICB9O1xuICAvKipcbiAgICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvaGl0Lmh0bWxcbiAgICovXG5cblxuICB2YXIgaGl0RnVuYyA9IGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL25vdGJvdW5jZS5odG1sXG4gICAqL1xuXG4gIHZhciBub3RCb3VuY2UgPSBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9wYXJhbXMtbWV0aG9kLmh0bWxcbiAgICovXG5cbiAgdmFyIHBhcmFtcyA9IG5vb3BGdW5jO1xuICAvKipcbiAgICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvcmVhY2hnb2FsLmh0bWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7YW55fSBjdHhcbiAgICovXG5cbiAgdmFyIHJlYWNoR29hbCA9IGZ1bmN0aW9uIHJlYWNoR29hbCh0YXJnZXQsIHBhcmFtcywgY2FsbGJhY2ssIGN0eCkge1xuICAgIGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucyhudWxsLCB7XG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjdHg6IGN0eFxuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvc2V0LXVzZXItaWQuaHRtbFxuICAgKi9cblxuXG4gIHZhciBzZXRVc2VySUQgPSBub29wRnVuYztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL3VzZXItcGFyYW1zLmh0bWxcbiAgICovXG5cbiAgdmFyIHVzZXJQYXJhbXMgPSBub29wRnVuYztcbiAgdmFyIGFwaSA9IHtcbiAgICBpbml0OiBpbml0LFxuICAgIGFkZEZpbGVFeHRlbnNpb246IGFkZEZpbGVFeHRlbnNpb24sXG4gICAgZXh0TGluazogZXh0TGluayxcbiAgICBmaWxlOiBmaWxlLFxuICAgIGdldENsaWVudElEOiBnZXRDbGllbnRJRCxcbiAgICBoaXQ6IGhpdEZ1bmMsXG4gICAgbm90Qm91bmNlOiBub3RCb3VuY2UsXG4gICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgcmVhY2hHb2FsOiByZWFjaEdvYWwsXG4gICAgc2V0VXNlcklEOiBzZXRVc2VySUQsXG4gICAgdXNlclBhcmFtczogdXNlclBhcmFtc1xuICB9O1xuXG4gIGZ1bmN0aW9uIHltKGlkLCBmdW5jTmFtZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhcGlbZnVuY05hbWVdICYmIGFwaVtmdW5jTmFtZV0uYXBwbHkoYXBpLCBhcmdzKTtcbiAgfVxuXG4gIHdpbmRvdy55bSA9IHltO1xuICBoaXQoc291cmNlKTtcbn1cbm1ldHJpa2FZYW5kZXhUYWcubmFtZXMgPSBbJ21ldHJpa2EteWFuZGV4LXRhZyddO1xubWV0cmlrYVlhbmRleFRhZy5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmNdO1xuXG4vKipcbiAqIEByZWRpcmVjdCBtZXRyaWthLXlhbmRleC13YXRjaFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3MgdGhlIG9sZCBZYW5kZXggTWV0cmlrYSBBUEkuXG4gKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9fbWV0aG9kLXJlZmVyZW5jZS5odG1sXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogfHxtYy55YW5kZXgucnUvbWV0cmlrYS93YXRjaC5qcyRzY3JpcHQscmVkaXJlY3Q9bWV0cmlrYS15YW5kZXgtd2F0Y2hcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIG1ldHJpa2FZYW5kZXhXYXRjaChzb3VyY2UpIHtcbiAgdmFyIGNiTmFtZSA9ICd5YW5kZXhfbWV0cmlrYV9jYWxsYmFja3MnO1xuICAvKipcbiAgICogR2V0cyBjYWxsYmFjayBhbmQgaXRzIGNvbnRleHQgZnJvbSBvcHRpb25zIGFuZCBjYWxsIGl0IGluIGFzeW5jIHdheVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBZYW5kZXggTWV0cmlrYSBBUEkgb3B0aW9uc1xuICAgKi9cblxuICB2YXIgYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zID0gZnVuY3Rpb24gYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIHZhciBjdHggPSBvcHRpb25zLmN0eDtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gY3R4ICE9PSB1bmRlZmluZWQgPyBjYWxsYmFjay5iaW5kKGN0eCkgOiBjYWxsYmFjaztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBNZXRyaWthKCkge30gLy8gY29uc3RydWN0b3JcbiAgLy8gTWV0aG9kcyB3aXRob3V0IG9wdGlvbnNcblxuXG4gIE1ldHJpa2EucHJvdG90eXBlLmFkZEZpbGVFeHRlbnNpb24gPSBub29wRnVuYztcbiAgTWV0cmlrYS5wcm90b3R5cGUuZ2V0Q2xpZW50SUQgPSBub29wRnVuYztcbiAgTWV0cmlrYS5wcm90b3R5cGUuc2V0VXNlcklEID0gbm9vcEZ1bmM7XG4gIE1ldHJpa2EucHJvdG90eXBlLnVzZXJQYXJhbXMgPSBub29wRnVuYzsgLy8gTWV0aG9kcyB3aXRoIG9wdGlvbnNcbiAgLy8gVGhlIG9yZGVyIG9mIGFyZ3VtZW50cyBzaG91bGQgYmUga2VwdCBpbiBhY2NvcmRpbmcgdG8gQVBJXG5cbiAgTWV0cmlrYS5wcm90b3R5cGUuZXh0TGluayA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIH07XG5cbiAgTWV0cmlrYS5wcm90b3R5cGUuZmlsZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIH07XG5cbiAgTWV0cmlrYS5wcm90b3R5cGUuaGl0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgIGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgfTtcblxuICBNZXRyaWthLnByb3RvdHlwZS5yZWFjaEdvYWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJhbXMsIGNiLCBjdHgpIHtcbiAgICBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnMoe1xuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgY3R4OiBjdHhcbiAgICB9KTtcbiAgfTtcblxuICBNZXRyaWthLnByb3RvdHlwZS5ub3RCb3VuY2UgPSBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnM7XG5cbiAgaWYgKHdpbmRvdy5ZYSkge1xuICAgIHdpbmRvdy5ZYS5NZXRyaWthID0gTWV0cmlrYTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuWWEgPSB7XG4gICAgICBNZXRyaWthOiBNZXRyaWthXG4gICAgfTtcbiAgfVxuXG4gIGlmICh3aW5kb3dbY2JOYW1lXSAmJiBBcnJheS5pc0FycmF5KHdpbmRvd1tjYk5hbWVdKSkge1xuICAgIHdpbmRvd1tjYk5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmdW5jKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBoaXQoc291cmNlKTtcbn1cbm1ldHJpa2FZYW5kZXhXYXRjaC5uYW1lcyA9IFsnbWV0cmlrYS15YW5kZXgtd2F0Y2gnXTtcbm1ldHJpa2FZYW5kZXhXYXRjaC5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmNdO1xuXG4vKipcbiAqIEByZWRpcmVjdCBhbWF6b24tYXBzdGFnXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBBbWF6b24ncyBhcHN0YWcuanNcbiAqXG4gKiBSZWxhdGVkIFVCTyByZWRpcmVjdCByZXNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9ibG9iL2Y4NDJhYjZkM2MxY2YwMzk0Zjk1ZDI3MDkyYmY1OTYyNzI2MmRhNDAvc3JjL3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy9hbWF6b25fYXBzdGFnLmpzXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogfHxhbWF6b24tYWRzeXN0ZW0uY29tL2FheDIvYXBzdGFnLmpzJHNjcmlwdCxyZWRpcmVjdD1hbWF6b24tYXBzdGFnXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBBbWF6b25BcHN0YWcoc291cmNlKSB7XG4gIHZhciBhcHN0YWdXcmFwcGVyID0ge1xuICAgIGZldGNoQmlkczogZnVuY3Rpb24gZmV0Y2hCaWRzKGEsIGIpIHtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBiKFtdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXQ6IG5vb3BGdW5jLFxuICAgIHNldERpc3BsYXlCaWRzOiBub29wRnVuYyxcbiAgICB0YXJnZXRpbmdLZXlzOiBub29wRnVuY1xuICB9O1xuICB3aW5kb3cuYXBzdGFnID0gYXBzdGFnV3JhcHBlcjtcbiAgaGl0KHNvdXJjZSk7XG59XG5BbWF6b25BcHN0YWcubmFtZXMgPSBbJ2FtYXpvbi1hcHN0YWcnLCAndWJvLWFtYXpvbl9hcHN0YWcuanMnLCAnYW1hem9uX2Fwc3RhZy5qcyddO1xuQW1hem9uQXBzdGFnLmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuY107XG5cbnZhciByZWRpcmVjdHNMaXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBub2V2YWw6IG5vZXZhbCxcbiAgICBHb29nbGVBbmFseXRpY3M6IEdvb2dsZUFuYWx5dGljcyxcbiAgICBHb29nbGVBbmFseXRpY3NHYTogR29vZ2xlQW5hbHl0aWNzR2EsXG4gICAgR29vZ2xlU3luZGljYXRpb25BZHNCeUdvb2dsZTogR29vZ2xlU3luZGljYXRpb25BZHNCeUdvb2dsZSxcbiAgICBHb29nbGVUYWdTZXJ2aWNlc0dwdDogR29vZ2xlVGFnU2VydmljZXNHcHQsXG4gICAgU2NvcmVDYXJkUmVzZWFyY2hCZWFjb246IFNjb3JlQ2FyZFJlc2VhcmNoQmVhY29uLFxuICAgIG1ldHJpa2FZYW5kZXhUYWc6IG1ldHJpa2FZYW5kZXhUYWcsXG4gICAgbWV0cmlrYVlhbmRleFdhdGNoOiBtZXRyaWthWWFuZGV4V2F0Y2gsXG4gICAgcHJldmVudEZhYjogcHJldmVudEZhYixcbiAgICBwcmV2ZW50QmFiOiBwcmV2ZW50QmFiLFxuICAgIHNldFBvcGFkc0R1bW15OiBzZXRQb3BhZHNEdW1teSxcbiAgICBwcmV2ZW50UG9wYWRzTmV0OiBwcmV2ZW50UG9wYWRzTmV0LFxuICAgIEFtYXpvbkFwc3RhZzogQW1hem9uQXBzdGFnXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gX2NsYXNzQ2FsbENoZWNrO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBjcmVhdGVDbGFzcyA9IF9jcmVhdGVDbGFzcztcblxuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAndW5kZWZpbmVkJyB8fCBzdWJqZWN0ID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSQxKHNlcXVlbmNlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlcXVlbmNlKSkgcmV0dXJuIHNlcXVlbmNlO2Vsc2UgaWYgKGlzTm90aGluZyhzZXF1ZW5jZSkpIHJldHVybiBbXTtcbiAgcmV0dXJuIFtzZXF1ZW5jZV07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwga2V5LCBzb3VyY2VLZXlzO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBjb3VudCkge1xuICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyhudW1iZXIpIHtcbiAgcmV0dXJuIG51bWJlciA9PT0gMCAmJiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IDEgLyBudW1iZXI7XG59XG5cbnZhciBpc05vdGhpbmdfMSA9IGlzTm90aGluZztcbnZhciBpc09iamVjdF8xID0gaXNPYmplY3Q7XG52YXIgdG9BcnJheV8xID0gdG9BcnJheSQxO1xudmFyIHJlcGVhdF8xID0gcmVwZWF0O1xudmFyIGlzTmVnYXRpdmVaZXJvXzEgPSBpc05lZ2F0aXZlWmVybztcbnZhciBleHRlbmRfMSA9IGV4dGVuZDtcbnZhciBjb21tb24gPSB7XG4gIGlzTm90aGluZzogaXNOb3RoaW5nXzEsXG4gIGlzT2JqZWN0OiBpc09iamVjdF8xLFxuICB0b0FycmF5OiB0b0FycmF5XzEsXG4gIHJlcGVhdDogcmVwZWF0XzEsXG4gIGlzTmVnYXRpdmVaZXJvOiBpc05lZ2F0aXZlWmVyb18xLFxuICBleHRlbmQ6IGV4dGVuZF8xXG59O1xuXG4vLyBZQU1MIGVycm9yIGNsYXNzLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTg5ODRcblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgdGhpcy5uYW1lID0gJ1lBTUxFeGNlcHRpb24nO1xuICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5tZXNzYWdlID0gKHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJykgKyAodGhpcy5tYXJrID8gJyAnICsgdGhpcy5tYXJrLnRvU3RyaW5nKCkgOiAnJyk7IC8vIEluY2x1ZGUgc3RhY2sgdHJhY2UgaW4gZXJyb3Igb2JqZWN0XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2sgfHwgJyc7XG4gIH1cbn0gLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb247XG5cbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5uYW1lICsgJzogJztcbiAgcmVzdWx0ICs9IHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBleGNlcHRpb24gPSBZQU1MRXhjZXB0aW9uO1xuXG5mdW5jdGlvbiBNYXJrKG5hbWUsIGJ1ZmZlciwgcG9zaXRpb24sIGxpbmUsIGNvbHVtbikge1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB0aGlzLmxpbmUgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbn1cblxuTWFyay5wcm90b3R5cGUuZ2V0U25pcHBldCA9IGZ1bmN0aW9uIGdldFNuaXBwZXQoaW5kZW50LCBtYXhMZW5ndGgpIHtcbiAgdmFyIGhlYWQsIHN0YXJ0LCB0YWlsLCBlbmQsIHNuaXBwZXQ7XG4gIGlmICghdGhpcy5idWZmZXIpIHJldHVybiBudWxsO1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgNDtcbiAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDc1O1xuICBoZWFkID0gJyc7XG4gIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoc3RhcnQgPiAwICYmIFwiXFwwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOVwiLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KHN0YXJ0IC0gMSkpID09PSAtMSkge1xuICAgIHN0YXJ0IC09IDE7XG5cbiAgICBpZiAodGhpcy5wb3NpdGlvbiAtIHN0YXJ0ID4gbWF4TGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIGhlYWQgPSAnIC4uLiAnO1xuICAgICAgc3RhcnQgKz0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRhaWwgPSAnJztcbiAgZW5kID0gdGhpcy5wb3NpdGlvbjtcblxuICB3aGlsZSAoZW5kIDwgdGhpcy5idWZmZXIubGVuZ3RoICYmIFwiXFwwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOVwiLmluZGV4T2YodGhpcy5idWZmZXIuY2hhckF0KGVuZCkpID09PSAtMSkge1xuICAgIGVuZCArPSAxO1xuXG4gICAgaWYgKGVuZCAtIHRoaXMucG9zaXRpb24gPiBtYXhMZW5ndGggLyAyIC0gMSkge1xuICAgICAgdGFpbCA9ICcgLi4uICc7XG4gICAgICBlbmQgLT0gNTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNuaXBwZXQgPSB0aGlzLmJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTtcbiAgcmV0dXJuIGNvbW1vbi5yZXBlYXQoJyAnLCBpbmRlbnQpICsgaGVhZCArIHNuaXBwZXQgKyB0YWlsICsgJ1xcbicgKyBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50ICsgdGhpcy5wb3NpdGlvbiAtIHN0YXJ0ICsgaGVhZC5sZW5ndGgpICsgJ14nO1xufTtcblxuTWFyay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHZhciBzbmlwcGV0LFxuICAgICAgd2hlcmUgPSAnJztcblxuICBpZiAodGhpcy5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIHRoaXMubmFtZSArICdcIiAnO1xuICB9XG5cbiAgd2hlcmUgKz0gJ2F0IGxpbmUgJyArICh0aGlzLmxpbmUgKyAxKSArICcsIGNvbHVtbiAnICsgKHRoaXMuY29sdW1uICsgMSk7XG5cbiAgaWYgKCFjb21wYWN0KSB7XG4gICAgc25pcHBldCA9IHRoaXMuZ2V0U25pcHBldCgpO1xuXG4gICAgaWYgKHNuaXBwZXQpIHtcbiAgICAgIHdoZXJlICs9ICc6XFxuJyArIHNuaXBwZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdoZXJlO1xufTtcblxudmFyIG1hcmsgPSBNYXJrO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gWydraW5kJywgJ3Jlc29sdmUnLCAnY29uc3RydWN0JywgJ2luc3RhbmNlT2YnLCAncHJlZGljYXRlJywgJ3JlcHJlc2VudCcsICdkZWZhdWx0U3R5bGUnLCAnc3R5bGVBbGlhc2VzJ107XG52YXIgWUFNTF9OT0RFX0tJTkRTID0gWydzY2FsYXInLCAnc2VxdWVuY2UnLCAnbWFwcGluZyddO1xuXG5mdW5jdGlvbiBjb21waWxlU3R5bGVBbGlhc2VzKG1hcCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgIG1hcFtzdHlsZV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0W1N0cmluZyhhbGlhcyldID0gc3R5bGU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFR5cGUodGFnLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVW5rbm93biBvcHRpb24gXCInICsgbmFtZSArICdcIiBpcyBtZXQgaW4gZGVmaW5pdGlvbiBvZiBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICAgIH1cbiAgfSk7IC8vIFRPRE86IEFkZCB0YWcgZm9ybWF0IGNoZWNrLlxuXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtpbmQgPSBvcHRpb25zWydraW5kJ10gfHwgbnVsbDtcblxuICB0aGlzLnJlc29sdmUgPSBvcHRpb25zWydyZXNvbHZlJ10gfHwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHRoaXMuY29uc3RydWN0ID0gb3B0aW9uc1snY29uc3RydWN0J10gfHwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICB0aGlzLmluc3RhbmNlT2YgPSBvcHRpb25zWydpbnN0YW5jZU9mJ10gfHwgbnVsbDtcbiAgdGhpcy5wcmVkaWNhdGUgPSBvcHRpb25zWydwcmVkaWNhdGUnXSB8fCBudWxsO1xuICB0aGlzLnJlcHJlc2VudCA9IG9wdGlvbnNbJ3JlcHJlc2VudCddIHx8IG51bGw7XG4gIHRoaXMuZGVmYXVsdFN0eWxlID0gb3B0aW9uc1snZGVmYXVsdFN0eWxlJ10gfHwgbnVsbDtcbiAgdGhpcy5zdHlsZUFsaWFzZXMgPSBjb21waWxlU3R5bGVBbGlhc2VzKG9wdGlvbnNbJ3N0eWxlQWxpYXNlcyddIHx8IG51bGwpO1xuXG4gIGlmIChZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1Vua25vd24ga2luZCBcIicgKyB0aGlzLmtpbmQgKyAnXCIgaXMgc3BlY2lmaWVkIGZvciBcIicgKyB0YWcgKyAnXCIgWUFNTCB0eXBlLicpO1xuICB9XG59XG5cbnZhciB0eXBlID0gVHlwZTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuXG5mdW5jdGlvbiBjb21waWxlTGlzdChzY2hlbWEsIG5hbWUsIHJlc3VsdCkge1xuICB2YXIgZXhjbHVkZSA9IFtdO1xuICBzY2hlbWEuaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmNsdWRlZFNjaGVtYSkge1xuICAgIHJlc3VsdCA9IGNvbXBpbGVMaXN0KGluY2x1ZGVkU2NoZW1hLCBuYW1lLCByZXN1bHQpO1xuICB9KTtcbiAgc2NoZW1hW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUeXBlKSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJiBwcmV2aW91c1R5cGUua2luZCA9PT0gY3VycmVudFR5cGUua2luZCkge1xuICAgICAgICBleGNsdWRlLnB1c2gocHJldmlvdXNJbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2goY3VycmVudFR5cGUpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGV4Y2x1ZGUuaW5kZXhPZihpbmRleCkgPT09IC0xO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZU1hcCgpXG4vKiBsaXN0cy4uLiAqL1xue1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHNjYWxhcjoge30sXG4gICAgc2VxdWVuY2U6IHt9LFxuICAgIG1hcHBpbmc6IHt9LFxuICAgIGZhbGxiYWNrOiB7fVxuICB9LFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgZnVuY3Rpb24gY29sbGVjdFR5cGUodHlwZSkge1xuICAgIHJlc3VsdFt0eXBlLmtpbmRdW3R5cGUudGFnXSA9IHJlc3VsdFsnZmFsbGJhY2snXVt0eXBlLnRhZ10gPSB0eXBlO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIFNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHRoaXMuaW5jbHVkZSA9IGRlZmluaXRpb24uaW5jbHVkZSB8fCBbXTtcbiAgdGhpcy5pbXBsaWNpdCA9IGRlZmluaXRpb24uaW1wbGljaXQgfHwgW107XG4gIHRoaXMuZXhwbGljaXQgPSBkZWZpbml0aW9uLmV4cGxpY2l0IHx8IFtdO1xuICB0aGlzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZS5sb2FkS2luZCAmJiB0eXBlLmxvYWRLaW5kICE9PSAnc2NhbGFyJykge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignVGhlcmUgaXMgYSBub24tc2NhbGFyIHR5cGUgaW4gdGhlIGltcGxpY2l0IGxpc3Qgb2YgYSBzY2hlbWEuIEltcGxpY2l0IHJlc29sdmluZyBvZiBzdWNoIHR5cGVzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9KTtcbiAgdGhpcy5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2ltcGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnZXhwbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRUeXBlTWFwID0gY29tcGlsZU1hcCh0aGlzLmNvbXBpbGVkSW1wbGljaXQsIHRoaXMuY29tcGlsZWRFeHBsaWNpdCk7XG59XG5cblNjaGVtYS5ERUZBVUxUID0gbnVsbDtcblxuU2NoZW1hLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYSgpIHtcbiAgdmFyIHNjaGVtYXMsIHR5cGVzO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHNjaGVtYXMgPSBTY2hlbWEuREVGQVVMVDtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBzY2hlbWFzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdHlwZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBTY2hlbWEuY3JlYXRlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBzY2hlbWFzID0gY29tbW9uLnRvQXJyYXkoc2NoZW1hcyk7XG4gIHR5cGVzID0gY29tbW9uLnRvQXJyYXkodHlwZXMpO1xuXG4gIGlmICghc2NoZW1hcy5ldmVyeShmdW5jdGlvbiAoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYTtcbiAgfSkpIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBzdXBlciBzY2hlbWFzIChvciBhIHNpbmdsZSBTY2hlbWEgb2JqZWN0KSBjb250YWlucyBhIG5vbi1TY2hlbWEgb2JqZWN0LicpO1xuICB9XG5cbiAgaWYgKCF0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSQxKSB7XG4gICAgcmV0dXJuIHR5cGUkMSBpbnN0YW5jZW9mIHR5cGU7XG4gIH0pKSB7XG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgIGluY2x1ZGU6IHNjaGVtYXMsXG4gICAgZXhwbGljaXQ6IHR5cGVzXG4gIH0pO1xufTtcblxudmFyIHNjaGVtYSA9IFNjaGVtYTtcblxudmFyIHN0ciA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogJyc7XG4gIH1cbn0pO1xuXG52YXIgc2VxID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoZGF0YSkge1xuICAgIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdO1xuICB9XG59KTtcblxudmFyIG1hcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoZGF0YSkge1xuICAgIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xuICB9XG59KTtcblxudmFyIGZhaWxzYWZlID0gbmV3IHNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbc3RyLCBzZXEsIG1hcF1cbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE51bGwoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcbiAgcmV0dXJuIG1heCA9PT0gMSAmJiBkYXRhID09PSAnficgfHwgbWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJyk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09PSBudWxsO1xufVxuXG52YXIgX251bGwgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gY2Fub25pY2FsKCkge1xuICAgICAgcmV0dXJuICd+JztcbiAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gbG93ZXJjYXNlKCkge1xuICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gdXBwZXJjYXNlKCkge1xuICAgICAgcmV0dXJuICdOVUxMJztcbiAgICB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gY2FtZWxjYXNlKCkge1xuICAgICAgcmV0dXJuICdOdWxsJztcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG4gIHJldHVybiBtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSB8fCBtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBCb29sZWFuXSc7XG59XG5cbnZhciBib29sID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIGxvd2VyY2FzZShvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiB1cHBlcmNhc2Uob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJztcbiAgICB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gY2FtZWxjYXNlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxuZnVuY3Rpb24gaXNIZXhDb2RlKGMpIHtcbiAgcmV0dXJuIDB4MzBcbiAgLyogMCAqL1xuICA8PSBjICYmIGMgPD0gMHgzOVxuICAvKiA5ICovXG4gIHx8IDB4NDFcbiAgLyogQSAqL1xuICA8PSBjICYmIGMgPD0gMHg0NlxuICAvKiBGICovXG4gIHx8IDB4NjFcbiAgLyogYSAqL1xuICA8PSBjICYmIGMgPD0gMHg2NlxuICAvKiBmICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNPY3RDb2RlKGMpIHtcbiAgcmV0dXJuIDB4MzBcbiAgLyogMCAqL1xuICA8PSBjICYmIGMgPD0gMHgzN1xuICAvKiA3ICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNEZWNDb2RlKGMpIHtcbiAgcmV0dXJuIDB4MzBcbiAgLyogMCAqL1xuICA8PSBjICYmIGMgPD0gMHgzOVxuICAvKiA5ICovXG4gIDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaGFzRGlnaXRzID0gZmFsc2UsXG4gICAgICBjaDtcbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcbiAgY2ggPSBkYXRhW2luZGV4XTsgLy8gc2lnblxuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHJldHVybiB0cnVlO1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTsgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gICAgfSAvLyBiYXNlIDhcblxuXG4gICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgaWYgKCFpc09jdENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICB9IC8vIGJhc2UgMTAgKGV4Y2VwdCAwKSBvciBiYXNlIDYwXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG5cblxuICBpZiAoY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmIChjaCA9PT0gJzonKSBicmVhaztcblxuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgfSAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG5cblxuICBpZiAoIWhhc0RpZ2l0cyB8fCBjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7IC8vIGlmICFiYXNlNjAgLSBkb25lO1xuXG4gIGlmIChjaCAhPT0gJzonKSByZXR1cm4gdHJ1ZTsgLy8gYmFzZTYwIGFsbW9zdCBub3QgdXNlZCwgbm8gbmVlZHMgdG8gb3B0aW1pemVcblxuICByZXR1cm4gL14oOlswLTVdP1swLTldKSskLy50ZXN0KGRhdGEuc2xpY2UoaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLFxuICAgICAgc2lnbiA9IDEsXG4gICAgICBjaCxcbiAgICAgIGJhc2UsXG4gICAgICBkaWdpdHMgPSBbXTtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgc2lnbiA9IC0xO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgY2ggPSB2YWx1ZVswXTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJzAnKSByZXR1cm4gMDtcblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ2InKSByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICd4JykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDgpO1xuICB9XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlSW50KHYsIDEwKSk7XG4gICAgfSk7XG4gICAgdmFsdWUgPSAwO1xuICAgIGJhc2UgPSAxO1xuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSBkICogYmFzZTtcbiAgICAgIGJhc2UgKj0gNjA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpO1xufVxuXG52YXIgaW50ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogZnVuY3Rpb24gYmluYXJ5KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA+PSAwID8gJzBiJyArIG9iai50b1N0cmluZygyKSA6ICctMGInICsgb2JqLnRvU3RyaW5nKDIpLnNsaWNlKDEpO1xuICAgIH0sXG4gICAgb2N0YWw6IGZ1bmN0aW9uIG9jdGFsKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA+PSAwID8gJzAnICsgb2JqLnRvU3RyaW5nKDgpIDogJy0wJyArIG9iai50b1N0cmluZyg4KS5zbGljZSgxKTtcbiAgICB9LFxuICAgIGRlY2ltYWw6IGZ1bmN0aW9uIGRlY2ltYWwob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKDEwKTtcbiAgICB9LFxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiBoZXhhZGVjaW1hbChvYmopIHtcbiAgICAgIHJldHVybiBvYmogPj0gMCA/ICcweCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgOiAnLTB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5zbGljZSgxKTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2RlY2ltYWwnLFxuICBzdHlsZUFsaWFzZXM6IHtcbiAgICBiaW5hcnk6IFsyLCAnYmluJ10sXG4gICAgb2N0YWw6IFs4LCAnb2N0J10sXG4gICAgZGVjaW1hbDogWzEwLCAnZGVjJ10sXG4gICAgaGV4YWRlY2ltYWw6IFsxNiwgJ2hleCddXG4gIH1cbn0pO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cCggLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbideKD86Wy0rXT8oPzowfFsxLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArIC8vIC4yZTQsIC4yXG4vLyBzcGVjaWFsIGNhc2UsIHNlZW1zIG5vdCBmcm9tIHNwZWNcbid8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICsgLy8gMjA6NTlcbid8Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKicgKyAvLyAuaW5mXG4nfFstK10/XFxcXC4oPzppbmZ8SW5mfElORiknICsgLy8gLm5hblxuJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHwgLy8gUXVpY2sgaGFjayB0byBub3QgYWxsb3cgaW50ZWdlcnMgZW5kIHdpdGggYF9gXG4gIC8vIFByb2JhYmx5IHNob3VsZCB1cGRhdGUgcmVnZXhwICYgY2hlY2sgc3BlZWRcbiAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG4gIHZhbHVlID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcbiAgZGlnaXRzID0gW107XG5cbiAgaWYgKCcrLScuaW5kZXhPZih2YWx1ZVswXSkgPj0gMCkge1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcuaW5mJykge1xuICAgIHJldHVybiBzaWduID09PSAxID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9IGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzonKSA+PSAwKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUZsb2F0KHYsIDEwKSk7XG4gICAgfSk7XG4gICAgdmFsdWUgPSAwLjA7XG4gICAgYmFzZSA9IDE7XG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcbiAgICByZXR1cm4gc2lnbiAqIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XG59XG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgICAgcmV0dXJuICcubmFuJztcblxuICAgICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgICAgcmV0dXJuICcuTkFOJztcblxuICAgICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgICAgcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgICByZXR1cm4gJy5pbmYnO1xuXG4gICAgICBjYXNlICd1cHBlcmNhc2UnOlxuICAgICAgICByZXR1cm4gJy5JTkYnO1xuXG4gICAgICBjYXNlICdjYW1lbGNhc2UnOlxuICAgICAgICByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICAgIHJldHVybiAnLS5pbmYnO1xuXG4gICAgICBjYXNlICd1cHBlcmNhc2UnOlxuICAgICAgICByZXR1cm4gJy0uSU5GJztcblxuICAgICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgICAgcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7IC8vIEpTIHN0cmluZ2lmaWVyIGNhbiBidWlsZCBzY2llbnRpZmljIGZvcm1hdCB3aXRob3V0IGRvdHM6IDVlLTEwMCxcbiAgLy8gd2hpbGUgWUFNTCByZXF1cmVzIGRvdDogNS5lLTEwMC4gRml4IGl0IHdpdGggc2ltcGxlIGhhY2tcblxuICByZXR1cm4gU0NJRU5USUZJQ19XSVRIT1VUX0RPVC50ZXN0KHJlcykgPyByZXMucmVwbGFjZSgnZScsICcuZScpIDogcmVzO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIChvYmplY3QgJSAxICE9PSAwIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxudmFyIGZsb2F0ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxGbG9hdCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sRmxvYXQsXG4gIHByZWRpY2F0ZTogaXNGbG9hdCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sRmxvYXQsXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuXG52YXIganNvbiA9IG5ldyBzY2hlbWEoe1xuICBpbmNsdWRlOiBbZmFpbHNhZmVdLFxuICBpbXBsaWNpdDogW19udWxsLCBib29sLCBpbnQsIGZsb2F0XVxufSk7XG5cbnZhciBjb3JlID0gbmV3IHNjaGVtYSh7XG4gIGluY2x1ZGU6IFtqc29uXVxufSk7XG5cbnZhciBZQU1MX0RBVEVfUkVHRVhQID0gbmV3IFJlZ0V4cCgnXihbMC05XVswLTldWzAtOV1bMC05XSknICsgLy8gWzFdIHllYXJcbictKFswLTldWzAtOV0pJyArIC8vIFsyXSBtb250aFxuJy0oWzAtOV1bMC05XSkkJyk7IC8vIFszXSBkYXlcblxudmFyIFlBTUxfVElNRVNUQU1QX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyArIC8vIFsxXSB5ZWFyXG4nLShbMC05XVswLTldPyknICsgLy8gWzJdIG1vbnRoXG4nLShbMC05XVswLTldPyknICsgLy8gWzNdIGRheVxuJyg/OltUdF18WyBcXFxcdF0rKScgKyAvLyAuLi5cbicoWzAtOV1bMC05XT8pJyArIC8vIFs0XSBob3VyXG4nOihbMC05XVswLTldKScgKyAvLyBbNV0gbWludXRlXG4nOihbMC05XVswLTldKScgKyAvLyBbNl0gc2Vjb25kXG4nKD86XFxcXC4oWzAtOV0qKSk/JyArIC8vIFs3XSBmcmFjdGlvblxuJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuJyg/OjooWzAtOV1bMC05XSkpPykpPyQnKTsgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoWUFNTF9EQVRFX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgdmFyIG1hdGNoLFxuICAgICAgeWVhcixcbiAgICAgIG1vbnRoLFxuICAgICAgZGF5LFxuICAgICAgaG91cixcbiAgICAgIG1pbnV0ZSxcbiAgICAgIHNlY29uZCxcbiAgICAgIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCxcbiAgICAgIHR6X2hvdXIsXG4gICAgICB0el9taW51dGUsXG4gICAgICBkYXRlO1xuICBtYXRjaCA9IFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignRGF0ZSByZXNvbHZlIGVycm9yJyk7IC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArbWF0Y2hbMV07XG4gIG1vbnRoID0gK21hdGNoWzJdIC0gMTsgLy8gSlMgbW9udGggc3RhcnRzIHdpdGggMFxuXG4gIGRheSA9ICttYXRjaFszXTtcblxuICBpZiAoIW1hdGNoWzRdKSB7XG4gICAgLy8gbm8gaG91clxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gIH0gLy8gbWF0Y2g6IFs0XSBob3VyIFs1XSBtaW51dGUgWzZdIHNlY29uZCBbN10gZnJhY3Rpb25cblxuXG4gIGhvdXIgPSArbWF0Y2hbNF07XG4gIG1pbnV0ZSA9ICttYXRjaFs1XTtcbiAgc2Vjb25kID0gK21hdGNoWzZdO1xuXG4gIGlmIChtYXRjaFs3XSkge1xuICAgIGZyYWN0aW9uID0gbWF0Y2hbN10uc2xpY2UoMCwgMyk7XG5cbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgMykge1xuICAgICAgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgIH1cblxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9IC8vIG1hdGNoOiBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyIFsxMV0gdHpfbWludXRlXG5cblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gK21hdGNoWzEwXTtcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcbiAgICBkZWx0YSA9ICh0el9ob3VyICogNjAgKyB0el9taW51dGUpICogNjAwMDA7IC8vIGRlbHRhIGluIG1pbGktc2Vjb25kc1xuXG4gICAgaWYgKG1hdGNoWzldID09PSAnLScpIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbikpO1xuICBpZiAoZGVsdGEpIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcbiAgcmV0dXJuIGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudFlhbWxUaW1lc3RhbXAob2JqZWN0XG4vKiwgc3R5bGUqL1xuKSB7XG4gIHJldHVybiBvYmplY3QudG9JU09TdHJpbmcoKTtcbn1cblxudmFyIHRpbWVzdGFtcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFRpbWVzdGFtcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wLFxuICBpbnN0YW5jZU9mOiBEYXRlLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE1lcmdlKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICc8PCcgfHwgZGF0YSA9PT0gbnVsbDtcbn1cblxudmFyIG1lcmdlID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG5cbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAodGFyZ2V0KSB7XG5cdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGR5bmFtaWNhbGx5IHJlcXVpcmUgXCInICsgdGFyZ2V0ICsgJ1wiLiBQbGVhc2UgY29uZmlndXJlIHRoZSBkeW5hbWljUmVxdWlyZVRhcmdldHMgb3B0aW9uIG9mIEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzIGFwcHJvcHJpYXRlbHkgZm9yIHRoaXMgcmVxdWlyZSBjYWxsIHRvIGJlaGF2ZSBwcm9wZXJseS4nKTtcbn1cblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuXG52YXIgTm9kZUJ1ZmZlcjtcblxudHJ5IHtcbiAgLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24sIHRvIG5vdCBpbmNsdWRlIGBCdWZmZXJgIHNoaW1cbiAgdmFyIF9yZXF1aXJlID0gY29tbW9uanNSZXF1aXJlO1xuICBOb2RlQnVmZmVyID0gX3JlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbn0gY2F0Y2ggKF9fKSB7fSAvLyBbIDY0LCA2NSwgNjYgXSAtPiBbIHBhZGRpbmcsIENSLCBMRiBdXG5cblxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJpbmFyeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjb2RlLFxuICAgICAgaWR4LFxuICAgICAgYml0bGVuID0gMCxcbiAgICAgIG1heCA9IGRhdGEubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUDsgLy8gQ29udmVydCBvbmUgYnkgb25lLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTsgLy8gU2tpcCBDUi9MRlxuXG4gICAgaWYgKGNvZGUgPiA2NCkgY29udGludWU7IC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG5cbiAgICBpZiAoY29kZSA8IDApIHJldHVybiBmYWxzZTtcbiAgICBiaXRsZW4gKz0gNjtcbiAgfSAvLyBJZiB0aGVyZSBhcmUgYW55IGJpdHMgbGVmdCwgc291cmNlIHdhcyBjb3JydXB0ZWRcblxuXG4gIHJldHVybiBiaXRsZW4gJSA4ID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCxcbiAgICAgIHRhaWxiaXRzLFxuICAgICAgaW5wdXQgPSBkYXRhLnJlcGxhY2UoL1tcXHJcXG49XS9nLCAnJyksXG4gICAgICAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgbWF4ID0gaW5wdXQubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUCxcbiAgICAgIGJpdHMgPSAwLFxuICAgICAgcmVzdWx0ID0gW107IC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKGlkeCAlIDQgPT09IDAgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaChiaXRzID4+IDE2ICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzID4+IDggJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gYml0cyA8PCA2IHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9IC8vIER1bXAgdGFpbFxuXG5cbiAgdGFpbGJpdHMgPSBtYXggJSA0ICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICByZXN1bHQucHVzaChiaXRzID4+IDE2ICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyA+PiA4ICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgPj4gMTAgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzID4+IDIgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaChiaXRzID4+IDQgJiAweEZGKTtcbiAgfSAvLyBXcmFwIGludG8gQnVmZmVyIGZvciBOb2RlSlMgYW5kIGxlYXZlIEFycmF5IGZvciBicm93c2VyXG5cblxuICBpZiAoTm9kZUJ1ZmZlcikge1xuICAgIC8vIFN1cHBvcnQgbm9kZSA2LisgQnVmZmVyIEFQSSB3aGVuIGF2YWlsYWJsZVxuICAgIHJldHVybiBOb2RlQnVmZmVyLmZyb20gPyBOb2RlQnVmZmVyLmZyb20ocmVzdWx0KSA6IG5ldyBOb2RlQnVmZmVyKHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sQmluYXJ5KG9iamVjdFxuLyosIHN0eWxlKi9cbikge1xuICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIGlkeCxcbiAgICAgIHRhaWwsXG4gICAgICBtYXggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUDsgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKGlkeCAlIDMgPT09IDAgJiYgaWR4KSB7XG4gICAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTggJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyA+PiAxMiAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzID4+IDYgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICAgIH1cblxuICAgIGJpdHMgPSAoYml0cyA8PCA4KSArIG9iamVjdFtpZHhdO1xuICB9IC8vIER1bXAgdGFpbFxuXG5cbiAgdGFpbCA9IG1heCAlIDM7XG5cbiAgaWYgKHRhaWwgPT09IDApIHtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTggJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTIgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gNiAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyAmIDB4M0ZdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDIpIHtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTAgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gNCAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyA8PCAyICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMSkge1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyA+PiAyICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzIDw8IDQgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iamVjdCkge1xuICByZXR1cm4gTm9kZUJ1ZmZlciAmJiBOb2RlQnVmZmVyLmlzQnVmZmVyKG9iamVjdCk7XG59XG5cbnZhciBiaW5hcnkgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCaW5hcnksXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJpbmFyeSxcbiAgcHJlZGljYXRlOiBpc0JpbmFyeSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sQmluYXJ5XG59KTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICB2YXIgb2JqZWN0S2V5cyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBwYWlyLFxuICAgICAgcGFpcktleSxcbiAgICAgIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhaXIsIHBhaXJLZXkpKSB7XG4gICAgICAgIGlmICghcGFpckhhc0tleSkgcGFpckhhc0tleSA9IHRydWU7ZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG9iamVjdEtleXMuaW5kZXhPZihwYWlyS2V5KSA9PT0gLTEpIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdO1xufVxuXG52YXIgb21hcCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuXG52YXIgX3RvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICB2YXIgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBwYWlyLFxuICAgICAga2V5cyxcbiAgICAgIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBpZiAoX3RvU3RyaW5nJDEuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG4gICAgcmVzdWx0W2luZGV4XSA9IFtrZXlzWzBdLCBwYWlyW2tleXNbMF1dXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuICB2YXIgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBwYWlyLFxuICAgICAga2V5cyxcbiAgICAgIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG4gICAgcmVzdWx0W2luZGV4XSA9IFtrZXlzWzBdLCBwYWlyW2tleXNbMF1dXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBwYWlycyA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuXG52YXIgX2hhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFNldChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIGtleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQxLmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAob2JqZWN0W2tleV0gIT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFNldChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9O1xufVxuXG52YXIgc2V0ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcblxudmFyIGRlZmF1bHRfc2FmZSA9IG5ldyBzY2hlbWEoe1xuICBpbmNsdWRlOiBbY29yZV0sXG4gIGltcGxpY2l0OiBbdGltZXN0YW1wLCBtZXJnZV0sXG4gIGV4cGxpY2l0OiBbYmluYXJ5LCBvbWFwLCBwYWlycywgc2V0XVxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbnZhciBfdW5kZWZpbmVkID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3VuZGVmaW5lZCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQsXG4gIHByZWRpY2F0ZTogaXNVbmRlZmluZWQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZFxufSk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJzsgLy8gaWYgcmVnZXhwIHN0YXJ0cyB3aXRoICcvJyBpdCBjYW4gaGF2ZSBtb2RpZmllcnMgYW5kIG11c3QgYmUgcHJvcGVybHkgY2xvc2VkXG4gIC8vIGAvZm9vL2dpbWAgLSBtb2RpZmllcnMgdGFpbCBjYW4gYmUgbWF4aW11bSAzIGNoYXJzXG5cbiAgaWYgKHJlZ2V4cFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHRhaWwpIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAzKSByZXR1cm4gZmFsc2U7IC8vIGlmIGV4cHJlc3Npb24gc3RhcnRzIHdpdGggLywgaXMgc2hvdWxkIGJlIHByb3Blcmx5IHRlcm1pbmF0ZWRcblxuICAgIGlmIChyZWdleHBbcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxXSAhPT0gJy8nKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJzsgLy8gYC9mb28vZ2ltYCAtIHRhaWwgY2FuIGJlIG1heGltdW0gNCBjaGFyc1xuXG4gIGlmIChyZWdleHBbMF0gPT09ICcvJykge1xuICAgIGlmICh0YWlsKSBtb2RpZmllcnMgPSB0YWlsWzFdO1xuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwKG9iamVjdFxuLyosIHN0eWxlKi9cbikge1xuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcbiAgaWYgKG9iamVjdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmIChvYmplY3QubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG52YXIgcmVnZXhwID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG5cbnZhciBlc3ByaW1hOyAvLyBCcm93c2VyaWZpZWQgdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGVzcHJpbWFcbi8vXG4vLyAxLiBGb3Igbm9kZS5qcyBqdXN0IHJlcXVpcmUgbW9kdWxlIGFzIGRlcHNcbi8vIDIuIEZvciBicm93c2VyIHRyeSB0byByZXF1aXJlIG11ZHVsZSB2aWEgZXh0ZXJuYWwgQU1EIHN5c3RlbS5cbi8vICAgIElmIG5vdCBmb3VuZCAtIHRyeSB0byBmYWxsYmFjayB0byB3aW5kb3cuZXNwcmltYS4gSWYgbm90XG4vLyAgICBmb3VuZCB0b28gLSB0aGVuIGZhaWwgdG8gcGFyc2UuXG4vL1xuXG50cnkge1xuICAvLyB3b3JrYXJvdW5kIHRvIGV4Y2x1ZGUgcGFja2FnZSBmcm9tIGJyb3dzZXJpZnkgbGlzdC5cbiAgdmFyIF9yZXF1aXJlJDEgPSBjb21tb25qc1JlcXVpcmU7XG4gIGVzcHJpbWEgPSBfcmVxdWlyZSQxKCdlc3ByaW1hJyk7XG59IGNhdGNoIChfKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG4gIC8qIGdsb2JhbCB3aW5kb3cgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBlc3ByaW1hID0gd2luZG93LmVzcHJpbWE7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICAgIGFzdCA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7XG4gICAgICByYW5nZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKGFzdC50eXBlICE9PSAnUHJvZ3JhbScgfHwgYXN0LmJvZHkubGVuZ3RoICE9PSAxIHx8IGFzdC5ib2R5WzBdLnR5cGUgIT09ICdFeHByZXNzaW9uU3RhdGVtZW50JyB8fCBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicgJiYgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnRnVuY3Rpb25FeHByZXNzaW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cbiAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICBhc3QgPSBlc3ByaW1hLnBhcnNlKHNvdXJjZSwge1xuICAgIHJhbmdlOiB0cnVlXG4gIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmIChhc3QudHlwZSAhPT0gJ1Byb2dyYW0nIHx8IGFzdC5ib2R5Lmxlbmd0aCAhPT0gMSB8fCBhc3QuYm9keVswXS50eXBlICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHwgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nICYmIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBhc3QuYm9keVswXS5leHByZXNzaW9uLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHBhcmFtcy5wdXNoKHBhcmFtLm5hbWUpO1xuICB9KTtcbiAgYm9keSA9IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS5yYW5nZTsgLy8gRXNwcmltYSdzIHJhbmdlcyBpbmNsdWRlIHRoZSBmaXJzdCAneycgYW5kIHRoZSBsYXN0ICd9JyBjaGFyYWN0ZXJzIG9uXG4gIC8vIGZ1bmN0aW9uIGV4cHJlc3Npb25zLiBTbyBjdXQgdGhlbSBvdXQuXG5cbiAgaWYgKGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihwYXJhbXMsIHNvdXJjZS5zbGljZShib2R5WzBdICsgMSwgYm9keVsxXSAtIDEpKTtcbiAgfSAvLyBFUzYgYXJyb3cgZnVuY3Rpb25zIGNhbiBvbWl0IHRoZSBCbG9ja1N0YXRlbWVudC4gSW4gdGhhdCBjYXNlLCBqdXN0IHJldHVyblxuICAvLyB0aGUgYm9keS5cblxuICAvKmVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jKi9cblxuXG4gIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCAncmV0dXJuICcgKyBzb3VyY2Uuc2xpY2UoYm9keVswXSwgYm9keVsxXSkpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24ob2JqZWN0XG4vKiwgc3R5bGUqL1xuKSB7XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG52YXIgX2Z1bmN0aW9uID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL2Z1bmN0aW9uJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIHByZWRpY2F0ZTogaXNGdW5jdGlvbixcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb25cbn0pO1xuXG52YXIgZGVmYXVsdF9mdWxsID0gc2NoZW1hLkRFRkFVTFQgPSBuZXcgc2NoZW1hKHtcbiAgaW5jbHVkZTogW2RlZmF1bHRfc2FmZV0sXG4gIGV4cGxpY2l0OiBbX3VuZGVmaW5lZCwgcmVnZXhwLCBfZnVuY3Rpb25dXG59KTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuLG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxuXG52YXIgX2hhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIENPTlRFWFRfRkxPV19JTiA9IDE7XG52YXIgQ09OVEVYVF9GTE9XX09VVCA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiA9IDM7XG52YXIgQ09OVEVYVF9CTE9DS19PVVQgPSA0O1xudmFyIENIT01QSU5HX0NMSVAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQID0gMztcbnZhciBQQVRURVJOX05PTl9QUklOVEFCTEUgPSAvW1xceDAwLVxceDA4XFx4MEJcXHgwQ1xceDBFLVxceDFGXFx4N0YtXFx4ODRcXHg4Ni1cXHg5RlxcdUZGRkVcXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS87XG52YXIgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MgPSAvW1xceDg1XFx1MjAyOFxcdTIwMjldLztcbnZhciBQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyA9IC9bLFxcW1xcXVxce1xcfV0vO1xudmFyIFBBVFRFUk5fVEFHX0hBTkRMRSA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJID0gL14oPzohfFteLFxcW1xcXVxce1xcfV0pKD86JVswLTlhLWZdezJ9fFswLTlhLXpcXC0jO1xcL1xcPzpAJj1cXCtcXCQsX1xcLiF+XFwqJ1xcKFxcKVxcW1xcXV0pKiQvaTtcblxuZnVuY3Rpb24gX2NsYXNzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiBjID09PSAweDBBXG4gIC8qIExGICovXG4gIHx8IGMgPT09IDB4MERcbiAgLyogQ1IgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBpc19XSElURV9TUEFDRShjKSB7XG4gIHJldHVybiBjID09PSAweDA5XG4gIC8qIFRhYiAqL1xuICB8fCBjID09PSAweDIwXG4gIC8qIFNwYWNlICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNfV1NfT1JfRU9MKGMpIHtcbiAgcmV0dXJuIGMgPT09IDB4MDlcbiAgLyogVGFiICovXG4gIHx8IGMgPT09IDB4MjBcbiAgLyogU3BhY2UgKi9cbiAgfHwgYyA9PT0gMHgwQVxuICAvKiBMRiAqL1xuICB8fCBjID09PSAweDBEXG4gIC8qIENSICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNfRkxPV19JTkRJQ0FUT1IoYykge1xuICByZXR1cm4gYyA9PT0gMHgyQ1xuICAvKiAsICovXG4gIHx8IGMgPT09IDB4NUJcbiAgLyogWyAqL1xuICB8fCBjID09PSAweDVEXG4gIC8qIF0gKi9cbiAgfHwgYyA9PT0gMHg3QlxuICAvKiB7ICovXG4gIHx8IGMgPT09IDB4N0RcbiAgLyogfSAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgweDMwXG4gIC8qIDAgKi9cbiAgPD0gYyAmJiBjIDw9IDB4MzlcbiAgLyogOSAqL1xuICApIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cblxuXG4gIGxjID0gYyB8IDB4MjA7XG5cbiAgaWYgKDB4NjFcbiAgLyogYSAqL1xuICA8PSBsYyAmJiBsYyA8PSAweDY2XG4gIC8qIGYgKi9cbiAgKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzhcbiAgLyogeCAqL1xuICApIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cblxuICBpZiAoYyA9PT0gMHg3NVxuICAvKiB1ICovXG4gICkge1xuICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuXG4gIGlmIChjID09PSAweDU1XG4gIC8qIFUgKi9cbiAgKSB7XG4gICAgICByZXR1cm4gODtcbiAgICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgweDMwXG4gIC8qIDAgKi9cbiAgPD0gYyAmJiBjIDw9IDB4MzlcbiAgLyogOSAqL1xuICApIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVzY2FwZVNlcXVlbmNlKGMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4gIHJldHVybiBjID09PSAweDMwXG4gIC8qIDAgKi9cbiAgPyAnXFx4MDAnIDogYyA9PT0gMHg2MVxuICAvKiBhICovXG4gID8gJ1xceDA3JyA6IGMgPT09IDB4NjJcbiAgLyogYiAqL1xuICA/ICdcXHgwOCcgOiBjID09PSAweDc0XG4gIC8qIHQgKi9cbiAgPyAnXFx4MDknIDogYyA9PT0gMHgwOVxuICAvKiBUYWIgKi9cbiAgPyAnXFx4MDknIDogYyA9PT0gMHg2RVxuICAvKiBuICovXG4gID8gJ1xceDBBJyA6IGMgPT09IDB4NzZcbiAgLyogdiAqL1xuICA/ICdcXHgwQicgOiBjID09PSAweDY2XG4gIC8qIGYgKi9cbiAgPyAnXFx4MEMnIDogYyA9PT0gMHg3MlxuICAvKiByICovXG4gID8gJ1xceDBEJyA6IGMgPT09IDB4NjVcbiAgLyogZSAqL1xuICA/ICdcXHgxQicgOiBjID09PSAweDIwXG4gIC8qIFNwYWNlICovXG4gID8gJyAnIDogYyA9PT0gMHgyMlxuICAvKiBcIiAqL1xuICA/ICdcXHgyMicgOiBjID09PSAweDJGXG4gIC8qIC8gKi9cbiAgPyAnLycgOiBjID09PSAweDVDXG4gIC8qIFxcICovXG4gID8gJ1xceDVDJyA6IGMgPT09IDB4NEVcbiAgLyogTiAqL1xuICA/ICdcXHg4NScgOiBjID09PSAweDVGXG4gIC8qIF8gKi9cbiAgPyAnXFx4QTAnIDogYyA9PT0gMHg0Q1xuICAvKiBMICovXG4gID8gXCJcXHUyMDI4XCIgOiBjID09PSAweDUwXG4gIC8qIFAgKi9cbiAgPyBcIlxcdTIwMjlcIiA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9IC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuXG5cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgLSAweDAxMDAwMCA+PiAxMCkgKyAweEQ4MDAsIChjIC0gMHgwMTAwMDAgJiAweDAzRkYpICsgMHhEQzAwKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xuXG52YXIgc2ltcGxlRXNjYXBlTWFwID0gbmV3IEFycmF5KDI1Nik7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgc2ltcGxlRXNjYXBlQ2hlY2tbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKSA/IDEgOiAwO1xuICBzaW1wbGVFc2NhcGVNYXBbaV0gPSBzaW1wbGVFc2NhcGVTZXF1ZW5jZShpKTtcbn1cblxuZnVuY3Rpb24gU3RhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB0aGlzLmZpbGVuYW1lID0gb3B0aW9uc1snZmlsZW5hbWUnXSB8fCBudWxsO1xuICB0aGlzLnNjaGVtYSA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IGRlZmF1bHRfZnVsbDtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICB0aGlzLmxlZ2FjeSA9IG9wdGlvbnNbJ2xlZ2FjeSddIHx8IGZhbHNlO1xuICB0aGlzLmpzb24gPSBvcHRpb25zWydqc29uJ10gfHwgZmFsc2U7XG4gIHRoaXMubGlzdGVuZXIgPSBvcHRpb25zWydsaXN0ZW5lciddIHx8IG51bGw7XG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMudHlwZU1hcCA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkVHlwZU1hcDtcbiAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIHRoaXMucG9zaXRpb24gPSAwO1xuICB0aGlzLmxpbmUgPSAwO1xuICB0aGlzLmxpbmVTdGFydCA9IDA7XG4gIHRoaXMubGluZUluZGVudCA9IDA7XG4gIHRoaXMuZG9jdW1lbnRzID0gW107XG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBleGNlcHRpb24obWVzc2FnZSwgbmV3IG1hcmsoc3RhdGUuZmlsZW5hbWUsIHN0YXRlLmlucHV0LCBzdGF0ZS5wb3NpdGlvbiwgc3RhdGUubGluZSwgc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge1xuICBZQU1MOiBmdW5jdGlvbiBoYW5kbGVZYW1sRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IG1pbm9yIDwgMjtcblxuICAgIGlmIChtaW5vciAhPT0gMSAmJiBtaW5vciAhPT0gMikge1xuICAgICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAndW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cbiAgfSxcbiAgVEFHOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5JDIuY2FsbChzdGF0ZS50YWdNYXAsIGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGVyZSBpcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgc3VmZml4IGZvciBcIicgKyBoYW5kbGUgKyAnXCIgdGFnIGhhbmRsZScpO1xuICAgIH1cblxuICAgIGlmICghUEFUVEVSTl9UQUdfVVJJLnRlc3QocHJlZml4KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnRhZ01hcFtoYW5kbGVdID0gcHJlZml4O1xuICB9XG59O1xuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7IF9wb3NpdGlvbiA8IF9sZW5ndGg7IF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgICAgICBpZiAoIShfY2hhcmFjdGVyID09PSAweDA5IHx8IDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChfcmVzdWx0KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgc3RhdGUucmVzdWx0ICs9IF9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgZGVzdGluYXRpb24sIHNvdXJjZSwgb3ZlcnJpZGFibGVLZXlzKSB7XG4gIHZhciBzb3VyY2VLZXlzLCBrZXksIGluZGV4LCBxdWFudGl0eTtcblxuICBpZiAoIWNvbW1vbi5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlJyk7XG4gIH1cblxuICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuXG4gICAgaWYgKCFfaGFzT3duUHJvcGVydHkkMi5jYWxsKGRlc3RpbmF0aW9uLCBrZXkpKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgICBvdmVycmlkYWJsZUtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIHN0YXJ0TGluZSwgc3RhcnRQb3MpIHtcbiAgdmFyIGluZGV4LCBxdWFudGl0eTsgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGUpKSB7XG4gICAga2V5Tm9kZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGtleU5vZGUpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0ga2V5Tm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleU5vZGVbaW5kZXhdKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmVzdGVkIGFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUga2V5cycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlW2luZGV4XSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIGtleU5vZGVbaW5kZXhdID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG5cblxuICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBrZXlOb2RlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICBrZXlOb2RlID0gU3RyaW5nKGtleU5vZGUpO1xuXG4gIGlmIChfcmVzdWx0ID09PSBudWxsKSB7XG4gICAgX3Jlc3VsdCA9IHt9O1xuICB9XG5cbiAgaWYgKGtleVRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlTm9kZSkpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IHZhbHVlTm9kZS5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlW2luZGV4XSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgX3Jlc3VsdCwgdmFsdWVOb2RlLCBvdmVycmlkYWJsZUtleXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIXN0YXRlLmpzb24gJiYgIV9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwob3ZlcnJpZGFibGVLZXlzLCBrZXlOb2RlKSAmJiBfaGFzT3duUHJvcGVydHkkMi5jYWxsKF9yZXN1bHQsIGtleU5vZGUpKSB7XG4gICAgICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lIHx8IHN0YXRlLmxpbmU7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXJ0UG9zIHx8IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0ZWQgbWFwcGluZyBrZXknKTtcbiAgICB9XG5cbiAgICBfcmVzdWx0W2tleU5vZGVdID0gdmFsdWVOb2RlO1xuICAgIGRlbGV0ZSBvdmVycmlkYWJsZUtleXNba2V5Tm9kZV07XG4gIH1cblxuICByZXR1cm4gX3Jlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZExpbmVCcmVhayhzdGF0ZSkge1xuICB2YXIgY2g7XG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDBBXG4gIC8qIExGICovXG4gICkge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDBEXG4gIC8qIENSICovXG4gICkge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDBBXG4gICAgICAvKiBMRiAqL1xuICAgICAgKSB7XG4gICAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjNcbiAgICAvKiAjICovXG4gICAgKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBXG4gICAgICAgIC8qIExGICovXG4gICAgICAgICYmIGNoICE9PSAweDBEXG4gICAgICAgIC8qIENSICovXG4gICAgICAgICYmIGNoICE9PSAwKTtcbiAgICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKGNoID09PSAweDIwXG4gICAgICAvKiBTcGFjZSAqL1xuICAgICAgKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTsgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG5cbiAgaWYgKChjaCA9PT0gMHgyRFxuICAvKiAtICovXG4gIHx8IGNoID09PSAweDJFXG4gIC8qIC4gKi9cbiAgKSAmJiBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJiBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAyKSkge1xuICAgIF9wb3NpdGlvbiArPSAzO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAwIHx8IGlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgY291bnQpIHtcbiAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgfSBlbHNlIGlmIChjb3VudCA+IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgY291bnQgLSAxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpIHx8IGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSB8fCBjaCA9PT0gMHgyM1xuICAvKiAjICovXG4gIHx8IGNoID09PSAweDI2XG4gIC8qICYgKi9cbiAgfHwgY2ggPT09IDB4MkFcbiAgLyogKiAqL1xuICB8fCBjaCA9PT0gMHgyMVxuICAvKiAhICovXG4gIHx8IGNoID09PSAweDdDXG4gIC8qIHwgKi9cbiAgfHwgY2ggPT09IDB4M0VcbiAgLyogPiAqL1xuICB8fCBjaCA9PT0gMHgyN1xuICAvKiAnICovXG4gIHx8IGNoID09PSAweDIyXG4gIC8qIFwiICovXG4gIHx8IGNoID09PSAweDI1XG4gIC8qICUgKi9cbiAgfHwgY2ggPT09IDB4NDBcbiAgLyogQCAqL1xuICB8fCBjaCA9PT0gMHg2MFxuICAvKiBgICovXG4gICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICBpZiAoY2ggPT09IDB4M0ZcbiAgLyogPyAqL1xuICB8fCBjaCA9PT0gMHgyRFxuICAvKiAtICovXG4gICkge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHwgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4M0FcbiAgICAvKiA6ICovXG4gICAgKSB7XG4gICAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHwgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAweDIzXG4gICAgLyogIyAqL1xuICAgICkge1xuICAgICAgICBwcmVjZWRpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uIC0gMSk7XG5cbiAgICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHx8IHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2xpbmVJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIC0xKTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPj0gbm9kZUluZGVudCkge1xuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBjYXB0dXJlRW5kO1xuICAgICAgICBzdGF0ZS5saW5lID0gX2xpbmU7XG4gICAgICAgIHN0YXRlLmxpbmVTdGFydCA9IF9saW5lU3RhcnQ7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSBfbGluZUluZGVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdDb250ZW50KSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBzdGF0ZS5saW5lIC0gX2xpbmUpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG5cbiAgaWYgKHN0YXRlLnJlc3VsdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9IF9raW5kO1xuICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNoLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQ7XG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI3XG4gIC8qICcgKi9cbiAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDI3XG4gICAgLyogJyAqL1xuICAgICkge1xuICAgICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4MjdcbiAgICAgICAgLyogJyAqL1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgaGV4TGVuZ3RoLCBoZXhSZXN1bHQsIHRtcCwgY2g7XG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIyXG4gIC8qIFwiICovXG4gICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyMlxuICAgIC8qIFwiICovXG4gICAgKSB7XG4gICAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDXG4gICAgLyogXFwgKi9cbiAgICApIHtcbiAgICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7IC8vIFRPRE86IHJld29yayB0byBpbmxpbmUgZm4gd2l0aCBubyB0eXBlIGNhc3Q/XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9IHNpbXBsZUVzY2FwZU1hcFtjaF07XG4gICAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgfSBlbHNlIGlmICgodG1wID0gZXNjYXBlZEhleExlbihjaCkpID4gMCkge1xuICAgICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgICBoZXhSZXN1bHQgPSAwO1xuXG4gICAgICAgICAgZm9yICg7IGhleExlbmd0aCA+IDA7IGhleExlbmd0aC0tKSB7XG4gICAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmICgodG1wID0gZnJvbUhleENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGhleFJlc3VsdCA9IChoZXhSZXN1bHQgPDwgNCkgKyB0bXA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biBlc2NhcGUgc2VxdWVuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciByZWFkTmV4dCA9IHRydWUsXG4gICAgICBfbGluZSxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBfcmVzdWx0LFxuICAgICAgX2FuY2hvciA9IHN0YXRlLmFuY2hvcixcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIHRlcm1pbmF0b3IsXG4gICAgICBpc1BhaXIsXG4gICAgICBpc0V4cGxpY2l0UGFpcixcbiAgICAgIGlzTWFwcGluZyxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5Tm9kZSxcbiAgICAgIGtleVRhZyxcbiAgICAgIHZhbHVlTm9kZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDVCXG4gIC8qIFsgKi9cbiAgKSB7XG4gICAgICB0ZXJtaW5hdG9yID0gMHg1RDtcbiAgICAgIC8qIF0gKi9cblxuICAgICAgaXNNYXBwaW5nID0gZmFsc2U7XG4gICAgICBfcmVzdWx0ID0gW107XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg3QlxuICAvKiB7ICovXG4gICkge1xuICAgICAgdGVybWluYXRvciA9IDB4N0Q7XG4gICAgICAvKiB9ICovXG5cbiAgICAgIGlzTWFwcGluZyA9IHRydWU7XG4gICAgICBfcmVzdWx0ID0ge307XG4gICAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGXG4gICAgLyogPyAqL1xuICAgICkge1xuICAgICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIGNoID09PSAweDNBXG4gICAgLyogOiAqL1xuICAgICkge1xuICAgICAgICBpc1BhaXIgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0LnB1c2goa2V5Tm9kZSk7XG4gICAgfVxuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQ1xuICAgIC8qICwgKi9cbiAgICApIHtcbiAgICAgICAgcmVhZE5leHQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCxcbiAgICAgIGVtcHR5TGluZXMgPSAwLFxuICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZSxcbiAgICAgIHRtcCxcbiAgICAgIGNoO1xuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg3Q1xuICAvKiB8ICovXG4gICkge1xuICAgICAgZm9sZGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4M0VcbiAgLyogPiAqL1xuICApIHtcbiAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkJcbiAgICAvKiArICovXG4gICAgfHwgY2ggPT09IDB4MkRcbiAgICAvKiAtICovXG4gICAgKSB7XG4gICAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICAgIGNob21waW5nID0gY2ggPT09IDB4MkJcbiAgICAgICAgICAvKiArICovXG4gICAgICAgICAgPyBDSE9NUElOR19LRUVQIDogQ0hPTVBJTkdfU1RSSVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBmcm9tRGVjaW1hbENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgZXhwbGljaXQgaW5kZW50YXRpb24gd2lkdGggb2YgYSBibG9jayBzY2FsYXI7IGl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gb25lJyk7XG4gICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xuICAgICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCArIHRtcCAtIDE7XG4gICAgICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8ge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjNcbiAgICAvKiAjICovXG4gICAgKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH0gd2hpbGUgKCFpc19FT0woY2gpICYmIGNoICE9PSAwKTtcbiAgICAgIH1cbiAgfVxuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgPSAwO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoKCFkZXRlY3RlZEluZGVudCB8fCBzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkgJiYgY2ggPT09IDB4MjBcbiAgICAvKiBTcGFjZSAqL1xuICAgICkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIEVuZCBvZiB0aGUgc2NhbGFyLlxuXG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcbiAgICAgIC8vIFBlcmZvcm0gdGhlIGNob21waW5nLlxuICAgICAgaWYgKGNob21waW5nID09PSBDSE9NUElOR19LRUVQKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKGNob21waW5nID09PSBDSE9NUElOR19DTElQKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkge1xuICAgICAgICAgIC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cblxuXG4gICAgICBicmVhaztcbiAgICB9IC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cblxuXG4gICAgaWYgKGZvbGRpbmcpIHtcbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTsgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY29udGVudCBsaW5lIChjZi4gRXhhbXBsZSA4LjEpXG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTsgLy8gRW5kIG9mIG1vcmUtaW5kZW50ZWQgYmxvY2suXG4gICAgICB9IGVsc2UgaWYgKGF0TW9yZUluZGVudGVkKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzICsgMSk7IC8vIEp1c3Qgb25lIGxpbmUgYnJlYWsgLSBwZXJjZWl2ZSBhcyB0aGUgc2FtZSBsaW5lLlxuICAgICAgfSBlbHNlIGlmIChlbXB0eUxpbmVzID09PSAwKSB7XG4gICAgICAgIGlmIChkaWRSZWFkQ29udGVudCkge1xuICAgICAgICAgIC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH0gLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfSAvLyBMaXRlcmFsIHN0eWxlOiBqdXN0IGFkZCBleGFjdCBudW1iZXIgb2YgbGluZSBicmVha3MgYmV0d2VlbiBjb250ZW50IGxpbmVzLlxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgY2ggIT09IDApIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBfbGluZSxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCA9IFtdLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgZGV0ZWN0ZWQgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGlmIChjaCAhPT0gMHgyRFxuICAgIC8qIC0gKi9cbiAgICApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoIWlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDw9IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xuXG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9saW5lID0gc3RhdGUubGluZTtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19JTiwgZmFsc2UsIHRydWUpO1xuXG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG5cbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIGNoICE9PSAwKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgc2VxdWVuY2UgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdzZXF1ZW5jZSc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfcG9zLFxuICAgICAgX3RhZyA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSB7fSxcbiAgICAgIGtleVRhZyA9IG51bGwsXG4gICAgICBrZXlOb2RlID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSA9IG51bGwsXG4gICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZCA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuXG4gICAgX3BvcyA9IHN0YXRlLnBvc2l0aW9uOyAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cblxuICAgIGlmICgoY2ggPT09IDB4M0ZcbiAgICAvKiA/ICovXG4gICAgfHwgY2ggPT09IDB4M0FcbiAgICAvKiA6ICovXG4gICAgKSAmJiBpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgaWYgKGNoID09PSAweDNGXG4gICAgICAvKiA/ICovXG4gICAgICApIHtcbiAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGF0RXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAvLyBpLmUuIDB4M0EvKiA6ICovID09PSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGV4cGxpY2l0IGtleS5cbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2luY29tcGxldGUgZXhwbGljaXQgbWFwcGluZyBwYWlyOyBhIGtleSBub2RlIGlzIG1pc3NlZDsgb3IgZm9sbG93ZWQgYnkgYSBub24tdGFidWxhdGVkIGVtcHR5IGxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgICAgIGNoID0gZm9sbG93aW5nOyAvL1xuICAgICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgICAvL1xuICAgIH0gZWxzZSBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19PVVQsIGZhbHNlLCB0cnVlKSkge1xuICAgICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQVxuICAgICAgICAvKiA6ICovXG4gICAgICAgICkge1xuICAgICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Egd2hpdGVzcGFjZSBjaGFyYWN0ZXIgaXMgZXhwZWN0ZWQgYWZ0ZXIgdGhlIGtleS12YWx1ZSBzZXBhcmF0b3Igd2l0aGluIGEgYmxvY2sgbWFwcGluZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCk7XG4gICAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxvd0NvbXBhY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2NhbiBub3QgcmVhZCBhIGJsb2NrIG1hcHBpbmcgZW50cnk7IGEgbXVsdGlsaW5lIGtleSBtYXkgbm90IGJlIGFuIGltcGxpY2l0IGtleScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrOyAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICAgIH0gLy9cbiAgICAvLyBDb21tb24gcmVhZGluZyBjb2RlIGZvciBib3RoIGV4cGxpY2l0IGFuZCBpbXBsaWNpdCBub3RhdGlvbnMuXG4gICAgLy9cblxuXG4gICAgaWYgKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSB7XG4gICAgICBpZiAoY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfT1VULCB0cnVlLCBhbGxvd0NvbXBhY3QpKSB7XG4gICAgICAgIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAga2V5Tm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUsIF9saW5lLCBfcG9zKTtcbiAgICAgICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50ICYmIGNoICE9PSAwKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvL1xuICAvLyBFcGlsb2d1ZS5cbiAgLy9cbiAgLy8gU3BlY2lhbCBjYXNlOiBsYXN0IG1hcHBpbmcncyBub2RlIGNvbnRhaW5zIG9ubHkgdGhlIGtleSBpbiBleHBsaWNpdCBub3RhdGlvbi5cblxuXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICB9IC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG5cblxuICBpZiAoZGV0ZWN0ZWQpIHtcbiAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgc3RhdGUua2luZCA9ICdtYXBwaW5nJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGRldGVjdGVkO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGlzVmVyYmF0aW0gPSBmYWxzZSxcbiAgICAgIGlzTmFtZWQgPSBmYWxzZSxcbiAgICAgIHRhZ0hhbmRsZSxcbiAgICAgIHRhZ05hbWUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICBpZiAoY2ggIT09IDB4MjFcbiAgLyogISAqL1xuICApIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUudGFnICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGEgdGFnIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDNDXG4gIC8qIDwgKi9cbiAgKSB7XG4gICAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIxXG4gIC8qICEgKi9cbiAgKSB7XG4gICAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICAgIHRhZ0hhbmRsZSA9ICchISc7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IHdoaWxlIChjaCAhPT0gMCAmJiBjaCAhPT0gMHgzRVxuICAgIC8qID4gKi9cbiAgICApO1xuXG4gICAgaWYgKHN0YXRlLnBvc2l0aW9uIDwgc3RhdGUubGVuZ3RoKSB7XG4gICAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHZlcmJhdGltIHRhZycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgyMVxuICAgICAgLyogISAqL1xuICAgICAgKSB7XG4gICAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgICB0YWdIYW5kbGUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24gLSAxLCBzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKFBBVFRFUk5fRkxPV19JTkRJQ0FUT1JTLnRlc3QodGFnTmFtZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGZsb3cgaW5kaWNhdG9yIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnTmFtZSAmJiAhUEFUVEVSTl9UQUdfVVJJLnRlc3QodGFnTmFtZSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIG5hbWUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzOiAnICsgdGFnTmFtZSk7XG4gIH1cblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIHN0YXRlLnRhZyA9IHRhZ05hbWU7XG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDIuY2FsbChzdGF0ZS50YWdNYXAsIHRhZ0hhbmRsZSkpIHtcbiAgICBzdGF0ZS50YWcgPSBzdGF0ZS50YWdNYXBbdGFnSGFuZGxlXSArIHRhZ05hbWU7XG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnIScpIHtcbiAgICBzdGF0ZS50YWcgPSAnIScgKyB0YWdOYW1lO1xuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEhJykge1xuICAgIHN0YXRlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnTmFtZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5kZWNsYXJlZCB0YWcgaGFuZGxlIFwiJyArIHRhZ0hhbmRsZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICBpZiAoY2ggIT09IDB4MjZcbiAgLyogJiAqL1xuICApIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mIGFuIGFuY2hvciBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYW5jaG9yIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIHN0YXRlLmFuY2hvciA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEFsaWFzKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sIGFsaWFzLCBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICBpZiAoY2ggIT09IDB4MkFcbiAgLyogKiAqL1xuICApIHJldHVybiBmYWxzZTtcbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkgJiYgIWlzX0ZMT1dfSU5ESUNBVE9SKGNoKSkge1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gX3Bvc2l0aW9uKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWUgb2YgYW4gYWxpYXMgbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgYWxpYXMgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoIV9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwoc3RhdGUuYW5jaG9yTWFwLCBhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSxcbiAgICAgIC8vIDE6IHRoaXM+cGFyZW50LCAwOiB0aGlzPXBhcmVudCwgLTE6IHRoaXM8cGFyZW50XG4gIGF0TmV3TGluZSA9IGZhbHNlLFxuICAgICAgaGFzQ29udGVudCA9IGZhbHNlLFxuICAgICAgdHlwZUluZGV4LFxuICAgICAgdHlwZVF1YW50aXR5LFxuICAgICAgdHlwZSxcbiAgICAgIGZsb3dJbmRlbnQsXG4gICAgICBibG9ja0luZGVudDtcblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignb3BlbicsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmFuY2hvciA9IG51bGw7XG4gIHN0YXRlLmtpbmQgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuICBhbGxvd0Jsb2NrU3R5bGVzID0gYWxsb3dCbG9ja1NjYWxhcnMgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9CTE9DS19JTiA9PT0gbm9kZUNvbnRleHQ7XG5cbiAgaWYgKGFsbG93VG9TZWVrKSB7XG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMpIHtcbiAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhdE5ld0xpbmUgfHwgYWxsb3dDb21wYWN0O1xuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSB8fCBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICBpZiAoQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCB8fCBDT05URVhUX0ZMT1dfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudCArIDE7XG4gICAgfVxuXG4gICAgYmxvY2tJbmRlbnQgPSBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydDtcblxuICAgIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHwgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fCByZWFkRmxvd0NvbGxlY3Rpb24oc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkgfHwgcmVhZFNpbmdsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkgfHwgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkQWxpYXMoc3RhdGUpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsIHx8IHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2FsaWFzIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGFueSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGVudFN0YXR1cyA9PT0gMCkge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBibG9jayBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgdG8gaGF2ZSBzYW1lIGluZGVudGF0aW9uIGxldmVsIGFzIHRoZSBwYXJlbnQuXG4gICAgICAvLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3OTk3ODRcbiAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJyEnKSB7XG4gICAgaWYgKHN0YXRlLnRhZyA9PT0gJz8nKSB7XG4gICAgICAvLyBJbXBsaWNpdCByZXNvbHZpbmcgaXMgbm90IGFsbG93ZWQgZm9yIG5vbi1zY2FsYXIgdHlwZXMsIGFuZCAnPydcbiAgICAgIC8vIG5vbi1zcGVjaWZpYyB0YWcgaXMgb25seSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvIHBsYWluIHNjYWxhcnMuXG4gICAgICAvL1xuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIGNoZWNrIGtpbmQgY29uZm9ybWl0eSBpbiBjYXNlIHVzZXIgZXhwbGljaXRseSBhc3NpZ25zICc/J1xuICAgICAgLy8gdGFnLCBmb3IgZXhhbXBsZSBsaWtlIHRoaXM6IFwiITw/PiBbMF1cIlxuICAgICAgLy9cbiAgICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgc3RhdGUua2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8Pz4gdGFnOyBpdCBzaG91bGQgYmUgXCJzY2FsYXJcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1t0eXBlSW5kZXhdO1xuXG4gICAgICAgIGlmICh0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkge1xuICAgICAgICAgIC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG4gICAgICAgICAgc3RhdGUudGFnID0gdHlwZS50YWc7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDIuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcblxuICAgICAgaWYgKHN0YXRlLnJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlLmtpbmQgIT09IHN0YXRlLmtpbmQpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlLnJlc29sdmUoc3RhdGUucmVzdWx0KSkge1xuICAgICAgICAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCByZXNvbHZlIGEgbm9kZSB3aXRoICE8JyArIHN0YXRlLnRhZyArICc+IGV4cGxpY2l0IHRhZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcblxuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gdGFnICE8JyArIHN0YXRlLnRhZyArICc+Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLnRhZyAhPT0gbnVsbCB8fCBzdGF0ZS5hbmNob3IgIT09IG51bGwgfHwgaGFzQ29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVhZERvY3VtZW50KHN0YXRlKSB7XG4gIHZhciBkb2N1bWVudFN0YXJ0ID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBfcG9zaXRpb24sXG4gICAgICBkaXJlY3RpdmVOYW1lLFxuICAgICAgZGlyZWN0aXZlQXJncyxcbiAgICAgIGhhc0RpcmVjdGl2ZXMgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIHN0YXRlLnZlcnNpb24gPSBudWxsO1xuICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBzdGF0ZS5sZWdhY3k7XG4gIHN0YXRlLnRhZ01hcCA9IHt9O1xuICBzdGF0ZS5hbmNob3JNYXAgPSB7fTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IDAgfHwgY2ggIT09IDB4MjVcbiAgICAvKiAlICovXG4gICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09IDB4MjNcbiAgICAgIC8qICMgKi9cbiAgICAgICkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgICB9IHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfRU9MKGNoKSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkgYnJlYWs7XG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiYgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkRcbiAgLyogLSAqL1xuICAmJiBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSkgPT09IDB4MkRcbiAgLyogLSAqL1xuICAmJiBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMikgPT09IDB4MkRcbiAgLyogLSAqL1xuICApIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfSBlbHNlIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZXMgZW5kIG1hcmsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGNvbXBvc2VOb2RlKHN0YXRlLCBzdGF0ZS5saW5lSW5kZW50IC0gMSwgQ09OVEVYVF9CTE9DS19PVVQsIGZhbHNlLCB0cnVlKTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5jaGVja0xpbmVCcmVha3MgJiYgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkVcbiAgICAvKiAuICovXG4gICAgKSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCAtIDEpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucykge1xuICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IDApIHtcbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEFcbiAgICAvKiBMRiAqL1xuICAgICYmIGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MERcbiAgICAvKiBDUiAqL1xuICAgICkge1xuICAgICAgICBpbnB1dCArPSAnXFxuJztcbiAgICAgIH0gLy8gU3RyaXAgQk9NXG5cblxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKGlucHV0LCBvcHRpb25zKTtcbiAgdmFyIG51bGxwb3MgPSBpbnB1dC5pbmRleE9mKCdcXDAnKTtcblxuICBpZiAobnVsbHBvcyAhPT0gLTEpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiA9IG51bGxwb3M7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ251bGwgYnl0ZSBpcyBub3QgYWxsb3dlZCBpbiBpbnB1dCcpO1xuICB9IC8vIFVzZSAwIGFzIHN0cmluZyB0ZXJtaW5hdG9yLiBUaGF0IHNpZ25pZmljYW50bHkgc2ltcGxpZmllcyBib3VuZHMgY2hlY2suXG5cblxuICBzdGF0ZS5pbnB1dCArPSAnXFwwJztcblxuICB3aGlsZSAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MjBcbiAgLyogU3BhY2UgKi9cbiAgKSB7XG4gICAgc3RhdGUubGluZUluZGVudCArPSAxO1xuICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGggLSAxKSB7XG4gICAgcmVhZERvY3VtZW50KHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5kb2N1bWVudHM7XG59XG5cbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmIChpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9hZChpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50c1swXTtcbiAgfVxuXG4gIHRocm93IG5ldyBleGNlcHRpb24oJ2V4cGVjdGVkIGEgc2luZ2xlIGRvY3VtZW50IGluIHRoZSBzdHJlYW0sIGJ1dCBmb3VuZCBtb3JlJyk7XG59XG5cbmZ1bmN0aW9uIHNhZmVMb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yID09PSAnb2JqZWN0JyAmJiBpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gaXRlcmF0b3I7XG4gICAgaXRlcmF0b3IgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBjb21tb24uZXh0ZW5kKHtcbiAgICBzY2hlbWE6IGRlZmF1bHRfc2FmZVxuICB9LCBvcHRpb25zKSk7XG59XG5cbmZ1bmN0aW9uIHNhZmVMb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBsb2FkKGlucHV0LCBjb21tb24uZXh0ZW5kKHtcbiAgICBzY2hlbWE6IGRlZmF1bHRfc2FmZVxuICB9LCBvcHRpb25zKSk7XG59XG5cbnZhciBsb2FkQWxsXzEgPSBsb2FkQWxsO1xudmFyIGxvYWRfMSA9IGxvYWQ7XG52YXIgc2FmZUxvYWRBbGxfMSA9IHNhZmVMb2FkQWxsO1xudmFyIHNhZmVMb2FkXzEgPSBzYWZlTG9hZDtcbnZhciBsb2FkZXIgPSB7XG4gIGxvYWRBbGw6IGxvYWRBbGxfMSxcbiAgbG9hZDogbG9hZF8xLFxuICBzYWZlTG9hZEFsbDogc2FmZUxvYWRBbGxfMSxcbiAgc2FmZUxvYWQ6IHNhZmVMb2FkXzFcbn07XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG5cbnZhciBfdG9TdHJpbmckMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5JDMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIENIQVJfVEFCID0gMHgwOTtcbi8qIFRhYiAqL1xuXG52YXIgQ0hBUl9MSU5FX0ZFRUQgPSAweDBBO1xuLyogTEYgKi9cblxudmFyIENIQVJfQ0FSUklBR0VfUkVUVVJOID0gMHgwRDtcbi8qIENSICovXG5cbnZhciBDSEFSX1NQQUNFID0gMHgyMDtcbi8qIFNwYWNlICovXG5cbnZhciBDSEFSX0VYQ0xBTUFUSU9OID0gMHgyMTtcbi8qICEgKi9cblxudmFyIENIQVJfRE9VQkxFX1FVT1RFID0gMHgyMjtcbi8qIFwiICovXG5cbnZhciBDSEFSX1NIQVJQID0gMHgyMztcbi8qICMgKi9cblxudmFyIENIQVJfUEVSQ0VOVCA9IDB4MjU7XG4vKiAlICovXG5cbnZhciBDSEFSX0FNUEVSU0FORCA9IDB4MjY7XG4vKiAmICovXG5cbnZhciBDSEFSX1NJTkdMRV9RVU9URSA9IDB4Mjc7XG4vKiAnICovXG5cbnZhciBDSEFSX0FTVEVSSVNLID0gMHgyQTtcbi8qICogKi9cblxudmFyIENIQVJfQ09NTUEgPSAweDJDO1xuLyogLCAqL1xuXG52YXIgQ0hBUl9NSU5VUyA9IDB4MkQ7XG4vKiAtICovXG5cbnZhciBDSEFSX0NPTE9OID0gMHgzQTtcbi8qIDogKi9cblxudmFyIENIQVJfRVFVQUxTID0gMHgzRDtcbi8qID0gKi9cblxudmFyIENIQVJfR1JFQVRFUl9USEFOID0gMHgzRTtcbi8qID4gKi9cblxudmFyIENIQVJfUVVFU1RJT04gPSAweDNGO1xuLyogPyAqL1xuXG52YXIgQ0hBUl9DT01NRVJDSUFMX0FUID0gMHg0MDtcbi8qIEAgKi9cblxudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUI7XG4vKiBbICovXG5cbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDtcbi8qIF0gKi9cblxudmFyIENIQVJfR1JBVkVfQUNDRU5UID0gMHg2MDtcbi8qIGAgKi9cblxudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUID0gMHg3Qjtcbi8qIHsgKi9cblxudmFyIENIQVJfVkVSVElDQUxfTElORSA9IDB4N0M7XG4vKiB8ICovXG5cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgPSAweDdEO1xuLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuRVNDQVBFX1NFUVVFTkNFU1sweDAwXSA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gPSAnXFxcXGInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA5XSA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gPSAnXFxcXHYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBDXSA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gPSAnXFxcXGUnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIyXSA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdID0gJ1xcXFxOJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHhBMF0gPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbJ3knLCAnWScsICd5ZXMnLCAnWWVzJywgJ1lFUycsICdvbicsICdPbicsICdPTicsICduJywgJ04nLCAnbm8nLCAnTm8nLCAnTk8nLCAnb2ZmJywgJ09mZicsICdPRkYnXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG4gIGlmIChtYXAgPT09IG51bGwpIHJldHVybiB7fTtcbiAgcmVzdWx0ID0ge307XG4gIGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0YWcgPSBrZXlzW2luZGV4XTtcbiAgICBzdHlsZSA9IFN0cmluZyhtYXBbdGFnXSk7XG5cbiAgICBpZiAodGFnLnNsaWNlKDAsIDIpID09PSAnISEnKSB7XG4gICAgICB0YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZy5zbGljZSgyKTtcbiAgICB9XG5cbiAgICB0eXBlID0gc2NoZW1hLmNvbXBpbGVkVHlwZU1hcFsnZmFsbGJhY2snXVt0YWddO1xuXG4gICAgaWYgKHR5cGUgJiYgX2hhc093blByb3BlcnR5JDMuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlJDEob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSA9IG9wdGlvbnNbJ3NjaGVtYSddIHx8IGRlZmF1bHRfZnVsbDtcbiAgdGhpcy5pbmRlbnQgPSBNYXRoLm1heCgxLCBvcHRpb25zWydpbmRlbnQnXSB8fCAyKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkID0gb3B0aW9uc1snc2tpcEludmFsaWQnXSB8fCBmYWxzZTtcbiAgdGhpcy5mbG93TGV2ZWwgPSBjb21tb24uaXNOb3RoaW5nKG9wdGlvbnNbJ2Zsb3dMZXZlbCddKSA/IC0xIDogb3B0aW9uc1snZmxvd0xldmVsJ107XG4gIHRoaXMuc3R5bGVNYXAgPSBjb21waWxlU3R5bGVNYXAodGhpcy5zY2hlbWEsIG9wdGlvbnNbJ3N0eWxlcyddIHx8IG51bGwpO1xuICB0aGlzLnNvcnRLZXlzID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggPSBvcHRpb25zWydsaW5lV2lkdGgnXSB8fCA4MDtcbiAgdGhpcy5ub1JlZnMgPSBvcHRpb25zWydub1JlZnMnXSB8fCBmYWxzZTtcbiAgdGhpcy5ub0NvbXBhdE1vZGUgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgPSBvcHRpb25zWydjb25kZW5zZUZsb3cnXSB8fCBmYWxzZTtcbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcbiAgdGhpcy50YWcgPSBudWxsO1xuICB0aGlzLnJlc3VsdCA9ICcnO1xuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59IC8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuXG5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuXG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gWzMzXSBzLXdoaXRlIDo6PSBzLXNwYWNlIHwgcy10YWJcblxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoYykge1xuICByZXR1cm4gYyA9PT0gQ0hBUl9TUEFDRSB8fCBjID09PSBDSEFSX1RBQjtcbn0gLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgY2FuIGJlIHByaW50ZWQgd2l0aG91dCBlc2NhcGluZy5cbi8vIEZyb20gWUFNTCAxLjI6IFwiYW55IGFsbG93ZWQgY2hhcmFjdGVycyBrbm93biB0byBiZSBub24tcHJpbnRhYmxlXG4vLyBzaG91bGQgYWxzbyBiZSBlc2NhcGVkLiBbSG93ZXZlcixdIFRoaXMgaXNu4oCZdCBtYW5kYXRvcnlcIlxuLy8gRGVyaXZlZCBmcm9tIG5iLWNoYXIgLSBcXHQgLSAjeDg1IC0gI3hBMCAtICN4MjAyOCAtICN4MjAyOS5cblxuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAweDAwMDIwIDw9IGMgJiYgYyA8PSAweDAwMDA3RSB8fCAweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRiAmJiBjICE9PSAweDIwMjggJiYgYyAhPT0gMHgyMDI5IHx8IDB4MEUwMDAgPD0gYyAmJiBjIDw9IDB4MDBGRkZEICYmIGMgIT09IDB4RkVGRlxuICAvKiBCT00gKi9cbiAgfHwgMHgxMDAwMCA8PSBjICYmIGMgPD0gMHgxMEZGRkY7XG59IC8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBbMjRdIGItbGluZS1mZWVkICAgICAgIDo6PSAgICAgI3hBICAgIC8qIExGICovXG4vLyBbMjVdIGItY2FycmlhZ2UtcmV0dXJuIDo6PSAgICAgI3hEICAgIC8qIENSICovXG4vLyBbM10gIGMtYnl0ZS1vcmRlci1tYXJrIDo6PSAgICAgI3hGRUZGXG5cblxuZnVuY3Rpb24gaXNOc0NoYXIoYykge1xuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgIWlzV2hpdGVzcGFjZShjKSAvLyBieXRlLW9yZGVyLW1hcmtcbiAgJiYgYyAhPT0gMHhGRUZGIC8vIGItY2hhclxuICAmJiBjICE9PSBDSEFSX0NBUlJJQUdFX1JFVFVSTiAmJiBjICE9PSBDSEFSX0xJTkVfRkVFRDtcbn0gLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhZnRlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuXG5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlKGMsIHByZXYpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBuYi1jaGFyIC0gYy1mbG93LWluZGljYXRvciAtIFwiOlwiIC0gXCIjXCJcbiAgLy8gd2hlcmUgbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFyay5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRiAvLyAtIGMtZmxvdy1pbmRpY2F0b3JcbiAgJiYgYyAhPT0gQ0hBUl9DT01NQSAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgLy8gLSBcIjpcIiAtIFwiI1wiXG4gIC8vIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIFwiI1wiXG4gICYmIGMgIT09IENIQVJfQ09MT04gJiYgKGMgIT09IENIQVJfU0hBUlAgfHwgcHJldiAmJiBpc05zQ2hhcihwcmV2KSk7XG59IC8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cblxuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUZpcnN0KGMpIHtcbiAgLy8gVXNlcyBhIHN1YnNldCBvZiBucy1jaGFyIC0gYy1pbmRpY2F0b3JcbiAgLy8gd2hlcmUgbnMtY2hhciA9IG5iLWNoYXIgLSBzLXdoaXRlLlxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gMHhGRUZGICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gIC8vIC0gKGMtaW5kaWNhdG9yIDo6PVxuICAvLyDigJwt4oCdIHwg4oCcP+KAnSB8IOKAnDrigJ0gfCDigJws4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ0gfCDigJx74oCdIHwg4oCcfeKAnVxuICAmJiBjICE9PSBDSEFSX01JTlVTICYmIGMgIT09IENIQVJfUVVFU1RJT04gJiYgYyAhPT0gQ0hBUl9DT0xPTiAmJiBjICE9PSBDSEFSX0NPTU1BICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAmJiBjICE9PSBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAvLyB8IOKAnCPigJ0gfCDigJwm4oCdIHwg4oCcKuKAnSB8IOKAnCHigJ0gfCDigJx84oCdIHwg4oCcPeKAnSB8IOKAnD7igJ0gfCDigJwn4oCdIHwg4oCcXCLigJ1cbiAgJiYgYyAhPT0gQ0hBUl9TSEFSUCAmJiBjICE9PSBDSEFSX0FNUEVSU0FORCAmJiBjICE9PSBDSEFSX0FTVEVSSVNLICYmIGMgIT09IENIQVJfRVhDTEFNQVRJT04gJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FICYmIGMgIT09IENIQVJfRVFVQUxTICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOICYmIGMgIT09IENIQVJfU0lOR0xFX1FVT1RFICYmIGMgIT09IENIQVJfRE9VQkxFX1FVT1RFIC8vIHwg4oCcJeKAnSB8IOKAnEDigJ0gfCDigJxg4oCdKVxuICAmJiBjICE9PSBDSEFSX1BFUkNFTlQgJiYgYyAhPT0gQ0hBUl9DT01NRVJDSUFMX0FUICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufSAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGlzIHJlcXVpcmVkLlxuXG5cbmZ1bmN0aW9uIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSB7XG4gIHZhciBsZWFkaW5nU3BhY2VSZSA9IC9eXFxuKiAvO1xuICByZXR1cm4gbGVhZGluZ1NwYWNlUmUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgU1RZTEVfUExBSU4gPSAxLFxuICAgIFNUWUxFX1NJTkdMRSA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgPSA1OyAvLyBEZXRlcm1pbmVzIHdoaWNoIHNjYWxhciBzdHlsZXMgYXJlIHBvc3NpYmxlIGFuZCByZXR1cm5zIHRoZSBwcmVmZXJyZWQgc3R5bGUuXG4vLyBsaW5lV2lkdGggPSAtMSA9PiBubyBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBzdHIubGVuZ3RoID4gMC5cbi8vIFBvc3QtY29uZGl0aW9uczpcbi8vICAgIFNUWUxFX1BMQUlOIG9yIFNUWUxFX1NJTkdMRSA9PiBubyBcXG4gYXJlIGluIHRoZSBzdHJpbmcuXG4vLyAgICBTVFlMRV9MSVRFUkFMID0+IG5vIGxpbmVzIGFyZSBzdWl0YWJsZSBmb3IgZm9sZGluZyAob3IgbGluZVdpZHRoIGlzIC0xKS5cbi8vICAgIFNUWUxFX0ZPTERFRCA9PiBhIGxpbmUgPiBsaW5lV2lkdGggYW5kIGNhbiBiZSBmb2xkZWQgKGFuZCBsaW5lV2lkdGggIT0gLTEpLlxuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1b3VzVHlwZSkge1xuICB2YXIgaTtcbiAgdmFyIGNoYXIsIHByZXZfY2hhcjtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG5cbiAgdmFyIHNob3VsZFRyYWNrV2lkdGggPSBsaW5lV2lkdGggIT09IC0xO1xuICB2YXIgcHJldmlvdXNMaW5lQnJlYWsgPSAtMTsgLy8gY291bnQgdGhlIGZpcnN0IGxpbmUgY29ycmVjdGx5XG5cbiAgdmFyIHBsYWluID0gaXNQbGFpblNhZmVGaXJzdChzdHJpbmcuY2hhckNvZGVBdCgwKSkgJiYgIWlzV2hpdGVzcGFjZShzdHJpbmcuY2hhckNvZGVBdChzdHJpbmcubGVuZ3RoIC0gMSkpO1xuXG4gIGlmIChzaW5nbGVMaW5lT25seSkge1xuICAgIC8vIENhc2U6IG5vIGJsb2NrIHN0eWxlcy5cbiAgICAvLyBDaGVjayBmb3IgZGlzYWxsb3dlZCBjaGFyYWN0ZXJzIHRvIHJ1bGUgb3V0IHBsYWluIGFuZCBzaW5nbGUuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG5cbiAgICAgIHByZXZfY2hhciA9IGkgPiAwID8gc3RyaW5nLmNoYXJDb2RlQXQoaSAtIDEpIDogbnVsbDtcbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldl9jaGFyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZTogYmxvY2sgc3R5bGVzIHBlcm1pdHRlZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlOyAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuXG4gICAgICAgIGlmIChzaG91bGRUcmFja1dpZHRoKSB7XG4gICAgICAgICAgaGFzRm9sZGFibGVMaW5lID0gaGFzRm9sZGFibGVMaW5lIHx8IC8vIEZvbGRhYmxlIGxpbmUgPSB0b28gbG9uZywgYW5kIG5vdCBtb3JlLWluZGVudGVkLlxuICAgICAgICAgIGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiYgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJztcbiAgICAgICAgICBwcmV2aW91c0xpbmVCcmVhayA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG5cbiAgICAgIHByZXZfY2hhciA9IGkgPiAwID8gc3RyaW5nLmNoYXJDb2RlQXQoaSAtIDEpIDogbnVsbDtcbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldl9jaGFyKTtcbiAgICB9IC8vIGluIGNhc2UgdGhlIGVuZCBpcyBtaXNzaW5nIGEgXFxuXG5cblxuICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fCBzaG91bGRUcmFja1dpZHRoICYmIGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiYgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJztcbiAgfSAvLyBBbHRob3VnaCBldmVyeSBzdHlsZSBjYW4gcmVwcmVzZW50IFxcbiB3aXRob3V0IGVzY2FwaW5nLCBwcmVmZXIgYmxvY2sgc3R5bGVzXG4gIC8vIGZvciBtdWx0aWxpbmUsIHNpbmNlIHRoZXkncmUgbW9yZSByZWFkYWJsZSBhbmQgdGhleSBkb24ndCBhZGQgZW1wdHkgbGluZXMuXG4gIC8vIEFsc28gcHJlZmVyIGZvbGRpbmcgYSBzdXBlci1sb25nIGxpbmUuXG5cblxuICBpZiAoIWhhc0xpbmVCcmVhayAmJiAhaGFzRm9sZGFibGVMaW5lKSB7XG4gICAgLy8gU3RyaW5ncyBpbnRlcnByZXRhYmxlIGFzIGFub3RoZXIgdHlwZSBoYXZlIHRvIGJlIHF1b3RlZDtcbiAgICAvLyBlLmcuIHRoZSBzdHJpbmcgJ3RydWUnIHZzLiB0aGUgYm9vbGVhbiB0cnVlLlxuICAgIHJldHVybiBwbGFpbiAmJiAhdGVzdEFtYmlndW91c1R5cGUoc3RyaW5nKSA/IFNUWUxFX1BMQUlOIDogU1RZTEVfU0lOR0xFO1xuICB9IC8vIEVkZ2UgY2FzZTogYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGNhbiBvbmx5IGhhdmUgb25lIGRpZ2l0LlxuXG5cbiAgaWYgKGluZGVudFBlckxldmVsID4gOSAmJiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9IC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuXG5cbiAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG59IC8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAg4oCiIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICDigKIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5cblxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIHN0cmluZywgbGV2ZWwsIGlza2V5KSB7XG4gIHN0YXRlLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIicnXCI7XG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5ub0NvbXBhdE1vZGUgJiYgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nICsgXCInXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIOKJpCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cblxuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGggPT09IC0xID8gLTEgOiBNYXRoLm1heChNYXRoLm1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKSwgc3RhdGUubGluZVdpZHRoIC0gaW5kZW50KTsgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cblxuICAgIHZhciBzaW5nbGVMaW5lT25seSA9IGlza2V5IC8vIE5vIGJsb2NrIHN0eWxlcyBpbiBmbG93IG1vZGUuXG4gICAgfHwgc3RhdGUuZmxvd0xldmVsID4gLTEgJiYgbGV2ZWwgPj0gc3RhdGUuZmxvd0xldmVsO1xuXG4gICAgZnVuY3Rpb24gdGVzdEFtYmlndWl0eShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cmluZyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBzdGF0ZS5pbmRlbnQsIGxpbmVXaWR0aCwgdGVzdEFtYmlndWl0eSkpIHtcbiAgICAgIGNhc2UgU1RZTEVfUExBSU46XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG5cbiAgICAgIGNhc2UgU1RZTEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG5cbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KSArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhzdHJpbmcsIGluZGVudCkpO1xuXG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KSArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhmb2xkU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSwgaW5kZW50KSk7XG5cbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcpICsgJ1wiJztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignaW1wb3NzaWJsZSBlcnJvcjogaW52YWxpZCBzY2FsYXIgc3R5bGUnKTtcbiAgICB9XG4gIH0oKTtcbn0gLy8gUHJlLWNvbmRpdGlvbnM6IHN0cmluZyBpcyB2YWxpZCBmb3IgYSBibG9jayBzY2FsYXIsIDEgPD0gaW5kZW50UGVyTGV2ZWwgPD0gOS5cblxuXG5mdW5jdGlvbiBibG9ja0hlYWRlcihzdHJpbmcsIGluZGVudFBlckxldmVsKSB7XG4gIHZhciBpbmRlbnRJbmRpY2F0b3IgPSBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykgPyBTdHJpbmcoaW5kZW50UGVyTGV2ZWwpIDogJyc7IC8vIG5vdGUgdGhlIHNwZWNpYWwgY2FzZTogdGhlIHN0cmluZyAnXFxuJyBjb3VudHMgYXMgYSBcInRyYWlsaW5nXCIgZW1wdHkgbGluZS5cblxuICB2YXIgY2xpcCA9IHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nO1xuICB2YXIga2VlcCA9IGNsaXAgJiYgKHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMl0gPT09ICdcXG4nIHx8IHN0cmluZyA9PT0gJ1xcbicpO1xuICB2YXIgY2hvbXAgPSBrZWVwID8gJysnIDogY2xpcCA/ICcnIDogJy0nO1xuICByZXR1cm4gaW5kZW50SW5kaWNhdG9yICsgY2hvbXAgKyAnXFxuJztcbn0gLy8gKFNlZSB0aGUgbm90ZSBmb3Igd3JpdGVTY2FsYXIuKVxuXG5cbmZ1bmN0aW9uIGRyb3BFbmRpbmdOZXdsaW5lKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbicgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufSAvLyBOb3RlOiBhIGxvbmcgbGluZSB3aXRob3V0IGEgc3VpdGFibGUgYnJlYWsgcG9pbnQgd2lsbCBleGNlZWQgdGhlIHdpZHRoIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IGV2ZXJ5IGNoYXIgaW4gc3RyIGlzUHJpbnRhYmxlLCBzdHIubGVuZ3RoID4gMCwgd2lkdGggPiAwLlxuXG5cbmZ1bmN0aW9uIGZvbGRTdHJpbmcoc3RyaW5nLCB3aWR0aCkge1xuICAvLyBJbiBmb2xkZWQgc3R5bGUsICRrJCBjb25zZWN1dGl2ZSBuZXdsaW5lcyBvdXRwdXQgYXMgJGsrMSQgbmV3bGluZXPigJRcbiAgLy8gdW5sZXNzIHRoZXkncmUgYmVmb3JlIG9yIGFmdGVyIGEgbW9yZS1pbmRlbnRlZCBsaW5lLCBvciBhdCB0aGUgdmVyeVxuICAvLyBiZWdpbm5pbmcgb3IgZW5kLCBpbiB3aGljaCBjYXNlICRrJCBtYXBzIHRvICRrJC5cbiAgLy8gVGhlcmVmb3JlLCBwYXJzZSBlYWNoIGNodW5rIGFzIG5ld2xpbmUocykgZm9sbG93ZWQgYnkgYSBjb250ZW50IGxpbmUuXG4gIHZhciBsaW5lUmUgPSAvKFxcbispKFteXFxuXSopL2c7IC8vIGZpcnN0IGxpbmUgKHBvc3NpYmx5IGFuIGVtcHR5IGxpbmUpXG5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dExGID0gc3RyaW5nLmluZGV4T2YoJ1xcbicpO1xuICAgIG5leHRMRiA9IG5leHRMRiAhPT0gLTEgPyBuZXh0TEYgOiBzdHJpbmcubGVuZ3RoO1xuICAgIGxpbmVSZS5sYXN0SW5kZXggPSBuZXh0TEY7XG4gICAgcmV0dXJuIGZvbGRMaW5lKHN0cmluZy5zbGljZSgwLCBuZXh0TEYpLCB3aWR0aCk7XG4gIH0oKTsgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgeWV0LCBkb24ndCBhZGQgYW4gZXh0cmEgXFxuLlxuXG5cbiAgdmFyIHByZXZNb3JlSW5kZW50ZWQgPSBzdHJpbmdbMF0gPT09ICdcXG4nIHx8IHN0cmluZ1swXSA9PT0gJyAnO1xuICB2YXIgbW9yZUluZGVudGVkOyAvLyByZXN0IG9mIHRoZSBsaW5lc1xuXG4gIHZhciBtYXRjaDtcblxuICB3aGlsZSAobWF0Y2ggPSBsaW5lUmUuZXhlYyhzdHJpbmcpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1hdGNoWzFdLFxuICAgICAgICBsaW5lID0gbWF0Y2hbMl07XG4gICAgbW9yZUluZGVudGVkID0gbGluZVswXSA9PT0gJyAnO1xuICAgIHJlc3VsdCArPSBwcmVmaXggKyAoIXByZXZNb3JlSW5kZW50ZWQgJiYgIW1vcmVJbmRlbnRlZCAmJiBsaW5lICE9PSAnJyA/ICdcXG4nIDogJycpICsgZm9sZExpbmUobGluZSwgd2lkdGgpO1xuICAgIHByZXZNb3JlSW5kZW50ZWQgPSBtb3JlSW5kZW50ZWQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSAvLyBHcmVlZHkgbGluZSBicmVha2luZy5cbi8vIFBpY2tzIHRoZSBsb25nZXN0IGxpbmUgdW5kZXIgdGhlIGxpbWl0IGVhY2ggdGltZSxcbi8vIG90aGVyd2lzZSBzZXR0bGVzIGZvciB0aGUgc2hvcnRlc3QgbGluZSBvdmVyIHRoZSBsaW1pdC5cbi8vIE5CLiBNb3JlLWluZGVudGVkIGxpbmVzICpjYW5ub3QqIGJlIGZvbGRlZCwgYXMgdGhhdCB3b3VsZCBhZGQgYW4gZXh0cmEgXFxuLlxuXG5cbmZ1bmN0aW9uIGZvbGRMaW5lKGxpbmUsIHdpZHRoKSB7XG4gIGlmIChsaW5lID09PSAnJyB8fCBsaW5lWzBdID09PSAnICcpIHJldHVybiBsaW5lOyAvLyBTaW5jZSBhIG1vcmUtaW5kZW50ZWQgbGluZSBhZGRzIGEgXFxuLCBicmVha3MgY2FuJ3QgYmUgZm9sbG93ZWQgYnkgYSBzcGFjZS5cblxuICB2YXIgYnJlYWtSZSA9IC8gW14gXS9nOyAvLyBub3RlOiB0aGUgbWF0Y2ggaW5kZXggd2lsbCBhbHdheXMgYmUgPD0gbGVuZ3RoLTIuXG5cbiAgdmFyIG1hdGNoOyAvLyBzdGFydCBpcyBhbiBpbmNsdXNpdmUgaW5kZXguIGVuZCwgY3VyciwgYW5kIG5leHQgYXJlIGV4Y2x1c2l2ZS5cblxuICB2YXIgc3RhcnQgPSAwLFxuICAgICAgZW5kLFxuICAgICAgY3VyciA9IDAsXG4gICAgICBuZXh0ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnOyAvLyBJbnZhcmlhbnRzOiAwIDw9IHN0YXJ0IDw9IGxlbmd0aC0xLlxuICAvLyAgIDAgPD0gY3VyciA8PSBuZXh0IDw9IG1heCgwLCBsZW5ndGgtMikuIGN1cnIgLSBzdGFydCA8PSB3aWR0aC5cbiAgLy8gSW5zaWRlIHRoZSBsb29wOlxuICAvLyAgIEEgbWF0Y2ggaW1wbGllcyBsZW5ndGggPj0gMiwgc28gY3VyciBhbmQgbmV4dCBhcmUgPD0gbGVuZ3RoLTIuXG5cbiAgd2hpbGUgKG1hdGNoID0gYnJlYWtSZS5leGVjKGxpbmUpKSB7XG4gICAgbmV4dCA9IG1hdGNoLmluZGV4OyAvLyBtYWludGFpbiBpbnZhcmlhbnQ6IGN1cnIgLSBzdGFydCA8PSB3aWR0aFxuXG4gICAgaWYgKG5leHQgLSBzdGFydCA+IHdpZHRoKSB7XG4gICAgICBlbmQgPSBjdXJyID4gc3RhcnQgPyBjdXJyIDogbmV4dDsgLy8gZGVyaXZlIGVuZCA8PSBsZW5ndGgtMlxuXG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpOyAvLyBza2lwIHRoZSBzcGFjZSB0aGF0IHdhcyBvdXRwdXQgYXMgXFxuXG5cbiAgICAgIHN0YXJ0ID0gZW5kICsgMTsgLy8gZGVyaXZlIHN0YXJ0IDw9IGxlbmd0aC0xXG4gICAgfVxuXG4gICAgY3VyciA9IG5leHQ7XG4gIH0gLy8gQnkgdGhlIGludmFyaWFudHMsIHN0YXJ0IDw9IGxlbmd0aC0xLCBzbyB0aGVyZSBpcyBzb21ldGhpbmcgbGVmdCBvdmVyLlxuICAvLyBJdCBpcyBlaXRoZXIgdGhlIHdob2xlIHN0cmluZyBvciBhIHBhcnQgc3RhcnRpbmcgZnJvbSBub24td2hpdGVzcGFjZS5cblxuXG4gIHJlc3VsdCArPSAnXFxuJzsgLy8gSW5zZXJ0IGEgYnJlYWsgaWYgdGhlIHJlbWFpbmRlciBpcyB0b28gbG9uZyBhbmQgdGhlcmUgaXMgYSBicmVhayBhdmFpbGFibGUuXG5cbiAgaWYgKGxpbmUubGVuZ3RoIC0gc3RhcnQgPiB3aWR0aCAmJiBjdXJyID4gc3RhcnQpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCwgY3VycikgKyAnXFxuJyArIGxpbmUuc2xpY2UoY3VyciArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2xpY2UoMSk7IC8vIGRyb3AgZXh0cmEgXFxuIGpvaW5lclxufSAvLyBFc2NhcGVzIGEgZG91YmxlLXF1b3RlZCBzdHJpbmcuXG5cblxuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjaGFyLCBuZXh0Q2hhcjtcbiAgdmFyIGVzY2FwZVNlcTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTsgLy8gQ2hlY2sgZm9yIHN1cnJvZ2F0ZSBwYWlycyAocmVmZXJlbmNlIFVuaWNvZGUgMy4wIHNlY3Rpb24gXCIzLjcgU3Vycm9nYXRlc1wiKS5cblxuICAgIGlmIChjaGFyID49IDB4RDgwMCAmJiBjaGFyIDw9IDB4REJGRlxuICAgIC8qIGhpZ2ggc3Vycm9nYXRlICovXG4gICAgKSB7XG4gICAgICAgIG5leHRDaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuXG4gICAgICAgIGlmIChuZXh0Q2hhciA+PSAweERDMDAgJiYgbmV4dENoYXIgPD0gMHhERkZGXG4gICAgICAgIC8qIGxvdyBzdXJyb2dhdGUgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBDb21iaW5lIHRoZSBzdXJyb2dhdGUgcGFpciBhbmQgc3RvcmUgaXQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVIZXgoKGNoYXIgLSAweEQ4MDApICogMHg0MDAgKyBuZXh0Q2hhciAtIDB4REMwMCArIDB4MTAwMDApOyAvLyBBZHZhbmNlIGluZGV4IG9uZSBleHRyYSBzaW5jZSB3ZSBhbHJlYWR5IHVzZWQgdGhhdCBjaGFyIGhlcmUuXG5cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgIGVzY2FwZVNlcSA9IEVTQ0FQRV9TRVFVRU5DRVNbY2hhcl07XG4gICAgcmVzdWx0ICs9ICFlc2NhcGVTZXEgJiYgaXNQcmludGFibGUoY2hhcikgPyBzdHJpbmdbaV0gOiBlc2NhcGVTZXEgfHwgZW5jb2RlSGV4KGNoYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoaW5kZXggIT09IDApIF9yZXN1bHQgKz0gJywnICsgKCFzdGF0ZS5jb25kZW5zZUZsb3cgPyAnICcgOiAnJyk7XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RbaW5kZXhdLCB0cnVlLCB0cnVlKSkge1xuICAgICAgaWYgKCFjb21wYWN0IHx8IGluZGV4ICE9PSAwKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSAnO1xuICAgICAgfVxuXG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuICAgIGlmIChpbmRleCAhPT0gMCkgcGFpckJ1ZmZlciArPSAnLCAnO1xuICAgIGlmIChzdGF0ZS5jb25kZW5zZUZsb3cpIHBhaXJCdWZmZXIgKz0gJ1wiJztcbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RLZXksIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpIHBhaXJCdWZmZXIgKz0gJz8gJztcbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDsgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cblxuICAgIF9yZXN1bHQgKz0gcGFpckJ1ZmZlcjtcbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAneycgKyBfcmVzdWx0ICsgJ30nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIGV4cGxpY2l0UGFpcixcbiAgICAgIHBhaXJCdWZmZXI7IC8vIEFsbG93IHNvcnRpbmcga2V5cyBzbyB0aGF0IHRoZSBvdXRwdXQgZmlsZSBpcyBkZXRlcm1pbmlzdGljXG5cbiAgaWYgKHN0YXRlLnNvcnRLZXlzID09PSB0cnVlKSB7XG4gICAgLy8gRGVmYXVsdCBzb3J0aW5nXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlLnNvcnRLZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gQ3VzdG9tIHNvcnQgZnVuY3Rpb25cbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoc3RhdGUuc29ydEtleXMpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnNvcnRLZXlzKSB7XG4gICAgLy8gU29tZXRoaW5nIGlzIHdyb25nXG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignc29ydEtleXMgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSAnJztcblxuICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdEtleSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5LlxuICAgIH1cblxuICAgIGV4cGxpY2l0UGFpciA9IHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JyB8fCBzdGF0ZS5kdW1wICYmIHN0YXRlLmR1bXAubGVuZ3RoID4gMTAyNDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0VmFsdWUsIHRydWUsIGV4cGxpY2l0UGFpcikpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzogJztcbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7IC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAne30nOyAvLyBFbXB0eSBtYXBwaW5nIGlmIG5vIHZhbGlkIHBhaXJzLlxufVxuXG5mdW5jdGlvbiBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGV4cGxpY2l0KSB7XG4gIHZhciBfcmVzdWx0LCB0eXBlTGlzdCwgaW5kZXgsIGxlbmd0aCwgdHlwZSwgc3R5bGU7XG5cbiAgdHlwZUxpc3QgPSBleHBsaWNpdCA/IHN0YXRlLmV4cGxpY2l0VHlwZXMgOiBzdGF0ZS5pbXBsaWNpdFR5cGVzO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0eXBlTGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHR5cGVMaXN0W2luZGV4XTtcblxuICAgIGlmICgodHlwZS5pbnN0YW5jZU9mIHx8IHR5cGUucHJlZGljYXRlKSAmJiAoIXR5cGUuaW5zdGFuY2VPZiB8fCB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgaW5zdGFuY2VvZiB0eXBlLmluc3RhbmNlT2YpICYmICghdHlwZS5wcmVkaWNhdGUgfHwgdHlwZS5wcmVkaWNhdGUob2JqZWN0KSkpIHtcbiAgICAgIHN0YXRlLnRhZyA9IGV4cGxpY2l0ID8gdHlwZS50YWcgOiAnPyc7XG5cbiAgICAgIGlmICh0eXBlLnJlcHJlc2VudCkge1xuICAgICAgICBzdHlsZSA9IHN0YXRlLnN0eWxlTWFwW3R5cGUudGFnXSB8fCB0eXBlLmRlZmF1bHRTdHlsZTtcblxuICAgICAgICBpZiAoX3RvU3RyaW5nJDIuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5JDMuY2FsbCh0eXBlLnJlcHJlc2VudCwgc3R5bGUpKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50W3N0eWxlXShvYmplY3QsIHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCchPCcgKyB0eXBlLnRhZyArICc+IHRhZyByZXNvbHZlciBhY2NlcHRzIG5vdCBcIicgKyBzdHlsZSArICdcIiBzdHlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZHVtcCA9IF9yZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cbi8vIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBvciBmYWxzZSBvbiBpbnZhbGlkIG9iamVjdC5cbi8vXG5cblxuZnVuY3Rpb24gd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBibG9jaywgY29tcGFjdCwgaXNrZXkpIHtcbiAgc3RhdGUudGFnID0gbnVsbDtcbiAgc3RhdGUuZHVtcCA9IG9iamVjdDtcblxuICBpZiAoIWRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgZmFsc2UpKSB7XG4gICAgZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCB0cnVlKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gX3RvU3RyaW5nJDIuY2FsbChzdGF0ZS5kdW1wKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9IHN0YXRlLmZsb3dMZXZlbCA8IDAgfHwgc3RhdGUuZmxvd0xldmVsID4gbGV2ZWw7XG4gIH1cblxuICB2YXIgb2JqZWN0T3JBcnJheSA9IHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBkdXBsaWNhdGVJbmRleCxcbiAgICAgIGR1cGxpY2F0ZTtcblxuICBpZiAob2JqZWN0T3JBcnJheSkge1xuICAgIGR1cGxpY2F0ZUluZGV4ID0gc3RhdGUuZHVwbGljYXRlcy5pbmRleE9mKG9iamVjdCk7XG4gICAgZHVwbGljYXRlID0gZHVwbGljYXRlSW5kZXggIT09IC0xO1xuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JyB8fCBkdXBsaWNhdGUgfHwgc3RhdGUuaW5kZW50ICE9PSAyICYmIGxldmVsID4gMCkge1xuICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIGlmIChibG9jayAmJiBPYmplY3Qua2V5cyhzdGF0ZS5kdW1wKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcblxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcblxuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArICcgJyArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBhcnJheUxldmVsID0gc3RhdGUubm9BcnJheUluZGVudCAmJiBsZXZlbCA+IDAgPyBsZXZlbCAtIDEgOiBsZXZlbDtcblxuICAgICAgaWYgKGJsb2NrICYmIHN0YXRlLmR1bXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYXJyYXlMZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG5cbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgYXJyYXlMZXZlbCwgc3RhdGUuZHVtcCk7XG5cbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wLCBsZXZlbCwgaXNrZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuc2tpcEludmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ3VuYWNjZXB0YWJsZSBraW5kIG9mIGFuIG9iamVjdCB0byBkdW1wICcgKyB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICBzdGF0ZS5kdW1wID0gJyE8JyArIHN0YXRlLnRhZyArICc+ICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcbiAgaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGR1cGxpY2F0ZXNJbmRleGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBzdGF0ZS5kdXBsaWNhdGVzLnB1c2gob2JqZWN0c1tkdXBsaWNhdGVzSW5kZXhlc1tpbmRleF1dKTtcbiAgfVxuXG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIG9iamVjdEtleUxpc3QsIGluZGV4LCBsZW5ndGg7XG5cbiAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jykge1xuICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlJDEob3B0aW9ucyk7XG4gIGlmICghc3RhdGUubm9SZWZzKSBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKGlucHV0LCBzdGF0ZSk7XG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIGlucHV0LCB0cnVlLCB0cnVlKSkgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBzYWZlRHVtcChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gZHVtcChpbnB1dCwgY29tbW9uLmV4dGVuZCh7XG4gICAgc2NoZW1hOiBkZWZhdWx0X3NhZmVcbiAgfSwgb3B0aW9ucykpO1xufVxuXG52YXIgZHVtcF8xID0gZHVtcDtcbnZhciBzYWZlRHVtcF8xID0gc2FmZUR1bXA7XG52YXIgZHVtcGVyID0ge1xuICBkdW1wOiBkdW1wXzEsXG4gIHNhZmVEdW1wOiBzYWZlRHVtcF8xXG59O1xuXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uICcgKyBuYW1lICsgJyBpcyBkZXByZWNhdGVkIGFuZCBjYW5ub3QgYmUgdXNlZC4nKTtcbiAgfTtcbn1cblxudmFyIFR5cGUkMSA9IHR5cGU7XG52YXIgU2NoZW1hJDEgPSBzY2hlbWE7XG52YXIgRkFJTFNBRkVfU0NIRU1BID0gZmFpbHNhZmU7XG52YXIgSlNPTl9TQ0hFTUEgPSBqc29uO1xudmFyIENPUkVfU0NIRU1BID0gY29yZTtcbnZhciBERUZBVUxUX1NBRkVfU0NIRU1BID0gZGVmYXVsdF9zYWZlO1xudmFyIERFRkFVTFRfRlVMTF9TQ0hFTUEgPSBkZWZhdWx0X2Z1bGw7XG52YXIgbG9hZCQxID0gbG9hZGVyLmxvYWQ7XG52YXIgbG9hZEFsbCQxID0gbG9hZGVyLmxvYWRBbGw7XG52YXIgc2FmZUxvYWQkMSA9IGxvYWRlci5zYWZlTG9hZDtcbnZhciBzYWZlTG9hZEFsbCQxID0gbG9hZGVyLnNhZmVMb2FkQWxsO1xudmFyIGR1bXAkMSA9IGR1bXBlci5kdW1wO1xudmFyIHNhZmVEdW1wJDEgPSBkdW1wZXIuc2FmZUR1bXA7XG52YXIgWUFNTEV4Y2VwdGlvbiQxID0gZXhjZXB0aW9uOyAvLyBEZXByZWNhdGVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcblxudmFyIE1JTklNQUxfU0NIRU1BID0gZmFpbHNhZmU7XG52YXIgU0FGRV9TQ0hFTUEgPSBkZWZhdWx0X3NhZmU7XG52YXIgREVGQVVMVF9TQ0hFTUEgPSBkZWZhdWx0X2Z1bGw7IC8vIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGZyb20gSlMtWUFNTCAxLngueFxuXG52YXIgc2NhbiA9IGRlcHJlY2F0ZWQoJ3NjYW4nKTtcbnZhciBwYXJzZSA9IGRlcHJlY2F0ZWQoJ3BhcnNlJyk7XG52YXIgY29tcG9zZSA9IGRlcHJlY2F0ZWQoJ2NvbXBvc2UnKTtcbnZhciBhZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG52YXIganNZYW1sID0ge1xuICBUeXBlOiBUeXBlJDEsXG4gIFNjaGVtYTogU2NoZW1hJDEsXG4gIEZBSUxTQUZFX1NDSEVNQTogRkFJTFNBRkVfU0NIRU1BLFxuICBKU09OX1NDSEVNQTogSlNPTl9TQ0hFTUEsXG4gIENPUkVfU0NIRU1BOiBDT1JFX1NDSEVNQSxcbiAgREVGQVVMVF9TQUZFX1NDSEVNQTogREVGQVVMVF9TQUZFX1NDSEVNQSxcbiAgREVGQVVMVF9GVUxMX1NDSEVNQTogREVGQVVMVF9GVUxMX1NDSEVNQSxcbiAgbG9hZDogbG9hZCQxLFxuICBsb2FkQWxsOiBsb2FkQWxsJDEsXG4gIHNhZmVMb2FkOiBzYWZlTG9hZCQxLFxuICBzYWZlTG9hZEFsbDogc2FmZUxvYWRBbGwkMSxcbiAgZHVtcDogZHVtcCQxLFxuICBzYWZlRHVtcDogc2FmZUR1bXAkMSxcbiAgWUFNTEV4Y2VwdGlvbjogWUFNTEV4Y2VwdGlvbiQxLFxuICBNSU5JTUFMX1NDSEVNQTogTUlOSU1BTF9TQ0hFTUEsXG4gIFNBRkVfU0NIRU1BOiBTQUZFX1NDSEVNQSxcbiAgREVGQVVMVF9TQ0hFTUE6IERFRkFVTFRfU0NIRU1BLFxuICBzY2FuOiBzY2FuLFxuICBwYXJzZTogcGFyc2UsXG4gIGNvbXBvc2U6IGNvbXBvc2UsXG4gIGFkZENvbnN0cnVjdG9yOiBhZGRDb25zdHJ1Y3RvclxufTtcblxudmFyIGpzWWFtbCQxID0ganNZYW1sO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXG4gKiBSZWRpcmVjdCAtIG9iamVjdCB1c2VkIHRvIHJlZGlyZWN0IHNvbWUgcmVxdWVzdHNcbiAqIGUuZy5cbiAqIHtcbiAqICAgICAgdGl0bGU6IDF4MS10cmFuc3BhcmVudC5naWZcbiAqICAgICAgY29tbWVudDogaHR0cDovL3Byb2JhYmx5cHJvZ3JhbW1pbmcuY29tLzIwMDkvMDMvMTUvdGhlLXRpbmllc3QtZ2lmLWV2ZXJcbiAqICAgICAgY29udGVudFR5cGU6IGltYWdlL2dpZjtiYXNlNjRcbiAqICAgICAgY29udGVudDogUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVxuICogfVxuICogQHR5cGVkZWYge09iamVjdH0gUmVkaXJlY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aXRsZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbW1lbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGVudFR5cGVcbiAqL1xuXG52YXIgUmVkaXJlY3RzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHJhd1lhbWwgaW50byBKUyBvYmplY3Qgd2l0aCBzb3VyY2VzIHRpdGxlcyB1c2VkIGFzIGtleXNcbiAgICogQHBhcmFtIHJhd1lhbWxcbiAgICogQHJldHVybnMge09iamVjdDxSZWRpcmVjdD59IC0gcmV0dXJuIG9iamVjdCB3aXRoIHRpdGxlcyBpbiB0aGUga2V5cyBhbmQgUmVkaXJlY3RTb3VyY2VzXG4gICAqIGluIHRoZSB2YWx1ZXNcbiAgICovXG4gIGZ1bmN0aW9uIFJlZGlyZWN0cyhyYXdZYW1sKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVkaXJlY3RzKTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgYXJyT2ZSZWRpcmVjdHMgPSBqc1lhbWwkMS5zYWZlTG9hZChyYXdZYW1sKTtcbiAgICAgIHRoaXMucmVkaXJlY3RzID0gYXJyT2ZSZWRpcmVjdHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlZGlyZWN0KSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGFjYyksIHt9LCBkZWZpbmVQcm9wZXJ0eSh7fSwgcmVkaXJlY3QudGl0bGUsIHJlZGlyZWN0KSk7XG4gICAgICB9LCB7fSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FzIHVuYWJsZSB0byBsb2FkIFlBTUwgaW50byBKUyBkdWUgdG86IFwiLmNvbmNhdChlLm1lc3NhZ2UpKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlZGlyZWN0IHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXG4gICAqIEByZXR1cm4ge1JlZGlyZWN0fVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFJlZGlyZWN0cywgW3tcbiAgICBrZXk6IFwiZ2V0UmVkaXJlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVkaXJlY3QodGl0bGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5yZWRpcmVjdHMsIHRpdGxlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdHNbdGl0bGVdO1xuICAgICAgfSAvLyBsb29rIHRpdGxlIGFtb25nIGFsaWFzZXNcblxuXG4gICAgICB2YXIgdmFsdWVzID0gT2JqZWN0LmtleXModGhpcy5yZWRpcmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZWRpcmVjdHNba2V5XTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHZhbHVlcy5maW5kKGZ1bmN0aW9uIChyZWRpcmVjdCkge1xuICAgICAgICB2YXIgYWxpYXNlcyA9IHJlZGlyZWN0LmFsaWFzZXM7XG5cbiAgICAgICAgaWYgKCFhbGlhc2VzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsaWFzZXMuaW5kZXhPZih0aXRsZSkgPiAtMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWRpcmVjdHM7XG59KCk7XG5cbi8qKlxuICogRmluZHMgcmVkaXJlY3QgcmVzb3VyY2UgYnkgaXQncyBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHJlZGlyZWN0IG5hbWVcbiAqL1xuXG52YXIgZ2V0UmVkaXJlY3RCeU5hbWUgPSBmdW5jdGlvbiBnZXRSZWRpcmVjdEJ5TmFtZShuYW1lKSB7XG4gIHZhciByZWRpcmVjdHMgPSBPYmplY3Qua2V5cyhyZWRpcmVjdHNMaXN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiByZWRpcmVjdHNMaXN0W2tleV07XG4gIH0pO1xuICByZXR1cm4gcmVkaXJlY3RzLmZpbmQoZnVuY3Rpb24gKHIpIHtcbiAgICByZXR1cm4gci5uYW1lcyAmJiByLm5hbWVzLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgfSk7XG59O1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTb3VyY2UgLSByZWRpcmVjdCBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSByZWRpcmVjdCBuYW1lXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IGFyZ3MgQXJndW1lbnRzIGZvciByZWRpcmVjdCBmdW5jdGlvblxuICogQHByb3BlcnR5IHsnZXh0ZW5zaW9uJ3wndGVzdCd9IFtlbmdpbmVdIC1cbiAqIERlZmluZXMgdGhlIGZpbmFsIGZvcm0gb2YgcmVkaXJlY3Qgc3RyaW5nIHByZXNlbnRhdGlvblxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmVyYm9zZV0gZmxhZyB0byBlbmFibGUgcHJpbnRpbmcgdG8gY29uc29sZSBkZWJ1ZyBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogUmV0dXJucyByZWRpcmVjdCBjb2RlIGJ5IHBhcmFtXG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSByZWRpcmVjdCBjb2RlXG4gKi9cblxuXG52YXIgZ2V0UmVkaXJlY3RDb2RlID0gZnVuY3Rpb24gZ2V0UmVkaXJlY3RDb2RlKHNvdXJjZSkge1xuICB2YXIgcmVkaXJlY3QgPSBnZXRSZWRpcmVjdEJ5TmFtZShzb3VyY2UubmFtZSk7XG4gIHZhciByZXN1bHQgPSBhdHRhY2hEZXBlbmRlbmNpZXMocmVkaXJlY3QpO1xuICByZXN1bHQgPSBhZGRDYWxsKHJlZGlyZWN0LCByZXN1bHQpOyAvLyByZWRpcmVjdCBjb2RlIGZvciBkaWZmZXJlbnQgc291cmNlcyBpcyBjaGVja2VkIGluIHRlc3RzXG4gIC8vIHNvIGl0IHNob3VsZCBiZSBqdXN0IGEgY29kZSB3aXRob3V0IGFueSBzb3VyY2UgYW5kIHByb3BzIHBhc3NlZFxuXG4gIHJlc3VsdCA9IHNvdXJjZS5lbmdpbmUgPT09ICd0ZXN0JyA/IHdyYXBJbk5vbmFtZUZ1bmMocmVzdWx0KSA6IHBhc3NTb3VyY2VBbmRQcm9wcyhzb3VyY2UsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcmVkaXJlY3RzQ2pzID0ge1xuICBSZWRpcmVjdHM6IFJlZGlyZWN0cyxcbiAgZ2V0Q29kZTogZ2V0UmVkaXJlY3RDb2RlLFxuICBpc0FkZ1JlZGlyZWN0UnVsZTogdmFsaWRhdG9yLmlzQWRnUmVkaXJlY3RSdWxlLFxuICBpc1ZhbGlkQWRnUmVkaXJlY3RSdWxlOiB2YWxpZGF0b3IuaXNWYWxpZEFkZ1JlZGlyZWN0UnVsZSxcbiAgaXNBZGdSZWRpcmVjdENvbXBhdGlibGVXaXRoVWJvOiB2YWxpZGF0b3IuaXNBZGdSZWRpcmVjdENvbXBhdGlibGVXaXRoVWJvLFxuICBpc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGc6IHZhbGlkYXRvci5pc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcsXG4gIGlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZzogdmFsaWRhdG9yLmlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZyxcbiAgY29udmVydFVib1JlZGlyZWN0VG9BZGc6IGNvbnZlcnRVYm9SZWRpcmVjdFRvQWRnLFxuICBjb252ZXJ0QWJwUmVkaXJlY3RUb0FkZzogY29udmVydEFicFJlZGlyZWN0VG9BZGcsXG4gIGNvbnZlcnRSZWRpcmVjdFRvQWRnOiBjb252ZXJ0UmVkaXJlY3RUb0FkZyxcbiAgY29udmVydEFkZ1JlZGlyZWN0VG9VYm86IGNvbnZlcnRBZGdSZWRpcmVjdFRvVWJvXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNvdXJjZSAtIHNjcmlwdGxldCBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBTY3JpcHRsZXQgbmFtZVxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBhcmdzIEFyZ3VtZW50cyBmb3Igc2NyaXB0bGV0IGZ1bmN0aW9uXG4gKiBAcHJvcGVydHkgeydleHRlbnNpb24nfCdjb3JlbGlicyd8J3Rlc3QnfSBlbmdpbmUgLVxuICogRGVmaW5lcyB0aGUgZmluYWwgZm9ybSBvZiBzY3JpcHRsZXQgc3RyaW5nIHByZXNlbnRhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt2ZXJzaW9uXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmVyYm9zZV0gZmxhZyB0byBlbmFibGUgcHJpbnRpbmcgdG8gY29uc29sZSBkZWJ1ZyBpbmZvcm1hdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtydWxlVGV4dF0gU291cmNlIHJ1bGUgdGV4dCBpcyB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZG9tYWluTmFtZV0gZG9tYWluIG5hbWUgd2hlcmUgc2NyaXB0bGV0IGlzIGFwcGxpZWQ7IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgc2NyaXB0bGV0IGNvZGUgYnkgcGFyYW1cbiAqIEBwYXJhbSB7U291cmNlfSBzb3VyY2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHNjcmlwdGxldCBjb2RlXG4gKi9cblxuZnVuY3Rpb24gZ2V0U2NyaXB0bGV0Q29kZShzb3VyY2UpIHtcbiAgaWYgKCF2YWxpZGF0b3IuaXNWYWxpZFNjcmlwdGxldE5hbWUoc291cmNlLm5hbWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2NyaXB0bGV0ID0gdmFsaWRhdG9yLmdldFNjcmlwdGxldEJ5TmFtZShzb3VyY2UubmFtZSk7XG4gIHZhciByZXN1bHQgPSBhdHRhY2hEZXBlbmRlbmNpZXMoc2NyaXB0bGV0KTtcbiAgcmVzdWx0ID0gYWRkQ2FsbChzY3JpcHRsZXQsIHJlc3VsdCk7XG4gIHJlc3VsdCA9IHNvdXJjZS5lbmdpbmUgPT09ICdjb3JlbGlicycgfHwgc291cmNlLmVuZ2luZSA9PT0gJ3Rlc3QnID8gd3JhcEluTm9uYW1lRnVuYyhyZXN1bHQpIDogcGFzc1NvdXJjZUFuZFByb3BzKHNvdXJjZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogU2NyaXB0bGV0cyB2YXJpYWJsZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIG1ldGhvZHM6XG4gKiBgaW52b2tlYCBtZXRob2QgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IHdpdGggYFNvdXJjZWAgdHlwZVxuICogYHZhbGlkYXRlYCBtZXRob2QgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IHdpdGggYFN0cmluZ2AgdHlwZVxuICovXG5cblxudmFyIHNjcmlwdGxldHNPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgaW52b2tlOiBnZXRTY3JpcHRsZXRDb2RlLFxuICAgIGlzVmFsaWRTY3JpcHRsZXROYW1lOiB2YWxpZGF0b3IuaXNWYWxpZFNjcmlwdGxldE5hbWUsXG4gICAgaXNWYWxpZFNjcmlwdGxldFJ1bGU6IGlzVmFsaWRTY3JpcHRsZXRSdWxlLFxuICAgIGlzQWRnU2NyaXB0bGV0UnVsZTogdmFsaWRhdG9yLmlzQWRnU2NyaXB0bGV0UnVsZSxcbiAgICBpc1Vib1NjcmlwdGxldFJ1bGU6IHZhbGlkYXRvci5pc1Vib1NjcmlwdGxldFJ1bGUsXG4gICAgaXNBYnBTbmlwcGV0UnVsZTogdmFsaWRhdG9yLmlzQWJwU25pcHBldFJ1bGUsXG4gICAgY29udmVydFVib1RvQWRnOiBjb252ZXJ0VWJvU2NyaXB0bGV0VG9BZGcsXG4gICAgY29udmVydEFicFRvQWRnOiBjb252ZXJ0QWJwU25pcHBldFRvQWRnLFxuICAgIGNvbnZlcnRTY3JpcHRsZXRUb0FkZzogY29udmVydFNjcmlwdGxldFRvQWRnLFxuICAgIGNvbnZlcnRBZGdUb1VibzogY29udmVydEFkZ1NjcmlwdGxldFRvVWJvLFxuICAgIHJlZGlyZWN0czogcmVkaXJlY3RzQ2pzXG4gIH07XG59KCk7XG5cbi8qKlxuICogQWRkIG1vZHVsZSBleHBvcnRzIHRvIGJlIHVzZWQgYXMgbm9kZSBwYWNrYWdlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBzY3JpcHRsZXRzT2JqZWN0O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgIElmIHlvdSB3YW50IHRvIGFkZCB5b3VyIG93biBzY3JpcHRsZXQgIHxcbiAqIHwgIHBsZWFzZSBwdXQgeW91ciBjb2RlIGJlbG93ICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js\n");

/***/ }),

/***/ "./node_modules/webextension-polyfill-ts/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/webextension-polyfill-ts/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nexports.browser = __webpack_require__(/*! webextension-polyfill */ \"./node_modules/webextension-polyfill/dist/browser-polyfill.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vbm9kZV9tb2R1bGVzL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC10cy9saWIvaW5kZXguanM/NzI4YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxDQUFDLGNBQWMsRUFBQzs7QUFFN0QsbUlBQWtEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC10cy9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZXhwb3J0cy5icm93c2VyID0gcmVxdWlyZShcIndlYmV4dGVuc2lvbi1wb2x5ZmlsbFwiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webextension-polyfill-ts/lib/index.js\n");

/***/ }),

/***/ "./node_modules/webextension-polyfill/dist/browser-polyfill.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webextension-polyfill/dist/browser-polyfill.js ***!
  \*********************************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (module) {\n  /* webextension-polyfill - v0.7.0 - Tue Nov 10 2020 20:24:04 */\n\n  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n\n  /* vim: set sts=2 sw=2 et tw=80: */\n\n  /* This Source Code Form is subject to the terms of the Mozilla Public\n   * License, v. 2.0. If a copy of the MPL was not distributed with this\n   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n  \"use strict\";\n\n  if (typeof browser === \"undefined\" || Object.getPrototypeOf(browser) !== Object.prototype) {\n    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n    const SEND_RESPONSE_DEPRECATION_WARNING = \"Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)\"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n    // optimization for Firefox. Since Spidermonkey does not fully parse the\n    // contents of a function until the first time it's called, and since it will\n    // never actually need to be called, this allows the polyfill to be included\n    // in Firefox nearly for free.\n\n    const wrapAPIs = extensionAPIs => {\n      // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n      // at build time by replacing the following \"include\" with the content of the\n      // JSON file.\n      const apiMetadata = {\n        \"alarms\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"clearAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"bookmarks\": {\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getChildren\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getRecent\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getSubTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTree\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"browserAction\": {\n          \"disable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"enable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"getBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"openPopup\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"browsingData\": {\n          \"remove\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"removeCache\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCookies\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeDownloads\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFormData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeHistory\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeLocalStorage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePasswords\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePluginData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"settings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"commands\": {\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"contextMenus\": {\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"cookies\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAllCookieStores\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"devtools\": {\n          \"inspectedWindow\": {\n            \"eval\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 2,\n              \"singleCallbackArg\": false\n            }\n          },\n          \"panels\": {\n            \"create\": {\n              \"minArgs\": 3,\n              \"maxArgs\": 3,\n              \"singleCallbackArg\": true\n            },\n            \"elements\": {\n              \"createSidebarPane\": {\n                \"minArgs\": 1,\n                \"maxArgs\": 1\n              }\n            }\n          }\n        },\n        \"downloads\": {\n          \"cancel\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"download\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"erase\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFileIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"open\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"pause\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFile\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"resume\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"extension\": {\n          \"isAllowedFileSchemeAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"isAllowedIncognitoAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"history\": {\n          \"addUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"deleteRange\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getVisits\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"i18n\": {\n          \"detectLanguage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAcceptLanguages\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"identity\": {\n          \"launchWebAuthFlow\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"idle\": {\n          \"queryState\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"management\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setEnabled\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"uninstallSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"notifications\": {\n          \"clear\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPermissionLevel\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"pageAction\": {\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"hide\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"permissions\": {\n          \"contains\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"request\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"runtime\": {\n          \"getBackgroundPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPlatformInfo\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"openOptionsPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"requestUpdateCheck\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"sendMessage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 3\n          },\n          \"sendNativeMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"setUninstallURL\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"sessions\": {\n          \"getDevices\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getRecentlyClosed\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"restore\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"storage\": {\n          \"local\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          },\n          \"managed\": {\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            }\n          },\n          \"sync\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        },\n        \"tabs\": {\n          \"captureVisibleTab\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"detectLanguage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"discard\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"duplicate\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"executeScript\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getZoom\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getZoomSettings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goBack\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goForward\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"highlight\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"insertCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"query\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"reload\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"sendMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 3\n          },\n          \"setZoom\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"setZoomSettings\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"update\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          }\n        },\n        \"topSites\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"webNavigation\": {\n          \"getAllFrames\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFrame\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"webRequest\": {\n          \"handlerBehaviorChanged\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"windows\": {\n          \"create\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getLastFocused\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        }\n      };\n\n      if (Object.keys(apiMetadata).length === 0) {\n        throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n      }\n      /**\n       * A WeakMap subclass which creates and stores a value for any key which does\n       * not exist when accessed, but behaves exactly as an ordinary WeakMap\n       * otherwise.\n       *\n       * @param {function} createItem\n       *        A function which will be called in order to create the value for any\n       *        key which does not exist, the first time it is accessed. The\n       *        function receives, as its only argument, the key being created.\n       */\n\n\n      class DefaultWeakMap extends WeakMap {\n        constructor(createItem, items = undefined) {\n          super(items);\n          this.createItem = createItem;\n        }\n\n        get(key) {\n          if (!this.has(key)) {\n            this.set(key, this.createItem(key));\n          }\n\n          return super.get(key);\n        }\n\n      }\n      /**\n       * Returns true if the given object is an object with a `then` method, and can\n       * therefore be assumed to behave as a Promise.\n       *\n       * @param {*} value The value to test.\n       * @returns {boolean} True if the value is thenable.\n       */\n\n\n      const isThenable = value => {\n        return value && typeof value === \"object\" && typeof value.then === \"function\";\n      };\n      /**\n       * Creates and returns a function which, when called, will resolve or reject\n       * the given promise based on how it is called:\n       *\n       * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n       *   the promise is rejected with that value.\n       * - If the function is called with exactly one argument, the promise is\n       *   resolved to that value.\n       * - Otherwise, the promise is resolved to an array containing all of the\n       *   function's arguments.\n       *\n       * @param {object} promise\n       *        An object containing the resolution and rejection functions of a\n       *        promise.\n       * @param {function} promise.resolve\n       *        The promise's resolution function.\n       * @param {function} promise.rejection\n       *        The promise's rejection function.\n       * @param {object} metadata\n       *        Metadata about the wrapped method which has created the callback.\n       * @param {integer} metadata.maxResolvedArgs\n       *        The maximum number of arguments which may be passed to the\n       *        callback created by the wrapped async function.\n       *\n       * @returns {function}\n       *        The generated callback function.\n       */\n\n\n      const makeCallback = (promise, metadata) => {\n        return (...callbackArgs) => {\n          if (extensionAPIs.runtime.lastError) {\n            promise.reject(extensionAPIs.runtime.lastError);\n          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {\n            promise.resolve(callbackArgs[0]);\n          } else {\n            promise.resolve(callbackArgs);\n          }\n        };\n      };\n\n      const pluralizeArguments = numArgs => numArgs == 1 ? \"argument\" : \"arguments\";\n      /**\n       * Creates a wrapper function for a method with the given name and metadata.\n       *\n       * @param {string} name\n       *        The name of the method which is being wrapped.\n       * @param {object} metadata\n       *        Metadata about the method being wrapped.\n       * @param {integer} metadata.minArgs\n       *        The minimum number of arguments which must be passed to the\n       *        function. If called with fewer than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxArgs\n       *        The maximum number of arguments which may be passed to the\n       *        function. If called with more than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxResolvedArgs\n       *        The maximum number of arguments which may be passed to the\n       *        callback created by the wrapped async function.\n       *\n       * @returns {function(object, ...*)}\n       *       The generated wrapper function.\n       */\n\n\n      const wrapAsyncFunction = (name, metadata) => {\n        return function asyncFunctionWrapper(target, ...args) {\n          if (args.length < metadata.minArgs) {\n            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          if (args.length > metadata.maxArgs) {\n            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          return new Promise((resolve, reject) => {\n            if (metadata.fallbackToNoCallback) {\n              // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n              // and so the polyfill will try to call it with a callback first, and it will fallback\n              // to not passing the callback if the first call fails.\n              try {\n                target[name](...args, makeCallback({\n                  resolve,\n                  reject\n                }, metadata));\n              } catch (cbError) {\n                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + \"falling back to call it without a callback: \", cbError);\n                target[name](...args); // Update the API method metadata, so that the next API calls will not try to\n                // use the unsupported callback anymore.\n\n                metadata.fallbackToNoCallback = false;\n                metadata.noCallback = true;\n                resolve();\n              }\n            } else if (metadata.noCallback) {\n              target[name](...args);\n              resolve();\n            } else {\n              target[name](...args, makeCallback({\n                resolve,\n                reject\n              }, metadata));\n            }\n          });\n        };\n      };\n      /**\n       * Wraps an existing method of the target object, so that calls to it are\n       * intercepted by the given wrapper function. The wrapper function receives,\n       * as its first argument, the original `target` object, followed by each of\n       * the arguments passed to the original method.\n       *\n       * @param {object} target\n       *        The original target object that the wrapped method belongs to.\n       * @param {function} method\n       *        The method being wrapped. This is used as the target of the Proxy\n       *        object which is created to wrap the method.\n       * @param {function} wrapper\n       *        The wrapper function which is called in place of a direct invocation\n       *        of the wrapped method.\n       *\n       * @returns {Proxy<function>}\n       *        A Proxy object for the given method, which invokes the given wrapper\n       *        method in its place.\n       */\n\n\n      const wrapMethod = (target, method, wrapper) => {\n        return new Proxy(method, {\n          apply(targetMethod, thisObj, args) {\n            return wrapper.call(thisObj, target, ...args);\n          }\n\n        });\n      };\n\n      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n      /**\n       * Wraps an object in a Proxy which intercepts and wraps certain methods\n       * based on the given `wrappers` and `metadata` objects.\n       *\n       * @param {object} target\n       *        The target object to wrap.\n       *\n       * @param {object} [wrappers = {}]\n       *        An object tree containing wrapper functions for special cases. Any\n       *        function present in this object tree is called in place of the\n       *        method in the same location in the `target` object tree. These\n       *        wrapper methods are invoked as described in {@see wrapMethod}.\n       *\n       * @param {object} [metadata = {}]\n       *        An object tree containing metadata used to automatically generate\n       *        Promise-based wrapper functions for asynchronous. Any function in\n       *        the `target` object tree which has a corresponding metadata object\n       *        in the same location in the `metadata` tree is replaced with an\n       *        automatically-generated wrapper function, as described in\n       *        {@see wrapAsyncFunction}\n       *\n       * @returns {Proxy<object>}\n       */\n\n      const wrapObject = (target, wrappers = {}, metadata = {}) => {\n        let cache = Object.create(null);\n        let handlers = {\n          has(proxyTarget, prop) {\n            return prop in target || prop in cache;\n          },\n\n          get(proxyTarget, prop, receiver) {\n            if (prop in cache) {\n              return cache[prop];\n            }\n\n            if (!(prop in target)) {\n              return undefined;\n            }\n\n            let value = target[prop];\n\n            if (typeof value === \"function\") {\n              // This is a method on the underlying object. Check if we need to do\n              // any wrapping.\n              if (typeof wrappers[prop] === \"function\") {\n                // We have a special-case wrapper for this method.\n                value = wrapMethod(target, target[prop], wrappers[prop]);\n              } else if (hasOwnProperty(metadata, prop)) {\n                // This is an async method that we have metadata for. Create a\n                // Promise wrapper for it.\n                let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n                value = wrapMethod(target, target[prop], wrapper);\n              } else {\n                // This is a method that we don't know or care about. Return the\n                // original method, bound to the underlying object.\n                value = value.bind(target);\n              }\n            } else if (typeof value === \"object\" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {\n              // This is an object that we need to do some wrapping for the children\n              // of. Create a sub-object wrapper for it with the appropriate child\n              // metadata.\n              value = wrapObject(value, wrappers[prop], metadata[prop]);\n            } else if (hasOwnProperty(metadata, \"*\")) {\n              // Wrap all properties in * namespace.\n              value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n            } else {\n              // We don't need to do any wrapping for this property,\n              // so just forward all access to the underlying object.\n              Object.defineProperty(cache, prop, {\n                configurable: true,\n                enumerable: true,\n\n                get() {\n                  return target[prop];\n                },\n\n                set(value) {\n                  target[prop] = value;\n                }\n\n              });\n              return value;\n            }\n\n            cache[prop] = value;\n            return value;\n          },\n\n          set(proxyTarget, prop, value, receiver) {\n            if (prop in cache) {\n              cache[prop] = value;\n            } else {\n              target[prop] = value;\n            }\n\n            return true;\n          },\n\n          defineProperty(proxyTarget, prop, desc) {\n            return Reflect.defineProperty(cache, prop, desc);\n          },\n\n          deleteProperty(proxyTarget, prop) {\n            return Reflect.deleteProperty(cache, prop);\n          }\n\n        }; // Per contract of the Proxy API, the \"get\" proxy handler must return the\n        // original value of the target if that value is declared read-only and\n        // non-configurable. For this reason, we create an object with the\n        // prototype set to `target` instead of using `target` directly.\n        // Otherwise we cannot return a custom object for APIs that\n        // are declared read-only and non-configurable, such as `chrome.devtools`.\n        //\n        // The proxy handlers themselves will still use the original `target`\n        // instead of the `proxyTarget`, so that the methods and properties are\n        // dereferenced via the original targets.\n\n        let proxyTarget = Object.create(target);\n        return new Proxy(proxyTarget, handlers);\n      };\n      /**\n       * Creates a set of wrapper functions for an event object, which handles\n       * wrapping of listener functions that those messages are passed.\n       *\n       * A single wrapper is created for each listener function, and stored in a\n       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n       * retrieve the original wrapper, so that  attempts to remove a\n       * previously-added listener work as expected.\n       *\n       * @param {DefaultWeakMap<function, function>} wrapperMap\n       *        A DefaultWeakMap object which will create the appropriate wrapper\n       *        for a given listener function when one does not exist, and retrieve\n       *        an existing one when it does.\n       *\n       * @returns {object}\n       */\n\n\n      const wrapEvent = wrapperMap => ({\n        addListener(target, listener, ...args) {\n          target.addListener(wrapperMap.get(listener), ...args);\n        },\n\n        hasListener(target, listener) {\n          return target.hasListener(wrapperMap.get(listener));\n        },\n\n        removeListener(target, listener) {\n          target.removeListener(wrapperMap.get(listener));\n        }\n\n      }); // Keep track if the deprecation warning has been logged at least once.\n\n\n      let loggedSendResponseDeprecationWarning = false;\n      const onMessageWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n        /**\n         * Wraps a message listener function so that it may send responses based on\n         * its return value, rather than by returning a sentinel value and calling a\n         * callback. If the listener function returns a Promise, the response is\n         * sent when the promise either resolves or rejects.\n         *\n         * @param {*} message\n         *        The message sent by the other end of the channel.\n         * @param {object} sender\n         *        Details about the sender of the message.\n         * @param {function(*)} sendResponse\n         *        A callback which, when called with an arbitrary argument, sends\n         *        that value as a response.\n         * @returns {boolean}\n         *        True if the wrapped listener returned a Promise, which will later\n         *        yield a response. False otherwise.\n         */\n\n\n        return function onMessage(message, sender, sendResponse) {\n          let didCallSendResponse = false;\n          let wrappedSendResponse;\n          let sendResponsePromise = new Promise(resolve => {\n            wrappedSendResponse = function (response) {\n              if (!loggedSendResponseDeprecationWarning) {\n                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);\n                loggedSendResponseDeprecationWarning = true;\n              }\n\n              didCallSendResponse = true;\n              resolve(response);\n            };\n          });\n          let result;\n\n          try {\n            result = listener(message, sender, wrappedSendResponse);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n\n          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called\n          // wrappedSendResponse synchronously, we can exit earlier\n          // because there will be no response sent from this listener.\n\n          if (result !== true && !isResultThenable && !didCallSendResponse) {\n            return false;\n          } // A small helper to send the message if the promise resolves\n          // and an error if the promise rejects (a wrapped sendMessage has\n          // to translate the message into a resolved promise or a rejected\n          // promise).\n\n\n          const sendPromisedResult = promise => {\n            promise.then(msg => {\n              // send the message value.\n              sendResponse(msg);\n            }, error => {\n              // Send a JSON representation of the error if the rejected value\n              // is an instance of error, or the object itself otherwise.\n              let message;\n\n              if (error && (error instanceof Error || typeof error.message === \"string\")) {\n                message = error.message;\n              } else {\n                message = \"An unexpected error occurred\";\n              }\n\n              sendResponse({\n                __mozWebExtensionPolyfillReject__: true,\n                message\n              });\n            }).catch(err => {\n              // Print an error on the console if unable to send the response.\n              console.error(\"Failed to send onMessage rejected reply\", err);\n            });\n          }; // If the listener returned a Promise, send the resolved value as a\n          // result, otherwise wait the promise related to the wrappedSendResponse\n          // callback to resolve and send it as a response.\n\n\n          if (isResultThenable) {\n            sendPromisedResult(result);\n          } else {\n            sendPromisedResult(sendResponsePromise);\n          } // Let Chrome know that the listener is replying.\n\n\n          return true;\n        };\n      });\n\n      const wrappedSendMessageCallback = ({\n        reject,\n        resolve\n      }, reply) => {\n        if (extensionAPIs.runtime.lastError) {\n          // Detect when none of the listeners replied to the sendMessage call and resolve\n          // the promise to undefined as in Firefox.\n          // See https://github.com/mozilla/webextension-polyfill/issues/130\n          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n            resolve();\n          } else {\n            reject(extensionAPIs.runtime.lastError);\n          }\n        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n          // Convert back the JSON representation of the error into\n          // an Error instance.\n          reject(new Error(reply.message));\n        } else {\n          resolve(reply);\n        }\n      };\n\n      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        return new Promise((resolve, reject) => {\n          const wrappedCb = wrappedSendMessageCallback.bind(null, {\n            resolve,\n            reject\n          });\n          args.push(wrappedCb);\n          apiNamespaceObj.sendMessage(...args);\n        });\n      };\n\n      const staticWrappers = {\n        runtime: {\n          onMessage: wrapEvent(onMessageWrappers),\n          onMessageExternal: wrapEvent(onMessageWrappers),\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 1,\n            maxArgs: 3\n          })\n        },\n        tabs: {\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 2,\n            maxArgs: 3\n          })\n        }\n      };\n      const settingMetadata = {\n        clear: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        get: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        set: {\n          minArgs: 1,\n          maxArgs: 1\n        }\n      };\n      apiMetadata.privacy = {\n        network: {\n          \"*\": settingMetadata\n        },\n        services: {\n          \"*\": settingMetadata\n        },\n        websites: {\n          \"*\": settingMetadata\n        }\n      };\n      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n    };\n\n    if (typeof chrome != \"object\" || !chrome || !chrome.runtime || !chrome.runtime.id) {\n      throw new Error(\"This script should only be loaded in a browser extension.\");\n    } // The build process adds a UMD wrapper around this file, which makes the\n    // `module` variable available.\n\n\n    module.exports = wrapAPIs(chrome);\n  } else {\n    module.exports = browser;\n  }\n});\n//# sourceMappingURL=browser-polyfill.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW1wbGUtYWRibG9ja2VyLy4vbm9kZV9tb2R1bGVzL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanM/OTg0NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxpQ0FBZ0MsQ0FBQyxNQUFRLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUN4RCxHQUFHLE1BQU0sWUFRTjtBQUNILENBQUM7QUFDRDs7QUFFQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1U0FBdVM7QUFDdlM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCLEdBQUcscUNBQXFDLE9BQU8sS0FBSyxVQUFVLFlBQVk7QUFDMUk7O0FBRUE7QUFDQSw4Q0FBOEMsaUJBQWlCLEdBQUcscUNBQXFDLE9BQU8sS0FBSyxVQUFVLFlBQVk7QUFDekk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsL2Rpc3QvYnJvd3Nlci1wb2x5ZmlsbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShcIndlYmV4dGVuc2lvbi1wb2x5ZmlsbFwiLCBbXCJtb2R1bGVcIl0sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZmFjdG9yeShtb2R1bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtb2QgPSB7XG4gICAgICBleHBvcnRzOiB7fVxuICAgIH07XG4gICAgZmFjdG9yeShtb2QpO1xuICAgIGdsb2JhbC5icm93c2VyID0gbW9kLmV4cG9ydHM7XG4gIH1cbn0pKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgLyogd2ViZXh0ZW5zaW9uLXBvbHlmaWxsIC0gdjAuNy4wIC0gVHVlIE5vdiAxMCAyMDIwIDIwOjI0OjA0ICovXG5cbiAgLyogLSotIE1vZGU6IGluZGVudC10YWJzLW1vZGU6IG5pbDsganMtaW5kZW50LWxldmVsOiAyIC0qLSAqL1xuXG4gIC8qIHZpbTogc2V0IHN0cz0yIHN3PTIgZXQgdHc9ODA6ICovXG5cbiAgLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICAgKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gICAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmICh0eXBlb2YgYnJvd3NlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYnJvd3NlcikgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UgPSBcIlRoZSBtZXNzYWdlIHBvcnQgY2xvc2VkIGJlZm9yZSBhIHJlc3BvbnNlIHdhcyByZWNlaXZlZC5cIjtcbiAgICBjb25zdCBTRU5EX1JFU1BPTlNFX0RFUFJFQ0FUSU9OX1dBUk5JTkcgPSBcIlJldHVybmluZyBhIFByb21pc2UgaXMgdGhlIHByZWZlcnJlZCB3YXkgdG8gc2VuZCBhIHJlcGx5IGZyb20gYW4gb25NZXNzYWdlL29uTWVzc2FnZUV4dGVybmFsIGxpc3RlbmVyLCBhcyB0aGUgc2VuZFJlc3BvbnNlIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBzcGVjcyAoU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvTW96aWxsYS9BZGQtb25zL1dlYkV4dGVuc2lvbnMvQVBJL3J1bnRpbWUvb25NZXNzYWdlKVwiOyAvLyBXcmFwcGluZyB0aGUgYnVsayBvZiB0aGlzIHBvbHlmaWxsIGluIGEgb25lLXRpbWUtdXNlIGZ1bmN0aW9uIGlzIGEgbWlub3JcbiAgICAvLyBvcHRpbWl6YXRpb24gZm9yIEZpcmVmb3guIFNpbmNlIFNwaWRlcm1vbmtleSBkb2VzIG5vdCBmdWxseSBwYXJzZSB0aGVcbiAgICAvLyBjb250ZW50cyBvZiBhIGZ1bmN0aW9uIHVudGlsIHRoZSBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgc2luY2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGFjdHVhbGx5IG5lZWQgdG8gYmUgY2FsbGVkLCB0aGlzIGFsbG93cyB0aGUgcG9seWZpbGwgdG8gYmUgaW5jbHVkZWRcbiAgICAvLyBpbiBGaXJlZm94IG5lYXJseSBmb3IgZnJlZS5cblxuICAgIGNvbnN0IHdyYXBBUElzID0gZXh0ZW5zaW9uQVBJcyA9PiB7XG4gICAgICAvLyBOT1RFOiBhcGlNZXRhZGF0YSBpcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZW50IG9mIHRoZSBhcGktbWV0YWRhdGEuanNvbiBmaWxlXG4gICAgICAvLyBhdCBidWlsZCB0aW1lIGJ5IHJlcGxhY2luZyB0aGUgZm9sbG93aW5nIFwiaW5jbHVkZVwiIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgICAvLyBKU09OIGZpbGUuXG4gICAgICBjb25zdCBhcGlNZXRhZGF0YSA9IHtcbiAgICAgICAgXCJhbGFybXNcIjoge1xuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjbGVhckFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJvb2ttYXJrc1wiOiB7XG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDaGlsZHJlblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFJlY2VudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFN1YlRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUcmVlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJicm93c2VyQWN0aW9uXCI6IHtcbiAgICAgICAgICBcImRpc2FibGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlbmFibGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRCYWRnZUJhY2tncm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEJhZGdlVGV4dFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuUG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRCYWRnZUJhY2tncm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEJhZGdlVGV4dFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnJvd3NpbmdEYXRhXCI6IHtcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNhY2hlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ29va2llc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZURvd25sb2Fkc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUZvcm1EYXRhXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlSGlzdG9yeVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUxvY2FsU3RvcmFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBhc3N3b3Jkc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBsdWdpbkRhdGFcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvbW1hbmRzXCI6IHtcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvbnRleHRNZW51c1wiOiB7XG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjb29raWVzXCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbENvb2tpZVN0b3Jlc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRldnRvb2xzXCI6IHtcbiAgICAgICAgICBcImluc3BlY3RlZFdpbmRvd1wiOiB7XG4gICAgICAgICAgICBcImV2YWxcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDIsXG4gICAgICAgICAgICAgIFwic2luZ2xlQ2FsbGJhY2tBcmdcIjogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicGFuZWxzXCI6IHtcbiAgICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDMsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzLFxuICAgICAgICAgICAgICBcInNpbmdsZUNhbGxiYWNrQXJnXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcbiAgICAgICAgICAgICAgXCJjcmVhdGVTaWRlYmFyUGFuZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJkb3dubG9hZHNcIjoge1xuICAgICAgICAgIFwiY2FuY2VsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZG93bmxvYWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlcmFzZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEZpbGVJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3BlblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInBhdXNlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRmlsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlc3VtZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNob3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRlbnNpb25cIjoge1xuICAgICAgICAgIFwiaXNBbGxvd2VkRmlsZVNjaGVtZUFjY2Vzc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImlzQWxsb3dlZEluY29nbml0b0FjY2Vzc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImhpc3RvcnlcIjoge1xuICAgICAgICAgIFwiYWRkVXJsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlUmFuZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVVcmxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRWaXNpdHNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpMThuXCI6IHtcbiAgICAgICAgICBcImRldGVjdExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWNjZXB0TGFuZ3VhZ2VzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRlbnRpdHlcIjoge1xuICAgICAgICAgIFwibGF1bmNoV2ViQXV0aEZsb3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpZGxlXCI6IHtcbiAgICAgICAgICBcInF1ZXJ5U3RhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYW5hZ2VtZW50XCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFNlbGZcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidW5pbnN0YWxsU2VsZlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm5vdGlmaWNhdGlvbnNcIjoge1xuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRQZXJtaXNzaW9uTGV2ZWxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYWdlQWN0aW9uXCI6IHtcbiAgICAgICAgICBcImdldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0SWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaG93XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGVybWlzc2lvbnNcIjoge1xuICAgICAgICAgIFwiY29udGFpbnNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicnVudGltZVwiOiB7XG4gICAgICAgICAgXCJnZXRCYWNrZ3JvdW5kUGFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBsYXRmb3JtSW5mb1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5PcHRpb25zUGFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlcXVlc3RVcGRhdGVDaGVja1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmRNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE5hdGl2ZU1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRVbmluc3RhbGxVUkxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXNzaW9uc1wiOiB7XG4gICAgICAgICAgXCJnZXREZXZpY2VzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UmVjZW50bHlDbG9zZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXN0b3JlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic3RvcmFnZVwiOiB7XG4gICAgICAgICAgXCJsb2NhbFwiOiB7XG4gICAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1hbmFnZWRcIjoge1xuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic3luY1wiOiB7XG4gICAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRhYnNcIjoge1xuICAgICAgICAgIFwiY2FwdHVyZVZpc2libGVUYWJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZXRlY3RMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRpc2NhcmRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkdXBsaWNhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJleGVjdXRlU2NyaXB0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Q3VycmVudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFpvb21cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRab29tU2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnb0JhY2tcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnb0ZvcndhcmRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWdobGlnaHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpbnNlcnRDU1NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicXVlcnlcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZWxvYWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDU1NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFpvb21cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRab29tU2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0b3BTaXRlc1wiOiB7XG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3ZWJOYXZpZ2F0aW9uXCI6IHtcbiAgICAgICAgICBcImdldEFsbEZyYW1lc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEZyYW1lXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2ViUmVxdWVzdFwiOiB7XG4gICAgICAgICAgXCJoYW5kbGVyQmVoYXZpb3JDaGFuZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2luZG93c1wiOiB7XG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDdXJyZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0TGFzdEZvY3VzZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKGFwaU1ldGFkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXBpLW1ldGFkYXRhLmpzb24gaGFzIG5vdCBiZWVuIGluY2x1ZGVkIGluIGJyb3dzZXItcG9seWZpbGxcIik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEEgV2Vha01hcCBzdWJjbGFzcyB3aGljaCBjcmVhdGVzIGFuZCBzdG9yZXMgYSB2YWx1ZSBmb3IgYW55IGtleSB3aGljaCBkb2VzXG4gICAgICAgKiBub3QgZXhpc3Qgd2hlbiBhY2Nlc3NlZCwgYnV0IGJlaGF2ZXMgZXhhY3RseSBhcyBhbiBvcmRpbmFyeSBXZWFrTWFwXG4gICAgICAgKiBvdGhlcndpc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY3JlYXRlSXRlbVxuICAgICAgICogICAgICAgIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSB2YWx1ZSBmb3IgYW55XG4gICAgICAgKiAgICAgICAga2V5IHdoaWNoIGRvZXMgbm90IGV4aXN0LCB0aGUgZmlyc3QgdGltZSBpdCBpcyBhY2Nlc3NlZC4gVGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZXMsIGFzIGl0cyBvbmx5IGFyZ3VtZW50LCB0aGUga2V5IGJlaW5nIGNyZWF0ZWQuXG4gICAgICAgKi9cblxuXG4gICAgICBjbGFzcyBEZWZhdWx0V2Vha01hcCBleHRlbmRzIFdlYWtNYXAge1xuICAgICAgICBjb25zdHJ1Y3RvcihjcmVhdGVJdGVtLCBpdGVtcyA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN1cGVyKGl0ZW1zKTtcbiAgICAgICAgICB0aGlzLmNyZWF0ZUl0ZW0gPSBjcmVhdGVJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB0aGlzLmNyZWF0ZUl0ZW0oa2V5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdpdGggYSBgdGhlbmAgbWV0aG9kLCBhbmQgY2FuXG4gICAgICAgKiB0aGVyZWZvcmUgYmUgYXNzdW1lZCB0byBiZWhhdmUgYXMgYSBQcm9taXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdGhlbmFibGUuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBpc1RoZW5hYmxlID0gdmFsdWUgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2gsIHdoZW4gY2FsbGVkLCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0XG4gICAgICAgKiB0aGUgZ2l2ZW4gcHJvbWlzZSBiYXNlZCBvbiBob3cgaXQgaXMgY2FsbGVkOlxuICAgICAgICpcbiAgICAgICAqIC0gSWYsIHdoZW4gY2FsbGVkLCBgY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yYCBjb250YWlucyBhIG5vbi1udWxsIG9iamVjdCxcbiAgICAgICAqICAgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCB0aGF0IHZhbHVlLlxuICAgICAgICogLSBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZXhhY3RseSBvbmUgYXJndW1lbnQsIHRoZSBwcm9taXNlIGlzXG4gICAgICAgKiAgIHJlc29sdmVkIHRvIHRoYXQgdmFsdWUuXG4gICAgICAgKiAtIE90aGVyd2lzZSwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgdG8gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlXG4gICAgICAgKiAgIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9taXNlXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc29sdXRpb24gYW5kIHJlamVjdGlvbiBmdW5jdGlvbnMgb2YgYVxuICAgICAgICogICAgICAgIHByb21pc2UuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9taXNlLnJlc29sdmVcbiAgICAgICAqICAgICAgICBUaGUgcHJvbWlzZSdzIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9taXNlLnJlamVjdGlvblxuICAgICAgICogICAgICAgIFRoZSBwcm9taXNlJ3MgcmVqZWN0aW9uIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIHdyYXBwZWQgbWV0aG9kIHdoaWNoIGhhcyBjcmVhdGVkIHRoZSBjYWxsYmFjay5cbiAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gbWV0YWRhdGEubWF4UmVzb2x2ZWRBcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICogICAgICAgIGNhbGxiYWNrIGNyZWF0ZWQgYnkgdGhlIHdyYXBwZWQgYXN5bmMgZnVuY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9ufVxuICAgICAgICogICAgICAgIFRoZSBnZW5lcmF0ZWQgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBtYWtlQ2FsbGJhY2sgPSAocHJvbWlzZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuICguLi5jYWxsYmFja0FyZ3MpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZyB8fCBjYWxsYmFja0FyZ3MubGVuZ3RoIDw9IDEgJiYgbWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoY2FsbGJhY2tBcmdzWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrQXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcGx1cmFsaXplQXJndW1lbnRzID0gbnVtQXJncyA9PiBudW1BcmdzID09IDEgPyBcImFyZ3VtZW50XCIgOiBcImFyZ3VtZW50c1wiO1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiBmb3IgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgbWV0YWRhdGEuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHdoaWNoIGlzIGJlaW5nIHdyYXBwZWQuXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGFcbiAgICAgICAqICAgICAgICBNZXRhZGF0YSBhYm91dCB0aGUgbWV0aG9kIGJlaW5nIHdyYXBwZWQuXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1pbkFyZ3NcbiAgICAgICAqICAgICAgICBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHdoaWNoIG11c3QgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uLiBJZiBjYWxsZWQgd2l0aCBmZXdlciB0aGFuIHRoaXMgbnVtYmVyIG9mIGFyZ3VtZW50cywgdGhlXG4gICAgICAgKiAgICAgICAgd3JhcHBlciB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gbWV0YWRhdGEubWF4QXJnc1xuICAgICAgICogICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbi4gSWYgY2FsbGVkIHdpdGggbW9yZSB0aGFuIHRoaXMgbnVtYmVyIG9mIGFyZ3VtZW50cywgdGhlXG4gICAgICAgKiAgICAgICAgd3JhcHBlciB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gbWV0YWRhdGEubWF4UmVzb2x2ZWRBcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICogICAgICAgIGNhbGxiYWNrIGNyZWF0ZWQgYnkgdGhlIHdyYXBwZWQgYXN5bmMgZnVuY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKG9iamVjdCwgLi4uKil9XG4gICAgICAgKiAgICAgICBUaGUgZ2VuZXJhdGVkIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwQXN5bmNGdW5jdGlvbiA9IChuYW1lLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXN5bmNGdW5jdGlvbldyYXBwZXIodGFyZ2V0LCAuLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgbWV0YWRhdGEubWluQXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21ldGFkYXRhLm1pbkFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1pbkFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBtZXRhZGF0YS5tYXhBcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IG1vc3QgJHttZXRhZGF0YS5tYXhBcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5tYXhBcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5mYWxsYmFja1RvTm9DYWxsYmFjaykge1xuICAgICAgICAgICAgICAvLyBUaGlzIEFQSSBtZXRob2QgaGFzIGN1cnJlbnRseSBubyBjYWxsYmFjayBvbiBDaHJvbWUsIGJ1dCBpdCByZXR1cm4gYSBwcm9taXNlIG9uIEZpcmVmb3gsXG4gICAgICAgICAgICAgIC8vIGFuZCBzbyB0aGUgcG9seWZpbGwgd2lsbCB0cnkgdG8gY2FsbCBpdCB3aXRoIGEgY2FsbGJhY2sgZmlyc3QsIGFuZCBpdCB3aWxsIGZhbGxiYWNrXG4gICAgICAgICAgICAgIC8vIHRvIG5vdCBwYXNzaW5nIHRoZSBjYWxsYmFjayBpZiB0aGUgZmlyc3QgY2FsbCBmYWlscy5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncywgbWFrZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICB9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChjYkVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IEFQSSBtZXRob2QgZG9lc24ndCBzZWVtIHRvIHN1cHBvcnQgdGhlIGNhbGxiYWNrIHBhcmFtZXRlciwgYCArIFwiZmFsbGluZyBiYWNrIHRvIGNhbGwgaXQgd2l0aG91dCBhIGNhbGxiYWNrOiBcIiwgY2JFcnJvcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MpOyAvLyBVcGRhdGUgdGhlIEFQSSBtZXRob2QgbWV0YWRhdGEsIHNvIHRoYXQgdGhlIG5leHQgQVBJIGNhbGxzIHdpbGwgbm90IHRyeSB0b1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgdW5zdXBwb3J0ZWQgY2FsbGJhY2sgYW55bW9yZS5cblxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmZhbGxiYWNrVG9Ob0NhbGxiYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubm9DYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLm5vQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncywgbWFrZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICB9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgYW4gZXhpc3RpbmcgbWV0aG9kIG9mIHRoZSB0YXJnZXQgb2JqZWN0LCBzbyB0aGF0IGNhbGxzIHRvIGl0IGFyZVxuICAgICAgICogaW50ZXJjZXB0ZWQgYnkgdGhlIGdpdmVuIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHJlY2VpdmVzLFxuICAgICAgICogYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCB0aGUgb3JpZ2luYWwgYHRhcmdldGAgb2JqZWN0LCBmb2xsb3dlZCBieSBlYWNoIG9mXG4gICAgICAgKiB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAgICAgICAqICAgICAgICBUaGUgb3JpZ2luYWwgdGFyZ2V0IG9iamVjdCB0aGF0IHRoZSB3cmFwcGVkIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kXG4gICAgICAgKiAgICAgICAgVGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLiBUaGlzIGlzIHVzZWQgYXMgdGhlIHRhcmdldCBvZiB0aGUgUHJveHlcbiAgICAgICAqICAgICAgICBvYmplY3Qgd2hpY2ggaXMgY3JlYXRlZCB0byB3cmFwIHRoZSBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgVGhlIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGluIHBsYWNlIG9mIGEgZGlyZWN0IGludm9jYXRpb25cbiAgICAgICAqICAgICAgICBvZiB0aGUgd3JhcHBlZCBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb3h5PGZ1bmN0aW9uPn1cbiAgICAgICAqICAgICAgICBBIFByb3h5IG9iamVjdCBmb3IgdGhlIGdpdmVuIG1ldGhvZCwgd2hpY2ggaW52b2tlcyB0aGUgZ2l2ZW4gd3JhcHBlclxuICAgICAgICogICAgICAgIG1ldGhvZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwTWV0aG9kID0gKHRhcmdldCwgbWV0aG9kLCB3cmFwcGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkobWV0aG9kLCB7XG4gICAgICAgICAgYXBwbHkodGFyZ2V0TWV0aG9kLCB0aGlzT2JqLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5jYWxsKHRoaXNPYmosIHRhcmdldCwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGV0IGhhc093blByb3BlcnR5ID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBhbiBvYmplY3QgaW4gYSBQcm94eSB3aGljaCBpbnRlcmNlcHRzIGFuZCB3cmFwcyBjZXJ0YWluIG1ldGhvZHNcbiAgICAgICAqIGJhc2VkIG9uIHRoZSBnaXZlbiBgd3JhcHBlcnNgIGFuZCBgbWV0YWRhdGFgIG9iamVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICAgICAgICogICAgICAgIFRoZSB0YXJnZXQgb2JqZWN0IHRvIHdyYXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFt3cmFwcGVycyA9IHt9XVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCB0cmVlIGNvbnRhaW5pbmcgd3JhcHBlciBmdW5jdGlvbnMgZm9yIHNwZWNpYWwgY2FzZXMuIEFueVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uIHByZXNlbnQgaW4gdGhpcyBvYmplY3QgdHJlZSBpcyBjYWxsZWQgaW4gcGxhY2Ugb2YgdGhlXG4gICAgICAgKiAgICAgICAgbWV0aG9kIGluIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBgdGFyZ2V0YCBvYmplY3QgdHJlZS4gVGhlc2VcbiAgICAgICAqICAgICAgICB3cmFwcGVyIG1ldGhvZHMgYXJlIGludm9rZWQgYXMgZGVzY3JpYmVkIGluIHtAc2VlIHdyYXBNZXRob2R9LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbbWV0YWRhdGEgPSB7fV1cbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgdHJlZSBjb250YWluaW5nIG1ldGFkYXRhIHVzZWQgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZVxuICAgICAgICogICAgICAgIFByb21pc2UtYmFzZWQgd3JhcHBlciBmdW5jdGlvbnMgZm9yIGFzeW5jaHJvbm91cy4gQW55IGZ1bmN0aW9uIGluXG4gICAgICAgKiAgICAgICAgdGhlIGB0YXJnZXRgIG9iamVjdCB0cmVlIHdoaWNoIGhhcyBhIGNvcnJlc3BvbmRpbmcgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiAgICAgICAgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIGBtZXRhZGF0YWAgdHJlZSBpcyByZXBsYWNlZCB3aXRoIGFuXG4gICAgICAgKiAgICAgICAgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgd3JhcHBlciBmdW5jdGlvbiwgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgKiAgICAgICAge0BzZWUgd3JhcEFzeW5jRnVuY3Rpb259XG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb3h5PG9iamVjdD59XG4gICAgICAgKi9cblxuICAgICAgY29uc3Qgd3JhcE9iamVjdCA9ICh0YXJnZXQsIHdyYXBwZXJzID0ge30sIG1ldGFkYXRhID0ge30pID0+IHtcbiAgICAgICAgbGV0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0ge1xuICAgICAgICAgIGhhcyhwcm94eVRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0IHx8IHByb3AgaW4gY2FjaGU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldChwcm94eVRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZVtwcm9wXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2Qgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LiBDaGVjayBpZiB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAgIC8vIGFueSB3cmFwcGluZy5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVyc1twcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNwZWNpYWwtY2FzZSB3cmFwcGVyIGZvciB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBNZXRob2QodGFyZ2V0LCB0YXJnZXRbcHJvcF0sIHdyYXBwZXJzW3Byb3BdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIG1ldGhvZCB0aGF0IHdlIGhhdmUgbWV0YWRhdGEgZm9yLiBDcmVhdGUgYVxuICAgICAgICAgICAgICAgIC8vIFByb21pc2Ugd3JhcHBlciBmb3IgaXQuXG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSB3cmFwQXN5bmNGdW5jdGlvbihwcm9wLCBtZXRhZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwTWV0aG9kKHRhcmdldCwgdGFyZ2V0W3Byb3BdLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWV0aG9kIHRoYXQgd2UgZG9uJ3Qga25vdyBvciBjYXJlIGFib3V0LiBSZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgbWV0aG9kLCBib3VuZCB0byB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5iaW5kKHRhcmdldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIChoYXNPd25Qcm9wZXJ0eSh3cmFwcGVycywgcHJvcCkgfHwgaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIHByb3ApKSkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIG9iamVjdCB0aGF0IHdlIG5lZWQgdG8gZG8gc29tZSB3cmFwcGluZyBmb3IgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgIC8vIG9mLiBDcmVhdGUgYSBzdWItb2JqZWN0IHdyYXBwZXIgZm9yIGl0IHdpdGggdGhlIGFwcHJvcHJpYXRlIGNoaWxkXG4gICAgICAgICAgICAgIC8vIG1ldGFkYXRhLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBPYmplY3QodmFsdWUsIHdyYXBwZXJzW3Byb3BdLCBtZXRhZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBcIipcIikpIHtcbiAgICAgICAgICAgICAgLy8gV3JhcCBhbGwgcHJvcGVydGllcyBpbiAqIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwT2JqZWN0KHZhbHVlLCB3cmFwcGVyc1twcm9wXSwgbWV0YWRhdGFbXCIqXCJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gYW55IHdyYXBwaW5nIGZvciB0aGlzIHByb3BlcnR5LFxuICAgICAgICAgICAgICAvLyBzbyBqdXN0IGZvcndhcmQgYWxsIGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2V0KHByb3h5VGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIGNhY2hlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHByb3h5VGFyZ2V0LCBwcm9wLCBkZXNjKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZSwgcHJvcCwgZGVzYyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHByb3h5VGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShjYWNoZSwgcHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07IC8vIFBlciBjb250cmFjdCBvZiB0aGUgUHJveHkgQVBJLCB0aGUgXCJnZXRcIiBwcm94eSBoYW5kbGVyIG11c3QgcmV0dXJuIHRoZVxuICAgICAgICAvLyBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgdGFyZ2V0IGlmIHRoYXQgdmFsdWUgaXMgZGVjbGFyZWQgcmVhZC1vbmx5IGFuZFxuICAgICAgICAvLyBub24tY29uZmlndXJhYmxlLiBGb3IgdGhpcyByZWFzb24sIHdlIGNyZWF0ZSBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgICAgLy8gcHJvdG90eXBlIHNldCB0byBgdGFyZ2V0YCBpbnN0ZWFkIG9mIHVzaW5nIGB0YXJnZXRgIGRpcmVjdGx5LlxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgY2Fubm90IHJldHVybiBhIGN1c3RvbSBvYmplY3QgZm9yIEFQSXMgdGhhdFxuICAgICAgICAvLyBhcmUgZGVjbGFyZWQgcmVhZC1vbmx5IGFuZCBub24tY29uZmlndXJhYmxlLCBzdWNoIGFzIGBjaHJvbWUuZGV2dG9vbHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcHJveHkgaGFuZGxlcnMgdGhlbXNlbHZlcyB3aWxsIHN0aWxsIHVzZSB0aGUgb3JpZ2luYWwgYHRhcmdldGBcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgYHByb3h5VGFyZ2V0YCwgc28gdGhhdCB0aGUgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBhcmVcbiAgICAgICAgLy8gZGVyZWZlcmVuY2VkIHZpYSB0aGUgb3JpZ2luYWwgdGFyZ2V0cy5cblxuICAgICAgICBsZXQgcHJveHlUYXJnZXQgPSBPYmplY3QuY3JlYXRlKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIGhhbmRsZXJzKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzZXQgb2Ygd3JhcHBlciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IG9iamVjdCwgd2hpY2ggaGFuZGxlc1xuICAgICAgICogd3JhcHBpbmcgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRoYXQgdGhvc2UgbWVzc2FnZXMgYXJlIHBhc3NlZC5cbiAgICAgICAqXG4gICAgICAgKiBBIHNpbmdsZSB3cmFwcGVyIGlzIGNyZWF0ZWQgZm9yIGVhY2ggbGlzdGVuZXIgZnVuY3Rpb24sIGFuZCBzdG9yZWQgaW4gYVxuICAgICAgICogbWFwLiBTdWJzZXF1ZW50IGNhbGxzIHRvIGBhZGRMaXN0ZW5lcmAsIGBoYXNMaXN0ZW5lcmAsIG9yIGByZW1vdmVMaXN0ZW5lcmBcbiAgICAgICAqIHJldHJpZXZlIHRoZSBvcmlnaW5hbCB3cmFwcGVyLCBzbyB0aGF0ICBhdHRlbXB0cyB0byByZW1vdmUgYVxuICAgICAgICogcHJldmlvdXNseS1hZGRlZCBsaXN0ZW5lciB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RGVmYXVsdFdlYWtNYXA8ZnVuY3Rpb24sIGZ1bmN0aW9uPn0gd3JhcHBlck1hcFxuICAgICAgICogICAgICAgIEEgRGVmYXVsdFdlYWtNYXAgb2JqZWN0IHdoaWNoIHdpbGwgY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgZm9yIGEgZ2l2ZW4gbGlzdGVuZXIgZnVuY3Rpb24gd2hlbiBvbmUgZG9lcyBub3QgZXhpc3QsIGFuZCByZXRyaWV2ZVxuICAgICAgICogICAgICAgIGFuIGV4aXN0aW5nIG9uZSB3aGVuIGl0IGRvZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBFdmVudCA9IHdyYXBwZXJNYXAgPT4gKHtcbiAgICAgICAgYWRkTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lciwgLi4uYXJncykge1xuICAgICAgICAgIHRhcmdldC5hZGRMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lciksIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0xpc3RlbmVyKHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0Lmhhc0xpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lcikpO1xuICAgICAgICB9XG5cbiAgICAgIH0pOyAvLyBLZWVwIHRyYWNrIGlmIHRoZSBkZXByZWNhdGlvbiB3YXJuaW5nIGhhcyBiZWVuIGxvZ2dlZCBhdCBsZWFzdCBvbmNlLlxuXG5cbiAgICAgIGxldCBsb2dnZWRTZW5kUmVzcG9uc2VEZXByZWNhdGlvbldhcm5pbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG9uTWVzc2FnZVdyYXBwZXJzID0gbmV3IERlZmF1bHRXZWFrTWFwKGxpc3RlbmVyID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwcyBhIG1lc3NhZ2UgbGlzdGVuZXIgZnVuY3Rpb24gc28gdGhhdCBpdCBtYXkgc2VuZCByZXNwb25zZXMgYmFzZWQgb25cbiAgICAgICAgICogaXRzIHJldHVybiB2YWx1ZSwgcmF0aGVyIHRoYW4gYnkgcmV0dXJuaW5nIGEgc2VudGluZWwgdmFsdWUgYW5kIGNhbGxpbmcgYVxuICAgICAgICAgKiBjYWxsYmFjay4gSWYgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHJldHVybnMgYSBQcm9taXNlLCB0aGUgcmVzcG9uc2UgaXNcbiAgICAgICAgICogc2VudCB3aGVuIHRoZSBwcm9taXNlIGVpdGhlciByZXNvbHZlcyBvciByZWplY3RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyp9IG1lc3NhZ2VcbiAgICAgICAgICogICAgICAgIFRoZSBtZXNzYWdlIHNlbnQgYnkgdGhlIG90aGVyIGVuZCBvZiB0aGUgY2hhbm5lbC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNlbmRlclxuICAgICAgICAgKiAgICAgICAgRGV0YWlscyBhYm91dCB0aGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBzZW5kUmVzcG9uc2VcbiAgICAgICAgICogICAgICAgIEEgY2FsbGJhY2sgd2hpY2gsIHdoZW4gY2FsbGVkIHdpdGggYW4gYXJiaXRyYXJ5IGFyZ3VtZW50LCBzZW5kc1xuICAgICAgICAgKiAgICAgICAgdGhhdCB2YWx1ZSBhcyBhIHJlc3BvbnNlLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICogICAgICAgIFRydWUgaWYgdGhlIHdyYXBwZWQgbGlzdGVuZXIgcmV0dXJuZWQgYSBQcm9taXNlLCB3aGljaCB3aWxsIGxhdGVyXG4gICAgICAgICAqICAgICAgICB5aWVsZCBhIHJlc3BvbnNlLiBGYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uTWVzc2FnZShtZXNzYWdlLCBzZW5kZXIsIHNlbmRSZXNwb25zZSkge1xuICAgICAgICAgIGxldCBkaWRDYWxsU2VuZFJlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgbGV0IHdyYXBwZWRTZW5kUmVzcG9uc2U7XG4gICAgICAgICAgbGV0IHNlbmRSZXNwb25zZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHdyYXBwZWRTZW5kUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgaWYgKCFsb2dnZWRTZW5kUmVzcG9uc2VEZXByZWNhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oU0VORF9SRVNQT05TRV9ERVBSRUNBVElPTl9XQVJOSU5HLCBuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRpZENhbGxTZW5kUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBsaXN0ZW5lcihtZXNzYWdlLCBzZW5kZXIsIHdyYXBwZWRTZW5kUmVzcG9uc2UpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzdWx0ID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc1Jlc3VsdFRoZW5hYmxlID0gcmVzdWx0ICE9PSB0cnVlICYmIGlzVGhlbmFibGUocmVzdWx0KTsgLy8gSWYgdGhlIGxpc3RlbmVyIGRpZG4ndCByZXR1cm5lZCB0cnVlIG9yIGEgUHJvbWlzZSwgb3IgY2FsbGVkXG4gICAgICAgICAgLy8gd3JhcHBlZFNlbmRSZXNwb25zZSBzeW5jaHJvbm91c2x5LCB3ZSBjYW4gZXhpdCBlYXJsaWVyXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSB3aWxsIGJlIG5vIHJlc3BvbnNlIHNlbnQgZnJvbSB0aGlzIGxpc3RlbmVyLlxuXG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSAmJiAhaXNSZXN1bHRUaGVuYWJsZSAmJiAhZGlkQ2FsbFNlbmRSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gLy8gQSBzbWFsbCBoZWxwZXIgdG8gc2VuZCB0aGUgbWVzc2FnZSBpZiB0aGUgcHJvbWlzZSByZXNvbHZlc1xuICAgICAgICAgIC8vIGFuZCBhbiBlcnJvciBpZiB0aGUgcHJvbWlzZSByZWplY3RzIChhIHdyYXBwZWQgc2VuZE1lc3NhZ2UgaGFzXG4gICAgICAgICAgLy8gdG8gdHJhbnNsYXRlIHRoZSBtZXNzYWdlIGludG8gYSByZXNvbHZlZCBwcm9taXNlIG9yIGEgcmVqZWN0ZWRcbiAgICAgICAgICAvLyBwcm9taXNlKS5cblxuXG4gICAgICAgICAgY29uc3Qgc2VuZFByb21pc2VkUmVzdWx0ID0gcHJvbWlzZSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4obXNnID0+IHtcbiAgICAgICAgICAgICAgLy8gc2VuZCB0aGUgbWVzc2FnZSB2YWx1ZS5cbiAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKG1zZyk7XG4gICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgIC8vIFNlbmQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlcnJvciBpZiB0aGUgcmVqZWN0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgLy8gaXMgYW4gaW5zdGFuY2Ugb2YgZXJyb3IsIG9yIHRoZSBvYmplY3QgaXRzZWxmIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgbGV0IG1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgaWYgKGVycm9yICYmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWRcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNlbmRSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgX19tb3pXZWJFeHRlbnNpb25Qb2x5ZmlsbFJlamVjdF9fOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAvLyBQcmludCBhbiBlcnJvciBvbiB0aGUgY29uc29sZSBpZiB1bmFibGUgdG8gc2VuZCB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2VuZCBvbk1lc3NhZ2UgcmVqZWN0ZWQgcmVwbHlcIiwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07IC8vIElmIHRoZSBsaXN0ZW5lciByZXR1cm5lZCBhIFByb21pc2UsIHNlbmQgdGhlIHJlc29sdmVkIHZhbHVlIGFzIGFcbiAgICAgICAgICAvLyByZXN1bHQsIG90aGVyd2lzZSB3YWl0IHRoZSBwcm9taXNlIHJlbGF0ZWQgdG8gdGhlIHdyYXBwZWRTZW5kUmVzcG9uc2VcbiAgICAgICAgICAvLyBjYWxsYmFjayB0byByZXNvbHZlIGFuZCBzZW5kIGl0IGFzIGEgcmVzcG9uc2UuXG5cblxuICAgICAgICAgIGlmIChpc1Jlc3VsdFRoZW5hYmxlKSB7XG4gICAgICAgICAgICBzZW5kUHJvbWlzZWRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZFByb21pc2VkUmVzdWx0KHNlbmRSZXNwb25zZVByb21pc2UpO1xuICAgICAgICAgIH0gLy8gTGV0IENocm9tZSBrbm93IHRoYXQgdGhlIGxpc3RlbmVyIGlzIHJlcGx5aW5nLlxuXG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB3cmFwcGVkU2VuZE1lc3NhZ2VDYWxsYmFjayA9ICh7XG4gICAgICAgIHJlamVjdCxcbiAgICAgICAgcmVzb2x2ZVxuICAgICAgfSwgcmVwbHkpID0+IHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAvLyBEZXRlY3Qgd2hlbiBub25lIG9mIHRoZSBsaXN0ZW5lcnMgcmVwbGllZCB0byB0aGUgc2VuZE1lc3NhZ2UgY2FsbCBhbmQgcmVzb2x2ZVxuICAgICAgICAgIC8vIHRoZSBwcm9taXNlIHRvIHVuZGVmaW5lZCBhcyBpbiBGaXJlZm94LlxuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS93ZWJleHRlbnNpb24tcG9seWZpbGwvaXNzdWVzLzEzMFxuICAgICAgICAgIGlmIChleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UgPT09IENIUk9NRV9TRU5EX01FU1NBR0VfQ0FMTEJBQ0tfTk9fUkVTUE9OU0VfTUVTU0FHRSkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlcGx5ICYmIHJlcGx5Ll9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXykge1xuICAgICAgICAgIC8vIENvbnZlcnQgYmFjayB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaW50b1xuICAgICAgICAgIC8vIGFuIEVycm9yIGluc3RhbmNlLlxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVwbHkubWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocmVwbHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB3cmFwcGVkU2VuZE1lc3NhZ2UgPSAobmFtZSwgbWV0YWRhdGEsIGFwaU5hbWVzcGFjZU9iaiwgLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBtZXRhZGF0YS5taW5BcmdzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21ldGFkYXRhLm1pbkFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1pbkFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IG1ldGFkYXRhLm1heEFyZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IG1vc3QgJHttZXRhZGF0YS5tYXhBcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5tYXhBcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYiA9IHdyYXBwZWRTZW5kTWVzc2FnZUNhbGxiYWNrLmJpbmQobnVsbCwge1xuICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyZ3MucHVzaCh3cmFwcGVkQ2IpO1xuICAgICAgICAgIGFwaU5hbWVzcGFjZU9iai5zZW5kTWVzc2FnZSguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGF0aWNXcmFwcGVycyA9IHtcbiAgICAgICAgcnVudGltZToge1xuICAgICAgICAgIG9uTWVzc2FnZTogd3JhcEV2ZW50KG9uTWVzc2FnZVdyYXBwZXJzKSxcbiAgICAgICAgICBvbk1lc3NhZ2VFeHRlcm5hbDogd3JhcEV2ZW50KG9uTWVzc2FnZVdyYXBwZXJzKSxcbiAgICAgICAgICBzZW5kTWVzc2FnZTogd3JhcHBlZFNlbmRNZXNzYWdlLmJpbmQobnVsbCwgXCJzZW5kTWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgICAgbWF4QXJnczogM1xuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHRhYnM6IHtcbiAgICAgICAgICBzZW5kTWVzc2FnZTogd3JhcHBlZFNlbmRNZXNzYWdlLmJpbmQobnVsbCwgXCJzZW5kTWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBtaW5BcmdzOiAyLFxuICAgICAgICAgICAgbWF4QXJnczogM1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBzZXR0aW5nTWV0YWRhdGEgPSB7XG4gICAgICAgIGNsZWFyOiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH0sXG4gICAgICAgIGdldDoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGFwaU1ldGFkYXRhLnByaXZhY3kgPSB7XG4gICAgICAgIG5ldHdvcms6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH0sXG4gICAgICAgIHNlcnZpY2VzOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9LFxuICAgICAgICB3ZWJzaXRlczoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB3cmFwT2JqZWN0KGV4dGVuc2lvbkFQSXMsIHN0YXRpY1dyYXBwZXJzLCBhcGlNZXRhZGF0YSk7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgY2hyb21lICE9IFwib2JqZWN0XCIgfHwgIWNocm9tZSB8fCAhY2hyb21lLnJ1bnRpbWUgfHwgIWNocm9tZS5ydW50aW1lLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNjcmlwdCBzaG91bGQgb25seSBiZSBsb2FkZWQgaW4gYSBicm93c2VyIGV4dGVuc2lvbi5cIik7XG4gICAgfSAvLyBUaGUgYnVpbGQgcHJvY2VzcyBhZGRzIGEgVU1EIHdyYXBwZXIgYXJvdW5kIHRoaXMgZmlsZSwgd2hpY2ggbWFrZXMgdGhlXG4gICAgLy8gYG1vZHVsZWAgdmFyaWFibGUgYXZhaWxhYmxlLlxuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdyYXBBUElzKGNocm9tZSk7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBicm93c2VyO1xuICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXItcG9seWZpbGwuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webextension-polyfill/dist/browser-polyfill.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/content.ts");
/******/ 	
/******/ })()
;