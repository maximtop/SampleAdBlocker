/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _asyncToGenerator)\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzPzFkYTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz9hMzRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdIQUErQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./src/content.ts":
/*!************************!*\
  !*** ./src/content.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var webextension_polyfill_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! webextension-polyfill-ts */ \"./node_modules/webextension-polyfill-ts/lib/index.js\");\n/* harmony import */ var extended_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! extended-css */ \"./node_modules/extended-css/dist/extended-css.esm.js\");\n/* harmony import */ var scriptlets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! scriptlets */ \"./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js\");\n/* harmony import */ var scriptlets__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(scriptlets__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _pages_common_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pages/common/constants */ \"./src/pages/common/constants.ts\");\n\n\n\n/* eslint-disable no-console */\n\n\n\n\n\n/**\n * Logs a message if verbose is true\n *\n * @param verbose\n * @param message\n */\nvar logMessage = function logMessage(verbose, message) {\n  if (verbose) {\n    console.log(\"(AG) \".concat(message));\n  }\n};\n\nvar getSelectorsAndScripts = /*#__PURE__*/function () {\n  var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee() {\n    var response;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return webextension_polyfill_ts__WEBPACK_IMPORTED_MODULE_2__.browser.runtime.sendMessage({\n              type: _pages_common_constants__WEBPACK_IMPORTED_MODULE_5__.Messages.GetRules,\n              data: {\n                url: window.location.href\n              }\n            });\n\n          case 2:\n            response = _context.sent;\n\n            if (!(response == null)) {\n              _context.next = 6;\n              break;\n            }\n\n            console.log('AG: data not ready yet');\n            return _context.abrupt(\"return\", null);\n\n          case 6:\n            _context.prev = 6;\n            return _context.abrupt(\"return\", JSON.parse(response));\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](6);\n            console.log('AG: an error occurred during fetching selectors and scripts from background page', _context.t0);\n            return _context.abrupt(\"return\", null);\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[6, 10]]);\n  }));\n\n  return function getSelectorsAndScripts() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Execute scripts in a page context and cleanup itself when execution completes\n * @param scripts Scripts array to execute\n */\n\n\nvar executeScripts = function executeScripts(scripts) {\n  // Wrap with try catch\n  scripts.unshift('( function () { try {');\n  scripts.push(\"} catch (ex) { console.error('Error executing AG js: ' + ex); } })();\");\n  var scriptTag = document.createElement('script');\n  scriptTag.setAttribute('type', 'text/javascript');\n  scriptTag.textContent = scripts.join('\\r\\n');\n  var parent = document.head || document.documentElement;\n  parent.appendChild(scriptTag);\n\n  if (scriptTag.parentNode) {\n    scriptTag.parentNode.removeChild(scriptTag);\n  }\n};\n/**\n * Applies JS injections.\n * @param scripts Array with JS scripts\n * @param verbose logging\n */\n\n\nvar applyScripts = function applyScripts(scripts, verbose) {\n  if (!scripts || scripts.length === 0) {\n    return;\n  }\n\n  logMessage(verbose, \"scripts length: \".concat(scripts.length));\n  executeScripts(scripts.reverse());\n};\n/**\n * Protects specified style element from changes to the current document\n * Add a mutation observer, which is adds our rules again if it was removed\n *\n * @param protectStyleEl protected style element\n */\n\n\nvar protectStyleElementContent = function protectStyleElementContent(protectStyleEl) {\n  // @ts-ignore\n  var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n  if (!MutationObserver) {\n    return;\n  }\n  /* observer, which observe protectStyleEl inner changes, without deleting styleEl */\n\n\n  var innerObserver = new MutationObserver(function (mutations) {\n    for (var i = 0; i < mutations.length; i += 1) {\n      var m = mutations[i]; // @ts-ignore\n\n      if (protectStyleEl.hasAttribute('mod') && protectStyleEl.getAttribute('mod') === 'inner') {\n        // @ts-ignore\n        protectStyleEl.removeAttribute('mod');\n        break;\n      } // @ts-ignore\n\n\n      protectStyleEl.setAttribute('mod', 'inner');\n      var isProtectStyleElModified = false;\n      /**\n       * further, there are two mutually exclusive situations: either there were changes\n       * the text of protectStyleEl, either there was removes a whole child \"text\"\n       * element of protectStyleEl we'll process both of them\n       */\n\n      if (m.removedNodes.length > 0) {\n        for (var j = 0; j < m.removedNodes.length; j += 1) {\n          isProtectStyleElModified = true;\n          protectStyleEl.appendChild(m.removedNodes[j]);\n        }\n      } else if (m.oldValue) {\n        isProtectStyleElModified = true; // eslint-disable-next-line no-param-reassign\n\n        protectStyleEl.textContent = m.oldValue;\n      }\n\n      if (!isProtectStyleElModified) {\n        // @ts-ignore\n        protectStyleEl.removeAttribute('mod');\n      }\n    }\n  });\n  innerObserver.observe(protectStyleEl, {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    characterDataOldValue: true\n  });\n};\n/**\n * Applies css stylesheet\n * @param styleSelectors Array of stylesheets or selectors\n * @param verbose logging\n */\n\n\nvar applyCss = function applyCss(styleSelectors, verbose) {\n  console.log(styleSelectors);\n\n  if (!styleSelectors || !styleSelectors.length) {\n    return;\n  }\n\n  console.log(styleSelectors);\n  logMessage(verbose, \"css length: \".concat(styleSelectors.length));\n  var styleElement = document.createElement('style');\n  styleElement.setAttribute('type', 'text/css');\n  (document.head || document.documentElement).appendChild(styleElement);\n  var selectors = styleSelectors.map(function (s) {\n    return s.trim();\n  });\n  console.log(selectors);\n  selectors.forEach(function (selector) {\n    styleElement.sheet.insertRule(selector);\n  });\n  protectStyleElementContent(styleElement);\n};\n/**\n * Applies Extended Css stylesheet\n *\n * @param extendedCss Array with ExtendedCss stylesheets\n * @param verbose logging\n */\n\n\nvar applyExtendedCss = function applyExtendedCss(extendedCss, verbose) {\n  if (!extendedCss || !extendedCss.length) {\n    return;\n  }\n\n  logMessage(verbose, \"extended css length: \".concat(extendedCss.length));\n  var extcss = new extended_css__WEBPACK_IMPORTED_MODULE_3__.default({\n    styleSheet: extendedCss.filter(function (s) {\n      return s.length > 0;\n    }).map(function (s) {\n      return s.trim();\n    }).map(function (s) {\n      return s[s.length - 1] !== '}' ? \"\".concat(s, \" {display:none!important;}\") : s;\n    }).join('\\n')\n  });\n  extcss.apply();\n};\n/**\n * Applies scriptlets\n *\n * @param scriptletsData Array with scriptlets data\n * @param verbose logging\n */\n\n\nvar applyScriptlets = function applyScriptlets(scriptletsData, verbose) {\n  if (!scriptletsData || !scriptletsData.length) {\n    return;\n  }\n\n  logMessage(verbose, \"scriptlets length: \".concat(scriptletsData.length));\n  var scriptletExecutableScripts = scriptletsData.map(function (s) {\n    var param = JSON.parse(s);\n    param.engine = 'safari-extension';\n\n    if (verbose) {\n      param.verbose = true;\n    }\n\n    var code = (scriptlets__WEBPACK_IMPORTED_MODULE_4___default()) && scriptlets__WEBPACK_IMPORTED_MODULE_4___default().invoke(param);\n    return code || '';\n  });\n  console.log(scriptletExecutableScripts);\n  executeScripts(scriptletExecutableScripts); // @ts-ignore\n\n  console.log(window.adg);\n};\n/**\n * Applies injected script and css\n *\n * @param selectorsAndScripts\n * @param verbose\n */\n\n\nvar applyAdvancedBlockingData = function applyAdvancedBlockingData(selectorsAndScripts) {\n  var verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  logMessage(verbose, 'Applying scripts and css..');\n  logMessage(verbose, \"Frame url: \".concat(window.location.href));\n  applyScripts(selectorsAndScripts.scripts, verbose);\n  applyCss(selectorsAndScripts.cssInject, verbose);\n  applyExtendedCss(selectorsAndScripts.cssExtended, verbose);\n  applyScriptlets(selectorsAndScripts.scriptlets, verbose);\n  logMessage(verbose, 'Applying scripts and css - done');\n};\n\nvar main = /*#__PURE__*/function () {\n  var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.default)( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2() {\n    var selectorsAndScripts;\n    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(document instanceof HTMLDocument)) {\n              _context2.next = 6;\n              break;\n            }\n\n            if (!(window.location.href && window.location.href.indexOf('http') === 0)) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 4;\n            return getSelectorsAndScripts();\n\n          case 4:\n            selectorsAndScripts = _context2.sent;\n\n            if (selectorsAndScripts) {\n              applyAdvancedBlockingData(selectorsAndScripts);\n            }\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function main() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmain();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL3NyYy9jb250ZW50LnRzPzEwNWQiXSwibmFtZXMiOlsibG9nTWVzc2FnZSIsInZlcmJvc2UiLCJtZXNzYWdlIiwiY29uc29sZSIsImxvZyIsImdldFNlbGVjdG9yc0FuZFNjcmlwdHMiLCJicm93c2VyIiwidHlwZSIsIk1lc3NhZ2VzIiwiZGF0YSIsInVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsInJlc3BvbnNlIiwiSlNPTiIsInBhcnNlIiwiZXhlY3V0ZVNjcmlwdHMiLCJzY3JpcHRzIiwidW5zaGlmdCIsInB1c2giLCJzY3JpcHRUYWciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJ0ZXh0Q29udGVudCIsImpvaW4iLCJwYXJlbnQiLCJoZWFkIiwiZG9jdW1lbnRFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBseVNjcmlwdHMiLCJsZW5ndGgiLCJyZXZlcnNlIiwicHJvdGVjdFN0eWxlRWxlbWVudENvbnRlbnQiLCJwcm90ZWN0U3R5bGVFbCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiaW5uZXJPYnNlcnZlciIsIm11dGF0aW9ucyIsImkiLCJtIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiaXNQcm90ZWN0U3R5bGVFbE1vZGlmaWVkIiwicmVtb3ZlZE5vZGVzIiwiaiIsIm9sZFZhbHVlIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiYXBwbHlDc3MiLCJzdHlsZVNlbGVjdG9ycyIsInN0eWxlRWxlbWVudCIsInNlbGVjdG9ycyIsIm1hcCIsInMiLCJ0cmltIiwiZm9yRWFjaCIsInNlbGVjdG9yIiwic2hlZXQiLCJpbnNlcnRSdWxlIiwiYXBwbHlFeHRlbmRlZENzcyIsImV4dGVuZGVkQ3NzIiwiZXh0Y3NzIiwiRXh0ZW5kZWRDc3MiLCJzdHlsZVNoZWV0IiwiZmlsdGVyIiwiYXBwbHkiLCJhcHBseVNjcmlwdGxldHMiLCJzY3JpcHRsZXRzRGF0YSIsInNjcmlwdGxldEV4ZWN1dGFibGVTY3JpcHRzIiwicGFyYW0iLCJlbmdpbmUiLCJjb2RlIiwic2NyaXB0bGV0cyIsImFkZyIsImFwcGx5QWR2YW5jZWRCbG9ja2luZ0RhdGEiLCJzZWxlY3RvcnNBbmRTY3JpcHRzIiwiY3NzSW5qZWN0IiwiY3NzRXh0ZW5kZWQiLCJtYWluIiwiSFRNTERvY3VtZW50IiwiaW5kZXhPZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQSxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFDQyxPQUFELEVBQW1CQyxPQUFuQixFQUF1QztBQUN0RCxNQUFJRCxPQUFKLEVBQWE7QUFDVEUsV0FBTyxDQUFDQyxHQUFSLGdCQUFvQkYsT0FBcEI7QUFDSDtBQUNKLENBSkQ7O0FBTUEsSUFBTUcsc0JBQXNCO0FBQUEsbUxBQUc7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFDSkMsaUZBQUEsQ0FBNEI7QUFDL0NDLGtCQUFJLEVBQUVDLHNFQUR5QztBQUUvQ0Msa0JBQUksRUFBRTtBQUNGQyxtQkFBRyxFQUFFQyxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDO0FBRG5CO0FBRnlDLGFBQTVCLENBREk7O0FBQUE7QUFDckJDLG9CQURxQjs7QUFBQSxrQkFRdkJBLFFBQVEsSUFBSSxJQVJXO0FBQUE7QUFBQTtBQUFBOztBQVN2QlgsbUJBQU8sQ0FBQ0MsR0FBUixDQUFZLHdCQUFaO0FBVHVCLDZDQVVoQixJQVZnQjs7QUFBQTtBQUFBO0FBQUEsNkNBY2hCVyxJQUFJLENBQUNDLEtBQUwsQ0FBV0YsUUFBWCxDQWRnQjs7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QUFDQUQsWUFBVSxDQUFDQyxPQUFELHVCQUF3QlUsTUFBTSxDQUFDQyxRQUFQLENBQWdCQyxJQUF4QyxFQUFWO0FBRUFvQixjQUFZLENBQUNrRCxtQkFBbUIsQ0FBQ2pFLE9BQXJCLEVBQThCakIsT0FBOUIsQ0FBWjtBQUNBdUQsVUFBUSxDQUFDMkIsbUJBQW1CLENBQUNDLFNBQXJCLEVBQWdDbkYsT0FBaEMsQ0FBUjtBQUNBa0Usa0JBQWdCLENBQUNnQixtQkFBbUIsQ0FBQ0UsV0FBckIsRUFBa0NwRixPQUFsQyxDQUFoQjtBQUNBeUUsaUJBQWUsQ0FBQ1MsbUJBQW1CLENBQUNILFVBQXJCLEVBQWlDL0UsT0FBakMsQ0FBZjtBQUVBRCxZQUFVLENBQUNDLE9BQUQsRUFBVSxpQ0FBVixDQUFWO0FBQ0gsQ0FWRDs7QUFZQSxJQUFNcUYsSUFBSTtBQUFBLG9MQUFHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQU9MaEUsUUFBUSxZQUFZaUUsWUFQZjtBQUFBO0FBQUE7QUFBQTs7QUFBQSxrQkFRRDVFLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsSUFBaEIsSUFBd0JGLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsSUFBaEIsQ0FBcUIyRSxPQUFyQixDQUE2QixNQUE3QixNQUF5QyxDQVJoRTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLG1CQVNpQ25GLHNCQUFzQixFQVR2RDs7QUFBQTtBQVNLOEUsK0JBVEw7O0FBVUQsZ0JBQUlBLG1CQUFKLEVBQXlCO0FBQ3JCRCx1Q0FBeUIsQ0FBQ0MsbUJBQUQsQ0FBekI7QUFDSDs7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUFIOztBQUFBLGtCQUFKRyxJQUFJO0FBQUE7QUFBQTtBQUFBLEdBQVY7O0FBaUJBQSxJQUFJIiwiZmlsZSI6Ii4vc3JjL2NvbnRlbnQudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5pbXBvcnQgeyBicm93c2VyIH0gZnJvbSAnd2ViZXh0ZW5zaW9uLXBvbHlmaWxsLXRzJztcbmltcG9ydCBFeHRlbmRlZENzcyBmcm9tICdleHRlbmRlZC1jc3MnO1xuaW1wb3J0IHNjcmlwdGxldHMgZnJvbSAnc2NyaXB0bGV0cyc7XG5cbmltcG9ydCB7IE1lc3NhZ2VzIH0gZnJvbSAnLi9wYWdlcy9jb21tb24vY29uc3RhbnRzJztcblxuaW50ZXJmYWNlIFNlbGVjdG9yc0FuZFNjcmlwdHMge1xuICAgIHNjcmlwdHM6IHN0cmluZ1tdLFxuICAgIGNzc0luamVjdDogc3RyaW5nW10sXG4gICAgY3NzRXh0ZW5kZWQ6IHN0cmluZ1tdLFxuICAgIHNjcmlwdGxldHM6IHN0cmluZ1tdLFxufVxuXG4vKipcbiAqIExvZ3MgYSBtZXNzYWdlIGlmIHZlcmJvc2UgaXMgdHJ1ZVxuICpcbiAqIEBwYXJhbSB2ZXJib3NlXG4gKiBAcGFyYW0gbWVzc2FnZVxuICovXG5jb25zdCBsb2dNZXNzYWdlID0gKHZlcmJvc2U6IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZykgPT4ge1xuICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAoQUcpICR7bWVzc2FnZX1gKTtcbiAgICB9XG59O1xuXG5jb25zdCBnZXRTZWxlY3RvcnNBbmRTY3JpcHRzID0gYXN5bmMgKCk6IFByb21pc2U8U2VsZWN0b3JzQW5kU2NyaXB0cyB8IG51bGw+ID0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGJyb3dzZXIucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6IE1lc3NhZ2VzLkdldFJ1bGVzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1cmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0FHOiBkYXRhIG5vdCByZWFkeSB5ZXQnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UpIGFzIFNlbGVjdG9yc0FuZFNjcmlwdHM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQUc6IGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBmZXRjaGluZyBzZWxlY3RvcnMgYW5kIHNjcmlwdHMgZnJvbSBiYWNrZ3JvdW5kIHBhZ2UnLCBlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIHNjcmlwdHMgaW4gYSBwYWdlIGNvbnRleHQgYW5kIGNsZWFudXAgaXRzZWxmIHdoZW4gZXhlY3V0aW9uIGNvbXBsZXRlc1xuICogQHBhcmFtIHNjcmlwdHMgU2NyaXB0cyBhcnJheSB0byBleGVjdXRlXG4gKi9cbmNvbnN0IGV4ZWN1dGVTY3JpcHRzID0gKHNjcmlwdHM6IHN0cmluZ1tdKSA9PiB7XG4gICAgLy8gV3JhcCB3aXRoIHRyeSBjYXRjaFxuICAgIHNjcmlwdHMudW5zaGlmdCgnKCBmdW5jdGlvbiAoKSB7IHRyeSB7Jyk7XG4gICAgc2NyaXB0cy5wdXNoKFwifSBjYXRjaCAoZXgpIHsgY29uc29sZS5lcnJvcignRXJyb3IgZXhlY3V0aW5nIEFHIGpzOiAnICsgZXgpOyB9IH0pKCk7XCIpO1xuXG4gICAgY29uc3Qgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0VGFnLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcbiAgICBzY3JpcHRUYWcudGV4dENvbnRlbnQgPSBzY3JpcHRzLmpvaW4oJ1xcclxcbicpO1xuXG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG4gICAgaWYgKHNjcmlwdFRhZy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHNjcmlwdFRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdFRhZyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIEpTIGluamVjdGlvbnMuXG4gKiBAcGFyYW0gc2NyaXB0cyBBcnJheSB3aXRoIEpTIHNjcmlwdHNcbiAqIEBwYXJhbSB2ZXJib3NlIGxvZ2dpbmdcbiAqL1xuY29uc3QgYXBwbHlTY3JpcHRzID0gKHNjcmlwdHM6IHN0cmluZ1tdLCB2ZXJib3NlOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFzY3JpcHRzIHx8IHNjcmlwdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dNZXNzYWdlKHZlcmJvc2UsIGBzY3JpcHRzIGxlbmd0aDogJHtzY3JpcHRzLmxlbmd0aH1gKTtcbiAgICBleGVjdXRlU2NyaXB0cyhzY3JpcHRzLnJldmVyc2UoKSk7XG59O1xuXG4vKipcbiAqIFByb3RlY3RzIHNwZWNpZmllZCBzdHlsZSBlbGVtZW50IGZyb20gY2hhbmdlcyB0byB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQWRkIGEgbXV0YXRpb24gb2JzZXJ2ZXIsIHdoaWNoIGlzIGFkZHMgb3VyIHJ1bGVzIGFnYWluIGlmIGl0IHdhcyByZW1vdmVkXG4gKlxuICogQHBhcmFtIHByb3RlY3RTdHlsZUVsIHByb3RlY3RlZCBzdHlsZSBlbGVtZW50XG4gKi9cbmNvbnN0IHByb3RlY3RTdHlsZUVsZW1lbnRDb250ZW50ID0gKHByb3RlY3RTdHlsZUVsOiBOb2RlKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IE11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBvYnNlcnZlciwgd2hpY2ggb2JzZXJ2ZSBwcm90ZWN0U3R5bGVFbCBpbm5lciBjaGFuZ2VzLCB3aXRob3V0IGRlbGV0aW5nIHN0eWxlRWwgKi9cbiAgICBjb25zdCBpbm5lck9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtdXRhdGlvbnNbaV07XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAocHJvdGVjdFN0eWxlRWwuaGFzQXR0cmlidXRlKCdtb2QnKSAmJiBwcm90ZWN0U3R5bGVFbC5nZXRBdHRyaWJ1dGUoJ21vZCcpID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHByb3RlY3RTdHlsZUVsLnJlbW92ZUF0dHJpYnV0ZSgnbW9kJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHByb3RlY3RTdHlsZUVsLnNldEF0dHJpYnV0ZSgnbW9kJywgJ2lubmVyJyk7XG4gICAgICAgICAgICBsZXQgaXNQcm90ZWN0U3R5bGVFbE1vZGlmaWVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZnVydGhlciwgdGhlcmUgYXJlIHR3byBtdXR1YWxseSBleGNsdXNpdmUgc2l0dWF0aW9uczogZWl0aGVyIHRoZXJlIHdlcmUgY2hhbmdlc1xuICAgICAgICAgICAgICogdGhlIHRleHQgb2YgcHJvdGVjdFN0eWxlRWwsIGVpdGhlciB0aGVyZSB3YXMgcmVtb3ZlcyBhIHdob2xlIGNoaWxkIFwidGV4dFwiXG4gICAgICAgICAgICAgKiBlbGVtZW50IG9mIHByb3RlY3RTdHlsZUVsIHdlJ2xsIHByb2Nlc3MgYm90aCBvZiB0aGVtXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChtLnJlbW92ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpc1Byb3RlY3RTdHlsZUVsTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwcm90ZWN0U3R5bGVFbC5hcHBlbmRDaGlsZChtLnJlbW92ZWROb2Rlc1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaXNQcm90ZWN0U3R5bGVFbE1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBwcm90ZWN0U3R5bGVFbC50ZXh0Q29udGVudCA9IG0ub2xkVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNQcm90ZWN0U3R5bGVFbE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHByb3RlY3RTdHlsZUVsLnJlbW92ZUF0dHJpYnV0ZSgnbW9kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBpbm5lck9ic2VydmVyLm9ic2VydmUocHJvdGVjdFN0eWxlRWwsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgY3NzIHN0eWxlc2hlZXRcbiAqIEBwYXJhbSBzdHlsZVNlbGVjdG9ycyBBcnJheSBvZiBzdHlsZXNoZWV0cyBvciBzZWxlY3RvcnNcbiAqIEBwYXJhbSB2ZXJib3NlIGxvZ2dpbmdcbiAqL1xuY29uc3QgYXBwbHlDc3MgPSAoc3R5bGVTZWxlY3RvcnM6IHN0cmluZ1tdLCB2ZXJib3NlOiBib29sZWFuKSA9PiB7XG4gICAgY29uc29sZS5sb2coc3R5bGVTZWxlY3RvcnMpO1xuICAgIGlmICghc3R5bGVTZWxlY3RvcnMgfHwgIXN0eWxlU2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coc3R5bGVTZWxlY3RvcnMpO1xuXG4gICAgbG9nTWVzc2FnZSh2ZXJib3NlLCBgY3NzIGxlbmd0aDogJHtzdHlsZVNlbGVjdG9ycy5sZW5ndGh9YCk7XG5cbiAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cbiAgICBjb25zdCBzZWxlY3RvcnMgPSBzdHlsZVNlbGVjdG9ycy5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgICBjb25zb2xlLmxvZyhzZWxlY3RvcnMpO1xuICAgIHNlbGVjdG9ycy5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xuICAgICAgICBzdHlsZUVsZW1lbnQuc2hlZXQhLmluc2VydFJ1bGUoc2VsZWN0b3IpO1xuICAgIH0pO1xuXG4gICAgcHJvdGVjdFN0eWxlRWxlbWVudENvbnRlbnQoc3R5bGVFbGVtZW50KTtcbn07XG5cbi8qKlxuICogQXBwbGllcyBFeHRlbmRlZCBDc3Mgc3R5bGVzaGVldFxuICpcbiAqIEBwYXJhbSBleHRlbmRlZENzcyBBcnJheSB3aXRoIEV4dGVuZGVkQ3NzIHN0eWxlc2hlZXRzXG4gKiBAcGFyYW0gdmVyYm9zZSBsb2dnaW5nXG4gKi9cbmNvbnN0IGFwcGx5RXh0ZW5kZWRDc3MgPSAoZXh0ZW5kZWRDc3M6IHN0cmluZ1tdLCB2ZXJib3NlOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFleHRlbmRlZENzcyB8fCAhZXh0ZW5kZWRDc3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2dNZXNzYWdlKHZlcmJvc2UsIGBleHRlbmRlZCBjc3MgbGVuZ3RoOiAke2V4dGVuZGVkQ3NzLmxlbmd0aH1gKTtcbiAgICBjb25zdCBleHRjc3MgPSBuZXcgRXh0ZW5kZWRDc3Moe1xuICAgICAgICBzdHlsZVNoZWV0OiBleHRlbmRlZENzc1xuICAgICAgICAgICAgLmZpbHRlcigocykgPT4gcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgLm1hcCgocykgPT4gcy50cmltKCkpXG4gICAgICAgICAgICAubWFwKChzKSA9PiAoc1tzLmxlbmd0aCAtIDFdICE9PSAnfScgPyBgJHtzfSB7ZGlzcGxheTpub25lIWltcG9ydGFudDt9YCA6IHMpKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxuICAgIH0pO1xuICAgIGV4dGNzcy5hcHBseSgpO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHNjcmlwdGxldHNcbiAqXG4gKiBAcGFyYW0gc2NyaXB0bGV0c0RhdGEgQXJyYXkgd2l0aCBzY3JpcHRsZXRzIGRhdGFcbiAqIEBwYXJhbSB2ZXJib3NlIGxvZ2dpbmdcbiAqL1xuY29uc3QgYXBwbHlTY3JpcHRsZXRzID0gKHNjcmlwdGxldHNEYXRhOiBzdHJpbmdbXSwgdmVyYm9zZTogYm9vbGVhbikgPT4ge1xuICAgIGlmICghc2NyaXB0bGV0c0RhdGEgfHwgIXNjcmlwdGxldHNEYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nTWVzc2FnZSh2ZXJib3NlLCBgc2NyaXB0bGV0cyBsZW5ndGg6ICR7c2NyaXB0bGV0c0RhdGEubGVuZ3RofWApO1xuICAgIGNvbnN0IHNjcmlwdGxldEV4ZWN1dGFibGVTY3JpcHRzID0gc2NyaXB0bGV0c0RhdGFcbiAgICAgICAgLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICAgICAgcGFyYW0uZW5naW5lID0gJ3NhZmFyaS1leHRlbnNpb24nO1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBwYXJhbS52ZXJib3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHNjcmlwdGxldHMgJiYgc2NyaXB0bGV0cy5pbnZva2UocGFyYW0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGUgfHwgJyc7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coc2NyaXB0bGV0RXhlY3V0YWJsZVNjcmlwdHMpO1xuICAgIGV4ZWN1dGVTY3JpcHRzKHNjcmlwdGxldEV4ZWN1dGFibGVTY3JpcHRzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc29sZS5sb2cod2luZG93LmFkZyk7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgaW5qZWN0ZWQgc2NyaXB0IGFuZCBjc3NcbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3JzQW5kU2NyaXB0c1xuICogQHBhcmFtIHZlcmJvc2VcbiAqL1xuY29uc3QgYXBwbHlBZHZhbmNlZEJsb2NraW5nRGF0YSA9IChzZWxlY3RvcnNBbmRTY3JpcHRzOiBTZWxlY3RvcnNBbmRTY3JpcHRzLCB2ZXJib3NlID0gdHJ1ZSkgPT4ge1xuICAgIGxvZ01lc3NhZ2UodmVyYm9zZSwgJ0FwcGx5aW5nIHNjcmlwdHMgYW5kIGNzcy4uJyk7XG4gICAgbG9nTWVzc2FnZSh2ZXJib3NlLCBgRnJhbWUgdXJsOiAke3dpbmRvdy5sb2NhdGlvbi5ocmVmfWApO1xuXG4gICAgYXBwbHlTY3JpcHRzKHNlbGVjdG9yc0FuZFNjcmlwdHMuc2NyaXB0cywgdmVyYm9zZSk7XG4gICAgYXBwbHlDc3Moc2VsZWN0b3JzQW5kU2NyaXB0cy5jc3NJbmplY3QsIHZlcmJvc2UpO1xuICAgIGFwcGx5RXh0ZW5kZWRDc3Moc2VsZWN0b3JzQW5kU2NyaXB0cy5jc3NFeHRlbmRlZCwgdmVyYm9zZSk7XG4gICAgYXBwbHlTY3JpcHRsZXRzKHNlbGVjdG9yc0FuZFNjcmlwdHMuc2NyaXB0bGV0cywgdmVyYm9zZSk7XG5cbiAgICBsb2dNZXNzYWdlKHZlcmJvc2UsICdBcHBseWluZyBzY3JpcHRzIGFuZCBjc3MgLSBkb25lJyk7XG59O1xuXG5jb25zdCBtYWluID0gYXN5bmMgKCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFdpdGggdGhlIGZvbGxvd2luZyBsaW1pdGF0aW9uIHdlIGZpeCBzb21lIHRyb3VibGVzIHdpdGggR21haWwgYW5kIHNjcm9sbGluZ1xuICAgICAqIG9uIHZhcmlvdXMgd2Vic2l0ZXNcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vQWRHdWFyZEZvclNhZmFyaS9pc3N1ZXMvNDMzXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0FkR3VhcmRGb3JTYWZhcmkvaXNzdWVzLzQ0MVxuICAgICAqL1xuICAgIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mIEhUTUxEb2N1bWVudCkge1xuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYgJiYgd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignaHR0cCcpID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvcnNBbmRTY3JpcHRzID0gYXdhaXQgZ2V0U2VsZWN0b3JzQW5kU2NyaXB0cygpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yc0FuZFNjcmlwdHMpIHtcbiAgICAgICAgICAgICAgICBhcHBseUFkdmFuY2VkQmxvY2tpbmdEYXRhKHNlbGVjdG9yc0FuZFNjcmlwdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxubWFpbigpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/content.ts\n");

/***/ }),

/***/ "./src/pages/common/constants.ts":
/*!***************************************!*\
  !*** ./src/pages/common/constants.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Messages\": () => (/* binding */ Messages)\n/* harmony export */ });\nvar Messages;\n\n(function (Messages) {\n  Messages[\"GetRules\"] = \"get_rules\";\n  Messages[\"WriteInNativeLog\"] = \"write_in_native_log\";\n})(Messages || (Messages = {}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL3NyYy9wYWdlcy9jb21tb24vY29uc3RhbnRzLnRzP2U2ZGYiXSwibmFtZXMiOlsiTWVzc2FnZXMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBTyxJQUFLQSxRQUFaOztXQUFZQSxRO0FBQUFBLFU7QUFBQUEsVTtHQUFBQSxRLEtBQUFBLFEiLCJmaWxlIjoiLi9zcmMvcGFnZXMvY29tbW9uL2NvbnN0YW50cy50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBlbnVtIE1lc3NhZ2VzIHtcbiAgICBHZXRSdWxlcyA9ICdnZXRfcnVsZXMnLFxuICAgIFdyaXRlSW5OYXRpdmVMb2cgPSAnd3JpdGVfaW5fbmF0aXZlX2xvZycsXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/common/constants.ts\n");

/***/ }),

/***/ "./node_modules/extended-css/dist/extended-css.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/extended-css/dist/extended-css.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*! extended-css - v1.3.12 - Mon May 31 2021\n* https://github.com/AdguardTeam/ExtendedCss\n* Copyright (c) 2021 AdGuard. Licensed LGPL-3.0\n*/\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable no-console */\nvar utils = {};\nutils.MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n/**\n * Stores native Node textContent getter to be used for contains pseudo-class\n * because elements' 'textContent' and 'innerText' properties might be mocked\n * https://github.com/AdguardTeam/ExtendedCss/issues/127\n */\n\nutils.nodeTextContentGetter = function () {\n  var nativeNode = window.Node || Node;\n  return Object.getOwnPropertyDescriptor(nativeNode.prototype, 'textContent').get;\n}();\n\nutils.isSafariBrowser = function () {\n  var isChrome = navigator.userAgent.indexOf('Chrome') > -1;\n  var isSafari = navigator.userAgent.indexOf('Safari') > -1;\n\n  if (isSafari) {\n    if (isChrome) {\n      // Chrome seems to have both Chrome and Safari userAgents\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n}();\n/**\n * Converts regular expressions passed as pseudo class arguments into RegExp instances.\n * Have to unescape doublequote \" as well, because we escape them while enclosing such\n * arguments with doublequotes, and sizzle does not automatically unescapes them.\n */\n\n\nutils.pseudoArgToRegex = function (regexSrc, flag) {\n  flag = flag || 'i';\n  regexSrc = regexSrc.trim().replace(/\\\\([\"\\\\])/g, '$1');\n  return new RegExp(regexSrc, flag);\n};\n/**\n * Converts string to the regexp\n * @param {string} str\n * @returns {RegExp}\n */\n\n\nutils.toRegExp = function (str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n\nutils.startsWith = function (str, prefix) {\n  // if str === '', (str && false) will return ''\n  // that's why it has to be !!str\n  return !!str && str.indexOf(prefix) === 0;\n};\n\nutils.endsWith = function (str, postfix) {\n  if (!str || !postfix) {\n    return false;\n  }\n\n  if (str.endsWith) {\n    return str.endsWith(postfix);\n  }\n\n  var t = String(postfix);\n  var index = str.lastIndexOf(t);\n  return index >= 0 && index === str.length - t.length;\n};\n/**\n * Helper function for creating regular expression from a url filter rule syntax.\n */\n\n\nutils.createURLRegex = function () {\n  // Constants\n  var regexConfiguration = {\n    maskStartUrl: '||',\n    maskPipe: '|',\n    maskSeparator: '^',\n    maskAnySymbol: '*',\n    regexAnySymbol: '.*',\n    regexSeparator: '([^ a-zA-Z0-9.%_-]|$)',\n    regexStartUrl: '^(http|https|ws|wss)://([a-z0-9-_.]+\\\\.)?',\n    regexStartString: '^',\n    regexEndString: '$'\n  }; // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp\n  // should be escaped . * + ? ^ $ { } ( ) | [ ] / \\\n  // except of * | ^\n\n  var specials = ['.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '\\\\', '/'];\n  var specialsRegex = new RegExp(\"[\".concat(specials.join('\\\\'), \"]\"), 'g');\n  /**\n   * Escapes regular expression string\n   */\n\n  var escapeRegExp = function escapeRegExp(str) {\n    return str.replace(specialsRegex, '\\\\$&');\n  };\n\n  var replaceAll = function replaceAll(str, find, replace) {\n    if (!str) {\n      return str;\n    }\n\n    return str.split(find).join(replace);\n  };\n  /**\n   * Main function that converts a url filter rule string to a regex.\n   * @param {string} str\n   * @return {RegExp}\n   */\n\n\n  var createRegexText = function createRegexText(str) {\n    var regex = escapeRegExp(str);\n\n    if (utils.startsWith(regex, regexConfiguration.maskStartUrl)) {\n      regex = regex.substring(0, regexConfiguration.maskStartUrl.length) + replaceAll(regex.substring(regexConfiguration.maskStartUrl.length, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } else if (utils.startsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regex.substring(0, regexConfiguration.maskPipe.length) + replaceAll(regex.substring(regexConfiguration.maskPipe.length, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } else {\n      regex = replaceAll(regex.substring(0, regex.length - 1), '\\|', '\\\\|') + regex.substring(regex.length - 1);\n    } // Replacing special url masks\n\n\n    regex = replaceAll(regex, regexConfiguration.maskAnySymbol, regexConfiguration.regexAnySymbol);\n    regex = replaceAll(regex, regexConfiguration.maskSeparator, regexConfiguration.regexSeparator);\n\n    if (utils.startsWith(regex, regexConfiguration.maskStartUrl)) {\n      regex = regexConfiguration.regexStartUrl + regex.substring(regexConfiguration.maskStartUrl.length);\n    } else if (utils.startsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regexConfiguration.regexStartString + regex.substring(regexConfiguration.maskPipe.length);\n    }\n\n    if (utils.endsWith(regex, regexConfiguration.maskPipe)) {\n      regex = regex.substring(0, regex.length - 1) + regexConfiguration.regexEndString;\n    }\n\n    return new RegExp(regex, 'i');\n  };\n\n  return createRegexText;\n}();\n/**\n * Creates an object implementing Location interface from a url.\n * An alternative to URL.\n * https://github.com/AdguardTeam/FingerprintingBlocker/blob/master/src/shared/url.ts#L64\n */\n\n\nutils.createLocation = function (href) {\n  var anchor = document.createElement('a');\n  anchor.href = href;\n\n  if (anchor.host === '') {\n    anchor.href = anchor.href; // eslint-disable-line no-self-assign\n  }\n\n  return anchor;\n};\n/**\n * Checks whether A has the same origin as B.\n * @param {string} urlA location.href of A.\n * @param {Location} locationB location of B.\n * @param {string} domainB document.domain of B.\n * @return {boolean}\n */\n\n\nutils.isSameOrigin = function (urlA, locationB, domainB) {\n  var locationA = utils.createLocation(urlA); // eslint-disable-next-line no-script-url\n\n  if (locationA.protocol === 'javascript:' || locationA.href === 'about:blank') {\n    return true;\n  }\n\n  if (locationA.protocol === 'data:' || locationA.protocol === 'file:') {\n    return false;\n  }\n\n  return locationA.hostname === domainB && locationA.port === locationB.port && locationA.protocol === locationB.protocol;\n};\n/**\n * A helper class to throttle function calls with setTimeout and requestAnimationFrame.\n */\n\n\nutils.AsyncWrapper = function () {\n  /**\n   * PhantomJS passes a wrong timestamp to the requestAnimationFrame callback and that breaks the AsyncWrapper logic\n   * https://github.com/ariya/phantomjs/issues/14832\n   */\n  var supported = typeof window.requestAnimationFrame !== 'undefined' && !/phantom/i.test(navigator.userAgent);\n  var rAF = supported ? requestAnimationFrame : setTimeout;\n  var cAF = supported ? cancelAnimationFrame : clearTimeout;\n  var perf = supported ? performance : Date;\n  /**\n   * @param {Function} callback\n   * @param {number} throttle number, the provided callback should be executed twice\n   * in this time frame.\n   * @constructor\n   */\n\n  function AsyncWrapper(callback, throttle) {\n    this.callback = callback;\n    this.throttle = throttle;\n    this.wrappedCallback = this.wrappedCallback.bind(this);\n\n    if (this.wrappedAsapCallback) {\n      this.wrappedAsapCallback = this.wrappedAsapCallback.bind(this);\n    }\n  }\n  /** @private */\n\n\n  AsyncWrapper.prototype.wrappedCallback = function (ts) {\n    this.lastRun = isNumber(ts) ? ts : perf.now();\n    delete this.rAFid;\n    delete this.timerId;\n    delete this.asapScheduled;\n    this.callback();\n  };\n  /** @private Indicates whether there is a scheduled callback. */\n\n\n  AsyncWrapper.prototype.hasPendingCallback = function () {\n    return isNumber(this.rAFid) || isNumber(this.timerId);\n  };\n  /**\n   * Schedules a function call before the next animation frame.\n   */\n\n\n  AsyncWrapper.prototype.run = function () {\n    if (this.hasPendingCallback()) {\n      // There is a pending execution scheduled.\n      return;\n    }\n\n    if (typeof this.lastRun !== 'undefined') {\n      var elapsed = perf.now() - this.lastRun;\n\n      if (elapsed < this.throttle) {\n        this.timerId = setTimeout(this.wrappedCallback, this.throttle - elapsed);\n        return;\n      }\n    }\n\n    this.rAFid = rAF(this.wrappedCallback);\n  };\n  /**\n   * Schedules a function call in the most immenent microtask.\n   * This cannot be canceled.\n   */\n\n\n  AsyncWrapper.prototype.runAsap = function () {\n    if (this.asapScheduled) {\n      return;\n    }\n\n    this.asapScheduled = true;\n    cAF(this.rAFid);\n    clearTimeout(this.timerId);\n\n    if (utils.MutationObserver) {\n      /**\n       * Using MutationObservers to access microtask queue is a standard technique,\n       * used in ASAP library\n       * {@link https://github.com/kriskowal/asap/blob/master/browser-raw.js#L140}\n       */\n      if (!this.mo) {\n        this.mo = new utils.MutationObserver(this.wrappedCallback);\n        this.node = document.createTextNode(1);\n        this.mo.observe(this.node, {\n          characterData: true\n        });\n      }\n\n      this.node.nodeValue = -this.node.nodeValue;\n    } else {\n      setTimeout(this.wrappedCallback);\n    }\n  };\n  /**\n   * Runs scheduled execution immediately, if there were any.\n   */\n\n\n  AsyncWrapper.prototype.runImmediately = function () {\n    if (this.hasPendingCallback()) {\n      cAF(this.rAFid);\n      clearTimeout(this.timerId);\n      delete this.rAFid;\n      delete this.timerId;\n      this.wrappedCallback();\n    }\n  };\n\n  AsyncWrapper.now = function () {\n    return perf.now();\n  };\n\n  return AsyncWrapper;\n}();\n/**\n * Stores native OdP to be used in WeakMap and Set polyfills.\n */\n\n\nutils.defineProperty = Object.defineProperty;\nutils.WeakMap = typeof WeakMap !== 'undefined' ? WeakMap : function () {\n  /** Originally based on {@link https://github.com/Polymer/WeakMap} */\n  var counter = Date.now() % 1e9;\n\n  var WeakMap = function WeakMap() {\n    this.name = \"__st\".concat(Math.random() * 1e9 >>> 0).concat(counter++, \"__\");\n  };\n\n  WeakMap.prototype = {\n    set: function set(key, value) {\n      var entry = key[this.name];\n\n      if (entry && entry[0] === key) {\n        entry[1] = value;\n      } else {\n        utils.defineProperty(key, this.name, {\n          value: [key, value],\n          writable: true\n        });\n      }\n\n      return this;\n    },\n    get: function get(key) {\n      var entry = key[this.name];\n      return entry && entry[0] === key ? entry[1] : undefined;\n    },\n    delete: function _delete(key) {\n      var entry = key[this.name];\n\n      if (!entry) {\n        return false;\n      }\n\n      var hasValue = entry[0] === key;\n      delete entry[0];\n      delete entry[1];\n      return hasValue;\n    },\n    has: function has(key) {\n      var entry = key[this.name];\n\n      if (!entry) {\n        return false;\n      }\n\n      return entry[0] === key;\n    }\n  };\n  return WeakMap;\n}();\nutils.Set = typeof Set !== 'undefined' ? Set : function () {\n  var counter = Date.now() % 1e9;\n  /**\n   * A polyfill which covers only the basic usage.\n   * Only supports methods that are supported in IE11.\n   * {@link https://docs.microsoft.com/en-us/scripting/javascript/reference/set-object-javascript}\n   * Assumes that 'key's are all objects, not primitives such as a number.\n   *\n   * @param {Array} items Initial items in this set\n   */\n\n  var Set = function Set(items) {\n    this.name = \"__st\".concat(Math.random() * 1e9 >>> 0).concat(counter++, \"__\");\n    this.keys = [];\n\n    if (items && items.length) {\n      var iItems = items.length;\n\n      while (iItems--) {\n        this.add(items[iItems]);\n      }\n    }\n  };\n\n  Set.prototype = {\n    add: function add(key) {\n      if (!isNumber(key[this.name])) {\n        var index = this.keys.push(key) - 1;\n        utils.defineProperty(key, this.name, {\n          value: index,\n          writable: true\n        });\n      }\n    },\n    delete: function _delete(key) {\n      if (isNumber(key[this.name])) {\n        var index = key[this.name];\n        delete this.keys[index];\n        key[this.name] = undefined;\n      }\n    },\n    has: function has(key) {\n      return isNumber(key[this.name]);\n    },\n    clear: function clear() {\n      this.keys.forEach(function (key) {\n        key[this.name] = undefined;\n      });\n      this.keys.length = 0;\n    },\n    forEach: function forEach(cb) {\n      var that = this;\n      this.keys.forEach(function (value) {\n        cb(value, value, that);\n      });\n    }\n  };\n  utils.defineProperty(Set.prototype, 'size', {\n    get: function get() {\n      // Skips holes.\n      return this.keys.reduce(function (acc) {\n        return acc + 1;\n      }, 0);\n    }\n  });\n  return Set;\n}();\n/**\n * Vendor-specific Element.prototype.matches\n */\n\nutils.matchesPropertyName = function () {\n  var props = ['matches', 'matchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector', 'webkitMatchesSelector'];\n\n  for (var i = 0; i < 6; i++) {\n    if (Element.prototype.hasOwnProperty(props[i])) {\n      return props[i];\n    }\n  }\n}();\n/**\n * Provides stats information\n */\n\n\nutils.Stats = function () {\n  /** @member {Array<number>} */\n  this.array = [];\n  /** @member {number} */\n\n  this.length = 0;\n  var zeroDescriptor = {\n    value: 0,\n    writable: true\n  };\n  /** @member {number} @private */\n\n  Object.defineProperty(this, 'sum', zeroDescriptor);\n  /** @member {number} @private */\n\n  Object.defineProperty(this, 'squaredSum', zeroDescriptor);\n};\n/**\n * @param {number} dataPoint data point\n */\n\n\nutils.Stats.prototype.push = function (dataPoint) {\n  this.array.push(dataPoint);\n  this.length++;\n  this.sum += dataPoint;\n  this.squaredSum += dataPoint * dataPoint;\n  /** @member {number} */\n\n  this.mean = this.sum / this.length;\n  /** @member {number} */\n  // eslint-disable-next-line no-restricted-properties\n\n  this.stddev = Math.sqrt(this.squaredSum / this.length - Math.pow(this.mean, 2));\n};\n/** Safe console.error version */\n\n\nutils.logError = typeof console !== 'undefined' && console.error && Function.prototype.bind && console.error.bind ? console.error.bind(window.console) : console.error;\n/** Safe console.info version */\n\nutils.logInfo = typeof console !== 'undefined' && console.info && Function.prototype.bind && console.info.bind ? console.info.bind(window.console) : console.info;\n\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n/**\n * Returns path to element we will use as element identifier\n * @param {Element} inputEl\n * @returns {string} - path to the element\n */\n\n\nutils.getNodeSelector = function (inputEl) {\n  if (!(inputEl instanceof Element)) {\n    throw new Error('Function received argument with wrong type');\n  }\n\n  var el = inputEl;\n  var path = []; // we need to check '!!el' first because it is possible\n  // that some ancestor of the inputEl was removed before it\n\n  while (!!el && el.nodeType === Node.ELEMENT_NODE) {\n    var selector = el.nodeName.toLowerCase();\n\n    if (el.id && typeof el.id === 'string') {\n      selector += \"#\".concat(el.id);\n      path.unshift(selector);\n      break;\n    } else {\n      var sibling = el;\n      var nth = 1;\n\n      while (sibling.previousSibling) {\n        sibling = sibling.previousSibling;\n\n        if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName.toLowerCase() === selector) {\n          nth++;\n        }\n      }\n\n      if (nth !== 1) {\n        selector += \":nth-of-type(\".concat(nth, \")\");\n      }\n    }\n\n    path.unshift(selector);\n    el = el.parentNode;\n  }\n\n  return path.join(' > ');\n};\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Helper class css utils\n *\n * @type {{normalize}}\n */\nvar cssUtils = function () {\n  /**\n   * Regex that matches AdGuard's backward compatible syntaxes.\n   */\n  var reAttrFallback = /\\[-(?:ext|abp)-([a-z-_]+)=([\"'])((?:(?=(\\\\?))\\4.)*?)\\2\\]/g;\n  /**\n   * Complex replacement function.\n   * Unescapes quote characters inside of an extended selector.\n   *\n   * @param match     Whole matched string\n   * @param name      Group 1\n   * @param quoteChar Group 2\n   * @param value     Group 3\n   */\n\n  var evaluateMatch = function evaluateMatch(match, name, quoteChar, value) {\n    // Unescape quotes\n    var re = new RegExp(\"([^\\\\\\\\]|^)\\\\\\\\\".concat(quoteChar), 'g');\n    value = value.replace(re, \"$1\".concat(quoteChar));\n    return \":\".concat(name, \"(\").concat(value, \")\");\n  }; // Sizzle's parsing of pseudo class arguments is buggy on certain circumstances\n  // We support following form of arguments:\n  // 1. for :matches-css, those of a form {propertyName}: /.*/\n  // 2. for :contains, those of a form /.*/\n  // We transform such cases in a way that Sizzle has no ambiguity in parsing arguments.\n\n\n  var reMatchesCss = /\\:(matches-css(?:-after|-before)?)\\(([a-z-\\s]*\\:\\s*\\/(?:\\\\.|[^\\/])*?\\/\\s*)\\)/g;\n  var reContains = /:(?:-abp-)?(contains|has-text)\\((\\s*\\/(?:\\\\.|[^\\/])*?\\/\\s*)\\)/g;\n  var reScope = /\\(\\:scope >/g; // Note that we require `/` character in regular expressions to be escaped.\n\n  /**\n   * Used for pre-processing pseudo-classes values with above two regexes.\n   */\n\n  var addQuotes = function addQuotes(_, c1, c2) {\n    return \":\".concat(c1, \"(\\\"\").concat(c2.replace(/[\"\\\\]/g, '\\\\$&'), \"\\\")\");\n  };\n\n  var SCOPE_REPLACER = '(>';\n  /**\n   * Normalizes specified css text in a form that can be parsed by the\n   * Sizzle engine.\n   * Normalization means\n   *  1. transforming [-ext-*=\"\"] attributes to pseudo classes\n   *  2. enclosing possibly ambiguous arguments of `:contains`,\n   *     `:matches-css` pseudo classes with quotes.\n   * @param {string} cssText\n   * @return {string}\n   */\n\n  var normalize = function normalize(cssText) {\n    var normalizedCssText = cssText.replace(reAttrFallback, evaluateMatch).replace(reMatchesCss, addQuotes).replace(reContains, addQuotes).replace(reScope, SCOPE_REPLACER);\n    return normalizedCssText;\n  };\n\n  var isSimpleSelectorValid = function isSimpleSelectorValid(selector) {\n    try {\n      document.querySelectorAll(selector);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return {\n    normalize: normalize,\n    isSimpleSelectorValid: isSimpleSelectorValid\n  };\n}();\n\n/*!\n * Sizzle CSS Selector Engine v2.3.4-pre-adguard\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2020-08-04\n */\n\n/**\n * Version of Sizzle patched by AdGuard in order to be used in the ExtendedCss module.\n * https://github.com/AdguardTeam/sizzle-extcss\n *\n * Look for [AdGuard Patch] and ADGUARD_EXTCSS markers to find out what exactly was changed by us.\n *\n * Global changes:\n * 1. Added additional parameters to the \"Sizzle.tokenize\" method so that it can be used for stylesheets parsing and validation.\n * 2. Added tokens re-sorting mechanism forcing slow pseudos to be matched last  (see sortTokenGroups).\n * 3. Fix the nonnativeSelectorCache caching -- there was no value corresponding to a key.\n * 4. Added Sizzle.compile call to the `:has` pseudo definition.\n *\n * Changes that are applied to the ADGUARD_EXTCSS build only:\n * 1. Do not expose Sizzle to the global scope. Initialize it lazily via initializeSizzle().\n * 2. Removed :contains pseudo declaration -- its syntax is changed and declared outside of Sizzle.\n * 3. Removed declarations for the following non-standard pseudo classes:\n * :parent, :header, :input, :button, :text, :first, :last, :eq,\n * :even, :odd, :lt, :gt, :nth, :radio, :checkbox, :file,\n * :password, :image, :submit, :reset\n * 4. Added es6 module export\n */\nvar Sizzle;\n/**\n * Initializes Sizzle object.\n * In the case of AdGuard ExtendedCss we want to avoid initializing Sizzle right away\n * and exposing it to the global scope.\n */\n\nvar initializeSizzle = function initializeSizzle() {\n  // jshint ignore:line\n  if (!Sizzle) {\n    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n    Sizzle = function (window) {\n      var support,\n          Expr,\n          getText,\n          isXML,\n          tokenize,\n          compile,\n          select,\n          outermostContext,\n          sortInput,\n          hasDuplicate,\n          // Local document vars\n      setDocument,\n          document,\n          docElem,\n          documentIsHTML,\n          rbuggyQSA,\n          rbuggyMatches,\n          matches,\n          contains,\n          // Instance-specific data\n      expando = \"sizzle\" + 1 * new Date(),\n          preferredDoc = window.document,\n          dirruns = 0,\n          done = 0,\n          classCache = createCache(),\n          tokenCache = createCache(),\n          compilerCache = createCache(),\n          nonnativeSelectorCache = createCache(),\n          sortOrder = function sortOrder(a, b) {\n        if (a === b) {\n          hasDuplicate = true;\n        }\n\n        return 0;\n      },\n          // Instance methods\n      hasOwn = {}.hasOwnProperty,\n          arr = [],\n          pop = arr.pop,\n          push_native = arr.push,\n          push = arr.push,\n          slice = arr.slice,\n          // Use a stripped-down indexOf as it's faster than native\n      // https://jsperf.com/thor-indexof-vs-for/5\n      indexOf = function indexOf(list, elem) {\n        var i = 0,\n            len = list.length;\n\n        for (; i < len; i++) {\n          if (list[i] === elem) {\n            return i;\n          }\n        }\n\n        return -1;\n      },\n          booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n          // Regular expressions\n      // http://www.w3.org/TR/css3-selectors/#whitespace\n      whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n          // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n      identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n          // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n      attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n      \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n      \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n          pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n      // 1. quoted (capture 3; capture 4 or capture 5)\n      \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n      \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n      \".*\" + \")\\\\)|)\",\n          // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n      rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n          rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n          rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n          rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n          rpseudo = new RegExp(pseudos),\n          ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n          matchExpr = {\n        \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n        \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n        \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n        \"ATTR\": new RegExp(\"^\" + attributes),\n        \"PSEUDO\": new RegExp(\"^\" + pseudos),\n        \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n        \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n        // For use in libraries implementing .is()\n        // We use this for POS matching in `select`\n        \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n      },\n          rnative = /^[^{]+\\{\\s*\\[native \\w/,\n          // Easily-parseable/retrievable ID or TAG or CLASS selectors\n      rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n          rsibling = /[+~]/,\n          // CSS escapes\n      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n      runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n          funescape = function funescape(_, escaped, escapedWhitespace) {\n        var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n        // Support: Firefox<24\n        // Workaround erroneous numeric interpretation of +\"0x\"\n\n        return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n        String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n      },\n          // CSS string/identifier serialization\n      // https://drafts.csswg.org/cssom/#common-serializing-idioms\n      rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n          fcssescape = function fcssescape(ch, asCodePoint) {\n        if (asCodePoint) {\n          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n          if (ch === \"\\0\") {\n            return \"\\uFFFD\";\n          } // Control characters and (dependent upon position) numbers get escaped as code points\n\n\n          return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n        } // Other potentially-special ASCII characters get backslash-escaped\n\n\n        return \"\\\\\" + ch;\n      },\n          // Used for iframes\n      // See setDocument()\n      // Removing the function wrapper causes a \"Permission Denied\"\n      // error in IE\n      unloadHandler = function unloadHandler() {\n        setDocument();\n      },\n          inDisabledFieldset = addCombinator(function (elem) {\n        return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n      }, {\n        dir: \"parentNode\",\n        next: \"legend\"\n      }); // Optimize for push.apply( _, NodeList )\n\n\n      try {\n        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n        // Detect silently failing push.apply\n\n        arr[preferredDoc.childNodes.length].nodeType;\n      } catch (e) {\n        push = {\n          apply: arr.length ? // Leverage slice if possible\n          function (target, els) {\n            push_native.apply(target, slice.call(els));\n          } : // Support: IE<9\n          // Otherwise append directly\n          function (target, els) {\n            var j = target.length,\n                i = 0; // Can't trust NodeList.length\n\n            while (target[j++] = els[i++]) {}\n\n            target.length = j - 1;\n          }\n        };\n      }\n\n      function Sizzle(selector, context, results, seed) {\n        var m,\n            i,\n            elem,\n            nid,\n            match,\n            groups,\n            newSelector,\n            newContext = context && context.ownerDocument,\n            // nodeType defaults to 9, since context defaults to document\n        nodeType = context ? context.nodeType : 9;\n        results = results || []; // Return early from calls with invalid selector or context\n\n        if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n          return results;\n        } // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n        if (!seed) {\n          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n            setDocument(context);\n          }\n\n          context = context || document;\n\n          if (documentIsHTML) {\n            // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n            // (excepting DocumentFragment context, where the methods don't exist)\n            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n              // ID selector\n              if (m = match[1]) {\n                // Document context\n                if (nodeType === 9) {\n                  if (elem = context.getElementById(m)) {\n                    // Support: IE, Opera, Webkit\n                    // TODO: identify versions\n                    // getElementById can match elements by name instead of ID\n                    if (elem.id === m) {\n                      results.push(elem);\n                      return results;\n                    }\n                  } else {\n                    return results;\n                  } // Element context\n\n                } else {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } // Type selector\n\n              } else if (match[2]) {\n                push.apply(results, context.getElementsByTagName(selector));\n                return results; // Class selector\n              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n                push.apply(results, context.getElementsByClassName(m));\n                return results;\n              }\n            } // Take advantage of querySelectorAll\n\n\n            if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n              if (nodeType !== 1) {\n                newContext = context;\n                newSelector = selector; // qSA looks outside Element context, which is not what we want\n                // Thanks to Andrew Dupont for this workaround technique\n                // Support: IE <=8\n                // Exclude object elements\n              } else if (context.nodeName.toLowerCase() !== \"object\") {\n                // Capture the context ID, setting it first if necessary\n                if (nid = context.getAttribute(\"id\")) {\n                  nid = nid.replace(rcssescape, fcssescape);\n                } else {\n                  context.setAttribute(\"id\", nid = expando);\n                } // Prefix every selector in the list\n\n\n                groups = tokenize(selector);\n                i = groups.length;\n\n                while (i--) {\n                  groups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\n                }\n\n                newSelector = groups.join(\",\"); // Expand context for sibling selectors\n\n                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n              }\n\n              if (newSelector) {\n                try {\n                  push.apply(results, newContext.querySelectorAll(newSelector));\n                  return results;\n                } catch (qsaError) {\n                  // [AdGuard Path]: Fix the cache value\n                  nonnativeSelectorCache(selector, true);\n                } finally {\n                  if (nid === expando) {\n                    context.removeAttribute(\"id\");\n                  }\n                }\n              }\n            }\n          }\n        } // All others\n\n\n        return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n      }\n      /**\n       * Create key-value caches of limited size\n       * @returns {function(string, object)} Returns the Object data after storing it on itself with\n       *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n       *\tdeleting the oldest entry\n       */\n\n\n      function createCache() {\n        var keys = [];\n\n        function cache(key, value) {\n          // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n          if (keys.push(key + \" \") > Expr.cacheLength) {\n            // Only keep the most recent entries\n            delete cache[keys.shift()];\n          }\n\n          return cache[key + \" \"] = value;\n        }\n\n        return cache;\n      }\n      /**\n       * Mark a function for special use by Sizzle\n       * @param {Function} fn The function to mark\n       */\n\n\n      function markFunction(fn) {\n        fn[expando] = true;\n        return fn;\n      }\n      /**\n       * Support testing using an element\n       * @param {Function} fn Passed the created element and returns a boolean result\n       */\n\n\n      function assert(fn) {\n        var el = document.createElement(\"fieldset\");\n\n        try {\n          return !!fn(el);\n        } catch (e) {\n          return false;\n        } finally {\n          // Remove from its parent by default\n          if (el.parentNode) {\n            el.parentNode.removeChild(el);\n          } // release memory in IE\n\n\n          el = null;\n        }\n      }\n      /**\n       * Adds the same handler for all of the specified attrs\n       * @param {String} attrs Pipe-separated list of attributes\n       * @param {Function} handler The method that will be applied\n       */\n\n\n      function addHandle(attrs, handler) {\n        var arr = attrs.split(\"|\"),\n            i = arr.length;\n\n        while (i--) {\n          Expr.attrHandle[arr[i]] = handler;\n        }\n      }\n      /**\n       * Checks document order of two siblings\n       * @param {Element} a\n       * @param {Element} b\n       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n       */\n\n\n      function siblingCheck(a, b) {\n        var cur = b && a,\n            diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes\n\n        if (diff) {\n          return diff;\n        } // Check if b follows a\n\n\n        if (cur) {\n          while (cur = cur.nextSibling) {\n            if (cur === b) {\n              return -1;\n            }\n          }\n        }\n\n        return a ? 1 : -1;\n      }\n      /**\n       * Returns a function to use in pseudos for :enabled/:disabled\n       * @param {Boolean} disabled true for :disabled; false for :enabled\n       */\n\n\n      function createDisabledPseudo(disabled) {\n        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n        return function (elem) {\n          // Only certain elements can match :enabled or :disabled\n          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n          if (\"form\" in elem) {\n            // Check for inherited disabledness on relevant non-disabled elements:\n            // * listed form-associated elements in a disabled fieldset\n            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n            // * option elements in a disabled optgroup\n            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n            // All such elements have a \"form\" property.\n            if (elem.parentNode && elem.disabled === false) {\n              // Option elements defer to a parent optgroup if present\n              if (\"label\" in elem) {\n                if (\"label\" in elem.parentNode) {\n                  return elem.parentNode.disabled === disabled;\n                } else {\n                  return elem.disabled === disabled;\n                }\n              } // Support: IE 6 - 11\n              // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\n\n              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually\n\n              /* jshint -W018 */\n              elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n            }\n\n            return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.\n            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n            // even exist on them, let alone have a boolean value.\n          } else if (\"label\" in elem) {\n            return elem.disabled === disabled;\n          } // Remaining elements are neither :enabled nor :disabled\n\n\n          return false;\n        };\n      }\n      /**\n       * Checks a node for validity as a Sizzle context\n       * @param {Element|Object=} context\n       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n       */\n\n\n      function testContext(context) {\n        return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n      } // Expose support vars for convenience\n\n\n      support = Sizzle.support = {};\n      /**\n       * Detects XML nodes\n       * @param {Element|Object} elem An element or a document\n       * @returns {Boolean} True iff elem is a non-HTML XML node\n       */\n\n      isXML = Sizzle.isXML = function (elem) {\n        // documentElement is verified for cases where it doesn't yet exist\n        // (such as loading iframes in IE - #4833)\n        var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n        return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n      };\n      /**\n       * Sets document-related variables once based on the current document\n       * @param {Element|Object} [doc] An element or document object to use to set the document\n       * @returns {Object} Returns the current document\n       */\n\n\n      setDocument = Sizzle.setDocument = function (node) {\n        var hasCompare,\n            subWindow,\n            doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n\n        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n          return document;\n        } // Update global variables\n\n\n        document = doc;\n        docElem = document.documentElement;\n        documentIsHTML = !isXML(document); // Support: IE 9-11, Edge\n        // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\n        if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n          // Support: IE 11, Edge\n          if (subWindow.addEventListener) {\n            subWindow.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n          } else if (subWindow.attachEvent) {\n            subWindow.attachEvent(\"onunload\", unloadHandler);\n          }\n        }\n        /* Attributes\n        ---------------------------------------------------------------------- */\n        // Support: IE<8\n        // Verify that getAttribute really returns attributes and not properties\n        // (excepting IE8 booleans)\n\n\n        support.attributes = assert(function (el) {\n          el.className = \"i\";\n          return !el.getAttribute(\"className\");\n        });\n        /* getElement(s)By*\n        ---------------------------------------------------------------------- */\n        // Check if getElementsByTagName(\"*\") returns only elements\n\n        support.getElementsByTagName = assert(function (el) {\n          el.appendChild(document.createComment(\"\"));\n          return !el.getElementsByTagName(\"*\").length;\n        }); // Support: IE<9\n\n        support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n        // Check if getElementById returns elements by name\n        // The broken getElementById methods don't pick up programmatically-set names,\n        // so use a roundabout getElementsByName test\n\n        support.getById = assert(function (el) {\n          docElem.appendChild(el).id = expando;\n          return !document.getElementsByName || !document.getElementsByName(expando).length;\n        }); // ID filter and find\n\n        if (support.getById) {\n          Expr.filter[\"ID\"] = function (id) {\n            var attrId = id.replace(runescape, funescape);\n            return function (elem) {\n              return elem.getAttribute(\"id\") === attrId;\n            };\n          };\n\n          Expr.find[\"ID\"] = function (id, context) {\n            if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n              var elem = context.getElementById(id);\n              return elem ? [elem] : [];\n            }\n          };\n        } else {\n          Expr.filter[\"ID\"] = function (id) {\n            var attrId = id.replace(runescape, funescape);\n            return function (elem) {\n              var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n              return node && node.value === attrId;\n            };\n          }; // Support: IE 6 - 7 only\n          // getElementById is not reliable as a find shortcut\n\n\n          Expr.find[\"ID\"] = function (id, context) {\n            if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n              var node,\n                  i,\n                  elems,\n                  elem = context.getElementById(id);\n\n              if (elem) {\n                // Verify the id attribute\n                node = elem.getAttributeNode(\"id\");\n\n                if (node && node.value === id) {\n                  return [elem];\n                } // Fall back on getElementsByName\n\n\n                elems = context.getElementsByName(id);\n                i = 0;\n\n                while (elem = elems[i++]) {\n                  node = elem.getAttributeNode(\"id\");\n\n                  if (node && node.value === id) {\n                    return [elem];\n                  }\n                }\n              }\n\n              return [];\n            }\n          };\n        } // Tag\n\n\n        Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n          if (typeof context.getElementsByTagName !== \"undefined\") {\n            return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n          } else if (support.qsa) {\n            return context.querySelectorAll(tag);\n          }\n        } : function (tag, context) {\n          var elem,\n              tmp = [],\n              i = 0,\n              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n          results = context.getElementsByTagName(tag); // Filter out possible comments\n\n          if (tag === \"*\") {\n            while (elem = results[i++]) {\n              if (elem.nodeType === 1) {\n                tmp.push(elem);\n              }\n            }\n\n            return tmp;\n          }\n\n          return results;\n        }; // Class\n\n        Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n          if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n            return context.getElementsByClassName(className);\n          }\n        };\n        /* QSA/matchesSelector\n        ---------------------------------------------------------------------- */\n        // QSA and matchesSelector support\n        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n        rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n        // We allow this because of a bug in IE8/9 that throws an error\n        // whenever `document.activeElement` is accessed on an iframe\n        // So, we allow :focus to pass through QSA all the time to avoid the IE error\n        // See https://bugs.jquery.com/ticket/13378\n\n        rbuggyQSA = [];\n\n        if (support.qsa = rnative.test(document.querySelectorAll)) {\n          // Build QSA regex\n          // Regex strategy adopted from Diego Perini\n          assert(function (el) {\n            // Select is set to empty string on purpose\n            // This is to test IE's treatment of not explicitly\n            // setting a boolean content attribute,\n            // since its presence should be enough\n            // https://bugs.jquery.com/ticket/12359\n            docElem.appendChild(el).innerHTML = AGPolicy.createHTML(\"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"); // Support: IE8, Opera 11-12.16\n            // Nothing should be selected when empty strings follow ^= or $= or *=\n            // The test attribute must be unknown in Opera but \"safe\" for WinRT\n            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n            if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n              rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n            } // Support: IE8\n            // Boolean attributes and \"value\" are not treated correctly\n\n\n            if (!el.querySelectorAll(\"[selected]\").length) {\n              rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n            } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n            if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n              rbuggyQSA.push(\"~=\");\n            } // Webkit/Opera - :checked should return selected option elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            // IE8 throws error here and will not see later tests\n\n\n            if (!el.querySelectorAll(\":checked\").length) {\n              rbuggyQSA.push(\":checked\");\n            } // Support: Safari 8+, iOS 8+\n            // https://bugs.webkit.org/show_bug.cgi?id=136851\n            // In-page `selector#id sibling-combinator selector` fails\n\n\n            if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n              rbuggyQSA.push(\".#.+[+~]\");\n            }\n          });\n          assert(function (el) {\n            el.innerHTML = AGPolicy.createHTML(\"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\"); // Support: Windows 8 Native Apps\n            // The type and name attributes are restricted during .innerHTML assignment\n\n            var input = document.createElement(\"input\");\n            input.setAttribute(\"type\", \"hidden\");\n            el.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n            // Enforce case-sensitivity of name attribute\n\n            if (el.querySelectorAll(\"[name=d]\").length) {\n              rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n            } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n            // IE8 throws error here and will not see later tests\n\n\n            if (el.querySelectorAll(\":enabled\").length !== 2) {\n              rbuggyQSA.push(\":enabled\", \":disabled\");\n            } // Support: IE9-11+\n            // IE's :disabled selector does not pick up the children of disabled fieldsets\n\n\n            docElem.appendChild(el).disabled = true;\n\n            if (el.querySelectorAll(\":disabled\").length !== 2) {\n              rbuggyQSA.push(\":enabled\", \":disabled\");\n            } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n            el.querySelectorAll(\"*,:x\");\n            rbuggyQSA.push(\",.*:\");\n          });\n        }\n\n        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n          assert(function (el) {\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node (IE 9)\n            support.disconnectedMatch = matches.call(el, \"*\"); // This should fail with an exception\n            // Gecko does not error, returns false instead\n\n            matches.call(el, \"[s!='']:x\");\n            rbuggyMatches.push(\"!=\", pseudos);\n          });\n        }\n\n        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n        /* Contains\n        ---------------------------------------------------------------------- */\n\n        hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n        // Purposefully self-exclusive\n        // As in, an element does not contain itself\n\n        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n          var adown = a.nodeType === 9 ? a.documentElement : a,\n              bup = b && b.parentNode;\n          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n        } : function (a, b) {\n          if (b) {\n            while (b = b.parentNode) {\n              if (b === a) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        };\n        /* Sorting\n        ---------------------------------------------------------------------- */\n        // Document order sorting\n\n        sortOrder = hasCompare ? function (a, b) {\n          // Flag for duplicate removal\n          if (a === b) {\n            hasDuplicate = true;\n            return 0;\n          } // Sort on method existence if only one input has compareDocumentPosition\n\n\n          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n          if (compare) {\n            return compare;\n          } // Calculate position if both inputs belong to the same document\n\n\n          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n          1; // Disconnected nodes\n\n          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n            // Choose the first element that is related to our preferred document\n            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n              return -1;\n            }\n\n            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n              return 1;\n            } // Maintain original order\n\n\n            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n          }\n\n          return compare & 4 ? -1 : 1;\n        } : function (a, b) {\n          // Exit early if the nodes are identical\n          if (a === b) {\n            hasDuplicate = true;\n            return 0;\n          }\n\n          var cur,\n              i = 0,\n              aup = a.parentNode,\n              bup = b.parentNode,\n              ap = [a],\n              bp = [b]; // Parentless nodes are either documents or disconnected\n\n          if (!aup || !bup) {\n            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n          } else if (aup === bup) {\n            return siblingCheck(a, b);\n          } // Otherwise we need full lists of their ancestors for comparison\n\n\n          cur = a;\n\n          while (cur = cur.parentNode) {\n            ap.unshift(cur);\n          }\n\n          cur = b;\n\n          while (cur = cur.parentNode) {\n            bp.unshift(cur);\n          } // Walk down the tree looking for a discrepancy\n\n\n          while (ap[i] === bp[i]) {\n            i++;\n          }\n\n          return i ? // Do a sibling check if the nodes have a common ancestor\n          siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n          ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n        };\n        return document;\n      };\n\n      Sizzle.matches = function (expr, elements) {\n        return Sizzle(expr, null, null, elements);\n      };\n\n      Sizzle.matchesSelector = function (elem, expr) {\n        // Set document vars if needed\n        if ((elem.ownerDocument || elem) !== document) {\n          setDocument(elem);\n        }\n\n        if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n          try {\n            var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n            // fragment in IE 9\n            elem.document && elem.document.nodeType !== 11) {\n              return ret;\n            }\n          } catch (e) {\n            // [AdGuard Path]: Fix the cache value\n            nonnativeSelectorCache(expr, true);\n          }\n        }\n\n        return Sizzle(expr, document, null, [elem]).length > 0;\n      };\n\n      Sizzle.contains = function (context, elem) {\n        // Set document vars if needed\n        if ((context.ownerDocument || context) !== document) {\n          setDocument(context);\n        }\n\n        return contains(context, elem);\n      };\n\n      Sizzle.attr = function (elem, name) {\n        // Set document vars if needed\n        if ((elem.ownerDocument || elem) !== document) {\n          setDocument(elem);\n        }\n\n        var fn = Expr.attrHandle[name.toLowerCase()],\n            // Don't get fooled by Object.prototype properties (jQuery #13807)\n        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n      };\n\n      Sizzle.escape = function (sel) {\n        return (sel + \"\").replace(rcssescape, fcssescape);\n      };\n\n      Sizzle.error = function (msg) {\n        throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n      };\n      /**\n       * Document sorting and removing duplicates\n       * @param {ArrayLike} results\n       */\n\n\n      Sizzle.uniqueSort = function (results) {\n        var elem,\n            duplicates = [],\n            j = 0,\n            i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n        hasDuplicate = !support.detectDuplicates;\n        sortInput = !support.sortStable && results.slice(0);\n        results.sort(sortOrder);\n\n        if (hasDuplicate) {\n          while (elem = results[i++]) {\n            if (elem === results[i]) {\n              j = duplicates.push(i);\n            }\n          }\n\n          while (j--) {\n            results.splice(duplicates[j], 1);\n          }\n        } // Clear input after sorting to release objects\n        // See https://github.com/jquery/sizzle/pull/225\n\n\n        sortInput = null;\n        return results;\n      };\n      /**\n       * Utility function for retrieving the text value of an array of DOM nodes\n       * @param {Array|Element} elem\n       */\n\n\n      getText = Sizzle.getText = function (elem) {\n        var node,\n            ret = \"\",\n            i = 0,\n            nodeType = elem.nodeType;\n\n        if (!nodeType) {\n          // If no nodeType, this is expected to be an array\n          while (node = elem[i++]) {\n            // Do not traverse comment nodes\n            ret += getText(node);\n          }\n        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n          // Use textContent for elements\n          // innerText usage removed for consistency of new lines (jQuery #11153)\n          if (typeof elem.textContent === \"string\") {\n            return elem.textContent;\n          } else {\n            // Traverse its children\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n              ret += getText(elem);\n            }\n          }\n        } else if (nodeType === 3 || nodeType === 4) {\n          return elem.nodeValue;\n        } // Do not include comment or processing instruction nodes\n\n\n        return ret;\n      };\n\n      Expr = Sizzle.selectors = {\n        // Can be adjusted by the user\n        cacheLength: 50,\n        createPseudo: markFunction,\n        match: matchExpr,\n        attrHandle: {},\n        find: {},\n        relative: {\n          \">\": {\n            dir: \"parentNode\",\n            first: true\n          },\n          \" \": {\n            dir: \"parentNode\"\n          },\n          \"+\": {\n            dir: \"previousSibling\",\n            first: true\n          },\n          \"~\": {\n            dir: \"previousSibling\"\n          }\n        },\n        preFilter: {\n          \"ATTR\": function ATTR(match) {\n            match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n            match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n            if (match[2] === \"~=\") {\n              match[3] = \" \" + match[3] + \" \";\n            }\n\n            return match.slice(0, 4);\n          },\n          \"CHILD\": function CHILD(match) {\n            /* matches from matchExpr[\"CHILD\"]\n            \t1 type (only|nth|...)\n            \t2 what (child|of-type)\n            \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n            \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n            \t5 sign of xn-component\n            \t6 x of xn-component\n            \t7 sign of y-component\n            \t8 y of y-component\n            */\n            match[1] = match[1].toLowerCase();\n\n            if (match[1].slice(0, 3) === \"nth\") {\n              // nth-* requires argument\n              if (!match[3]) {\n                Sizzle.error(match[0]);\n              } // numeric x and y parameters for Expr.filter.CHILD\n              // remember that false/true cast respectively to 0/1\n\n\n              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n              match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n            } else if (match[3]) {\n              Sizzle.error(match[0]);\n            }\n\n            return match;\n          },\n          \"PSEUDO\": function PSEUDO(match) {\n            var excess,\n                unquoted = !match[6] && match[2];\n\n            if (matchExpr[\"CHILD\"].test(match[0])) {\n              return null;\n            } // Accept quoted arguments as-is\n\n\n            if (match[3]) {\n              match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n            } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n            excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n              // excess is a negative index\n              match[0] = match[0].slice(0, excess);\n              match[2] = unquoted.slice(0, excess);\n            } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n            return match.slice(0, 3);\n          }\n        },\n        filter: {\n          \"TAG\": function TAG(nodeNameSelector) {\n            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n            return nodeNameSelector === \"*\" ? function () {\n              return true;\n            } : function (elem) {\n              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n            };\n          },\n          \"CLASS\": function CLASS(className) {\n            var pattern = classCache[className + \" \"];\n            return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n              return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n            });\n          },\n          \"ATTR\": function ATTR(name, operator, check) {\n            return function (elem) {\n              var result = Sizzle.attr(elem, name);\n\n              if (result == null) {\n                return operator === \"!=\";\n              }\n\n              if (!operator) {\n                return true;\n              }\n\n              result += \"\";\n              return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n            };\n          },\n          \"CHILD\": function CHILD(type, what, argument, first, last) {\n            var simple = type.slice(0, 3) !== \"nth\",\n                forward = type.slice(-4) !== \"last\",\n                ofType = what === \"of-type\";\n            return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n            function (elem) {\n              return !!elem.parentNode;\n            } : function (elem, context, xml) {\n              var cache,\n                  uniqueCache,\n                  outerCache,\n                  node,\n                  nodeIndex,\n                  start,\n                  dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                  parent = elem.parentNode,\n                  name = ofType && elem.nodeName.toLowerCase(),\n                  useCache = !xml && !ofType,\n                  diff = false;\n\n              if (parent) {\n                // :(first|last|only)-(child|of-type)\n                if (simple) {\n                  while (dir) {\n                    node = elem;\n\n                    while (node = node[dir]) {\n                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                        return false;\n                      }\n                    } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                    start = dir = type === \"only\" && !start && \"nextSibling\";\n                  }\n\n                  return true;\n                }\n\n                start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n                if (forward && useCache) {\n                  // Seek `elem` from a previously-cached index\n                  // ...in a gzip-friendly way\n                  node = parent;\n                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex && cache[2];\n                  node = nodeIndex && parent.childNodes[nodeIndex];\n\n                  while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                  diff = nodeIndex = 0) || start.pop()) {\n                    // When found, cache indexes on `parent` and break\n                    if (node.nodeType === 1 && ++diff && node === elem) {\n                      uniqueCache[type] = [dirruns, nodeIndex, diff];\n                      break;\n                    }\n                  }\n                } else {\n                  // Use previously-cached element index if available\n                  if (useCache) {\n                    // ...in a gzip-friendly way\n                    node = elem;\n                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                    // Defend against cloned attroperties (jQuery gh-1709)\n\n                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                    cache = uniqueCache[type] || [];\n                    nodeIndex = cache[0] === dirruns && cache[1];\n                    diff = nodeIndex;\n                  } // xml :nth-child(...)\n                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n                  if (diff === false) {\n                    // Use the same loop as above to seek `elem` from the start\n                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                        // Cache the index of each encountered element\n                        if (useCache) {\n                          outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n                          // Defend against cloned attroperties (jQuery gh-1709)\n\n                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                          uniqueCache[type] = [dirruns, diff];\n                        }\n\n                        if (node === elem) {\n                          break;\n                        }\n                      }\n                    }\n                  }\n                } // Incorporate the offset, then check against cycle size\n\n\n                diff -= last;\n                return diff === first || diff % first === 0 && diff / first >= 0;\n              }\n            };\n          },\n          \"PSEUDO\": function PSEUDO(pseudo, argument) {\n            // pseudo-class names are case-insensitive\n            // http://www.w3.org/TR/selectors/#pseudo-classes\n            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n            // Remember that setFilters inherits from pseudos\n            var args,\n                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n            // arguments are needed to create the filter function\n            // just as Sizzle does\n\n            if (fn[expando]) {\n              return fn(argument);\n            } // But maintain support for old signatures\n\n\n            if (fn.length > 1) {\n              args = [pseudo, pseudo, \"\", argument];\n              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n                var idx,\n                    matched = fn(seed, argument),\n                    i = matched.length;\n\n                while (i--) {\n                  idx = indexOf(seed, matched[i]);\n                  seed[idx] = !(matches[idx] = matched[i]);\n                }\n              }) : function (elem) {\n                return fn(elem, 0, args);\n              };\n            }\n\n            return fn;\n          }\n        },\n        pseudos: {\n          // Potentially complex pseudos\n          \"not\": markFunction(function (selector) {\n            // Trim the selector passed to compile\n            // to avoid treating leading and trailing\n            // spaces as combinators\n            var input = [],\n                results = [],\n                matcher = compile(selector.replace(rtrim, \"$1\"));\n            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n              var elem,\n                  unmatched = matcher(seed, null, xml, []),\n                  i = seed.length; // Match elements unmatched by `matcher`\n\n              while (i--) {\n                if (elem = unmatched[i]) {\n                  seed[i] = !(matches[i] = elem);\n                }\n              }\n            }) : function (elem, context, xml) {\n              input[0] = elem;\n              matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n              input[0] = null;\n              return !results.pop();\n            };\n          }),\n          \"has\": markFunction(function (selector) {\n            if (typeof selector === \"string\") {\n              Sizzle.compile(selector);\n            }\n\n            return function (elem) {\n              return Sizzle(selector, elem).length > 0;\n            };\n          }),\n          // Removed :contains pseudo-class declaration\n          // \"Whether an element is represented by a :lang() selector\n          // is based solely on the element's language value\n          // being equal to the identifier C,\n          // or beginning with the identifier C immediately followed by \"-\".\n          // The matching of C against the element's language value is performed case-insensitively.\n          // The identifier C does not have to be a valid language name.\"\n          // http://www.w3.org/TR/selectors/#lang-pseudo\n          \"lang\": markFunction(function (lang) {\n            // lang value must be a valid identifier\n            if (!ridentifier.test(lang || \"\")) {\n              Sizzle.error(\"unsupported lang: \" + lang);\n            }\n\n            lang = lang.replace(runescape, funescape).toLowerCase();\n            return function (elem) {\n              var elemLang;\n\n              do {\n                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                  elemLang = elemLang.toLowerCase();\n                  return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n                }\n              } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n              return false;\n            };\n          }),\n          // Miscellaneous\n          \"target\": function target(elem) {\n            var hash = window.location && window.location.hash;\n            return hash && hash.slice(1) === elem.id;\n          },\n          \"root\": function root(elem) {\n            return elem === docElem;\n          },\n          \"focus\": function focus(elem) {\n            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n          },\n          // Boolean properties\n          \"enabled\": createDisabledPseudo(false),\n          \"disabled\": createDisabledPseudo(true),\n          \"checked\": function checked(elem) {\n            // In CSS3, :checked should return both checked and selected elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            var nodeName = elem.nodeName.toLowerCase();\n            return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n          },\n          \"selected\": function selected(elem) {\n            // Accessing this property makes selected-by-default\n            // options in Safari work properly\n            if (elem.parentNode) {\n              elem.parentNode.selectedIndex;\n            }\n\n            return elem.selected === true;\n          },\n          // Contents\n          \"empty\": function empty(elem) {\n            // http://www.w3.org/TR/selectors/#empty-pseudo\n            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n            //   but not by others (comment: 8; processing instruction: 7; etc.)\n            // nodeType < 6 works because attributes (2) do not appear as children\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n              if (elem.nodeType < 6) {\n                return false;\n              }\n            }\n\n            return true;\n          } // Removed custom pseudo-classes\n\n        }\n      }; // Removed custom pseudo-classes\n      // Easy API for creating new setFilters\n\n      function setFilters() {}\n\n      setFilters.prototype = Expr.filters = Expr.pseudos;\n      Expr.setFilters = new setFilters();\n      /**\n       * [AdGuard Patch]:\n       * Sorts the tokens in order to mitigate the performance issues caused by matching slow pseudos first:\n       * https://github.com/AdguardTeam/ExtendedCss/issues/55#issuecomment-364058745\n       */\n\n      var sortTokenGroups = function () {\n        /**\n         * Splits compound selector into a list of simple selectors\n         *\n         * @param {*} tokens Tokens to split into groups\n         * @returns an array consisting of token groups (arrays) and relation tokens.\n         */\n        var splitCompoundSelector = function splitCompoundSelector(tokens) {\n          var groups = [];\n          var currentTokensGroup = [];\n          var maxIdx = tokens.length - 1;\n\n          for (var i = 0; i <= maxIdx; i++) {\n            var token = tokens[i];\n            var relative = Sizzle.selectors.relative[token.type];\n\n            if (relative) {\n              groups.push(currentTokensGroup);\n              groups.push(token);\n              currentTokensGroup = [];\n            } else {\n              currentTokensGroup.push(token);\n            }\n\n            if (i === maxIdx) {\n              groups.push(currentTokensGroup);\n            }\n          }\n\n          return groups;\n        };\n\n        var TOKEN_TYPES_VALUES = {\n          // nth-child, etc, always go last\n          \"CHILD\": 100,\n          \"ID\": 90,\n          \"CLASS\": 80,\n          \"TAG\": 70,\n          \"ATTR\": 70,\n          \"PSEUDO\": 60\n        };\n        var POSITIONAL_PSEUDOS = [\"nth\", \"first\", \"last\", \"eq\", \"even\", \"odd\", \"lt\", \"gt\", \"not\"];\n        /**\n         * A function that defines the sort order.\n         * Returns a value lesser than 0 if \"left\" is less than \"right\".\n         */\n\n        var compareFunction = function compareFunction(left, right) {\n          var leftValue = TOKEN_TYPES_VALUES[left.type];\n          var rightValue = TOKEN_TYPES_VALUES[right.type];\n          return leftValue - rightValue;\n        };\n        /**\n         * Checks if the specified tokens group is sortable.\n         * We do not re-sort tokens in case of any positional or child pseudos in the group\n         */\n\n\n        var isSortable = function isSortable(tokens) {\n          var iTokens = tokens.length;\n\n          while (iTokens--) {\n            var token = tokens[iTokens];\n\n            if (token.type === \"PSEUDO\" && POSITIONAL_PSEUDOS.indexOf(token.matches[0]) !== -1) {\n              return false;\n            }\n\n            if (token.type === \"CHILD\") {\n              return false;\n            }\n          }\n\n          return true;\n        };\n        /**\n         * Sorts the tokens in order to mitigate the issues caused by the left-to-right matching.\n         * The idea is change the tokens order so that Sizzle was matching fast selectors first (id, class),\n         * and slow selectors after that (and here I mean our slow custom pseudo classes).\n         *\n         * @param {Array} tokens An array of tokens to sort\n         * @returns {Array} A new re-sorted array\n         */\n\n\n        var sortTokens = function sortTokens(tokens) {\n          if (!tokens || tokens.length === 1) {\n            return tokens;\n          }\n\n          var sortedTokens = [];\n          var groups = splitCompoundSelector(tokens);\n\n          for (var i = 0; i < groups.length; i++) {\n            var group = groups[i];\n\n            if (group instanceof Array) {\n              if (isSortable(group)) {\n                group.sort(compareFunction);\n              }\n\n              sortedTokens = sortedTokens.concat(group);\n            } else {\n              sortedTokens.push(group);\n            }\n          }\n\n          return sortedTokens;\n        };\n        /**\n         * Sorts every tokens array inside of the specified \"groups\" array.\n         * See \"sortTokens\" methods for more information on how tokens are sorted.\n         *\n         * @param {Array} groups An array of tokens arrays.\n         * @returns {Array} A new array that consists of the same tokens arrays after sorting\n         */\n\n\n        var sortTokenGroups = function sortTokenGroups(groups) {\n          var sortedGroups = [];\n          var len = groups.length;\n          var i = 0;\n\n          for (; i < len; i++) {\n            sortedGroups.push(sortTokens(groups[i]));\n          }\n\n          return sortedGroups;\n        }; // Expose\n\n\n        return sortTokenGroups;\n      }();\n      /**\n       * Creates custom policy to use TrustedTypes CSP policy\n       * https://w3c.github.io/webappsec-trusted-types/dist/spec/\n       */\n\n\n      var AGPolicy = function createPolicy() {\n        var defaultPolicy = {\n          createHTML: function createHTML(input) {\n            return input;\n          },\n          createScript: function createScript(input) {\n            return input;\n          },\n          createScriptURL: function createScriptURL(input) {\n            return input;\n          }\n        };\n\n        if (window.trustedTypes && window.trustedTypes.createPolicy) {\n          return window.trustedTypes.createPolicy(\"AGPolicy\", defaultPolicy);\n        }\n\n        return defaultPolicy;\n      }();\n      /**\n       * [AdGuard Patch]:\n       * Removes trailing spaces from the tokens list\n       *\n       * @param {*} tokens An array of Sizzle tokens to post-process\n       */\n\n\n      function removeTrailingSpaces(tokens) {\n        var iTokens = tokens.length;\n\n        while (iTokens--) {\n          var token = tokens[iTokens];\n\n          if (token.type === \" \") {\n            tokens.length = iTokens;\n          } else {\n            break;\n          }\n        }\n      }\n      /**\n       * [AdGuard Patch]:\n       * An object with the information about selectors and their token representation\n       * @typedef {{selectorText: string, groups: Array}} SelectorData\n       * @property {string} selectorText A CSS selector text\n       * @property {Array} groups An array of token groups corresponding to that selector\n       */\n\n      /**\n       * [AdGuard Patch]:\n       * This method processes parsed token groups, divides them into a number of selectors\n       * and makes sure that each selector's tokens are cached properly in Sizzle.\n       *\n       * @param {*} groups Token groups (see {@link Sizzle.tokenize})\n       * @returns {Array.<SelectorData>} An array of selectors data we got from the groups\n       */\n\n\n      function tokenGroupsToSelectors(groups) {\n        // Remove trailing spaces which we can encounter in tolerant mode\n        // We're doing it in tolerant mode only as this is the only case when\n        // encountering trailing spaces is expected\n        removeTrailingSpaces(groups[groups.length - 1]); // We need sorted tokens to make cache work properly\n\n        var sortedGroups = sortTokenGroups(groups);\n        var selectors = [];\n\n        for (var i = 0; i < groups.length; i++) {\n          var tokenGroups = groups[i];\n          var selectorText = toSelector(tokenGroups);\n          selectors.push({\n            // Sizzle expects an array of token groups when compiling a selector\n            groups: [tokenGroups],\n            selectorText: selectorText\n          }); // Now make sure that selector tokens are cached\n\n          var tokensCacheItem = {\n            groups: tokenGroups,\n            sortedGroups: [sortedGroups[i]]\n          };\n          tokenCache(selectorText, tokensCacheItem);\n        }\n\n        return selectors;\n      }\n      /**\n       * [AdGuard Patch]:\n       * Add an additional argument for Sizzle.tokenize which indicates that it\n       * should not throw on invalid tokens, and instead should return tokens\n       * that it has produced so far.\n       *\n       * One more additional argument that allow to choose if you want to receive sorted or unsorted tokens\n       * The problem is that the re-sorted selectors are valid for Sizzle, but not for the browser.\n       * options.returnUnsorted -- return unsorted tokens if true.\n       * options.cacheOnly -- return cached result only. Required for unit-tests.\n       *\n       * @param {*} options Optional configuration object with two additional flags\n       * (options.tolerant, options.returnUnsorted, options.cacheOnly) -- see patches #5 and #6 notes\n       */\n\n\n      tokenize = Sizzle.tokenize = function (selector, parseOnly, options) {\n        var matched,\n            match,\n            tokens,\n            type,\n            soFar,\n            groups,\n            preFilters,\n            cached = tokenCache[selector + \" \"];\n        var tolerant = options && options.tolerant;\n        var returnUnsorted = options && options.returnUnsorted;\n        var cacheOnly = options && options.cacheOnly;\n\n        if (cached) {\n          if (parseOnly) {\n            return 0;\n          } else {\n            return (returnUnsorted ? cached.groups : cached.sortedGroups).slice(0);\n          }\n        }\n\n        if (cacheOnly) {\n          return null;\n        }\n\n        soFar = selector;\n        groups = [];\n        preFilters = Expr.preFilter;\n\n        while (soFar) {\n          // Comma and first run\n          if (!matched || (match = rcomma.exec(soFar))) {\n            if (match) {\n              // Don't consume trailing commas as valid\n              soFar = soFar.slice(match[0].length) || soFar;\n            }\n\n            groups.push(tokens = []);\n          }\n\n          matched = false; // Combinators\n\n          if (match = rcombinators.exec(soFar)) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              // Cast descendant combinators to space\n              type: match[0].replace(rtrim, \" \")\n            });\n            soFar = soFar.slice(matched.length);\n          } // Filters\n\n\n          for (type in Expr.filter) {\n            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n              matched = match.shift();\n              tokens.push({\n                value: matched,\n                type: type,\n                matches: match\n              });\n              soFar = soFar.slice(matched.length);\n            }\n          }\n\n          if (!matched) {\n            break;\n          }\n        } // Return the length of the invalid excess\n        // if we're just parsing\n        // Otherwise, throw an error or return tokens\n\n\n        var invalidLen = soFar.length;\n\n        if (parseOnly) {\n          return invalidLen;\n        }\n\n        if (invalidLen !== 0 && !tolerant) {\n          Sizzle.error(selector); // Throws an error.\n        }\n\n        if (tolerant) {\n          /**\n           * [AdGuard Patch]:\n           * In tolerant mode we return a special object that constists of\n           * an array of parsed selectors (and their tokens) and a \"nextIndex\" field\n           * that points to an index after which we're not able to parse selectors farther.\n           */\n          var nextIndex = selector.length - invalidLen;\n          var selectors = tokenGroupsToSelectors(groups);\n          return {\n            selectors: selectors,\n            nextIndex: nextIndex\n          };\n        }\n        /** [AdGuard Patch]: Sorting tokens */\n\n\n        var sortedGroups = sortTokenGroups(groups);\n        /** [AdGuard Patch]: Change the way tokens are cached */\n\n        var tokensCacheItem = {\n          groups: groups,\n          sortedGroups: sortedGroups\n        };\n        tokensCacheItem = tokenCache(selector, tokensCacheItem);\n        return (returnUnsorted ? tokensCacheItem.groups : tokensCacheItem.sortedGroups).slice(0);\n      };\n\n      function toSelector(tokens) {\n        var i = 0,\n            len = tokens.length,\n            selector = \"\";\n\n        for (; i < len; i++) {\n          selector += tokens[i].value;\n        }\n\n        return selector;\n      }\n\n      function addCombinator(matcher, combinator, base) {\n        var dir = combinator.dir,\n            skip = combinator.next,\n            key = skip || dir,\n            checkNonElements = base && key === \"parentNode\",\n            doneName = done++;\n        return combinator.first ? // Check against closest ancestor/preceding element\n        function (elem, context, xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              return matcher(elem, context, xml);\n            }\n          }\n\n          return false;\n        } : // Check against all ancestor/preceding elements\n        function (elem, context, xml) {\n          var oldCache,\n              uniqueCache,\n              outerCache,\n              newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n          if (xml) {\n            while (elem = elem[dir]) {\n              if (elem.nodeType === 1 || checkNonElements) {\n                if (matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            while (elem = elem[dir]) {\n              if (elem.nodeType === 1 || checkNonElements) {\n                outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n\n                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n                if (skip && skip === elem.nodeName.toLowerCase()) {\n                  elem = elem[dir] || elem;\n                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                  // Assign to newCache so results back-propagate to previous elements\n                  return newCache[2] = oldCache[2];\n                } else {\n                  // Reuse newcache so results back-propagate to previous elements\n                  uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                  if (newCache[2] = matcher(elem, context, xml)) {\n                    return true;\n                  }\n                }\n              }\n            }\n          }\n\n          return false;\n        };\n      }\n\n      function elementMatcher(matchers) {\n        return matchers.length > 1 ? function (elem, context, xml) {\n          var i = matchers.length;\n\n          while (i--) {\n            if (!matchers[i](elem, context, xml)) {\n              return false;\n            }\n          }\n\n          return true;\n        } : matchers[0];\n      }\n\n      function multipleContexts(selector, contexts, results) {\n        var i = 0,\n            len = contexts.length;\n\n        for (; i < len; i++) {\n          Sizzle(selector, contexts[i], results);\n        }\n\n        return results;\n      }\n\n      function condense(unmatched, map, filter, context, xml) {\n        var elem,\n            newUnmatched = [],\n            i = 0,\n            len = unmatched.length,\n            mapped = map != null;\n\n        for (; i < len; i++) {\n          if (elem = unmatched[i]) {\n            if (!filter || filter(elem, context, xml)) {\n              newUnmatched.push(elem);\n\n              if (mapped) {\n                map.push(i);\n              }\n            }\n          }\n        }\n\n        return newUnmatched;\n      }\n\n      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n        if (postFilter && !postFilter[expando]) {\n          postFilter = setMatcher(postFilter);\n        }\n\n        if (postFinder && !postFinder[expando]) {\n          postFinder = setMatcher(postFinder, postSelector);\n        }\n\n        return markFunction(function (seed, results, context, xml) {\n          var temp,\n              i,\n              elem,\n              preMap = [],\n              postMap = [],\n              preexisting = results.length,\n              // Get initial elements from seed or context\n          elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n              // Prefilter to get matcher input, preserving a map for seed-results synchronization\n          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n              matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n          [] : // ...otherwise use results directly\n          results : matcherIn; // Find primary matches\n\n          if (matcher) {\n            matcher(matcherIn, matcherOut, context, xml);\n          } // Apply postFilter\n\n\n          if (postFilter) {\n            temp = condense(matcherOut, postMap);\n            postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n            i = temp.length;\n\n            while (i--) {\n              if (elem = temp[i]) {\n                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n              }\n            }\n          }\n\n          if (seed) {\n            if (postFinder || preFilter) {\n              if (postFinder) {\n                // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                temp = [];\n                i = matcherOut.length;\n\n                while (i--) {\n                  if (elem = matcherOut[i]) {\n                    // Restore matcherIn since elem is not yet a final match\n                    temp.push(matcherIn[i] = elem);\n                  }\n                }\n\n                postFinder(null, matcherOut = [], temp, xml);\n              } // Move matched elements from seed to results to keep them synchronized\n\n\n              i = matcherOut.length;\n\n              while (i--) {\n                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                  seed[temp] = !(results[temp] = elem);\n                }\n              }\n            } // Add elements to results, through postFinder if defined\n\n          } else {\n            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n            if (postFinder) {\n              postFinder(null, results, matcherOut, xml);\n            } else {\n              push.apply(results, matcherOut);\n            }\n          }\n        });\n      }\n\n      function matcherFromTokens(tokens) {\n        var checkContext,\n            matcher,\n            j,\n            len = tokens.length,\n            leadingRelative = Expr.relative[tokens[0].type],\n            implicitRelative = leadingRelative || Expr.relative[\" \"],\n            i = leadingRelative ? 1 : 0,\n            // The foundational matcher ensures that elements are reachable from top-level context(s)\n        matchContext = addCombinator(function (elem) {\n          return elem === checkContext;\n        }, implicitRelative, true),\n            matchAnyContext = addCombinator(function (elem) {\n          return indexOf(checkContext, elem) > -1;\n        }, implicitRelative, true),\n            matchers = [function (elem, context, xml) {\n          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n          checkContext = null;\n          return ret;\n        }];\n\n        for (; i < len; i++) {\n          if (matcher = Expr.relative[tokens[i].type]) {\n            matchers = [addCombinator(elementMatcher(matchers), matcher)];\n          } else {\n            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n            if (matcher[expando]) {\n              // Find the next relative operator (if any) for proper handling\n              j = ++i;\n\n              for (; j < len; j++) {\n                if (Expr.relative[tokens[j].type]) {\n                  break;\n                }\n              }\n\n              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n              tokens.slice(0, i - 1).concat({\n                value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n              })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n            }\n\n            matchers.push(matcher);\n          }\n        }\n\n        return elementMatcher(matchers);\n      }\n\n      function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n        var bySet = setMatchers.length > 0,\n            byElement = elementMatchers.length > 0,\n            superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n          var elem,\n              j,\n              matcher,\n              matchedCount = 0,\n              i = \"0\",\n              unmatched = seed && [],\n              setMatched = [],\n              contextBackup = outermostContext,\n              // We must always have either seed elements or outermost context\n          elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n              // Use integer dirruns iff this is the outermost matcher\n          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n              len = elems.length;\n\n          if (outermost) {\n            outermostContext = context === document || context || outermost;\n          } // Add elements passing elementMatchers directly to results\n          // Support: IE<9, Safari\n          // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n          for (; i !== len && (elem = elems[i]) != null; i++) {\n            if (byElement && elem) {\n              j = 0;\n\n              if (!context && elem.ownerDocument !== document) {\n                setDocument(elem);\n                xml = !documentIsHTML;\n              }\n\n              while (matcher = elementMatchers[j++]) {\n                if (matcher(elem, context || document, xml)) {\n                  results.push(elem);\n                  break;\n                }\n              }\n\n              if (outermost) {\n                dirruns = dirrunsUnique;\n              }\n            } // Track unmatched elements for set filters\n\n\n            if (bySet) {\n              // They will have gone through all possible matchers\n              if (elem = !matcher && elem) {\n                matchedCount--;\n              } // Lengthen the array for every element, matched or not\n\n\n              if (seed) {\n                unmatched.push(elem);\n              }\n            }\n          } // `i` is now the count of elements visited above, and adding it to `matchedCount`\n          // makes the latter nonnegative.\n\n\n          matchedCount += i; // Apply set filters to unmatched elements\n          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n          // no element matchers and no seed.\n          // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n          // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n          // numerically zero.\n\n          if (bySet && i !== matchedCount) {\n            j = 0;\n\n            while (matcher = setMatchers[j++]) {\n              matcher(unmatched, setMatched, context, xml);\n            }\n\n            if (seed) {\n              // Reintegrate element matches to eliminate the need for sorting\n              if (matchedCount > 0) {\n                while (i--) {\n                  if (!(unmatched[i] || setMatched[i])) {\n                    setMatched[i] = pop.call(results);\n                  }\n                }\n              } // Discard index placeholder values to get only actual matches\n\n\n              setMatched = condense(setMatched);\n            } // Add matches to results\n\n\n            push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n              Sizzle.uniqueSort(results);\n            }\n          } // Override manipulation of globals by nested matchers\n\n\n          if (outermost) {\n            dirruns = dirrunsUnique;\n            outermostContext = contextBackup;\n          }\n\n          return unmatched;\n        };\n\n        return bySet ? markFunction(superMatcher) : superMatcher;\n      }\n\n      compile = Sizzle.compile = function (selector, match\n      /* Internal Use Only */\n      ) {\n        var i,\n            setMatchers = [],\n            elementMatchers = [],\n            cached = compilerCache[selector + \" \"];\n\n        if (!cached) {\n          // Generate a function of recursive functions that can be used to check each element\n          if (!match) {\n            match = tokenize(selector);\n          }\n\n          i = match.length;\n\n          while (i--) {\n            cached = matcherFromTokens(match[i]);\n\n            if (cached[expando]) {\n              setMatchers.push(cached);\n            } else {\n              elementMatchers.push(cached);\n            }\n          } // Cache the compiled function\n\n\n          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n          cached.selector = selector;\n        }\n\n        return cached;\n      };\n      /**\n       * A low-level selection function that works with Sizzle's compiled\n       *  selector functions\n       * @param {String|Function} selector A selector or a pre-compiled\n       *  selector function built with Sizzle.compile\n       * @param {Element} context\n       * @param {Array} [results]\n       * @param {Array} [seed] A set of elements to match against\n       */\n\n\n      select = Sizzle.select = function (selector, context, results, seed) {\n        var i,\n            tokens,\n            token,\n            type,\n            find,\n            compiled = typeof selector === \"function\" && selector,\n            match = !seed && tokenize(selector = compiled.selector || selector);\n        results = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n        // (the latter of which guarantees us context)\n\n        if (match.length === 1) {\n          // Reduce context if the leading compound selector is an ID\n          tokens = match[0] = match[0].slice(0);\n\n          if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n            context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n            if (!context) {\n              return results; // Precompiled matchers will still verify ancestry, so step up a level\n            } else if (compiled) {\n              context = context.parentNode;\n            }\n\n            selector = selector.slice(tokens.shift().value.length);\n          } // Fetch a seed set for right-to-left matching\n\n\n          i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n          while (i--) {\n            token = tokens[i]; // Abort if we hit a combinator\n\n            if (Expr.relative[type = token.type]) {\n              break;\n            }\n\n            if (find = Expr.find[type]) {\n              // Search, expanding context for leading sibling combinators\n              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n                // If seed is empty or no tokens remain, we can return early\n                tokens.splice(i, 1);\n                selector = seed.length && toSelector(tokens);\n\n                if (!selector) {\n                  push.apply(results, seed);\n                  return results;\n                }\n\n                break;\n              }\n            }\n          }\n        } // Compile and execute a filtering function if one is not provided\n        // Provide `match` to avoid retokenization if we modified the selector above\n\n\n        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n        return results;\n      }; // One-time assignments\n      // Sort stability\n\n\n      support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n      // Always assume duplicates if they aren't passed to the comparison function\n\n      support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n      setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n      // Detached nodes confoundingly follow *each other*\n\n      support.sortDetached = assert(function (el) {\n        // Should return 1, but returns 4 (following)\n        return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n      }); // Support: IE<8\n      // Prevent attribute/property \"interpolation\"\n      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n      if (!assert(function (el) {\n        el.innerHTML = AGPolicy.createHTML(\"<a href='#'></a>\");\n        return el.firstChild.getAttribute(\"href\") === \"#\";\n      })) {\n        addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n          if (!isXML) {\n            return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n          }\n        });\n      } // Support: IE<9\n      // Use defaultValue in place of getAttribute(\"value\")\n\n\n      if (!support.attributes || !assert(function (el) {\n        el.innerHTML = AGPolicy.createHTML(\"<input/>\");\n        el.firstChild.setAttribute(\"value\", \"\");\n        return el.firstChild.getAttribute(\"value\") === \"\";\n      })) {\n        addHandle(\"value\", function (elem, name, isXML) {\n          if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n            return elem.defaultValue;\n          }\n        });\n      } // Support: IE<9\n      // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n      if (!assert(function (el) {\n        return el.getAttribute(\"disabled\") == null;\n      })) {\n        addHandle(booleans, function (elem, name, isXML) {\n          var val;\n\n          if (!isXML) {\n            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n          }\n        });\n      } // EXPOSE\n      // Do not expose Sizzle to the global scope in the case of AdGuard ExtendedCss build\n\n\n      return Sizzle; // EXPOSE\n    }(window); //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n  }\n\n  return Sizzle;\n};\n\n/* jshint ignore:end */\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class that extends Sizzle and adds support for \"matches-css\" pseudo element.\n */\n\nvar StylePropertyMatcher = function (window) {\n  var isPhantom = !!window._phantom;\n  var useFallback = isPhantom && !!window.getMatchedCSSRules;\n  /**\n   * Unquotes specified value\n   * Webkit-based browsers singlequotes <string> content property values\n   * Other browsers doublequotes content property values.\n   */\n\n  var removeContentQuotes = function removeContentQuotes(value) {\n    if (typeof value === 'string') {\n      return value.replace(/^([\"'])([\\s\\S]*)\\1$/, '$2');\n    }\n\n    return value;\n  };\n\n  var getComputedStyle = window.getComputedStyle.bind(window);\n  var getMatchedCSSRules = useFallback ? window.getMatchedCSSRules.bind(window) : null;\n  /**\n   * There is an issue in browsers based on old webkit:\n   * getComputedStyle(el, \":before\") is empty if element is not visible.\n   *\n   * To circumvent this issue we use getMatchedCSSRules instead.\n   *\n   * It appears that getMatchedCSSRules sorts the CSS rules\n   * in increasing order of specifities of corresponding selectors.\n   * We pick the css rule that is being applied to an element based on this assumption.\n   *\n   * @param element       DOM node\n   * @param pseudoElement Optional pseudoElement name\n   * @param propertyName  CSS property name\n   */\n\n  var getComputedStylePropertyValue = function getComputedStylePropertyValue(element, pseudoElement, propertyName) {\n    var value = '';\n\n    if (useFallback && pseudoElement) {\n      var cssRules = getMatchedCSSRules(element, pseudoElement) || [];\n      var i = cssRules.length;\n\n      while (i-- > 0 && !value) {\n        value = cssRules[i].style.getPropertyValue(propertyName);\n      }\n    } else {\n      var style = getComputedStyle(element, pseudoElement);\n\n      if (style) {\n        value = style.getPropertyValue(propertyName); // https://bugs.webkit.org/show_bug.cgi?id=93445\n\n        if (propertyName === 'opacity' && utils.isSafariBrowser) {\n          value = (Math.round(parseFloat(value) * 100) / 100).toString();\n        }\n      }\n    }\n\n    if (propertyName === 'content') {\n      value = removeContentQuotes(value);\n    }\n\n    return value;\n  };\n  /**\n   * Adds url parameter quotes for non-regex pattern\n   * @param {string} pattern\n   */\n\n\n  var addUrlQuotes = function addUrlQuotes(pattern) {\n    // for regex patterns\n    if (pattern[0] === '/' && pattern[pattern.length - 1] === '/' && pattern.indexOf('\\\\\"') < 10) {\n      // e.g. /^url\\\\([a-z]{4}:[a-z]{5}/\n      // or /^url\\\\(data\\\\:\\\\image\\\\/gif;base64.+/\n      var re = /(\\^)?url(\\\\)?\\\\\\((\\w|\\[\\w)/g;\n      return pattern.replace(re, '$1url$2\\\\\\(\\\\\"?$3');\n    } // for non-regex patterns\n\n\n    if (pattern.indexOf('url(\"') === -1) {\n      var _re = /url\\((.*?)\\)/g;\n      return pattern.replace(_re, 'url(\"$1\")');\n    }\n\n    return pattern;\n  };\n  /**\n   * Class that matches element style against the specified expression\n   * @member {string} propertyName\n   * @member {string} pseudoElement\n   * @member {RegExp} regex\n   */\n\n\n  var Matcher = function Matcher(propertyFilter, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n\n    try {\n      var index = propertyFilter.indexOf(':');\n      this.propertyName = propertyFilter.substring(0, index).trim();\n      var pattern = propertyFilter.substring(index + 1).trim();\n      pattern = addUrlQuotes(pattern); // Unescaping pattern\n      // For non-regex patterns, (,),[,] should be unescaped, because we require escaping them in filter rules.\n      // For regex patterns, \",\\ should be escaped, because we manually escape those in extended-css-selector.js.\n\n      if (/^\\/.*\\/$/.test(pattern)) {\n        pattern = pattern.slice(1, -1);\n        this.regex = utils.pseudoArgToRegex(pattern);\n      } else {\n        pattern = pattern.replace(/\\\\([\\\\()[\\]\"])/g, '$1');\n        this.regex = utils.createURLRegex(pattern);\n      }\n    } catch (ex) {\n      utils.logError(\"StylePropertyMatcher: invalid match string \".concat(propertyFilter));\n    }\n  };\n  /**\n   * Function to check if element CSS property matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  Matcher.prototype.matches = function (element) {\n    if (!this.regex || !this.propertyName) {\n      return false;\n    }\n\n    var value = getComputedStylePropertyValue(element, this.pseudoElement, this.propertyName);\n    return value && this.regex.test(value);\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-css'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n    sizzle.selectors.pseudos['matches-css-before'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter, ':before');\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n    sizzle.selectors.pseudos['matches-css-after'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      var matcher = new Matcher(propertyFilter, ':after');\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}(window);\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar matcherUtils = {};\nmatcherUtils.MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n/**\n * Parses argument of matcher pseudo (for matches-attr and matches-property)\n * @param {string} matcherFilter argument of pseudo class\n * @returns {Array}\n */\n\nmatcherUtils.parseMatcherFilter = function (matcherFilter) {\n  var FULL_MATCH_MARKER = '\"=\"';\n  var rawArgs = [];\n\n  if (matcherFilter.indexOf(FULL_MATCH_MARKER) === -1) {\n    // if there is only one pseudo arg\n    // e.g. :matches-attr(\"data-name\") or :matches-property(\"inner.prop\")\n    // Sizzle will parse it and get rid of quotes\n    // so it might be valid arg already without them\n    rawArgs.push(matcherFilter);\n  } else {\n    matcherFilter.split('=').forEach(function (arg) {\n      if (arg[0] === '\"' && arg[arg.length - 1] === '\"') {\n        rawArgs.push(arg.slice(1, -1));\n      }\n    });\n  }\n\n  return rawArgs;\n};\n/**\n * @typedef {Object} ArgData\n * @property {string} arg\n * @property {boolean} isRegexp\n */\n\n/**\n * Parses raw matcher arg\n * @param {string} rawArg\n * @returns {ArgData}\n */\n\n\nmatcherUtils.parseRawMatcherArg = function (rawArg) {\n  var arg = rawArg;\n  var isRegexp = !!rawArg && rawArg[0] === '/' && rawArg[rawArg.length - 1] === '/';\n\n  if (isRegexp) {\n    // to avoid at least such case  :matches-property(\"//\")\n    if (rawArg.length > 2) {\n      arg = utils.toRegExp(rawArg);\n    } else {\n      throw new Error(\"Invalid regexp: \".concat(rawArg));\n    }\n  }\n\n  return {\n    arg: arg,\n    isRegexp: isRegexp\n  };\n};\n/**\n * @typedef Chain\n * @property {Object} base\n * @property {string} prop\n * @property {string} value\n */\n\n/**\n * Checks if the property exists in the base object (recursively).\n * @param {Object} base\n * @param {ArgData[]} chain array of objects - parsed string property chain\n * @param {Array} [output=[]] result acc\n * @returns {Chain[]} array of objects\n */\n\n\nmatcherUtils.filterRootsByRegexpChain = function (base, chain) {\n  var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var tempProp = chain[0];\n\n  if (chain.length === 1) {\n    // eslint-disable-next-line no-restricted-syntax\n    for (var key in base) {\n      if (tempProp.isRegexp) {\n        if (tempProp.arg.test(key)) {\n          output.push({\n            base: base,\n            prop: key,\n            value: base[key]\n          });\n        }\n      } else if (tempProp.arg === key) {\n        output.push({\n          base: base,\n          prop: tempProp.arg,\n          value: base[key]\n        });\n      }\n    }\n\n    return output;\n  } // if there is a regexp prop in input chain\n  // e.g. 'unit./^ad.+/.src' for 'unit.ad-1gf2.src unit.ad-fgd34.src'),\n  // every base keys should be tested by regexp and it can be more that one results\n\n\n  if (tempProp.isRegexp) {\n    var nextProp = chain.slice(1);\n    var baseKeys = []; // eslint-disable-next-line no-restricted-syntax\n\n    for (var _key in base) {\n      if (tempProp.arg.test(_key)) {\n        baseKeys.push(_key);\n      }\n    }\n\n    baseKeys.forEach(function (key) {\n      var item = base[key];\n      matcherUtils.filterRootsByRegexpChain(item, nextProp, output);\n    });\n  } // avoid TypeError while accessing to null-prop's child\n\n\n  if (base === null) {\n    return;\n  }\n\n  var nextBase = base[tempProp.arg];\n  chain = chain.slice(1);\n\n  if (nextBase !== undefined) {\n    matcherUtils.filterRootsByRegexpChain(nextBase, chain, output);\n  }\n\n  return output;\n};\n/**\n * Validates parsed args of matches-property pseudo\n * @param {...ArgData} args\n */\n\n\nmatcherUtils.validatePropMatcherArgs = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  for (var i = 0; i < args.length; i += 1) {\n    if (args[i].isRegexp) {\n      if (!utils.startsWith(args[i].arg.toString(), '/') || !utils.endsWith(args[i].arg.toString(), '/')) {\n        return false;\n      } // simple arg check if it is not a regexp\n\n    } else if (!/^[\\w-]+$/.test(args[i].arg)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Class that extends Sizzle and adds support for \"matches-attr\" pseudo element.\n */\n\nvar AttributesMatcher = function () {\n  /**\n   * Class that matches element attributes against the specified expressions\n   * @param {ArgData} nameArg - parsed name argument\n   * @param {ArgData} valueArg - parsed value argument\n   * @param {string} pseudoElement\n   * @constructor\n   *\n   * @member {string|RegExp} attrName\n   * @member {boolean} isRegexpName\n   * @member {string|RegExp} attrValue\n   * @member {boolean} isRegexpValue\n   */\n  var AttrMatcher = function AttrMatcher(nameArg, valueArg, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n    this.attrName = nameArg.arg;\n    this.isRegexpName = nameArg.isRegexp;\n    this.attrValue = valueArg.arg;\n    this.isRegexpValue = valueArg.isRegexp;\n  };\n  /**\n   * Function to check if element attributes matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  AttrMatcher.prototype.matches = function (element) {\n    var elAttrs = element.attributes;\n\n    if (elAttrs.length === 0 || !this.attrName) {\n      return false;\n    }\n\n    var i = 0;\n\n    while (i < elAttrs.length) {\n      var attr = elAttrs[i];\n      var matched = false;\n      var attrNameMatched = this.isRegexpName ? this.attrName.test(attr.name) : this.attrName === attr.name;\n\n      if (!this.attrValue) {\n        // for :matches-attr(\"/regex/\") or :matches-attr(\"attr-name\")\n        matched = attrNameMatched;\n      } else {\n        var attrValueMatched = this.isRegexpValue ? this.attrValue.test(attr.value) : this.attrValue === attr.value;\n        matched = attrNameMatched && attrValueMatched;\n      }\n\n      if (matched) {\n        return true;\n      }\n\n      i += 1;\n    }\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-attr'] = sizzle.selectors.createPseudo(function (attrFilter) {\n      var _matcherUtils$parseMa = matcherUtils.parseMatcherFilter(attrFilter),\n          _matcherUtils$parseMa2 = _slicedToArray(_matcherUtils$parseMa, 2),\n          rawName = _matcherUtils$parseMa2[0],\n          rawValue = _matcherUtils$parseMa2[1];\n\n      var nameArg = matcherUtils.parseRawMatcherArg(rawName);\n      var valueArg = matcherUtils.parseRawMatcherArg(rawValue);\n\n      if (!attrFilter || !matcherUtils.validatePropMatcherArgs(nameArg, valueArg)) {\n        throw new Error(\"Invalid argument of :matches-attr pseudo class: \".concat(attrFilter));\n      }\n\n      var matcher = new AttrMatcher(nameArg, valueArg);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Parses raw property arg\n * @param {string} input\n * @returns {ArgData[]} array of objects\n */\n\nvar parseRawPropChain = function parseRawPropChain(input) {\n  var PROPS_DIVIDER = '.';\n  var REGEXP_MARKER = '/';\n  var propsArr = [];\n  var str = input;\n\n  while (str.length > 0) {\n    if (utils.startsWith(str, PROPS_DIVIDER)) {\n      // for cases like '.prop.id' and 'nested..test'\n      throw new Error(\"Invalid chain property: \".concat(input));\n    }\n\n    if (!utils.startsWith(str, REGEXP_MARKER)) {\n      var isRegexp = false;\n      var dividerIndex = str.indexOf(PROPS_DIVIDER);\n\n      if (str.indexOf(PROPS_DIVIDER) === -1) {\n        // if there is no '.' left in str\n        // take the rest of str as prop\n        propsArr.push({\n          arg: str,\n          isRegexp: isRegexp\n        });\n        return propsArr;\n      } // else take prop from str\n\n\n      var prop = str.slice(0, dividerIndex); // for cases like 'asadf.?+/.test'\n\n      if (prop.indexOf(REGEXP_MARKER) > -1) {\n        // prop is '?+/'\n        throw new Error(\"Invalid chain property: \".concat(prop));\n      }\n\n      propsArr.push({\n        arg: prop,\n        isRegexp: isRegexp\n      }); // delete prop from str\n\n      str = str.slice(dividerIndex);\n    } else {\n      // deal with regexp\n      var propChunks = [];\n      propChunks.push(str.slice(0, 1)); // if str starts with '/', delete it from str and find closing regexp slash.\n      // note that chained property name can not include '/' or '.'\n      // so there is no checking for escaped characters\n\n      str = str.slice(1);\n      var regexEndIndex = str.indexOf(REGEXP_MARKER);\n\n      if (regexEndIndex < 1) {\n        // regexp should be at least === '/./'\n        // so we should avoid args like '/id' and 'test.//.id'\n        throw new Error(\"Invalid regexp: \".concat(REGEXP_MARKER).concat(str));\n      }\n\n      var _isRegexp = true; // take the rest regexp part\n\n      propChunks.push(str.slice(0, regexEndIndex + 1));\n\n      var _prop = utils.toRegExp(propChunks.join(''));\n\n      propsArr.push({\n        arg: _prop,\n        isRegexp: _isRegexp\n      }); // delete prop from str\n\n      str = str.slice(regexEndIndex + 1);\n    }\n\n    if (!str) {\n      return propsArr;\n    } // str should be like '.nextProp' now\n    // so 'zx.prop' or '.' is invalid\n\n\n    if (!utils.startsWith(str, PROPS_DIVIDER) || utils.startsWith(str, PROPS_DIVIDER) && str.length === 1) {\n      throw new Error(\"Invalid chain property: \".concat(input));\n    }\n\n    str = str.slice(1);\n  }\n};\n\nvar convertTypeFromStr = function convertTypeFromStr(value) {\n  var numValue = Number(value);\n  var output;\n\n  if (!Number.isNaN(numValue)) {\n    output = numValue;\n  } else {\n    switch (value) {\n      case 'undefined':\n        output = undefined;\n        break;\n\n      case 'null':\n        output = null;\n        break;\n\n      case 'true':\n        output = true;\n        break;\n\n      case 'false':\n        output = false;\n        break;\n\n      default:\n        output = value;\n    }\n  }\n\n  return output;\n};\n\nvar convertTypeIntoStr = function convertTypeIntoStr(value) {\n  var output;\n\n  switch (value) {\n    case undefined:\n      output = 'undefined';\n      break;\n\n    case null:\n      output = 'null';\n      break;\n\n    default:\n      output = value.toString();\n  }\n\n  return output;\n};\n/**\n * Class that extends Sizzle and adds support for \"matches-property\" pseudo element.\n */\n\n\nvar ElementPropertyMatcher = function () {\n  /**\n   * Class that matches element properties against the specified expressions\n   * @param {ArgData[]} propsChainArg - array of parsed props chain objects\n   * @param {ArgData} valueArg - parsed value argument\n   * @param {string} pseudoElement\n   * @constructor\n   *\n   * @member {Array} chainedProps\n   * @member {boolean} isRegexpName\n   * @member {string|RegExp} propValue\n   * @member {boolean} isRegexpValue\n   */\n  var PropMatcher = function PropMatcher(propsChainArg, valueArg, pseudoElement) {\n    this.pseudoElement = pseudoElement;\n    this.chainedProps = propsChainArg;\n    this.propValue = valueArg.arg;\n    this.isRegexpValue = valueArg.isRegexp;\n  };\n  /**\n   * Function to check if element properties matches filter pattern\n   * @param {Element} element to check\n   */\n\n\n  PropMatcher.prototype.matches = function (element) {\n    var ownerObjArr = matcherUtils.filterRootsByRegexpChain(element, this.chainedProps);\n\n    if (ownerObjArr.length === 0) {\n      return false;\n    }\n\n    var matched = true;\n\n    if (this.propValue) {\n      for (var i = 0; i < ownerObjArr.length; i += 1) {\n        var realValue = ownerObjArr[i].value;\n\n        if (this.isRegexpValue) {\n          matched = this.propValue.test(convertTypeIntoStr(realValue));\n        } else {\n          // handle 'null' and 'undefined' property values set as string\n          if (realValue === 'null' || realValue === 'undefined') {\n            matched = this.propValue === realValue;\n            break;\n          }\n\n          matched = convertTypeFromStr(this.propValue) === realValue;\n        }\n\n        if (matched) {\n          break;\n        }\n      }\n    }\n\n    return matched;\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['matches-property'] = sizzle.selectors.createPseudo(function (propertyFilter) {\n      if (!propertyFilter) {\n        throw new Error('No argument is given for :matches-property pseudo class');\n      }\n\n      var _matcherUtils$parseMa = matcherUtils.parseMatcherFilter(propertyFilter),\n          _matcherUtils$parseMa2 = _slicedToArray(_matcherUtils$parseMa, 2),\n          rawProp = _matcherUtils$parseMa2[0],\n          rawValue = _matcherUtils$parseMa2[1]; // chained property name can not include '/' or '.'\n      // so regex prop names with such escaped characters are invalid\n\n\n      if (rawProp.indexOf('\\\\/') > -1 || rawProp.indexOf('\\\\.') > -1) {\n        throw new Error(\"Invalid property name: \".concat(rawProp));\n      }\n\n      var propsChainArg = parseRawPropChain(rawProp);\n      var valueArg = matcherUtils.parseRawMatcherArg(rawValue);\n      var propsToValidate = [].concat(_toConsumableArray(propsChainArg), [valueArg]);\n\n      if (!matcherUtils.validatePropMatcherArgs(propsToValidate)) {\n        throw new Error(\"Invalid argument of :matches-property pseudo class: \".concat(propertyFilter));\n      }\n\n      var matcher = new PropMatcher(propsChainArg, valueArg);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  }; // EXPOSE\n\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Copyright 2020 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Class that extends Sizzle and adds support for :is() pseudo element.\n */\n\nvar IsAnyMatcher = function () {\n  /**\n   * Class that matches element by one of the selectors\n   * https://developer.mozilla.org/en-US/docs/Web/CSS/:is\n   * @param {Array} selectors\n   * @param {string} pseudoElement\n   * @constructor\n   */\n  var IsMatcher = function IsMatcher(selectors, pseudoElement) {\n    this.selectors = selectors;\n    this.pseudoElement = pseudoElement;\n  };\n  /**\n   * Function to check if element can be matched by any passed selector\n   * @param {Element} element to check\n   */\n\n\n  IsMatcher.prototype.matches = function (element) {\n    var isMatched = !!this.selectors.find(function (selector) {\n      var nodes = document.querySelectorAll(selector);\n      return Array.from(nodes).find(function (node) {\n        return node === element;\n      });\n    });\n    return isMatched;\n  };\n  /**\n   * Creates a new pseudo-class and registers it in Sizzle\n   */\n\n\n  var extendSizzle = function extendSizzle(sizzle) {\n    // First of all we should prepare Sizzle engine\n    sizzle.selectors.pseudos['is'] = sizzle.selectors.createPseudo(function (input) {\n      if (input === '') {\n        throw new Error(\"Invalid argument of :is pseudo-class: \".concat(input));\n      }\n\n      var selectors = input.split(',').map(function (s) {\n        return s.trim();\n      }); // collect valid selectors and log about invalid ones\n\n      var validSelectors = selectors.reduce(function (acc, selector) {\n        if (cssUtils.isSimpleSelectorValid(selector)) {\n          acc.push(selector);\n        } else {\n          utils.logInfo(\"Invalid selector passed to :is() pseudo-class: '\".concat(selector, \"'\"));\n        }\n\n        return acc;\n      }, []);\n      var matcher = new IsMatcher(validSelectors);\n      return function (element) {\n        return matcher.matches(element);\n      };\n    });\n  };\n\n  return {\n    extendSizzle: extendSizzle\n  };\n}();\n\n/**\n * Copyright 2021 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Extended selector factory module, for creating extended selector classes.\n *\n * Extended selection capabilities description:\n * https://github.com/AdguardTeam/ExtendedCss/blob/master/README.md\n */\n\nvar ExtendedSelectorFactory = function () {\n  // while adding new markers, constants in other AdGuard repos should be corrected\n  // AdGuard browser extension : CssFilterRule.SUPPORTED_PSEUDO_CLASSES and CssFilterRule.EXTENDED_CSS_MARKERS\n  // tsurlfilter, SafariConverterLib : EXT_CSS_PSEUDO_INDICATORS\n  var PSEUDO_EXTENSIONS_MARKERS = [':has', ':contains', ':has-text', ':matches-css', ':-abp-has', ':-abp-has-text', ':if', ':if-not', ':xpath', ':nth-ancestor', ':upward', ':remove', ':matches-attr', ':matches-property', ':-abp-contains', ':is'];\n  var initialized = false;\n  var Sizzle;\n  /**\n   * Lazy initialization of the ExtendedSelectorFactory and objects that might be necessary for creating and applying styles.\n   * This method extends Sizzle engine that we use under the hood with our custom pseudo-classes.\n   */\n\n  function initialize() {\n    if (initialized) {\n      return;\n    }\n\n    initialized = true; // Our version of Sizzle is initialized lazily as well\n\n    Sizzle = initializeSizzle(); // Add :matches-css-*() support\n\n    StylePropertyMatcher.extendSizzle(Sizzle); // Add :matches-attr() support\n\n    AttributesMatcher.extendSizzle(Sizzle); // Add :matches-property() support\n\n    ElementPropertyMatcher.extendSizzle(Sizzle); // Add :is() support\n\n    IsAnyMatcher.extendSizzle(Sizzle); // Add :contains, :has-text, :-abp-contains support\n\n    var containsPseudo = Sizzle.selectors.createPseudo(function (text) {\n      if (/^\\s*\\/.*\\/[gmisuy]*\\s*$/.test(text)) {\n        text = text.trim();\n        var flagsIndex = text.lastIndexOf('/');\n        var flags = text.substring(flagsIndex + 1);\n        text = text.substr(0, flagsIndex + 1).slice(1, -1).replace(/\\\\([\\\\\"])/g, '$1');\n        var regex;\n\n        try {\n          regex = new RegExp(text, flags);\n        } catch (e) {\n          throw new Error(\"Invalid argument of :contains pseudo class: \".concat(text));\n        }\n\n        return function (elem) {\n          var elemTextContent = utils.nodeTextContentGetter.apply(elem);\n          return regex.test(elemTextContent);\n        };\n      }\n\n      text = text.replace(/\\\\([\\\\()[\\]\"])/g, '$1');\n      return function (elem) {\n        var elemTextContent = utils.nodeTextContentGetter.apply(elem);\n        return elemTextContent.indexOf(text) > -1;\n      };\n    });\n    Sizzle.selectors.pseudos['contains'] = containsPseudo;\n    Sizzle.selectors.pseudos['has-text'] = containsPseudo;\n    Sizzle.selectors.pseudos['-abp-contains'] = containsPseudo; // Add :if, :-abp-has support\n\n    Sizzle.selectors.pseudos['if'] = Sizzle.selectors.pseudos['has'];\n    Sizzle.selectors.pseudos['-abp-has'] = Sizzle.selectors.pseudos['has']; // Add :if-not support\n\n    Sizzle.selectors.pseudos['if-not'] = Sizzle.selectors.createPseudo(function (selector) {\n      if (typeof selector === 'string') {\n        Sizzle.compile(selector);\n      }\n\n      return function (elem) {\n        return Sizzle(selector, elem).length === 0;\n      };\n    });\n    registerParserOnlyTokens();\n  }\n  /**\n   * Registrate custom tokens for parser.\n   * Needed for proper work of pseudos:\n   * for checking if the token is last and pseudo-class arguments validation\n   */\n\n\n  function registerParserOnlyTokens() {\n    Sizzle.selectors.pseudos['xpath'] = Sizzle.selectors.createPseudo(function (selector) {\n      try {\n        document.createExpression(selector, null);\n      } catch (e) {\n        throw new Error(\"Invalid argument of :xpath pseudo class: \".concat(selector));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['nth-ancestor'] = Sizzle.selectors.createPseudo(function (selector) {\n      var deep = Number(selector);\n\n      if (Number.isNaN(deep) || deep < 1 || deep >= 256) {\n        throw new Error(\"Invalid argument of :nth-ancestor pseudo class: \".concat(selector));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['upward'] = Sizzle.selectors.createPseudo(function (input) {\n      if (input === '') {\n        throw new Error(\"Invalid argument of :upward pseudo class: \".concat(input));\n      } else if (Number.isInteger(+input) && (+input < 1 || +input >= 256)) {\n        throw new Error(\"Invalid argument of :upward pseudo class: \".concat(input));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n    Sizzle.selectors.pseudos['remove'] = Sizzle.selectors.createPseudo(function (input) {\n      if (input !== '') {\n        throw new Error(\"Invalid argument of :remove pseudo class: \".concat(input));\n      }\n\n      return function () {\n        return true;\n      };\n    });\n  }\n  /**\n   * Checks if specified token can be used by document.querySelectorAll.\n   */\n\n\n  function isSimpleToken(token) {\n    var type = token.type;\n\n    if (type === 'ID' || type === 'CLASS' || type === 'ATTR' || type === 'TAG' || type === 'CHILD') {\n      // known simple tokens\n      return true;\n    }\n\n    if (type === 'PSEUDO') {\n      // check if value contains any of extended pseudo classes\n      var i = PSEUDO_EXTENSIONS_MARKERS.length;\n\n      while (i--) {\n        if (token.value.indexOf(PSEUDO_EXTENSIONS_MARKERS[i]) >= 0) {\n          return false;\n        }\n      }\n\n      return true;\n    } // all others aren't simple\n\n\n    return false;\n  }\n  /**\n   * Checks if specified token is a combinator\n   */\n\n\n  function isRelationToken(token) {\n    var type = token.type;\n    return type === ' ' || type === '>' || type === '+' || type === '~';\n  }\n  /**\n   * ExtendedSelectorParser is a helper class for creating various selector instances which\n   * all shares a method `querySelectorAll()` and `matches()` implementing different search strategies\n   * depending on a type of selector.\n   *\n   * Currently, there are 3 types:\n   *  A trait-less extended selector\n   *    - we directly feed selector strings to Sizzle.\n   *  A splitted extended selector\n   *    - such as #container #feedItem:has(.ads), where it is splitted to `#container` and `#feedItem:has(.ads)`.\n   */\n\n\n  function ExtendedSelectorParser(selectorText, tokens, debug) {\n    initialize();\n\n    if (typeof tokens === 'undefined') {\n      this.selectorText = cssUtils.normalize(selectorText); // Passing `returnUnsorted` in order to receive tokens in the order that's valid for the browser\n      // In Sizzle internally, the tokens are re-sorted: https://github.com/AdguardTeam/ExtendedCss/issues/55\n\n      this.tokens = Sizzle.tokenize(this.selectorText, false, {\n        returnUnsorted: true\n      });\n    } else {\n      this.selectorText = selectorText;\n      this.tokens = tokens;\n    }\n\n    if (debug === true) {\n      this.debug = true;\n    }\n  }\n\n  ExtendedSelectorParser.prototype = {\n    /**\n     * The main method, creates a selector instance depending on the type of a selector.\n     * @public\n     */\n    createSelector: function createSelector() {\n      var debug = this.debug;\n      var tokens = this.tokens;\n      var selectorText = this.selectorText;\n\n      if (tokens.length !== 1) {\n        // Comma-separate selector - can't optimize further\n        return new TraitLessSelector(selectorText, debug);\n      }\n\n      var xpathPart = this.getXpathPart();\n\n      if (typeof xpathPart !== 'undefined') {\n        return new XpathSelector(selectorText, xpathPart, debug);\n      }\n\n      var upwardPart = this.getUpwardPart();\n\n      if (typeof upwardPart !== 'undefined') {\n        var output;\n        var upwardDeep = parseInt(upwardPart, 10); // if upward parameter is not a number, we consider it as a selector\n\n        if (Number.isNaN(upwardDeep)) {\n          output = new UpwardSelector(selectorText, upwardPart, debug);\n        } else {\n          // upward works like nth-ancestor\n          var xpath = this.convertNthAncestorToken(upwardDeep);\n          output = new XpathSelector(selectorText, xpath, debug);\n        }\n\n        return output;\n      } // argument of pseudo-class remove;\n      // it's defined only if remove is parsed as last token\n      // and it's valid only if remove arg is empty string\n\n\n      var removePart = this.getRemovePart();\n\n      if (typeof removePart !== 'undefined') {\n        var hasValidRemovePart = removePart === '';\n        return new RemoveSelector(selectorText, hasValidRemovePart, debug);\n      }\n\n      tokens = tokens[0];\n      var l = tokens.length;\n      var lastRelTokenInd = this.getSplitPoint();\n\n      if (typeof lastRelTokenInd === 'undefined') {\n        try {\n          document.querySelector(selectorText);\n        } catch (e) {\n          return new TraitLessSelector(selectorText, debug);\n        }\n\n        return new NotAnExtendedSelector(selectorText, debug);\n      }\n\n      var simple = '';\n      var relation = null;\n      var complex = '';\n      var i = 0;\n\n      for (; i < lastRelTokenInd; i++) {\n        // build simple part\n        simple += tokens[i].value;\n      }\n\n      if (i > 0) {\n        // build relation part\n        relation = tokens[i++].type;\n      } // i is pointing to the start of a complex part.\n\n\n      for (; i < l; i++) {\n        complex += tokens[i].value;\n      }\n\n      return lastRelTokenInd === -1 ? new TraitLessSelector(selectorText, debug) : new SplittedSelector(selectorText, simple, relation, complex, debug);\n    },\n\n    /**\n     * @private\n     * @return {number|undefined} An index of a token that is split point.\n     * returns undefined if the selector does not contain any complex tokens\n     * or it is not eligible for splitting.\n     * Otherwise returns an integer indicating the index of the last relation token.\n     */\n    getSplitPoint: function getSplitPoint() {\n      var tokens = this.tokens[0]; // We split selector only when the last compound selector\n      // is the only extended selector.\n\n      var latestRelationTokenIndex = -1;\n      var haveMetComplexToken = false;\n\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (isRelationToken(token)) {\n          if (haveMetComplexToken) {\n            return;\n          }\n\n          latestRelationTokenIndex = i;\n        } else if (!isSimpleToken(token)) {\n          haveMetComplexToken = true;\n        }\n      }\n\n      if (!haveMetComplexToken) {\n        return;\n      }\n\n      return latestRelationTokenIndex;\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} xpath selector part if exists\n     * returns undefined if the selector does not contain xpath tokens\n     */\n    getXpathPart: function getXpathPart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'xpath') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':xpath\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n\n            if (matches[0] === 'nth-ancestor') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':nth-ancestor\\' should be at the end of the selector');\n              }\n\n              var deep = matches[1];\n\n              if (deep > 0 && deep < 256) {\n                return this.convertNthAncestorToken(deep);\n              }\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * converts nth-ancestor/upward deep value to xpath equivalent\n     * @param {number} deep\n     * @return {string}\n     */\n    convertNthAncestorToken: function convertNthAncestorToken(deep) {\n      var result = '..';\n\n      while (deep > 1) {\n        result += '/..';\n        deep--;\n      }\n\n      return result;\n    },\n\n    /**\n     * Checks if the token is last,\n     * except of remove pseudo-class\n     * @param {Array} tokens\n     * @param {number} i index of token\n     * @returns {boolean}\n     */\n    isLastToken: function isLastToken(tokens, i) {\n      // check id the next parsed token is remove pseudo\n      var isNextRemoveToken = tokens[i + 1] && tokens[i + 1].type === 'PSEUDO' && tokens[i + 1].matches && tokens[i + 1].matches[0] === 'remove'; // check if the token is last\n      // and if it is not check if it is remove one\n      // which should be skipped\n\n      return i + 1 !== tokens.length && !isNextRemoveToken;\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} upward parameter\n     * or undefined if the input does not contain upward tokens\n     */\n    getUpwardPart: function getUpwardPart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'upward') {\n              if (this.isLastToken(tokens, i)) {\n                throw new Error('Invalid pseudo: \\':upward\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * @private\n     * @return {string|undefined} remove parameter\n     * or undefined if the input does not contain remove tokens\n     */\n    getRemovePart: function getRemovePart() {\n      var tokens = this.tokens[0];\n\n      for (var i = 0, tokensLength = tokens.length; i < tokensLength; i++) {\n        var token = tokens[i];\n\n        if (token.type === 'PSEUDO') {\n          var matches = token.matches;\n\n          if (matches && matches.length > 1) {\n            if (matches[0] === 'remove') {\n              if (i + 1 !== tokensLength) {\n                throw new Error('Invalid pseudo: \\':remove\\' should be at the end of the selector');\n              }\n\n              return matches[1];\n            }\n          }\n        }\n      }\n    }\n  };\n  var globalDebuggingFlag = false;\n\n  function isDebugging() {\n    return globalDebuggingFlag || this.debug;\n  }\n  /**\n   * This class represents a selector which is not an extended selector.\n   * @param {string} selectorText\n   * @param {boolean=} debug\n   * @final\n   */\n\n\n  function NotAnExtendedSelector(selectorText, debug) {\n    this.selectorText = selectorText;\n    this.debug = debug;\n  }\n\n  NotAnExtendedSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      return document.querySelectorAll(this.selectorText);\n    },\n    matches: function matches(element) {\n      return element[utils.matchesPropertyName](this.selectorText);\n    },\n    isDebugging: isDebugging\n  };\n  /**\n   * A trait-less extended selector class.\n   * @param {string} selectorText\n   * @param {boolean=} debug\n   * @constructor\n   */\n\n  function TraitLessSelector(selectorText, debug) {\n    this.selectorText = selectorText;\n    this.debug = debug;\n    Sizzle.compile(selectorText);\n  }\n\n  TraitLessSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      return Sizzle(this.selectorText);\n    },\n\n    /** @final */\n    matches: function matches(element) {\n      return Sizzle.matchesSelector(element, this.selectorText);\n    },\n\n    /** @final */\n    isDebugging: isDebugging\n  };\n  /**\n   * Parental class for such pseudo-classes as xpath, upward, remove\n   * which are limited to be the last one token in selector\n   *\n   * @param {string} selectorText\n   * @param {string} pseudoClassArg pseudo-class arg\n   * @param {boolean=} debug\n   * @constructor\n   */\n\n  function BaseLastArgumentSelector(selectorText, pseudoClassArg, debug) {\n    this.selectorText = selectorText;\n    this.pseudoClassArg = pseudoClassArg;\n    this.debug = debug;\n    Sizzle.compile(this.selectorText);\n  }\n\n  BaseLastArgumentSelector.prototype = {\n    querySelectorAll: function querySelectorAll() {\n      var _this = this;\n\n      var resultNodes = [];\n      var simpleNodes;\n\n      if (this.selectorText) {\n        simpleNodes = Sizzle(this.selectorText);\n\n        if (!simpleNodes || !simpleNodes.length) {\n          return resultNodes;\n        }\n      } else {\n        simpleNodes = [document];\n      }\n\n      simpleNodes.forEach(function (node) {\n        _this.searchResultNodes(node, _this.pseudoClassArg, resultNodes);\n      });\n      return Sizzle.uniqueSort(resultNodes);\n    },\n\n    /** @final */\n    matches: function matches(element) {\n      var results = this.querySelectorAll();\n      return results.indexOf(element) > -1;\n    },\n\n    /** @final */\n    isDebugging: isDebugging,\n\n    /**\n     * Primitive method that returns all nodes if pseudo-class arg is defined.\n     * That logic works for remove pseudo-class,\n     * but for others it should be overridden.\n     * @param {Object} node context element\n     * @param {string} pseudoClassArg pseudo-class argument\n     * @param {Array} result\n     */\n    searchResultNodes: function searchResultNodes(node, pseudoClassArg, result) {\n      if (pseudoClassArg) {\n        result.push(node);\n      }\n    }\n  };\n  /**\n   * Xpath selector class\n   * Limited to support 'xpath' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {string} xpath value\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n  function XpathSelector(selectorText, xpath, debug) {\n    var NO_SELECTOR_MARKER = ':xpath(//';\n    var BODY_SELECTOR_REPLACER = 'body:xpath(//';\n    var modifiedSelectorText = selectorText; // Normally, a pseudo-class is applied to nodes selected by a selector -- selector:xpath(...).\n    // However, :xpath is special as the selector can be ommited.\n    // For any other pseudo-class that would mean \"apply to ALL DOM nodes\",\n    // but in case of :xpath it just means \"apply me to the document\".\n\n    if (utils.startsWith(selectorText, NO_SELECTOR_MARKER)) {\n      modifiedSelectorText = selectorText.replace(NO_SELECTOR_MARKER, BODY_SELECTOR_REPLACER);\n    }\n\n    BaseLastArgumentSelector.call(this, modifiedSelectorText, xpath, debug);\n  }\n\n  XpathSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  XpathSelector.prototype.constructor = XpathSelector;\n  /**\n   * Applies xpath pseudo-class to provided context node\n   * @param {Object} node context element\n   * @param {string} pseudoClassArg xpath\n   * @param {Array} result\n   * @override\n   */\n\n  XpathSelector.prototype.searchResultNodes = function (node, pseudoClassArg, result) {\n    var xpathResult = document.evaluate(pseudoClassArg, node, null, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);\n    var iNode; // eslint-disable-next-line no-cond-assign\n\n    while (iNode = xpathResult.iterateNext()) {\n      result.push(iNode);\n    }\n  };\n  /**\n   * Upward selector class\n   * Limited to support 'upward' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {string} upwardSelector value\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n\n  function UpwardSelector(selectorText, upwardSelector, debug) {\n    BaseLastArgumentSelector.call(this, selectorText, upwardSelector, debug);\n  }\n\n  UpwardSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  UpwardSelector.prototype.constructor = UpwardSelector;\n  /**\n   * Applies upward pseudo-class to provided context node\n   * @param {Object} node context element\n   * @param {string} upwardSelector upward selector\n   * @param {Array} result\n   * @override\n   */\n\n  UpwardSelector.prototype.searchResultNodes = function (node, upwardSelector, result) {\n    if (upwardSelector !== '') {\n      var parent = node.parentElement;\n\n      if (parent === null) {\n        return;\n      }\n\n      node = parent.closest(upwardSelector);\n\n      if (node === null) {\n        return;\n      }\n    }\n\n    result.push(node);\n  };\n  /**\n   * Remove selector class\n   * Limited to support 'remove' to be only the last one token in selector\n   * @param {string} selectorText\n   * @param {boolean} hasValidRemovePart\n   * @param {boolean=} debug\n   * @constructor\n   * @augments BaseLastArgumentSelector\n   */\n\n\n  function RemoveSelector(selectorText, hasValidRemovePart, debug) {\n    var REMOVE_PSEUDO_MARKER = ':remove()';\n    var removeMarkerIndex = selectorText.indexOf(REMOVE_PSEUDO_MARKER); // deleting remove part of rule instead of which\n    // pseudo-property property 'remove' will be added by ExtendedCssParser\n\n    var modifiedSelectorText = selectorText.slice(0, removeMarkerIndex);\n    BaseLastArgumentSelector.call(this, modifiedSelectorText, hasValidRemovePart, debug); // mark extendedSelector as Remove one for ExtendedCssParser\n\n    this.isRemoveSelector = true;\n  }\n\n  RemoveSelector.prototype = Object.create(BaseLastArgumentSelector.prototype);\n  RemoveSelector.prototype.constructor = RemoveSelector;\n  /**\n   * A splitted extended selector class.\n   *\n   * #container #feedItem:has(.ads)\n   * +--------+                     simple\n   *           +                    relation\n   *            +-----------------+ complex\n   * We split selector only when the last selector is complex\n   * @param {string} selectorText\n   * @param {string} simple\n   * @param {string} relation\n   * @param {string} complex\n   * @param {boolean=} debug\n   * @constructor\n   * @extends TraitLessSelector\n   */\n\n  function SplittedSelector(selectorText, simple, relation, complex, debug) {\n    TraitLessSelector.call(this, selectorText, debug);\n    this.simple = simple;\n    this.relation = relation;\n    this.complex = complex;\n    Sizzle.compile(complex);\n  }\n\n  SplittedSelector.prototype = Object.create(TraitLessSelector.prototype);\n  SplittedSelector.prototype.constructor = SplittedSelector;\n  /** @override */\n\n  SplittedSelector.prototype.querySelectorAll = function () {\n    var _this2 = this;\n\n    var resultNodes = [];\n    var simpleNodes;\n    var simple = this.simple;\n    var relation;\n\n    if (simple) {\n      // First we use simple selector to narrow our search\n      simpleNodes = document.querySelectorAll(simple);\n\n      if (!simpleNodes || !simpleNodes.length) {\n        return resultNodes;\n      }\n\n      relation = this.relation;\n    } else {\n      simpleNodes = [document];\n      relation = ' ';\n    }\n\n    switch (relation) {\n      case ' ':\n        simpleNodes.forEach(function (node) {\n          _this2.relativeSearch(node, resultNodes);\n        });\n        break;\n\n      case '>':\n        {\n          simpleNodes.forEach(function (node) {\n            Object.values(node.children).forEach(function (childNode) {\n              if (_this2.matches(childNode)) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n\n      case '+':\n        {\n          simpleNodes.forEach(function (node) {\n            var parentNode = node.parentNode;\n            Object.values(parentNode.children).forEach(function (childNode) {\n              if (_this2.matches(childNode) && childNode.previousElementSibling === node) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n\n      case '~':\n        {\n          simpleNodes.forEach(function (node) {\n            var parentNode = node.parentNode;\n            Object.values(parentNode.children).forEach(function (childNode) {\n              if (_this2.matches(childNode) && node.compareDocumentPosition(childNode) === 4) {\n                resultNodes.push(childNode);\n              }\n            });\n          });\n          break;\n        }\n    }\n\n    return Sizzle.uniqueSort(resultNodes);\n  };\n  /**\n   * Performs a search of \"complex\" part relative to results for the \"simple\" part.\n   * @param {Node} node a node matching the \"simple\" part.\n   * @param {Node[]} result an array to append search result.\n   */\n\n\n  SplittedSelector.prototype.relativeSearch = function (node, results) {\n    Sizzle(this.complex, node, results);\n  };\n\n  return {\n    /**\n     * Wraps the inner class so that the instance is not exposed.\n     */\n    createSelector: function createSelector(selector, tokens, debug) {\n      return new ExtendedSelectorParser(selector, tokens, debug).createSelector();\n    },\n\n    /**\n     * Mark every selector as a selector being debugged, so that timing information\n     * for the selector is printed to the console.\n     */\n    enableGlobalDebugging: function enableGlobalDebugging() {\n      globalDebuggingFlag = true;\n    }\n  };\n}();\n\n/**\n * Copyright 2016 Adguard Software Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A helper class that parses stylesheets containing extended selectors\n * into ExtendedSelector instances and key-value maps of style declarations.\n * Please note, that it does not support any complex things like media queries and such.\n */\n\nvar ExtendedCssParser = function () {\n  var reDeclEnd = /[;}]/g;\n  var reDeclDivider = /[;:}]/g;\n  var reNonWhitespace = /\\S/g;\n  var Sizzle;\n  /**\n   * @param {string} cssText\n   * @constructor\n   */\n\n  function Parser(cssText) {\n    this.cssText = cssText;\n  }\n\n  Parser.prototype = {\n    error: function error(position) {\n      throw new Error(\"CssParser: parse error at position \".concat(this.posOffset + position));\n    },\n\n    /**\n     * Validates that the tokens correspond to a valid selector.\n     * Sizzle is different from browsers and some selectors that it tolerates aren't actually valid.\n     * For instance, \"div >\" won't work in a browser, but it will in Sizzle (it'd be the same as \"div > *\").\n     *\n     * @param {*} selectors An array of SelectorData (selector, groups)\n     * @returns {boolean} false if any of the groups are invalid\n     */\n    validateSelectors: function validateSelectors(selectors) {\n      var iSelectors = selectors.length;\n\n      while (iSelectors--) {\n        var groups = selectors[iSelectors].groups;\n        var iGroups = groups.length;\n\n        while (iGroups--) {\n          var tokens = groups[iGroups];\n          var lastToken = tokens[tokens.length - 1];\n\n          if (Sizzle.selectors.relative[lastToken.type]) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Parses a stylesheet and returns a list of pairs of an ExtendedSelector and a styles map.\n     * This method will throw an error in case of an obviously invalid input.\n     * If any of the selectors used in the stylesheet cannot be compiled into an ExtendedSelector,\n     * it will be ignored.\n     *\n     * @typedef {Object} ExtendedStyle\n     * @property {Object} selector An instance of the {@link ExtendedSelector} class\n     * @property {Object} styleMap A map of styles parsed\n     *\n     * @returns {Array.<ExtendedStyle>} An array of the styles parsed\n     */\n    parseCss: function parseCss() {\n      this.posOffset = 0;\n\n      if (!this.cssText) {\n        this.error(0);\n      }\n\n      var results = [];\n\n      while (this.cssText) {\n        // Apply tolerant tokenization.\n        var parseResult = Sizzle.tokenize(this.cssText, false, {\n          tolerant: true,\n          returnUnsorted: true\n        });\n        var selectorData = parseResult.selectors;\n        this.nextIndex = parseResult.nextIndex;\n\n        if (this.cssText.charCodeAt(this.nextIndex) !== 123 ||\n        /* charCode of '{' */\n        !this.validateSelectors(selectorData)) {\n          this.error(this.nextIndex);\n        }\n\n        this.nextIndex++; // Move the pointer to the start of style declaration.\n\n        var styleMap = this.parseNextStyle();\n        var debug = false; // If there is a style property 'debug', mark the selector\n        // as a debuggable selector, and delete the style declaration.\n\n        var debugPropertyValue = styleMap['debug'];\n\n        if (typeof debugPropertyValue !== 'undefined') {\n          if (debugPropertyValue === 'global') {\n            ExtendedSelectorFactory.enableGlobalDebugging();\n          }\n\n          debug = true;\n          delete styleMap['debug'];\n        } // Creating an ExtendedSelector instance for every selector we got from Sizzle.tokenize.\n        // This is quite important as Sizzle does a poor job at executing selectors like \"selector1, selector2\".\n\n\n        for (var i = 0, l = selectorData.length; i < l; i++) {\n          var data = selectorData[i];\n\n          try {\n            var extendedSelector = ExtendedSelectorFactory.createSelector(data.selectorText, data.groups, debug);\n\n            if (extendedSelector.pseudoClassArg && extendedSelector.isRemoveSelector) {\n              // if there is remove pseudo-class in rule,\n              // the element will be removed and no other styles will be applied\n              styleMap['remove'] = 'true';\n            }\n\n            results.push({\n              selector: extendedSelector,\n              style: styleMap\n            });\n          } catch (ex) {\n            utils.logError(\"ExtendedCssParser: ignoring invalid selector \".concat(data.selectorText));\n          }\n        }\n      }\n\n      return results;\n    },\n    parseNextStyle: function parseNextStyle() {\n      var styleMap = Object.create(null);\n      var bracketPos = this.parseUntilClosingBracket(styleMap); // Cut out matched portion from cssText.\n\n      reNonWhitespace.lastIndex = bracketPos + 1;\n      var match = reNonWhitespace.exec(this.cssText);\n\n      if (match === null) {\n        this.cssText = '';\n        return styleMap;\n      }\n\n      var matchPos = match.index;\n      this.cssText = this.cssText.slice(matchPos);\n      this.posOffset += matchPos;\n      return styleMap;\n    },\n\n    /**\n     * @return {number} an index of the next '}' in `this.cssText`.\n     */\n    parseUntilClosingBracket: function parseUntilClosingBracket(styleMap) {\n      // Expects \":\", \";\", and \"}\".\n      reDeclDivider.lastIndex = this.nextIndex;\n      var match = reDeclDivider.exec(this.cssText);\n\n      if (match === null) {\n        this.error(this.nextIndex);\n      }\n\n      var matchPos = match.index;\n      var matched = match[0];\n\n      if (matched === '}') {\n        return matchPos;\n      }\n\n      if (matched === ':') {\n        var colonIndex = matchPos; // Expects \";\" and \"}\".\n\n        reDeclEnd.lastIndex = colonIndex;\n        match = reDeclEnd.exec(this.cssText);\n\n        if (match === null) {\n          this.error(colonIndex);\n        }\n\n        matchPos = match.index;\n        matched = match[0]; // Populates the `styleMap` key-value map.\n\n        var property = this.cssText.slice(this.nextIndex, colonIndex).trim();\n        var value = this.cssText.slice(colonIndex + 1, matchPos).trim();\n        styleMap[property] = value; // If found \"}\", re-run the outer loop.\n\n        if (matched === '}') {\n          return matchPos;\n        }\n      } // matchPos is the position of the next ';'.\n      // Increase 'nextIndex' and re-run the loop.\n\n\n      this.nextIndex = matchPos + 1;\n      return this.parseUntilClosingBracket(styleMap); // Should be a subject of tail-call optimization.\n    }\n  };\n  return {\n    parseCss: function parseCss(cssText) {\n      Sizzle = initializeSizzle();\n      return new Parser(cssUtils.normalize(cssText)).parseCss();\n    }\n  };\n}();\n\n/**\n * This callback is used to get affected node elements and handle style properties\n * before they are applied to them if it is necessary\n * @callback beforeStyleApplied\n * @param {object} affectedElement - Object containing DOM node and rule to be applied\n * @return {object} affectedElement - Same or modified object containing DOM node and rule to be applied\n */\n\n/**\n * Extended css class\n *\n * @param {Object} configuration\n * @param {string} configuration.styleSheet - the CSS stylesheet text\n * @param {beforeStyleApplied} [configuration.beforeStyleApplied] - the callback that handles affected elements\n * @constructor\n */\n\nfunction ExtendedCss(configuration) {\n  if (!configuration) {\n    throw new Error('Configuration is not provided.');\n  }\n\n  var styleSheet = configuration.styleSheet;\n  var beforeStyleApplied = configuration.beforeStyleApplied;\n\n  if (beforeStyleApplied && typeof beforeStyleApplied !== 'function') {\n    // eslint-disable-next-line max-len\n    throw new Error(\"Wrong configuration. Type of 'beforeStyleApplied' field should be a function, received: \".concat(_typeof(beforeStyleApplied)));\n  } // We use EventTracker to track the event that is likely to cause the mutation.\n  // The problem is that we cannot use `window.event` directly from the mutation observer call\n  // as we're not in the event handler context anymore.\n\n\n  var EventTracker = function () {\n    var ignoredEventTypes = ['mouseover', 'mouseleave', 'mouseenter', 'mouseout'];\n    var LAST_EVENT_TIMEOUT_MS = 10;\n    var EVENTS = [// keyboard events\n    'keydown', 'keypress', 'keyup', // mouse events\n    'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel']; // 'wheel' event makes scrolling in Safari twitchy\n    // https://github.com/AdguardTeam/ExtendedCss/issues/120\n\n    var safariProblematicEvents = ['wheel'];\n    var trackedEvents = utils.isSafariBrowser ? EVENTS.filter(function (el) {\n      return !(safariProblematicEvents.indexOf(el) > -1);\n    }) : EVENTS;\n    var lastEventType;\n    var lastEventTime;\n\n    var trackEvent = function trackEvent(e) {\n      lastEventType = e.type;\n      lastEventTime = Date.now();\n    };\n\n    trackedEvents.forEach(function (evName) {\n      document.documentElement.addEventListener(evName, trackEvent, true);\n    });\n\n    var getLastEventType = function getLastEventType() {\n      return lastEventType;\n    };\n\n    var getTimeSinceLastEvent = function getTimeSinceLastEvent() {\n      return Date.now() - lastEventTime;\n    };\n\n    return {\n      isIgnoredEventType: function isIgnoredEventType() {\n        return ignoredEventTypes.indexOf(getLastEventType()) > -1 && getTimeSinceLastEvent() < LAST_EVENT_TIMEOUT_MS;\n      }\n    };\n  }();\n\n  var rules = [];\n  var affectedElements = [];\n  var removalsStatistic = {};\n  var domObserved;\n  var eventListenerSupported = window.addEventListener;\n  var domMutationObserver;\n\n  function observeDocument(callback) {\n    // We are trying to limit the number of callback calls by not calling it on all kind of \"hover\" events.\n    // The rationale behind this is that \"hover\" events often cause attributes modification,\n    // but re-applying extCSS rules will be useless as these attribute changes are usually transient.\n    var isIgnoredMutation = function isIgnoredMutation(mutations) {\n      for (var i = 0; i < mutations.length; i += 1) {\n        if (mutations.type !== 'attributes') {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    if (utils.MutationObserver) {\n      domMutationObserver = new utils.MutationObserver(function (mutations) {\n        if (!mutations || mutations.length === 0) {\n          return;\n        }\n\n        if (EventTracker.isIgnoredEventType() && isIgnoredMutation(mutations)) {\n          return;\n        }\n\n        callback();\n      });\n      domMutationObserver.observe(document, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: ['id', 'class']\n      });\n    } else if (eventListenerSupported) {\n      document.addEventListener('DOMNodeInserted', callback, false);\n      document.addEventListener('DOMNodeRemoved', callback, false);\n      document.addEventListener('DOMAttrModified', callback, false);\n    }\n  }\n\n  function disconnectDocument(callback) {\n    if (domMutationObserver) {\n      domMutationObserver.disconnect();\n    } else if (eventListenerSupported) {\n      document.removeEventListener('DOMNodeInserted', callback, false);\n      document.removeEventListener('DOMNodeRemoved', callback, false);\n      document.removeEventListener('DOMAttrModified', callback, false);\n    }\n  }\n\n  var MAX_STYLE_PROTECTION_COUNT = 50;\n  var protectionObserverOption = {\n    attributes: true,\n    attributeOldValue: true,\n    attributeFilter: ['style']\n  };\n  /**\n   * Creates MutationObserver protection function\n   *\n   * @param styles\n   * @return {protectionFunction}\n   */\n\n  function createProtectionFunction(styles) {\n    function protectionFunction(mutations, observer) {\n      if (!mutations.length) {\n        return;\n      }\n\n      var mutation = mutations[0];\n      var target = mutation.target;\n      observer.disconnect();\n      styles.forEach(function (style) {\n        setStyleToElement(target, style);\n      });\n\n      if (++observer.styleProtectionCount < MAX_STYLE_PROTECTION_COUNT) {\n        observer.observe(target, protectionObserverOption);\n      } else {\n        utils.logError('ExtendedCss: infinite loop protection for style');\n      }\n    }\n\n    return protectionFunction;\n  }\n  /**\n   * Sets up a MutationObserver which protects style attributes from changes\n   * @param node DOM node\n   * @param rules rules\n   * @returns Mutation observer used to protect attribute or null if there's nothing to protect\n   */\n\n\n  function protectStyleAttribute(node, rules) {\n    if (!utils.MutationObserver) {\n      return null;\n    }\n\n    var styles = rules.map(function (r) {\n      return r.style;\n    });\n    var protectionObserver = new utils.MutationObserver(createProtectionFunction(styles));\n    protectionObserver.observe(node, protectionObserverOption); // Adds an expando to the observer to keep 'style fix counts'.\n\n    protectionObserver.styleProtectionCount = 0;\n    return protectionObserver;\n  }\n\n  function removeSuffix(str, suffix) {\n    var index = str.indexOf(suffix, str.length - suffix.length);\n\n    if (index >= 0) {\n      return str.substring(0, index);\n    }\n\n    return str;\n  }\n  /**\n   * Finds affectedElement object for the specified DOM node\n   * @param node  DOM node\n   * @returns     affectedElement found or null\n   */\n\n\n  function findAffectedElement(node) {\n    for (var i = 0; i < affectedElements.length; i += 1) {\n      if (affectedElements[i].node === node) {\n        return affectedElements[i];\n      }\n    }\n\n    return null;\n  }\n\n  function removeElement(affectedElement) {\n    var node = affectedElement.node;\n    affectedElement.removed = true;\n    var elementSelector = utils.getNodeSelector(node); // check if the element has been already removed earlier\n\n    var elementRemovalsCounter = removalsStatistic[elementSelector] || 0; // if removals attempts happened more than specified we do not try to remove node again\n\n    if (elementRemovalsCounter > MAX_STYLE_PROTECTION_COUNT) {\n      utils.logError('ExtendedCss: infinite loop protection for SELECTOR', elementSelector);\n      return;\n    }\n\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n      removalsStatistic[elementSelector] = elementRemovalsCounter + 1;\n    }\n  }\n  /**\n   * Applies style to the specified DOM node\n   * @param affectedElement Object containing DOM node and rule to be applied\n   */\n\n\n  function applyStyle(affectedElement) {\n    if (affectedElement.protectionObserver) {\n      // Style is already applied and protected by the observer\n      return;\n    }\n\n    if (beforeStyleApplied) {\n      affectedElement = beforeStyleApplied(affectedElement);\n\n      if (!affectedElement) {\n        return;\n      }\n    }\n\n    var _affectedElement = affectedElement,\n        node = _affectedElement.node;\n\n    for (var i = 0; i < affectedElement.rules.length; i++) {\n      var style = affectedElement.rules[i].style;\n\n      if (style['remove'] === 'true') {\n        removeElement(affectedElement);\n        return;\n      }\n\n      setStyleToElement(node, style);\n    }\n  }\n  /**\n   * Sets style to the specified DOM node\n   * @param node element\n   * @param style style\n   */\n\n\n  function setStyleToElement(node, style) {\n    Object.keys(style).forEach(function (prop) {\n      // Apply this style only to existing properties\n      // We can't use hasOwnProperty here (does not work in FF)\n      if (typeof node.style.getPropertyValue(prop) !== 'undefined') {\n        var value = style[prop]; // First we should remove !important attribute (or it won't be applied')\n\n        value = removeSuffix(value.trim(), '!important').trim();\n        node.style.setProperty(prop, value, 'important');\n      }\n    });\n  }\n  /**\n   * Reverts style for the affected object\n   */\n\n\n  function revertStyle(affectedElement) {\n    if (affectedElement.protectionObserver) {\n      affectedElement.protectionObserver.disconnect();\n    }\n\n    affectedElement.node.style.cssText = affectedElement.originalStyle;\n  }\n  /**\n   * Applies specified rule and returns list of elements affected\n   * @param rule Rule to apply\n   * @returns List of elements affected by this rule\n   */\n\n\n  function applyRule(rule) {\n    var debug = rule.selector.isDebugging();\n    var start;\n\n    if (debug) {\n      start = utils.AsyncWrapper.now();\n    }\n\n    var selector = rule.selector;\n    var nodes = selector.querySelectorAll();\n    nodes.forEach(function (node) {\n      var affectedElement = findAffectedElement(node);\n\n      if (affectedElement) {\n        affectedElement.rules.push(rule);\n        applyStyle(affectedElement);\n      } else {\n        // Applying style first time\n        var originalStyle = node.style.cssText;\n        affectedElement = {\n          node: node,\n          // affected DOM node\n          rules: [rule],\n          // rules to be applied\n          originalStyle: originalStyle,\n          // original node style\n          protectionObserver: null // style attribute observer\n\n        };\n        applyStyle(affectedElement);\n        affectedElements.push(affectedElement);\n      }\n    });\n\n    if (debug) {\n      var elapsed = utils.AsyncWrapper.now() - start;\n\n      if (!('timingStats' in rule)) {\n        rule.timingStats = new utils.Stats();\n      }\n\n      rule.timingStats.push(elapsed);\n    }\n\n    return nodes;\n  }\n  /**\n   * Applies filtering rules\n   */\n\n\n  function applyRules() {\n    var elementsIndex = []; // some rules could make call - selector.querySelectorAll() temporarily to change node id attribute\n    // this caused MutationObserver to call recursively\n    // https://github.com/AdguardTeam/ExtendedCss/issues/81\n\n    stopObserve();\n    rules.forEach(function (rule) {\n      var nodes = applyRule(rule);\n      Array.prototype.push.apply(elementsIndex, nodes);\n    }); // Now revert styles for elements which are no more affected\n\n    var l = affectedElements.length; // do nothing if there is no elements to process\n\n    if (elementsIndex.length > 0) {\n      while (l--) {\n        var obj = affectedElements[l];\n\n        if (elementsIndex.indexOf(obj.node) === -1) {\n          // Time to revert style\n          revertStyle(obj);\n          affectedElements.splice(l, 1);\n        } else if (!obj.removed) {\n          // Add style protection observer\n          // Protect \"style\" attribute from changes\n          if (!obj.protectionObserver) {\n            obj.protectionObserver = protectStyleAttribute(obj.node, obj.rules);\n          }\n        }\n      }\n    } // After styles are applied we can start observe again\n\n\n    observe();\n    printTimingInfo();\n  }\n\n  var APPLY_RULES_DELAY = 150;\n  var applyRulesScheduler = new utils.AsyncWrapper(applyRules, APPLY_RULES_DELAY);\n  var mainCallback = applyRulesScheduler.run.bind(applyRulesScheduler);\n\n  function observe() {\n    if (domObserved) {\n      return;\n    } // Handle dynamically added elements\n\n\n    domObserved = true;\n    observeDocument(mainCallback);\n  }\n\n  function stopObserve() {\n    if (!domObserved) {\n      return;\n    }\n\n    domObserved = false;\n    disconnectDocument(mainCallback);\n  }\n\n  function apply() {\n    applyRules();\n\n    if (document.readyState !== 'complete') {\n      document.addEventListener('DOMContentLoaded', applyRules);\n    }\n  }\n  /**\n   * Disposes ExtendedCss and removes our styles from matched elements\n   */\n\n\n  function dispose() {\n    stopObserve();\n    affectedElements.forEach(function (obj) {\n      revertStyle(obj);\n    });\n  }\n\n  var timingsPrinted = false;\n  /**\n   * Prints timing information for all selectors marked as \"debug\"\n   */\n\n  function printTimingInfo() {\n    if (timingsPrinted) {\n      return;\n    }\n\n    timingsPrinted = true;\n    var timings = rules.filter(function (rule) {\n      return rule.selector.isDebugging();\n    }).map(function (rule) {\n      return {\n        selectorText: rule.selector.selectorText,\n        timingStats: rule.timingStats\n      };\n    });\n\n    if (timings.length === 0) {\n      return;\n    } // Add location.href to the message to distinguish frames\n\n\n    utils.logInfo('[ExtendedCss] Timings for %o:\\n%o (in milliseconds)', window.location.href, timings);\n  } // First of all parse the stylesheet\n\n\n  rules = ExtendedCssParser.parseCss(styleSheet); // EXPOSE\n\n  this.dispose = dispose;\n  this.apply = apply;\n  /** Exposed for testing purposes only */\n\n  this._getAffectedElements = function () {\n    return affectedElements;\n  };\n}\n/**\n * Expose querySelectorAll for debugging and validating selectors\n *\n * @param {string} selectorText selector text\n * @param {boolean} noTiming if true -- do not print the timing to the console\n * @returns {Array<Node>|NodeList} a list of elements found\n * @throws Will throw an error if the argument is not a valid selector\n */\n\n\nExtendedCss.query = function (selectorText, noTiming) {\n  if (typeof selectorText !== 'string') {\n    throw new Error('Selector text is empty');\n  }\n\n  var now = utils.AsyncWrapper.now;\n  var start = now();\n\n  try {\n    return ExtendedSelectorFactory.createSelector(selectorText).querySelectorAll();\n  } finally {\n    var end = now();\n\n    if (!noTiming) {\n      utils.logInfo(\"[ExtendedCss] Elapsed: \".concat(Math.round((end - start) * 1000), \" \\u03BCs.\"));\n    }\n  }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExtendedCss);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy9leHRlbmRlZC1jc3MvZGlzdC9leHRlbmRlZC1jc3MuZXNtLmpzPzFmOTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9DQUFvQyxFQUFFO0FBQ3RDOztBQUVBLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMkJBQTJCLHlDQUF5QztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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SztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QixnQ0FBZ0M7O0FBRWhDLDhDQUE4Qzs7QUFFOUMsMkNBQTJDOztBQUUzQyxnREFBZ0Q7O0FBRWhELHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBLDJFQUEyRTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUCxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxrQkFBa0I7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKO0FBQ2pKO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxrQkFBa0I7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxrQkFBa0I7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFOztBQUVBO0FBQ0EseUZBQXlGOztBQUV6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCLHlCQUF5QixFQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsa0JBQWtCLE9BQU8sOEJBQThCLHVCQUF1QjtBQUM5RSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0EsZ0RBQWdELE9BQU87QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsT0FBTyx3QkFBd0I7QUFDL0M7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsY0FBYyxRQUFROztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLG1DQUFtQyxlQUFlOztBQUVsRCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLE9BQU8sMkNBQTJDO0FBQ2xEOzs7QUFHQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwTUFBME07QUFDMU07O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXRELHlFQUF5RTs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsa0NBQWtDO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFHOzs7QUFHSCxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsV0FBVyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2V4dGVuZGVkLWNzcy9kaXN0L2V4dGVuZGVkLWNzcy5lc20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgZXh0ZW5kZWQtY3NzIC0gdjEuMy4xMiAtIE1vbiBNYXkgMzEgMjAyMVxuKiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vRXh0ZW5kZWRDc3NcbiogQ29weXJpZ2h0IChjKSAyMDIxIEFkR3VhcmQuIExpY2Vuc2VkIExHUEwtMy4wXG4qL1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgQWRndWFyZCBTb2Z0d2FyZSBMdGRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG52YXIgdXRpbHMgPSB7fTtcbnV0aWxzLk11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbi8qKlxuICogU3RvcmVzIG5hdGl2ZSBOb2RlIHRleHRDb250ZW50IGdldHRlciB0byBiZSB1c2VkIGZvciBjb250YWlucyBwc2V1ZG8tY2xhc3NcbiAqIGJlY2F1c2UgZWxlbWVudHMnICd0ZXh0Q29udGVudCcgYW5kICdpbm5lclRleHQnIHByb3BlcnRpZXMgbWlnaHQgYmUgbW9ja2VkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vRXh0ZW5kZWRDc3MvaXNzdWVzLzEyN1xuICovXG5cbnV0aWxzLm5vZGVUZXh0Q29udGVudEdldHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hdGl2ZU5vZGUgPSB3aW5kb3cuTm9kZSB8fCBOb2RlO1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuYXRpdmVOb2RlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50JykuZ2V0O1xufSgpO1xuXG51dGlscy5pc1NhZmFyaUJyb3dzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpc0Nocm9tZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMTtcbiAgdmFyIGlzU2FmYXJpID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSA+IC0xO1xuXG4gIGlmIChpc1NhZmFyaSkge1xuICAgIGlmIChpc0Nocm9tZSkge1xuICAgICAgLy8gQ2hyb21lIHNlZW1zIHRvIGhhdmUgYm90aCBDaHJvbWUgYW5kIFNhZmFyaSB1c2VyQWdlbnRzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59KCk7XG4vKipcbiAqIENvbnZlcnRzIHJlZ3VsYXIgZXhwcmVzc2lvbnMgcGFzc2VkIGFzIHBzZXVkbyBjbGFzcyBhcmd1bWVudHMgaW50byBSZWdFeHAgaW5zdGFuY2VzLlxuICogSGF2ZSB0byB1bmVzY2FwZSBkb3VibGVxdW90ZSBcIiBhcyB3ZWxsLCBiZWNhdXNlIHdlIGVzY2FwZSB0aGVtIHdoaWxlIGVuY2xvc2luZyBzdWNoXG4gKiBhcmd1bWVudHMgd2l0aCBkb3VibGVxdW90ZXMsIGFuZCBzaXp6bGUgZG9lcyBub3QgYXV0b21hdGljYWxseSB1bmVzY2FwZXMgdGhlbS5cbiAqL1xuXG5cbnV0aWxzLnBzZXVkb0FyZ1RvUmVnZXggPSBmdW5jdGlvbiAocmVnZXhTcmMsIGZsYWcpIHtcbiAgZmxhZyA9IGZsYWcgfHwgJ2knO1xuICByZWdleFNyYyA9IHJlZ2V4U3JjLnRyaW0oKS5yZXBsYWNlKC9cXFxcKFtcIlxcXFxdKS9nLCAnJDEnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhTcmMsIGZsYWcpO1xufTtcbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIHRoZSByZWdleHBcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKi9cblxuXG51dGlscy50b1JlZ0V4cCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHN0clswXSA9PT0gJy8nICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcvJykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHN0ci5zbGljZSgxLCAtMSkpO1xuICB9XG5cbiAgdmFyIGVzY2FwZWQgPSBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoZXNjYXBlZCk7XG59O1xuXG51dGlscy5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHN0ciwgcHJlZml4KSB7XG4gIC8vIGlmIHN0ciA9PT0gJycsIChzdHIgJiYgZmFsc2UpIHdpbGwgcmV0dXJuICcnXG4gIC8vIHRoYXQncyB3aHkgaXQgaGFzIHRvIGJlICEhc3RyXG4gIHJldHVybiAhIXN0ciAmJiBzdHIuaW5kZXhPZihwcmVmaXgpID09PSAwO1xufTtcblxudXRpbHMuZW5kc1dpdGggPSBmdW5jdGlvbiAoc3RyLCBwb3N0Zml4KSB7XG4gIGlmICghc3RyIHx8ICFwb3N0Zml4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0ci5lbmRzV2l0aCkge1xuICAgIHJldHVybiBzdHIuZW5kc1dpdGgocG9zdGZpeCk7XG4gIH1cblxuICB2YXIgdCA9IFN0cmluZyhwb3N0Zml4KTtcbiAgdmFyIGluZGV4ID0gc3RyLmxhc3RJbmRleE9mKHQpO1xuICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA9PT0gc3RyLmxlbmd0aCAtIHQubGVuZ3RoO1xufTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSBhIHVybCBmaWx0ZXIgcnVsZSBzeW50YXguXG4gKi9cblxuXG51dGlscy5jcmVhdGVVUkxSZWdleCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQ29uc3RhbnRzXG4gIHZhciByZWdleENvbmZpZ3VyYXRpb24gPSB7XG4gICAgbWFza1N0YXJ0VXJsOiAnfHwnLFxuICAgIG1hc2tQaXBlOiAnfCcsXG4gICAgbWFza1NlcGFyYXRvcjogJ14nLFxuICAgIG1hc2tBbnlTeW1ib2w6ICcqJyxcbiAgICByZWdleEFueVN5bWJvbDogJy4qJyxcbiAgICByZWdleFNlcGFyYXRvcjogJyhbXiBhLXpBLVowLTkuJV8tXXwkKScsXG4gICAgcmVnZXhTdGFydFVybDogJ14oaHR0cHxodHRwc3x3c3x3c3MpOi8vKFthLXowLTktXy5dK1xcXFwuKT8nLFxuICAgIHJlZ2V4U3RhcnRTdHJpbmc6ICdeJyxcbiAgICByZWdleEVuZFN0cmluZzogJyQnXG4gIH07IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL3JlZ2V4cFxuICAvLyBzaG91bGQgYmUgZXNjYXBlZCAuICogKyA/IF4gJCB7IH0gKCApIHwgWyBdIC8gXFxcbiAgLy8gZXhjZXB0IG9mICogfCBeXG5cbiAgdmFyIHNwZWNpYWxzID0gWycuJywgJysnLCAnPycsICckJywgJ3snLCAnfScsICcoJywgJyknLCAnWycsICddJywgJ1xcXFwnLCAnLyddO1xuICB2YXIgc3BlY2lhbHNSZWdleCA9IG5ldyBSZWdFeHAoXCJbXCIuY29uY2F0KHNwZWNpYWxzLmpvaW4oJ1xcXFwnKSwgXCJdXCIpLCAnZycpO1xuICAvKipcbiAgICogRXNjYXBlcyByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nXG4gICAqL1xuXG4gIHZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHNwZWNpYWxzUmVnZXgsICdcXFxcJCYnKTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZUFsbCA9IGZ1bmN0aW9uIHJlcGxhY2VBbGwoc3RyLCBmaW5kLCByZXBsYWNlKSB7XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5zcGxpdChmaW5kKS5qb2luKHJlcGxhY2UpO1xuICB9O1xuICAvKipcbiAgICogTWFpbiBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGEgdXJsIGZpbHRlciBydWxlIHN0cmluZyB0byBhIHJlZ2V4LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge1JlZ0V4cH1cbiAgICovXG5cblxuICB2YXIgY3JlYXRlUmVnZXhUZXh0ID0gZnVuY3Rpb24gY3JlYXRlUmVnZXhUZXh0KHN0cikge1xuICAgIHZhciByZWdleCA9IGVzY2FwZVJlZ0V4cChzdHIpO1xuXG4gICAgaWYgKHV0aWxzLnN0YXJ0c1dpdGgocmVnZXgsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrU3RhcnRVcmwpKSB7XG4gICAgICByZWdleCA9IHJlZ2V4LnN1YnN0cmluZygwLCByZWdleENvbmZpZ3VyYXRpb24ubWFza1N0YXJ0VXJsLmxlbmd0aCkgKyByZXBsYWNlQWxsKHJlZ2V4LnN1YnN0cmluZyhyZWdleENvbmZpZ3VyYXRpb24ubWFza1N0YXJ0VXJsLmxlbmd0aCwgcmVnZXgubGVuZ3RoIC0gMSksICdcXHwnLCAnXFxcXHwnKSArIHJlZ2V4LnN1YnN0cmluZyhyZWdleC5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLnN0YXJ0c1dpdGgocmVnZXgsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrUGlwZSkpIHtcbiAgICAgIHJlZ2V4ID0gcmVnZXguc3Vic3RyaW5nKDAsIHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrUGlwZS5sZW5ndGgpICsgcmVwbGFjZUFsbChyZWdleC5zdWJzdHJpbmcocmVnZXhDb25maWd1cmF0aW9uLm1hc2tQaXBlLmxlbmd0aCwgcmVnZXgubGVuZ3RoIC0gMSksICdcXHwnLCAnXFxcXHwnKSArIHJlZ2V4LnN1YnN0cmluZyhyZWdleC5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVnZXggPSByZXBsYWNlQWxsKHJlZ2V4LnN1YnN0cmluZygwLCByZWdleC5sZW5ndGggLSAxKSwgJ1xcfCcsICdcXFxcfCcpICsgcmVnZXguc3Vic3RyaW5nKHJlZ2V4Lmxlbmd0aCAtIDEpO1xuICAgIH0gLy8gUmVwbGFjaW5nIHNwZWNpYWwgdXJsIG1hc2tzXG5cblxuICAgIHJlZ2V4ID0gcmVwbGFjZUFsbChyZWdleCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tBbnlTeW1ib2wsIHJlZ2V4Q29uZmlndXJhdGlvbi5yZWdleEFueVN5bWJvbCk7XG4gICAgcmVnZXggPSByZXBsYWNlQWxsKHJlZ2V4LCByZWdleENvbmZpZ3VyYXRpb24ubWFza1NlcGFyYXRvciwgcmVnZXhDb25maWd1cmF0aW9uLnJlZ2V4U2VwYXJhdG9yKTtcblxuICAgIGlmICh1dGlscy5zdGFydHNXaXRoKHJlZ2V4LCByZWdleENvbmZpZ3VyYXRpb24ubWFza1N0YXJ0VXJsKSkge1xuICAgICAgcmVnZXggPSByZWdleENvbmZpZ3VyYXRpb24ucmVnZXhTdGFydFVybCArIHJlZ2V4LnN1YnN0cmluZyhyZWdleENvbmZpZ3VyYXRpb24ubWFza1N0YXJ0VXJsLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5zdGFydHNXaXRoKHJlZ2V4LCByZWdleENvbmZpZ3VyYXRpb24ubWFza1BpcGUpKSB7XG4gICAgICByZWdleCA9IHJlZ2V4Q29uZmlndXJhdGlvbi5yZWdleFN0YXJ0U3RyaW5nICsgcmVnZXguc3Vic3RyaW5nKHJlZ2V4Q29uZmlndXJhdGlvbi5tYXNrUGlwZS5sZW5ndGgpO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5lbmRzV2l0aChyZWdleCwgcmVnZXhDb25maWd1cmF0aW9uLm1hc2tQaXBlKSkge1xuICAgICAgcmVnZXggPSByZWdleC5zdWJzdHJpbmcoMCwgcmVnZXgubGVuZ3RoIC0gMSkgKyByZWdleENvbmZpZ3VyYXRpb24ucmVnZXhFbmRTdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsICdpJyk7XG4gIH07XG5cbiAgcmV0dXJuIGNyZWF0ZVJlZ2V4VGV4dDtcbn0oKTtcbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgaW1wbGVtZW50aW5nIExvY2F0aW9uIGludGVyZmFjZSBmcm9tIGEgdXJsLlxuICogQW4gYWx0ZXJuYXRpdmUgdG8gVVJMLlxuICogaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0ZpbmdlcnByaW50aW5nQmxvY2tlci9ibG9iL21hc3Rlci9zcmMvc2hhcmVkL3VybC50cyNMNjRcbiAqL1xuXG5cbnV0aWxzLmNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKGhyZWYpIHtcbiAgdmFyIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgYW5jaG9yLmhyZWYgPSBocmVmO1xuXG4gIGlmIChhbmNob3IuaG9zdCA9PT0gJycpIHtcbiAgICBhbmNob3IuaHJlZiA9IGFuY2hvci5ocmVmOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtYXNzaWduXG4gIH1cblxuICByZXR1cm4gYW5jaG9yO1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgQSBoYXMgdGhlIHNhbWUgb3JpZ2luIGFzIEIuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsQSBsb2NhdGlvbi5ocmVmIG9mIEEuXG4gKiBAcGFyYW0ge0xvY2F0aW9ufSBsb2NhdGlvbkIgbG9jYXRpb24gb2YgQi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5CIGRvY3VtZW50LmRvbWFpbiBvZiBCLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbnV0aWxzLmlzU2FtZU9yaWdpbiA9IGZ1bmN0aW9uICh1cmxBLCBsb2NhdGlvbkIsIGRvbWFpbkIpIHtcbiAgdmFyIGxvY2F0aW9uQSA9IHV0aWxzLmNyZWF0ZUxvY2F0aW9uKHVybEEpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuXG4gIGlmIChsb2NhdGlvbkEucHJvdG9jb2wgPT09ICdqYXZhc2NyaXB0OicgfHwgbG9jYXRpb25BLmhyZWYgPT09ICdhYm91dDpibGFuaycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChsb2NhdGlvbkEucHJvdG9jb2wgPT09ICdkYXRhOicgfHwgbG9jYXRpb25BLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uQS5ob3N0bmFtZSA9PT0gZG9tYWluQiAmJiBsb2NhdGlvbkEucG9ydCA9PT0gbG9jYXRpb25CLnBvcnQgJiYgbG9jYXRpb25BLnByb3RvY29sID09PSBsb2NhdGlvbkIucHJvdG9jb2w7XG59O1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0byB0aHJvdHRsZSBmdW5jdGlvbiBjYWxscyB3aXRoIHNldFRpbWVvdXQgYW5kIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cbiAqL1xuXG5cbnV0aWxzLkFzeW5jV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFBoYW50b21KUyBwYXNzZXMgYSB3cm9uZyB0aW1lc3RhbXAgdG8gdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjYWxsYmFjayBhbmQgdGhhdCBicmVha3MgdGhlIEFzeW5jV3JhcHBlciBsb2dpY1xuICAgKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xNDgzMlxuICAgKi9cbiAgdmFyIHN1cHBvcnRlZCA9IHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJyAmJiAhL3BoYW50b20vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB2YXIgckFGID0gc3VwcG9ydGVkID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogc2V0VGltZW91dDtcbiAgdmFyIGNBRiA9IHN1cHBvcnRlZCA/IGNhbmNlbEFuaW1hdGlvbkZyYW1lIDogY2xlYXJUaW1lb3V0O1xuICB2YXIgcGVyZiA9IHN1cHBvcnRlZCA/IHBlcmZvcm1hbmNlIDogRGF0ZTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aHJvdHRsZSBudW1iZXIsIHRoZSBwcm92aWRlZCBjYWxsYmFjayBzaG91bGQgYmUgZXhlY3V0ZWQgdHdpY2VcbiAgICogaW4gdGhpcyB0aW1lIGZyYW1lLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gQXN5bmNXcmFwcGVyKGNhbGxiYWNrLCB0aHJvdHRsZSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgdGhpcy53cmFwcGVkQ2FsbGJhY2sgPSB0aGlzLndyYXBwZWRDYWxsYmFjay5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMud3JhcHBlZEFzYXBDYWxsYmFjaykge1xuICAgICAgdGhpcy53cmFwcGVkQXNhcENhbGxiYWNrID0gdGhpcy53cmFwcGVkQXNhcENhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgQXN5bmNXcmFwcGVyLnByb3RvdHlwZS53cmFwcGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAodHMpIHtcbiAgICB0aGlzLmxhc3RSdW4gPSBpc051bWJlcih0cykgPyB0cyA6IHBlcmYubm93KCk7XG4gICAgZGVsZXRlIHRoaXMuckFGaWQ7XG4gICAgZGVsZXRlIHRoaXMudGltZXJJZDtcbiAgICBkZWxldGUgdGhpcy5hc2FwU2NoZWR1bGVkO1xuICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgfTtcbiAgLyoqIEBwcml2YXRlIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGEgc2NoZWR1bGVkIGNhbGxiYWNrLiAqL1xuXG5cbiAgQXN5bmNXcmFwcGVyLnByb3RvdHlwZS5oYXNQZW5kaW5nQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMuckFGaWQpIHx8IGlzTnVtYmVyKHRoaXMudGltZXJJZCk7XG4gIH07XG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiBjYWxsIGJlZm9yZSB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAqL1xuXG5cbiAgQXN5bmNXcmFwcGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaGFzUGVuZGluZ0NhbGxiYWNrKCkpIHtcbiAgICAgIC8vIFRoZXJlIGlzIGEgcGVuZGluZyBleGVjdXRpb24gc2NoZWR1bGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5sYXN0UnVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGVsYXBzZWQgPSBwZXJmLm5vdygpIC0gdGhpcy5sYXN0UnVuO1xuXG4gICAgICBpZiAoZWxhcHNlZCA8IHRoaXMudGhyb3R0bGUpIHtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCh0aGlzLndyYXBwZWRDYWxsYmFjaywgdGhpcy50aHJvdHRsZSAtIGVsYXBzZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yQUZpZCA9IHJBRih0aGlzLndyYXBwZWRDYWxsYmFjayk7XG4gIH07XG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiBjYWxsIGluIHRoZSBtb3N0IGltbWVuZW50IG1pY3JvdGFzay5cbiAgICogVGhpcyBjYW5ub3QgYmUgY2FuY2VsZWQuXG4gICAqL1xuXG5cbiAgQXN5bmNXcmFwcGVyLnByb3RvdHlwZS5ydW5Bc2FwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFzYXBTY2hlZHVsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFzYXBTY2hlZHVsZWQgPSB0cnVlO1xuICAgIGNBRih0aGlzLnJBRmlkKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcblxuICAgIGlmICh1dGlscy5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAvKipcbiAgICAgICAqIFVzaW5nIE11dGF0aW9uT2JzZXJ2ZXJzIHRvIGFjY2VzcyBtaWNyb3Rhc2sgcXVldWUgaXMgYSBzdGFuZGFyZCB0ZWNobmlxdWUsXG4gICAgICAgKiB1c2VkIGluIEFTQVAgbGlicmFyeVxuICAgICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvYXNhcC9ibG9iL21hc3Rlci9icm93c2VyLXJhdy5qcyNMMTQwfVxuICAgICAgICovXG4gICAgICBpZiAoIXRoaXMubW8pIHtcbiAgICAgICAgdGhpcy5tbyA9IG5ldyB1dGlscy5NdXRhdGlvbk9ic2VydmVyKHRoaXMud3JhcHBlZENhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoMSk7XG4gICAgICAgIHRoaXMubW8ub2JzZXJ2ZSh0aGlzLm5vZGUsIHtcbiAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vZGUubm9kZVZhbHVlID0gLXRoaXMubm9kZS5ub2RlVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy53cmFwcGVkQ2FsbGJhY2spO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJ1bnMgc2NoZWR1bGVkIGV4ZWN1dGlvbiBpbW1lZGlhdGVseSwgaWYgdGhlcmUgd2VyZSBhbnkuXG4gICAqL1xuXG5cbiAgQXN5bmNXcmFwcGVyLnByb3RvdHlwZS5ydW5JbW1lZGlhdGVseSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5oYXNQZW5kaW5nQ2FsbGJhY2soKSkge1xuICAgICAgY0FGKHRoaXMuckFGaWQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICBkZWxldGUgdGhpcy5yQUZpZDtcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbWVySWQ7XG4gICAgICB0aGlzLndyYXBwZWRDYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBBc3luY1dyYXBwZXIubm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmLm5vdygpO1xuICB9O1xuXG4gIHJldHVybiBBc3luY1dyYXBwZXI7XG59KCk7XG4vKipcbiAqIFN0b3JlcyBuYXRpdmUgT2RQIHRvIGJlIHVzZWQgaW4gV2Vha01hcCBhbmQgU2V0IHBvbHlmaWxscy5cbiAqL1xuXG5cbnV0aWxzLmRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudXRpbHMuV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IFdlYWtNYXAgOiBmdW5jdGlvbiAoKSB7XG4gIC8qKiBPcmlnaW5hbGx5IGJhc2VkIG9uIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9XZWFrTWFwfSAqL1xuICB2YXIgY291bnRlciA9IERhdGUubm93KCkgJSAxZTk7XG5cbiAgdmFyIFdlYWtNYXAgPSBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHRoaXMubmFtZSA9IFwiX19zdFwiLmNvbmNhdChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKS5jb25jYXQoY291bnRlcisrLCBcIl9fXCIpO1xuICB9O1xuXG4gIFdlYWtNYXAucHJvdG90eXBlID0ge1xuICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXG4gICAgICBpZiAoZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSkge1xuICAgICAgICBlbnRyeVsxXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbHMuZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogW2tleSwgdmFsdWVdLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzVmFsdWUgPSBlbnRyeVswXSA9PT0ga2V5O1xuICAgICAgZGVsZXRlIGVudHJ5WzBdO1xuICAgICAgZGVsZXRlIGVudHJ5WzFdO1xuICAgICAgcmV0dXJuIGhhc1ZhbHVlO1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblxuICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeVswXSA9PT0ga2V5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFdlYWtNYXA7XG59KCk7XG51dGlscy5TZXQgPSB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyA/IFNldCA6IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvdW50ZXIgPSBEYXRlLm5vdygpICUgMWU5O1xuICAvKipcbiAgICogQSBwb2x5ZmlsbCB3aGljaCBjb3ZlcnMgb25seSB0aGUgYmFzaWMgdXNhZ2UuXG4gICAqIE9ubHkgc3VwcG9ydHMgbWV0aG9kcyB0aGF0IGFyZSBzdXBwb3J0ZWQgaW4gSUUxMS5cbiAgICoge0BsaW5rIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3NjcmlwdGluZy9qYXZhc2NyaXB0L3JlZmVyZW5jZS9zZXQtb2JqZWN0LWphdmFzY3JpcHR9XG4gICAqIEFzc3VtZXMgdGhhdCAna2V5J3MgYXJlIGFsbCBvYmplY3RzLCBub3QgcHJpbWl0aXZlcyBzdWNoIGFzIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBJbml0aWFsIGl0ZW1zIGluIHRoaXMgc2V0XG4gICAqL1xuXG4gIHZhciBTZXQgPSBmdW5jdGlvbiBTZXQoaXRlbXMpIHtcbiAgICB0aGlzLm5hbWUgPSBcIl9fc3RcIi5jb25jYXQoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkuY29uY2F0KGNvdW50ZXIrKywgXCJfX1wiKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcblxuICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpSXRlbXMgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpSXRlbXMtLSkge1xuICAgICAgICB0aGlzLmFkZChpdGVtc1tpSXRlbXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZSA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChrZXkpIHtcbiAgICAgIGlmICghaXNOdW1iZXIoa2V5W3RoaXMubmFtZV0pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5wdXNoKGtleSkgLSAxO1xuICAgICAgICB1dGlscy5kZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBpbmRleCxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIGlmIChpc051bWJlcihrZXlbdGhpcy5uYW1lXSkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmtleXNbaW5kZXhdO1xuICAgICAgICBrZXlbdGhpcy5uYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgcmV0dXJuIGlzTnVtYmVyKGtleVt0aGlzLm5hbWVdKTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMua2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAga2V5W3RoaXMubmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMua2V5cy5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdGhpcy5rZXlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNiKHZhbHVlLCB2YWx1ZSwgdGhhdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHV0aWxzLmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsICdzaXplJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gU2tpcHMgaG9sZXMuXG4gICAgICByZXR1cm4gdGhpcy5rZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjKSB7XG4gICAgICAgIHJldHVybiBhY2MgKyAxO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFNldDtcbn0oKTtcbi8qKlxuICogVmVuZG9yLXNwZWNpZmljIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNcbiAqL1xuXG51dGlscy5tYXRjaGVzUHJvcGVydHlOYW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJvcHMgPSBbJ21hdGNoZXMnLCAnbWF0Y2hlc1NlbGVjdG9yJywgJ21vek1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdvTWF0Y2hlc1NlbGVjdG9yJywgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvciddO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgaWYgKEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3BzW2ldKSkge1xuICAgICAgcmV0dXJuIHByb3BzW2ldO1xuICAgIH1cbiAgfVxufSgpO1xuLyoqXG4gKiBQcm92aWRlcyBzdGF0cyBpbmZvcm1hdGlvblxuICovXG5cblxudXRpbHMuU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKiBAbWVtYmVyIHtBcnJheTxudW1iZXI+fSAqL1xuICB0aGlzLmFycmF5ID0gW107XG4gIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICovXG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuICB2YXIgemVyb0Rlc2NyaXB0b3IgPSB7XG4gICAgdmFsdWU6IDAsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfTtcbiAgLyoqIEBtZW1iZXIge251bWJlcn0gQHByaXZhdGUgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N1bScsIHplcm9EZXNjcmlwdG9yKTtcbiAgLyoqIEBtZW1iZXIge251bWJlcn0gQHByaXZhdGUgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NxdWFyZWRTdW0nLCB6ZXJvRGVzY3JpcHRvcik7XG59O1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YVBvaW50IGRhdGEgcG9pbnRcbiAqL1xuXG5cbnV0aWxzLlN0YXRzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGFQb2ludCkge1xuICB0aGlzLmFycmF5LnB1c2goZGF0YVBvaW50KTtcbiAgdGhpcy5sZW5ndGgrKztcbiAgdGhpcy5zdW0gKz0gZGF0YVBvaW50O1xuICB0aGlzLnNxdWFyZWRTdW0gKz0gZGF0YVBvaW50ICogZGF0YVBvaW50O1xuICAvKiogQG1lbWJlciB7bnVtYmVyfSAqL1xuXG4gIHRoaXMubWVhbiA9IHRoaXMuc3VtIC8gdGhpcy5sZW5ndGg7XG4gIC8qKiBAbWVtYmVyIHtudW1iZXJ9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblxuICB0aGlzLnN0ZGRldiA9IE1hdGguc3FydCh0aGlzLnNxdWFyZWRTdW0gLyB0aGlzLmxlbmd0aCAtIE1hdGgucG93KHRoaXMubWVhbiwgMikpO1xufTtcbi8qKiBTYWZlIGNvbnNvbGUuZXJyb3IgdmVyc2lvbiAqL1xuXG5cbnV0aWxzLmxvZ0Vycm9yID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgJiYgY29uc29sZS5lcnJvci5iaW5kID8gY29uc29sZS5lcnJvci5iaW5kKHdpbmRvdy5jb25zb2xlKSA6IGNvbnNvbGUuZXJyb3I7XG4vKiogU2FmZSBjb25zb2xlLmluZm8gdmVyc2lvbiAqL1xuXG51dGlscy5sb2dJbmZvID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuaW5mbyAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAmJiBjb25zb2xlLmluZm8uYmluZCA/IGNvbnNvbGUuaW5mby5iaW5kKHdpbmRvdy5jb25zb2xlKSA6IGNvbnNvbGUuaW5mbztcblxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJztcbn1cbi8qKlxuICogUmV0dXJucyBwYXRoIHRvIGVsZW1lbnQgd2Ugd2lsbCB1c2UgYXMgZWxlbWVudCBpZGVudGlmaWVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGlucHV0RWxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gcGF0aCB0byB0aGUgZWxlbWVudFxuICovXG5cblxudXRpbHMuZ2V0Tm9kZVNlbGVjdG9yID0gZnVuY3Rpb24gKGlucHV0RWwpIHtcbiAgaWYgKCEoaW5wdXRFbCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiByZWNlaXZlZCBhcmd1bWVudCB3aXRoIHdyb25nIHR5cGUnKTtcbiAgfVxuXG4gIHZhciBlbCA9IGlucHV0RWw7XG4gIHZhciBwYXRoID0gW107IC8vIHdlIG5lZWQgdG8gY2hlY2sgJyEhZWwnIGZpcnN0IGJlY2F1c2UgaXQgaXMgcG9zc2libGVcbiAgLy8gdGhhdCBzb21lIGFuY2VzdG9yIG9mIHRoZSBpbnB1dEVsIHdhcyByZW1vdmVkIGJlZm9yZSBpdFxuXG4gIHdoaWxlICghIWVsICYmIGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHZhciBzZWxlY3RvciA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoZWwuaWQgJiYgdHlwZW9mIGVsLmlkID09PSAnc3RyaW5nJykge1xuICAgICAgc2VsZWN0b3IgKz0gXCIjXCIuY29uY2F0KGVsLmlkKTtcbiAgICAgIHBhdGgudW5zaGlmdChzZWxlY3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNpYmxpbmcgPSBlbDtcbiAgICAgIHZhciBudGggPSAxO1xuXG4gICAgICB3aGlsZSAoc2libGluZy5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcucHJldmlvdXNTaWJsaW5nO1xuXG4gICAgICAgIGlmIChzaWJsaW5nLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBzaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgbnRoKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG50aCAhPT0gMSkge1xuICAgICAgICBzZWxlY3RvciArPSBcIjpudGgtb2YtdHlwZShcIi5jb25jYXQobnRoLCBcIilcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGF0aC51bnNoaWZ0KHNlbGVjdG9yKTtcbiAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gcGF0aC5qb2luKCcgPiAnKTtcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgQWRndWFyZCBTb2Z0d2FyZSBMdGRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBjc3MgdXRpbHNcbiAqXG4gKiBAdHlwZSB7e25vcm1hbGl6ZX19XG4gKi9cbnZhciBjc3NVdGlscyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFJlZ2V4IHRoYXQgbWF0Y2hlcyBBZEd1YXJkJ3MgYmFja3dhcmQgY29tcGF0aWJsZSBzeW50YXhlcy5cbiAgICovXG4gIHZhciByZUF0dHJGYWxsYmFjayA9IC9cXFstKD86ZXh0fGFicCktKFthLXotX10rKT0oW1wiJ10pKCg/Oig/PShcXFxcPykpXFw0LikqPylcXDJcXF0vZztcbiAgLyoqXG4gICAqIENvbXBsZXggcmVwbGFjZW1lbnQgZnVuY3Rpb24uXG4gICAqIFVuZXNjYXBlcyBxdW90ZSBjaGFyYWN0ZXJzIGluc2lkZSBvZiBhbiBleHRlbmRlZCBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIG1hdGNoICAgICBXaG9sZSBtYXRjaGVkIHN0cmluZ1xuICAgKiBAcGFyYW0gbmFtZSAgICAgIEdyb3VwIDFcbiAgICogQHBhcmFtIHF1b3RlQ2hhciBHcm91cCAyXG4gICAqIEBwYXJhbSB2YWx1ZSAgICAgR3JvdXAgM1xuICAgKi9cblxuICB2YXIgZXZhbHVhdGVNYXRjaCA9IGZ1bmN0aW9uIGV2YWx1YXRlTWF0Y2gobWF0Y2gsIG5hbWUsIHF1b3RlQ2hhciwgdmFsdWUpIHtcbiAgICAvLyBVbmVzY2FwZSBxdW90ZXNcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKFteXFxcXFxcXFxdfF4pXFxcXFxcXFxcIi5jb25jYXQocXVvdGVDaGFyKSwgJ2cnKTtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmUsIFwiJDFcIi5jb25jYXQocXVvdGVDaGFyKSk7XG4gICAgcmV0dXJuIFwiOlwiLmNvbmNhdChuYW1lLCBcIihcIikuY29uY2F0KHZhbHVlLCBcIilcIik7XG4gIH07IC8vIFNpenpsZSdzIHBhcnNpbmcgb2YgcHNldWRvIGNsYXNzIGFyZ3VtZW50cyBpcyBidWdneSBvbiBjZXJ0YWluIGNpcmN1bXN0YW5jZXNcbiAgLy8gV2Ugc3VwcG9ydCBmb2xsb3dpbmcgZm9ybSBvZiBhcmd1bWVudHM6XG4gIC8vIDEuIGZvciA6bWF0Y2hlcy1jc3MsIHRob3NlIG9mIGEgZm9ybSB7cHJvcGVydHlOYW1lfTogLy4qL1xuICAvLyAyLiBmb3IgOmNvbnRhaW5zLCB0aG9zZSBvZiBhIGZvcm0gLy4qL1xuICAvLyBXZSB0cmFuc2Zvcm0gc3VjaCBjYXNlcyBpbiBhIHdheSB0aGF0IFNpenpsZSBoYXMgbm8gYW1iaWd1aXR5IGluIHBhcnNpbmcgYXJndW1lbnRzLlxuXG5cbiAgdmFyIHJlTWF0Y2hlc0NzcyA9IC9cXDoobWF0Y2hlcy1jc3MoPzotYWZ0ZXJ8LWJlZm9yZSk/KVxcKChbYS16LVxcc10qXFw6XFxzKlxcLyg/OlxcXFwufFteXFwvXSkqP1xcL1xccyopXFwpL2c7XG4gIHZhciByZUNvbnRhaW5zID0gLzooPzotYWJwLSk/KGNvbnRhaW5zfGhhcy10ZXh0KVxcKChcXHMqXFwvKD86XFxcXC58W15cXC9dKSo/XFwvXFxzKilcXCkvZztcbiAgdmFyIHJlU2NvcGUgPSAvXFwoXFw6c2NvcGUgPi9nOyAvLyBOb3RlIHRoYXQgd2UgcmVxdWlyZSBgL2AgY2hhcmFjdGVyIGluIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gYmUgZXNjYXBlZC5cblxuICAvKipcbiAgICogVXNlZCBmb3IgcHJlLXByb2Nlc3NpbmcgcHNldWRvLWNsYXNzZXMgdmFsdWVzIHdpdGggYWJvdmUgdHdvIHJlZ2V4ZXMuXG4gICAqL1xuXG4gIHZhciBhZGRRdW90ZXMgPSBmdW5jdGlvbiBhZGRRdW90ZXMoXywgYzEsIGMyKSB7XG4gICAgcmV0dXJuIFwiOlwiLmNvbmNhdChjMSwgXCIoXFxcIlwiKS5jb25jYXQoYzIucmVwbGFjZSgvW1wiXFxcXF0vZywgJ1xcXFwkJicpLCBcIlxcXCIpXCIpO1xuICB9O1xuXG4gIHZhciBTQ09QRV9SRVBMQUNFUiA9ICcoPic7XG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIHNwZWNpZmllZCBjc3MgdGV4dCBpbiBhIGZvcm0gdGhhdCBjYW4gYmUgcGFyc2VkIGJ5IHRoZVxuICAgKiBTaXp6bGUgZW5naW5lLlxuICAgKiBOb3JtYWxpemF0aW9uIG1lYW5zXG4gICAqICAxLiB0cmFuc2Zvcm1pbmcgWy1leHQtKj1cIlwiXSBhdHRyaWJ1dGVzIHRvIHBzZXVkbyBjbGFzc2VzXG4gICAqICAyLiBlbmNsb3NpbmcgcG9zc2libHkgYW1iaWd1b3VzIGFyZ3VtZW50cyBvZiBgOmNvbnRhaW5zYCxcbiAgICogICAgIGA6bWF0Y2hlcy1jc3NgIHBzZXVkbyBjbGFzc2VzIHdpdGggcXVvdGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG4gIHZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoY3NzVGV4dCkge1xuICAgIHZhciBub3JtYWxpemVkQ3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShyZUF0dHJGYWxsYmFjaywgZXZhbHVhdGVNYXRjaCkucmVwbGFjZShyZU1hdGNoZXNDc3MsIGFkZFF1b3RlcykucmVwbGFjZShyZUNvbnRhaW5zLCBhZGRRdW90ZXMpLnJlcGxhY2UocmVTY29wZSwgU0NPUEVfUkVQTEFDRVIpO1xuICAgIHJldHVybiBub3JtYWxpemVkQ3NzVGV4dDtcbiAgfTtcblxuICB2YXIgaXNTaW1wbGVTZWxlY3RvclZhbGlkID0gZnVuY3Rpb24gaXNTaW1wbGVTZWxlY3RvclZhbGlkKHNlbGVjdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICAgIGlzU2ltcGxlU2VsZWN0b3JWYWxpZDogaXNTaW1wbGVTZWxlY3RvclZhbGlkXG4gIH07XG59KCk7XG5cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy40LXByZS1hZGd1YXJkXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAqXG4gKiBEYXRlOiAyMDIwLTA4LTA0XG4gKi9cblxuLyoqXG4gKiBWZXJzaW9uIG9mIFNpenpsZSBwYXRjaGVkIGJ5IEFkR3VhcmQgaW4gb3JkZXIgdG8gYmUgdXNlZCBpbiB0aGUgRXh0ZW5kZWRDc3MgbW9kdWxlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL3NpenpsZS1leHRjc3NcbiAqXG4gKiBMb29rIGZvciBbQWRHdWFyZCBQYXRjaF0gYW5kIEFER1VBUkRfRVhUQ1NTIG1hcmtlcnMgdG8gZmluZCBvdXQgd2hhdCBleGFjdGx5IHdhcyBjaGFuZ2VkIGJ5IHVzLlxuICpcbiAqIEdsb2JhbCBjaGFuZ2VzOlxuICogMS4gQWRkZWQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHRoZSBcIlNpenpsZS50b2tlbml6ZVwiIG1ldGhvZCBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGZvciBzdHlsZXNoZWV0cyBwYXJzaW5nIGFuZCB2YWxpZGF0aW9uLlxuICogMi4gQWRkZWQgdG9rZW5zIHJlLXNvcnRpbmcgbWVjaGFuaXNtIGZvcmNpbmcgc2xvdyBwc2V1ZG9zIHRvIGJlIG1hdGNoZWQgbGFzdCAgKHNlZSBzb3J0VG9rZW5Hcm91cHMpLlxuICogMy4gRml4IHRoZSBub25uYXRpdmVTZWxlY3RvckNhY2hlIGNhY2hpbmcgLS0gdGhlcmUgd2FzIG5vIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gYSBrZXkuXG4gKiA0LiBBZGRlZCBTaXp6bGUuY29tcGlsZSBjYWxsIHRvIHRoZSBgOmhhc2AgcHNldWRvIGRlZmluaXRpb24uXG4gKlxuICogQ2hhbmdlcyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBBREdVQVJEX0VYVENTUyBidWlsZCBvbmx5OlxuICogMS4gRG8gbm90IGV4cG9zZSBTaXp6bGUgdG8gdGhlIGdsb2JhbCBzY29wZS4gSW5pdGlhbGl6ZSBpdCBsYXppbHkgdmlhIGluaXRpYWxpemVTaXp6bGUoKS5cbiAqIDIuIFJlbW92ZWQgOmNvbnRhaW5zIHBzZXVkbyBkZWNsYXJhdGlvbiAtLSBpdHMgc3ludGF4IGlzIGNoYW5nZWQgYW5kIGRlY2xhcmVkIG91dHNpZGUgb2YgU2l6emxlLlxuICogMy4gUmVtb3ZlZCBkZWNsYXJhdGlvbnMgZm9yIHRoZSBmb2xsb3dpbmcgbm9uLXN0YW5kYXJkIHBzZXVkbyBjbGFzc2VzOlxuICogOnBhcmVudCwgOmhlYWRlciwgOmlucHV0LCA6YnV0dG9uLCA6dGV4dCwgOmZpcnN0LCA6bGFzdCwgOmVxLFxuICogOmV2ZW4sIDpvZGQsIDpsdCwgOmd0LCA6bnRoLCA6cmFkaW8sIDpjaGVja2JveCwgOmZpbGUsXG4gKiA6cGFzc3dvcmQsIDppbWFnZSwgOnN1Ym1pdCwgOnJlc2V0XG4gKiA0LiBBZGRlZCBlczYgbW9kdWxlIGV4cG9ydFxuICovXG52YXIgU2l6emxlO1xuLyoqXG4gKiBJbml0aWFsaXplcyBTaXp6bGUgb2JqZWN0LlxuICogSW4gdGhlIGNhc2Ugb2YgQWRHdWFyZCBFeHRlbmRlZENzcyB3ZSB3YW50IHRvIGF2b2lkIGluaXRpYWxpemluZyBTaXp6bGUgcmlnaHQgYXdheVxuICogYW5kIGV4cG9zaW5nIGl0IHRvIHRoZSBnbG9iYWwgc2NvcGUuXG4gKi9cblxudmFyIGluaXRpYWxpemVTaXp6bGUgPSBmdW5jdGlvbiBpbml0aWFsaXplU2l6emxlKCkge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgaWYgKCFTaXp6bGUpIHtcbiAgICAvLzw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PFxuICAgIFNpenpsZSA9IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICAgIHZhciBzdXBwb3J0LFxuICAgICAgICAgIEV4cHIsXG4gICAgICAgICAgZ2V0VGV4dCxcbiAgICAgICAgICBpc1hNTCxcbiAgICAgICAgICB0b2tlbml6ZSxcbiAgICAgICAgICBjb21waWxlLFxuICAgICAgICAgIHNlbGVjdCxcbiAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgIHNvcnRJbnB1dCxcbiAgICAgICAgICBoYXNEdXBsaWNhdGUsXG4gICAgICAgICAgLy8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuICAgICAgc2V0RG9jdW1lbnQsXG4gICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgZG9jRWxlbSxcbiAgICAgICAgICBkb2N1bWVudElzSFRNTCxcbiAgICAgICAgICByYnVnZ3lRU0EsXG4gICAgICAgICAgcmJ1Z2d5TWF0Y2hlcyxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGNvbnRhaW5zLFxuICAgICAgICAgIC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcbiAgICAgIGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG4gICAgICAgICAgcHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICAgIGRpcnJ1bnMgPSAwLFxuICAgICAgICAgIGRvbmUgPSAwLFxuICAgICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgIHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgIGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgIG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uIHNvcnRPcmRlcihhLCBiKSB7XG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgICAgICAvLyBJbnN0YW5jZSBtZXRob2RzXG4gICAgICBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgICBhcnIgPSBbXSxcbiAgICAgICAgICBwb3AgPSBhcnIucG9wLFxuICAgICAgICAgIHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG4gICAgICAgICAgcHVzaCA9IGFyci5wdXNoLFxuICAgICAgICAgIHNsaWNlID0gYXJyLnNsaWNlLFxuICAgICAgICAgIC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YobGlzdCwgZWxlbSkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0sXG4gICAgICAgICAgYm9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG4gICAgICAgICAgLy8gUmVndWxhciBleHByZXNzaW9uc1xuICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2VcbiAgICAgIHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG4gICAgICBpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuICAgICAgICAgIC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuICAgICAgYXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICsgLy8gT3BlcmF0b3IgKGNhcHR1cmUgMilcbiAgICAgIFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArIC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG4gICAgICBcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG4gICAgICAgICAgcHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArIC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG4gICAgICAvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcbiAgICAgIFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgKyAvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcbiAgICAgIFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICsgLy8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuICAgICAgXCIuKlwiICsgXCIpXFxcXCl8KVwiLFxuICAgICAgICAgIC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcbiAgICAgIHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCh3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiKSxcbiAgICAgICAgICBydHJpbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIpLFxuICAgICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcbiAgICAgICAgICByY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiksXG4gICAgICAgICAgcnBzZXVkbyA9IG5ldyBSZWdFeHAocHNldWRvcyksXG4gICAgICAgICAgcmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiKSxcbiAgICAgICAgICBtYXRjaEV4cHIgPSB7XG4gICAgICAgIFwiSURcIjogbmV3IFJlZ0V4cChcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiKSxcbiAgICAgICAgXCJDTEFTU1wiOiBuZXcgUmVnRXhwKFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiKSxcbiAgICAgICAgXCJUQUdcIjogbmV3IFJlZ0V4cChcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiKSxcbiAgICAgICAgXCJBVFRSXCI6IG5ldyBSZWdFeHAoXCJeXCIgKyBhdHRyaWJ1dGVzKSxcbiAgICAgICAgXCJQU0VVRE9cIjogbmV3IFJlZ0V4cChcIl5cIiArIHBzZXVkb3MpLFxuICAgICAgICBcIkNISUxEXCI6IG5ldyBSZWdFeHAoXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiksXG4gICAgICAgIFwiYm9vbFwiOiBuZXcgUmVnRXhwKFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiKSxcbiAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG4gICAgICAgIC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcbiAgICAgICAgXCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cChcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiKVxuICAgICAgfSxcbiAgICAgICAgICBybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcbiAgICAgICAgICAvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcbiAgICAgIHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcbiAgICAgICAgICByc2libGluZyA9IC9bK35dLyxcbiAgICAgICAgICAvLyBDU1MgZXNjYXBlc1xuICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuICAgICAgcnVuZXNjYXBlID0gbmV3IFJlZ0V4cChcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiksXG4gICAgICAgICAgZnVuZXNjYXBlID0gZnVuY3Rpb24gZnVuZXNjYXBlKF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlKSB7XG4gICAgICAgIHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7IC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG4gICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cbiAgICAgICAgcmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgPyBlc2NhcGVkIDogaGlnaCA8IDAgPyAvLyBCTVAgY29kZXBvaW50XG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlnaCArIDB4MTAwMDApIDogLy8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwKTtcbiAgICAgIH0sXG4gICAgICAgICAgLy8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuICAgICAgcmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuICAgICAgICAgIGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiBmY3NzZXNjYXBlKGNoLCBhc0NvZGVQb2ludCkge1xuICAgICAgICBpZiAoYXNDb2RlUG9pbnQpIHtcbiAgICAgICAgICAvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFwwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcdUZGRkRcIjtcbiAgICAgICAgICB9IC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cblxuICAgICAgICAgIHJldHVybiBjaC5zbGljZSgwLCAtMSkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoY2gubGVuZ3RoIC0gMSkudG9TdHJpbmcoMTYpICsgXCIgXCI7XG4gICAgICAgIH0gLy8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXG5cbiAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY2g7XG4gICAgICB9LFxuICAgICAgICAgIC8vIFVzZWQgZm9yIGlmcmFtZXNcbiAgICAgIC8vIFNlZSBzZXREb2N1bWVudCgpXG4gICAgICAvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcbiAgICAgIC8vIGVycm9yIGluIElFXG4gICAgICB1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcbiAgICAgICAgc2V0RG9jdW1lbnQoKTtcbiAgICAgIH0sXG4gICAgICAgICAgaW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcbiAgICAgIH0sIHtcbiAgICAgICAgZGlyOiBcInBhcmVudE5vZGVcIixcbiAgICAgICAgbmV4dDogXCJsZWdlbmRcIlxuICAgICAgfSk7IC8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHVzaC5hcHBseShhcnIgPSBzbGljZS5jYWxsKHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKSwgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMpOyAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuICAgICAgICAvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cbiAgICAgICAgYXJyW3ByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHB1c2ggPSB7XG4gICAgICAgICAgYXBwbHk6IGFyci5sZW5ndGggPyAvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuICAgICAgICAgIGZ1bmN0aW9uICh0YXJnZXQsIGVscykge1xuICAgICAgICAgICAgcHVzaF9uYXRpdmUuYXBwbHkodGFyZ2V0LCBzbGljZS5jYWxsKGVscykpO1xuICAgICAgICAgIH0gOiAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuICAgICAgICAgIGZ1bmN0aW9uICh0YXJnZXQsIGVscykge1xuICAgICAgICAgICAgdmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGkgPSAwOyAvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblxuICAgICAgICAgICAgd2hpbGUgKHRhcmdldFtqKytdID0gZWxzW2krK10pIHt9XG5cbiAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSBqIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFNpenpsZShzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xuICAgICAgICB2YXIgbSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgbmlkLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICBncm91cHMsXG4gICAgICAgICAgICBuZXdTZWxlY3RvcixcbiAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcbiAgICAgICAgbm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG4gICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdOyAvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8IG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9IC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblxuXG4gICAgICAgIGlmICghc2VlZCkge1xuICAgICAgICAgIGlmICgoY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jKSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG4gICAgICAgICAgaWYgKGRvY3VtZW50SXNIVE1MKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuICAgICAgICAgICAgLy8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuICAgICAgICAgICAgaWYgKG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoc2VsZWN0b3IpKSkge1xuICAgICAgICAgICAgICAvLyBJRCBzZWxlY3RvclxuICAgICAgICAgICAgICBpZiAobSA9IG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uaWQgPT09IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgfSAvLyBFbGVtZW50IGNvbnRleHRcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgIGlmIChuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZChtKSkgJiYgY29udGFpbnMoY29udGV4dCwgZWxlbSkgJiYgZWxlbS5pZCA9PT0gbSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gVHlwZSBzZWxlY3RvclxuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0czsgLy8gQ2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblxuXG4gICAgICAgICAgICBpZiAoc3VwcG9ydC5xc2EgJiYgIW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl0gJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KHNlbGVjdG9yKSkpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBzZWxlY3RvcjsgLy8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG4gICAgICAgICAgICAgICAgLy8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PThcbiAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgaWYgKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFwiaWRcIikpIHtcbiAgICAgICAgICAgICAgICAgIG5pZCA9IG5pZC5yZXBsYWNlKHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZShcImlkXCIsIG5pZCA9IGV4cGFuZG8pO1xuICAgICAgICAgICAgICAgIH0gLy8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cblxuICAgICAgICAgICAgICAgIGdyb3VwcyA9IHRva2VuaXplKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpID0gZ3JvdXBzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKGdyb3Vwc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBncm91cHMuam9pbihcIixcIik7IC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXG4gICAgICAgICAgICAgICAgbmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3Qoc2VsZWN0b3IpICYmIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkgfHwgY29udGV4dDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChuZXdTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbChuZXdTZWxlY3RvcikpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAocXNhRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFtBZEd1YXJkIFBhdGhdOiBGaXggdGhlIGNhY2hlIHZhbHVlXG4gICAgICAgICAgICAgICAgICBub25uYXRpdmVTZWxlY3RvckNhY2hlKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5pZCA9PT0gZXhwYW5kbykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBBbGwgb3RoZXJzXG5cblxuICAgICAgICByZXR1cm4gc2VsZWN0KHNlbGVjdG9yLnJlcGxhY2UocnRyaW0sIFwiJDFcIiksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAgICAgICAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICAgICAgICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhY2hlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuICAgICAgICAgIGlmIChrZXlzLnB1c2goa2V5ICsgXCIgXCIpID4gRXhwci5jYWNoZUxlbmd0aCkge1xuICAgICAgICAgICAgLy8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG4gICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5cy5zaGlmdCgpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FjaGVba2V5ICsgXCIgXCJdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gbWFya0Z1bmN0aW9uKGZuKSB7XG4gICAgICAgIGZuW2V4cGFuZG9dID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gYXNzZXJ0KGZuKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAhIWZuKGVsKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcbiAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfSAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXG5cbiAgICAgICAgICBlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiBhZGRIYW5kbGUoYXR0cnMsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcbiAgICAgICAgICAgIGkgPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBFeHByLmF0dHJIYW5kbGVbYXJyW2ldXSA9IGhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBhXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gc2libGluZ0NoZWNrKGEsIGIpIHtcbiAgICAgICAgdmFyIGN1ciA9IGIgJiYgYSxcbiAgICAgICAgICAgIGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmIGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4OyAvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblxuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9IC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cblxuICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgd2hpbGUgKGN1ciA9IGN1ci5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGN1ciA9PT0gYikge1xuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPyAxIDogLTE7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyhkaXNhYmxlZCkge1xuICAgICAgICAvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgLy8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcbiAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG4gICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcbiAgICAgICAgICBpZiAoXCJmb3JtXCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuICAgICAgICAgICAgLy8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcbiAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcbiAgICAgICAgICAgIC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG4gICAgICAgICAgICAvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcbiAgICAgICAgICAgIC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgLy8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcbiAgICAgICAgICAgICAgaWYgKFwibGFiZWxcIiBpbiBlbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuICAgICAgICAgICAgICAvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXG5cbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHwgLy8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblxuICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTggKi9cbiAgICAgICAgICAgICAgZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiYgaW5EaXNhYmxlZEZpZWxkc2V0KGVsZW0pID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkOyAvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG4gICAgICAgICAgICAvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3RcbiAgICAgICAgICAgIC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuICAgICAgICAgIH0gZWxzZSBpZiAoXCJsYWJlbFwiIGluIGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICB9IC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICAgICAgICovXG5cblxuICAgICAgZnVuY3Rpb24gdGVzdENvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xuICAgICAgfSAvLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuXG5cbiAgICAgIHN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3RzIFhNTCBub2Rlc1xuICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAgICAgICAqL1xuXG4gICAgICBpc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgLy8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG4gICAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICAgICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAgICovXG5cblxuICAgICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaGFzQ29tcGFyZSxcbiAgICAgICAgICAgIHN1YldpbmRvdyxcbiAgICAgICAgICAgIGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYzsgLy8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblxuICAgICAgICBpZiAoZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH0gLy8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblxuXG4gICAgICAgIGRvY3VtZW50ID0gZG9jO1xuICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBkb2N1bWVudElzSFRNTCA9ICFpc1hNTChkb2N1bWVudCk7IC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2VcbiAgICAgICAgLy8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXG4gICAgICAgIGlmIChwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmIChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93KSB7XG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEsIEVkZ2VcbiAgICAgICAgICBpZiAoc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTsgLy8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcbiAgICAgICAgICB9IGVsc2UgaWYgKHN1YldpbmRvdy5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgc3ViV2luZG93LmF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIEF0dHJpYnV0ZXNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuICAgICAgICAvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblxuXG4gICAgICAgIHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbC5jbGFzc05hbWUgPSBcImlcIjtcbiAgICAgICAgICByZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qIGdldEVsZW1lbnQocylCeSpcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cbiAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpKTtcbiAgICAgICAgICByZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG4gICAgICAgIH0pOyAvLyBTdXBwb3J0OiBJRTw5XG5cbiAgICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpOyAvLyBTdXBwb3J0OiBJRTwxMFxuICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcbiAgICAgICAgLy8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG4gICAgICAgIC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXG4gICAgICAgIHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGVsKS5pZCA9IGV4cGFuZG87XG4gICAgICAgICAgcmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoZXhwYW5kbykubGVuZ3RoO1xuICAgICAgICB9KTsgLy8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cbiAgICAgICAgaWYgKHN1cHBvcnQuZ2V0QnlJZCkge1xuICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgRXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiAoaWQsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgICB2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbSA/IFtlbGVtXSA6IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9OyAvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG4gICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXG5cbiAgICAgICAgICBFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uIChpZCwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlLFxuICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgIGVsZW1zLFxuICAgICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtXTtcbiAgICAgICAgICAgICAgICB9IC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXG5cbiAgICAgICAgICAgICAgICBlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtc1tpKytdKSB7XG4gICAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gVGFnXG5cblxuICAgICAgICBFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gZnVuY3Rpb24gKHRhZywgY29udGV4dCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTsgLy8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG4gICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnFzYSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSA6IGZ1bmN0aW9uICh0YWcsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgdG1wID0gW10sXG4gICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG4gICAgICAgICAgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTsgLy8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXG4gICAgICAgICAgaWYgKHRhZyA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbGVtID0gcmVzdWx0c1tpKytdKSB7XG4gICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdG1wLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfTsgLy8gQ2xhc3NcblxuICAgICAgICBFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiAoY2xhc3NOYW1lLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qIFFTQS9tYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICAgICAgICAvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG4gICAgICAgIC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cblxuICAgICAgICByYnVnZ3lNYXRjaGVzID0gW107IC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG4gICAgICAgIC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuICAgICAgICAvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG4gICAgICAgIC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG4gICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblxuICAgICAgICByYnVnZ3lRU0EgPSBbXTtcblxuICAgICAgICBpZiAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCkpIHtcbiAgICAgICAgICAvLyBCdWlsZCBRU0EgcmVnZXhcbiAgICAgICAgICAvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG4gICAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgLy8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG4gICAgICAgICAgICAvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcbiAgICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmlubmVySFRNTCA9IEFHUG9saWN5LmNyZWF0ZUhUTUwoXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArIFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgKyBcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCIpOyAvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG4gICAgICAgICAgICAvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXG4gICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiKTtcbiAgICAgICAgICAgIH0gLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgICAvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cblxuICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIik7XG4gICAgICAgICAgICB9IC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXG5cbiAgICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcbiAgICAgICAgICAgIH0gLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXG5cbiAgICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuICAgICAgICAgICAgfSAvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuICAgICAgICAgICAgLy8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXG5cbiAgICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBBR1BvbGljeS5jcmVhdGVIVE1MKFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArIFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiKTsgLy8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG4gICAgICAgICAgICAvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblxuICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGlucHV0KS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwiRFwiKTsgLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgICAvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblxuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiKTtcbiAgICAgICAgICAgIH0gLy8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcbiAgICAgICAgICAgIC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cblxuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH0gLy8gU3VwcG9ydDogSUU5LTExK1xuICAgICAgICAgICAgLy8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cblxuICAgICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuZGlzYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH0gLy8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3NcblxuXG4gICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8IGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fCBkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSkge1xuICAgICAgICAgIGFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuICAgICAgICAgICAgLy8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcbiAgICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoZWwsIFwiKlwiKTsgLy8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgLy8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXG4gICAgICAgICAgICBtYXRjaGVzLmNhbGwoZWwsIFwiW3MhPScnXTp4XCIpO1xuICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcy5wdXNoKFwiIT1cIiwgcHNldWRvcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpKTtcbiAgICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSk7XG4gICAgICAgIC8qIENvbnRhaW5zXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgICAgICBoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24pOyAvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcbiAgICAgICAgLy8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG4gICAgICAgIC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cbiAgICAgICAgY29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbnRhaW5zKSA/IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcbiAgICAgICAgICAgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gICAgICAgICAgcmV0dXJuIGEgPT09IGJ1cCB8fCAhIShidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChhZG93bi5jb250YWlucyA/IGFkb3duLmNvbnRhaW5zKGJ1cCkgOiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2KSk7XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICB3aGlsZSAoYiA9IGIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBpZiAoYiA9PT0gYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKiBTb3J0aW5nXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbiAgICAgICAgLy8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXG4gICAgICAgIHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgPyBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG4gICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblxuXG4gICAgICAgICAgdmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXG4gICAgICAgICAgaWYgKGNvbXBhcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICAgIH0gLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXG5cbiAgICAgICAgICBjb21wYXJlID0gKGEub3duZXJEb2N1bWVudCB8fCBhKSA9PT0gKGIub3duZXJEb2N1bWVudCB8fCBiKSA/IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOiAvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAxOyAvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblxuICAgICAgICAgIGlmIChjb21wYXJlICYgMSB8fCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhKSA9PT0gY29tcGFyZSkge1xuICAgICAgICAgICAgLy8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG4gICAgICAgICAgICBpZiAoYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSkge1xuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSAvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXG5cbiAgICAgICAgICAgIHJldHVybiBzb3J0SW5wdXQgPyBpbmRleE9mKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mKHNvcnRJbnB1dCwgYikgOiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cixcbiAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgIGF1cCA9IGEucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgYnVwID0gYi5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICBhcCA9IFthXSxcbiAgICAgICAgICAgICAgYnAgPSBbYl07IC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cbiAgICAgICAgICBpZiAoIWF1cCB8fCAhYnVwKSB7XG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6IGIgPT09IGRvY3VtZW50ID8gMSA6IGF1cCA/IC0xIDogYnVwID8gMSA6IHNvcnRJbnB1dCA/IGluZGV4T2Yoc29ydElucHV0LCBhKSAtIGluZGV4T2Yoc29ydElucHV0LCBiKSA6IDA7IC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG4gICAgICAgICAgfSBlbHNlIGlmIChhdXAgPT09IGJ1cCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayhhLCBiKTtcbiAgICAgICAgICB9IC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cblxuICAgICAgICAgIGN1ciA9IGE7XG5cbiAgICAgICAgICB3aGlsZSAoY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGFwLnVuc2hpZnQoY3VyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXIgPSBiO1xuXG4gICAgICAgICAgd2hpbGUgKGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBicC51bnNoaWZ0KGN1cik7XG4gICAgICAgICAgfSAvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXG5cbiAgICAgICAgICB3aGlsZSAoYXBbaV0gPT09IGJwW2ldKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGkgPyAvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICBzaWJsaW5nQ2hlY2soYXBbaV0sIGJwW2ldKSA6IC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuICAgICAgICAgIGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6IGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDogMDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgfTtcblxuICAgICAgU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZXhwciwgZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGVsZW0sIGV4cHIpIHtcbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgIGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmICFub25uYXRpdmVTZWxlY3RvckNhY2hlW2V4cHIgKyBcIiBcIl0gJiYgKCFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoZXhwcikpICYmICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdChleHByKSkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJldCA9IG1hdGNoZXMuY2FsbChlbGVtLCBleHByKTsgLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXG4gICAgICAgICAgICBpZiAocmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHwgLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGluIElFIDlcbiAgICAgICAgICAgIGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBbQWRHdWFyZCBQYXRoXTogRml4IHRoZSBjYWNoZSB2YWx1ZVxuICAgICAgICAgICAgbm9ubmF0aXZlU2VsZWN0b3JDYWNoZShleHByLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU2l6emxlKGV4cHIsIGRvY3VtZW50LCBudWxsLCBbZWxlbV0pLmxlbmd0aCA+IDA7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlbSkge1xuICAgICAgICAvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKChjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCkgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgc2V0RG9jdW1lbnQoY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29udGFpbnMoY29udGV4dCwgZWxlbSk7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUuYXR0ciA9IGZ1bmN0aW9uIChlbGVtLCBuYW1lKSB7XG4gICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICBpZiAoKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVtuYW1lLnRvTG93ZXJDYXNlKCldLFxuICAgICAgICAgICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG4gICAgICAgIHZhbCA9IGZuICYmIGhhc093bi5jYWxsKEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpKSA/IGZuKGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgPyBlbGVtLmdldEF0dHJpYnV0ZShuYW1lKSA6ICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgPyB2YWwudmFsdWUgOiBudWxsO1xuICAgICAgfTtcblxuICAgICAgU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uIChzZWwpIHtcbiAgICAgICAgcmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUpO1xuICAgICAgfTtcblxuICAgICAgU2l6emxlLmVycm9yID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gICAgICAgKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICAgICAgICovXG5cblxuICAgICAgU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgIGR1cGxpY2F0ZXMgPSBbXSxcbiAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgaSA9IDA7IC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcblxuICAgICAgICBoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuICAgICAgICBzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoMCk7XG4gICAgICAgIHJlc3VsdHMuc29ydChzb3J0T3JkZXIpO1xuXG4gICAgICAgIGlmIChoYXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICB3aGlsZSAoZWxlbSA9IHJlc3VsdHNbaSsrXSkge1xuICAgICAgICAgICAgaWYgKGVsZW0gPT09IHJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgaiA9IGR1cGxpY2F0ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICByZXN1bHRzLnNwbGljZShkdXBsaWNhdGVzW2pdLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cblxuICAgICAgICBzb3J0SW5wdXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAgICAgICAqL1xuXG5cbiAgICAgIGdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBub2RlLFxuICAgICAgICAgICAgcmV0ID0gXCJcIixcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgIGlmICghbm9kZVR5cGUpIHtcbiAgICAgICAgICAvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuICAgICAgICAgIHdoaWxlIChub2RlID0gZWxlbVtpKytdKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuICAgICAgICAgICAgcmV0ICs9IGdldFRleHQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgIC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcbiAgICAgICAgICAvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuICAgICAgICAgIGlmICh0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuICAgICAgICAgICAgZm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICByZXQgKz0gZ2V0VGV4dChlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG4gICAgICAgIH0gLy8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG4gICAgICAgIC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuICAgICAgICBjYWNoZUxlbmd0aDogNTAsXG4gICAgICAgIGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuICAgICAgICBtYXRjaDogbWF0Y2hFeHByLFxuICAgICAgICBhdHRySGFuZGxlOiB7fSxcbiAgICAgICAgZmluZDoge30sXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgXCI+XCI6IHtcbiAgICAgICAgICAgIGRpcjogXCJwYXJlbnROb2RlXCIsXG4gICAgICAgICAgICBmaXJzdDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCIgXCI6IHtcbiAgICAgICAgICAgIGRpcjogXCJwYXJlbnROb2RlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiK1wiOiB7XG4gICAgICAgICAgICBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgICAgICAgICBmaXJzdDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ+XCI6IHtcbiAgICAgICAgICAgIGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlRmlsdGVyOiB7XG4gICAgICAgICAgXCJBVFRSXCI6IGZ1bmN0aW9uIEFUVFIobWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7IC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cbiAgICAgICAgICAgIG1hdGNoWzNdID0gKG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIpLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hbMl0gPT09IFwifj1cIikge1xuICAgICAgICAgICAgICBtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDSElMRFwiOiBmdW5jdGlvbiBDSElMRChtYXRjaCkge1xuICAgICAgICAgICAgLyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG4gICAgICAgICAgICBcdDEgdHlwZSAob25seXxudGh8Li4uKVxuICAgICAgICAgICAgXHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG4gICAgICAgICAgICBcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG4gICAgICAgICAgICBcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuICAgICAgICAgICAgXHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG4gICAgICAgICAgICBcdDYgeCBvZiB4bi1jb21wb25lbnRcbiAgICAgICAgICAgIFx0NyBzaWduIG9mIHktY29tcG9uZW50XG4gICAgICAgICAgICBcdDggeSBvZiB5LWNvbXBvbmVudFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdLnNsaWNlKDAsIDMpID09PSBcIm50aFwiKSB7XG4gICAgICAgICAgICAgIC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG4gICAgICAgICAgICAgIGlmICghbWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICB9IC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuICAgICAgICAgICAgICAvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cblxuICAgICAgICAgICAgICBtYXRjaFs0XSA9ICsobWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAobWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiKSk7XG4gICAgICAgICAgICAgIG1hdGNoWzVdID0gKyhtYXRjaFs3XSArIG1hdGNoWzhdIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiKTsgLy8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgIFNpenpsZS5lcnJvcihtYXRjaFswXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUFNFVURPXCI6IGZ1bmN0aW9uIFBTRVVETyhtYXRjaCkge1xuICAgICAgICAgICAgdmFyIGV4Y2VzcyxcbiAgICAgICAgICAgICAgICB1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QobWF0Y2hbMF0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSAvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXG5cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICBtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7IC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCh1bnF1b3RlZCkgJiYgKCAvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuICAgICAgICAgICAgZXhjZXNzID0gdG9rZW5pemUodW5xdW90ZWQsIHRydWUpKSAmJiAoIC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICAgICAgZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZihcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzKSAtIHVucXVvdGVkLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgLy8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcbiAgICAgICAgICAgICAgbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSgwLCBleGNlc3MpO1xuICAgICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XG4gICAgICAgICAgICB9IC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSgwLCAzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgIFwiVEFHXCI6IGZ1bmN0aW9uIFRBRyhub2RlTmFtZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDTEFTU1wiOiBmdW5jdGlvbiBDTEFTUyhjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVtjbGFzc05hbWUgKyBcIiBcIl07XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybiB8fCAocGF0dGVybiA9IG5ldyBSZWdFeHAoXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIpKSAmJiBjbGFzc0NhY2hlKGNsYXNzTmFtZSwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbiBBVFRSKG5hbWUsIG9wZXJhdG9yLCBjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBTaXp6bGUuYXR0cihlbGVtLCBuYW1lKTtcblxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiO1xuICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6IG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDogb3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKGNoZWNrKSA9PT0gMCA6IG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPiAtMSA6IG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoLWNoZWNrLmxlbmd0aCkgPT09IGNoZWNrIDogb3BlcmF0b3IgPT09IFwifj1cIiA/IChcIiBcIiArIHJlc3VsdC5yZXBsYWNlKHJ3aGl0ZXNwYWNlLCBcIiBcIikgKyBcIiBcIikuaW5kZXhPZihjaGVjaykgPiAtMSA6IG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSgwLCBjaGVjay5sZW5ndGggKyAxKSA9PT0gY2hlY2sgKyBcIi1cIiA6IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ0hJTERcIjogZnVuY3Rpb24gQ0hJTEQodHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0KSB7XG4gICAgICAgICAgICB2YXIgc2ltcGxlID0gdHlwZS5zbGljZSgwLCAzKSAhPT0gXCJudGhcIixcbiAgICAgICAgICAgICAgICBmb3J3YXJkID0gdHlwZS5zbGljZSgtNCkgIT09IFwibGFzdFwiLFxuICAgICAgICAgICAgICAgIG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgPyAvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG4gICAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICB2YXIgY2FjaGUsXG4gICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSxcbiAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUsXG4gICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICBkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuICAgICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgbmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICB1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcbiAgICAgICAgICAgICAgICAgIGRpZmYgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlW2Rpcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSAvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBbZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZF07IC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZCAmJiB1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgLy8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG4gICAgICAgICAgICAgICAgICAvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG4gICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbZXhwYW5kb10gfHwgKG5vZGVbZXhwYW5kb10gPSB7fSk7IC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXG4gICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHwgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgICBjYWNoZSA9IHVuaXF1ZUNhY2hlW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG4gICAgICAgICAgICAgICAgICBkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWzJdO1xuICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1tub2RlSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVtkaXJdIHx8ICggLy8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlW3R5cGVdID0gW2RpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZl07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICBpZiAodXNlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbZXhwYW5kb10gfHwgKG5vZGVbZXhwYW5kb10gPSB7fSk7IC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlW25vZGUudW5pcXVlSURdIHx8IChvdXRlckNhY2hlW25vZGUudW5pcXVlSURdID0ge30pO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IHVuaXF1ZUNhY2hlW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IG5vZGVJbmRleDtcbiAgICAgICAgICAgICAgICAgIH0gLy8geG1sIDpudGgtY2hpbGQoLi4uKVxuICAgICAgICAgICAgICAgICAgLy8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChkaWZmID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVtkaXJdIHx8IChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEpICYmICsrZGlmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBub2RlW2V4cGFuZG9dIHx8IChub2RlW2V4cGFuZG9dID0ge30pOyAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgZGlmZl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblxuXG4gICAgICAgICAgICAgICAgZGlmZiAtPSBsYXN0O1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmID09PSBmaXJzdCB8fCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBTRVVET1wiOiBmdW5jdGlvbiBQU0VVRE8ocHNldWRvLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgLy8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuICAgICAgICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgICAgICAgZm4gPSBFeHByLnBzZXVkb3NbcHNldWRvXSB8fCBFeHByLnNldEZpbHRlcnNbcHNldWRvLnRvTG93ZXJDYXNlKCldIHx8IFNpenpsZS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8pOyAvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAgICAgICAvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuICAgICAgICAgICAgLy8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXG4gICAgICAgICAgICBpZiAoZm5bZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuKGFyZ3VtZW50KTtcbiAgICAgICAgICAgIH0gLy8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cblxuICAgICAgICAgICAgaWYgKGZuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgYXJncyA9IFtwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnRdO1xuICAgICAgICAgICAgICByZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KHBzZXVkby50b0xvd2VyQ2FzZSgpKSA/IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHZhciBpZHgsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmbihzZWVkLCBhcmd1bWVudCksXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVkLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlkeCA9IGluZGV4T2Yoc2VlZCwgbWF0Y2hlZFtpXSk7XG4gICAgICAgICAgICAgICAgICBzZWVkW2lkeF0gPSAhKG1hdGNoZXNbaWR4XSA9IG1hdGNoZWRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkgOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihlbGVtLCAwLCBhcmdzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHNldWRvczoge1xuICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuICAgICAgICAgIFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG4gICAgICAgICAgICAvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuICAgICAgICAgICAgLy8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBbXSxcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW10sXG4gICAgICAgICAgICAgICAgbWF0Y2hlciA9IGNvbXBpbGUoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXCIkMVwiKSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcltleHBhbmRvXSA/IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtLFxuICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkID0gbWF0Y2hlcihzZWVkLCBudWxsLCB4bWwsIFtdKSxcbiAgICAgICAgICAgICAgICAgIGkgPSBzZWVkLmxlbmd0aDsgLy8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSA9IHVubWF0Y2hlZFtpXSkge1xuICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkgOiBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgIGlucHV0WzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgbWF0Y2hlcihpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzKTsgLy8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblxuICAgICAgICAgICAgICBpbnB1dFswXSA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiAhcmVzdWx0cy5wb3AoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG4gICAgICAgICAgXCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBTaXp6bGUuY29tcGlsZShzZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvLyBSZW1vdmVkIDpjb250YWlucyBwc2V1ZG8tY2xhc3MgZGVjbGFyYXRpb25cbiAgICAgICAgICAvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3JcbiAgICAgICAgICAvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuICAgICAgICAgIC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG4gICAgICAgICAgLy8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cbiAgICAgICAgICAvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgICAgICAvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuICAgICAgICAgIFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgICAgIC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcbiAgICAgICAgICAgIGlmICghcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgIFNpenpsZS5lcnJvcihcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhbmcgPSBsYW5nLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xuXG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/IGVsZW0ubGFuZyA6IGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgICBlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZihsYW5nICsgXCItXCIpID09PSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSB3aGlsZSAoKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xuICAgICAgICAgIFwidGFyZ2V0XCI6IGZ1bmN0aW9uIHRhcmdldChlbGVtKSB7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICAgIHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoMSkgPT09IGVsZW0uaWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJvb3RcIjogZnVuY3Rpb24gcm9vdChlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZm9jdXNcIjogZnVuY3Rpb24gZm9jdXMoZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllc1xuICAgICAgICAgIFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyhmYWxzZSksXG4gICAgICAgICAgXCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyh0cnVlKSxcbiAgICAgICAgICBcImNoZWNrZWRcIjogZnVuY3Rpb24gY2hlY2tlZChlbGVtKSB7XG4gICAgICAgICAgICAvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCB8fCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbGVjdGVkXCI6IGZ1bmN0aW9uIHNlbGVjdGVkKGVsZW0pIHtcbiAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcbiAgICAgICAgICAgIC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcbiAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgICBcImVtcHR5XCI6IGZ1bmN0aW9uIGVtcHR5KGVsZW0pIHtcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG4gICAgICAgICAgICAvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG4gICAgICAgICAgICAvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuICAgICAgICAgICAgLy8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuICAgICAgICAgICAgZm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA8IDYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSAvLyBSZW1vdmVkIGN1c3RvbSBwc2V1ZG8tY2xhc3Nlc1xuXG4gICAgICAgIH1cbiAgICAgIH07IC8vIFJlbW92ZWQgY3VzdG9tIHBzZXVkby1jbGFzc2VzXG4gICAgICAvLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcblxuICAgICAgZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5cbiAgICAgIHNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuICAgICAgRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcbiAgICAgIC8qKlxuICAgICAgICogW0FkR3VhcmQgUGF0Y2hdOlxuICAgICAgICogU29ydHMgdGhlIHRva2VucyBpbiBvcmRlciB0byBtaXRpZ2F0ZSB0aGUgcGVyZm9ybWFuY2UgaXNzdWVzIGNhdXNlZCBieSBtYXRjaGluZyBzbG93IHBzZXVkb3MgZmlyc3Q6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vRXh0ZW5kZWRDc3MvaXNzdWVzLzU1I2lzc3VlY29tbWVudC0zNjQwNTg3NDVcbiAgICAgICAqL1xuXG4gICAgICB2YXIgc29ydFRva2VuR3JvdXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BsaXRzIGNvbXBvdW5kIHNlbGVjdG9yIGludG8gYSBsaXN0IG9mIHNpbXBsZSBzZWxlY3RvcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSB0b2tlbnMgVG9rZW5zIHRvIHNwbGl0IGludG8gZ3JvdXBzXG4gICAgICAgICAqIEByZXR1cm5zIGFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgdG9rZW4gZ3JvdXBzIChhcnJheXMpIGFuZCByZWxhdGlvbiB0b2tlbnMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3BsaXRDb21wb3VuZFNlbGVjdG9yID0gZnVuY3Rpb24gc3BsaXRDb21wb3VuZFNlbGVjdG9yKHRva2Vucykge1xuICAgICAgICAgIHZhciBncm91cHMgPSBbXTtcbiAgICAgICAgICB2YXIgY3VycmVudFRva2Vuc0dyb3VwID0gW107XG4gICAgICAgICAgdmFyIG1heElkeCA9IHRva2Vucy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWF4SWR4OyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IFNpenpsZS5zZWxlY3RvcnMucmVsYXRpdmVbdG9rZW4udHlwZV07XG5cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgICBncm91cHMucHVzaChjdXJyZW50VG9rZW5zR3JvdXApO1xuICAgICAgICAgICAgICBncm91cHMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIGN1cnJlbnRUb2tlbnNHcm91cCA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudFRva2Vuc0dyb3VwLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PT0gbWF4SWR4KSB7XG4gICAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGN1cnJlbnRUb2tlbnNHcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgVE9LRU5fVFlQRVNfVkFMVUVTID0ge1xuICAgICAgICAgIC8vIG50aC1jaGlsZCwgZXRjLCBhbHdheXMgZ28gbGFzdFxuICAgICAgICAgIFwiQ0hJTERcIjogMTAwLFxuICAgICAgICAgIFwiSURcIjogOTAsXG4gICAgICAgICAgXCJDTEFTU1wiOiA4MCxcbiAgICAgICAgICBcIlRBR1wiOiA3MCxcbiAgICAgICAgICBcIkFUVFJcIjogNzAsXG4gICAgICAgICAgXCJQU0VVRE9cIjogNjBcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIFBPU0lUSU9OQUxfUFNFVURPUyA9IFtcIm50aFwiLCBcImZpcnN0XCIsIFwibGFzdFwiLCBcImVxXCIsIFwiZXZlblwiLCBcIm9kZFwiLCBcImx0XCIsIFwiZ3RcIiwgXCJub3RcIl07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyB0aGUgc29ydCBvcmRlci5cbiAgICAgICAgICogUmV0dXJucyBhIHZhbHVlIGxlc3NlciB0aGFuIDAgaWYgXCJsZWZ0XCIgaXMgbGVzcyB0aGFuIFwicmlnaHRcIi5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGNvbXBhcmVGdW5jdGlvbiA9IGZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHZhciBsZWZ0VmFsdWUgPSBUT0tFTl9UWVBFU19WQUxVRVNbbGVmdC50eXBlXTtcbiAgICAgICAgICB2YXIgcmlnaHRWYWx1ZSA9IFRPS0VOX1RZUEVTX1ZBTFVFU1tyaWdodC50eXBlXTtcbiAgICAgICAgICByZXR1cm4gbGVmdFZhbHVlIC0gcmlnaHRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIHRva2VucyBncm91cCBpcyBzb3J0YWJsZS5cbiAgICAgICAgICogV2UgZG8gbm90IHJlLXNvcnQgdG9rZW5zIGluIGNhc2Ugb2YgYW55IHBvc2l0aW9uYWwgb3IgY2hpbGQgcHNldWRvcyBpbiB0aGUgZ3JvdXBcbiAgICAgICAgICovXG5cblxuICAgICAgICB2YXIgaXNTb3J0YWJsZSA9IGZ1bmN0aW9uIGlzU29ydGFibGUodG9rZW5zKSB7XG4gICAgICAgICAgdmFyIGlUb2tlbnMgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGlUb2tlbnMtLSkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2lUb2tlbnNdO1xuXG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJQU0VVRE9cIiAmJiBQT1NJVElPTkFMX1BTRVVET1MuaW5kZXhPZih0b2tlbi5tYXRjaGVzWzBdKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJDSElMRFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvcnRzIHRoZSB0b2tlbnMgaW4gb3JkZXIgdG8gbWl0aWdhdGUgdGhlIGlzc3VlcyBjYXVzZWQgYnkgdGhlIGxlZnQtdG8tcmlnaHQgbWF0Y2hpbmcuXG4gICAgICAgICAqIFRoZSBpZGVhIGlzIGNoYW5nZSB0aGUgdG9rZW5zIG9yZGVyIHNvIHRoYXQgU2l6emxlIHdhcyBtYXRjaGluZyBmYXN0IHNlbGVjdG9ycyBmaXJzdCAoaWQsIGNsYXNzKSxcbiAgICAgICAgICogYW5kIHNsb3cgc2VsZWN0b3JzIGFmdGVyIHRoYXQgKGFuZCBoZXJlIEkgbWVhbiBvdXIgc2xvdyBjdXN0b20gcHNldWRvIGNsYXNzZXMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgQW4gYXJyYXkgb2YgdG9rZW5zIHRvIHNvcnRcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBBIG5ldyByZS1zb3J0ZWQgYXJyYXlcbiAgICAgICAgICovXG5cblxuICAgICAgICB2YXIgc29ydFRva2VucyA9IGZ1bmN0aW9uIHNvcnRUb2tlbnModG9rZW5zKSB7XG4gICAgICAgICAgaWYgKCF0b2tlbnMgfHwgdG9rZW5zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc29ydGVkVG9rZW5zID0gW107XG4gICAgICAgICAgdmFyIGdyb3VwcyA9IHNwbGl0Q29tcG91bmRTZWxlY3Rvcih0b2tlbnMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgaWYgKGlzU29ydGFibGUoZ3JvdXApKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc29ydGVkVG9rZW5zID0gc29ydGVkVG9rZW5zLmNvbmNhdChncm91cCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzb3J0ZWRUb2tlbnMucHVzaChncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNvcnRlZFRva2VucztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvcnRzIGV2ZXJ5IHRva2VucyBhcnJheSBpbnNpZGUgb2YgdGhlIHNwZWNpZmllZCBcImdyb3Vwc1wiIGFycmF5LlxuICAgICAgICAgKiBTZWUgXCJzb3J0VG9rZW5zXCIgbWV0aG9kcyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG9rZW5zIGFyZSBzb3J0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwcyBBbiBhcnJheSBvZiB0b2tlbnMgYXJyYXlzLlxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IHRoYXQgY29uc2lzdHMgb2YgdGhlIHNhbWUgdG9rZW5zIGFycmF5cyBhZnRlciBzb3J0aW5nXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdmFyIHNvcnRUb2tlbkdyb3VwcyA9IGZ1bmN0aW9uIHNvcnRUb2tlbkdyb3Vwcyhncm91cHMpIHtcbiAgICAgICAgICB2YXIgc29ydGVkR3JvdXBzID0gW107XG4gICAgICAgICAgdmFyIGxlbiA9IGdyb3Vwcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc29ydGVkR3JvdXBzLnB1c2goc29ydFRva2Vucyhncm91cHNbaV0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc29ydGVkR3JvdXBzO1xuICAgICAgICB9OyAvLyBFeHBvc2VcblxuXG4gICAgICAgIHJldHVybiBzb3J0VG9rZW5Hcm91cHM7XG4gICAgICB9KCk7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgY3VzdG9tIHBvbGljeSB0byB1c2UgVHJ1c3RlZFR5cGVzIENTUCBwb2xpY3lcbiAgICAgICAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtdHJ1c3RlZC10eXBlcy9kaXN0L3NwZWMvXG4gICAgICAgKi9cblxuXG4gICAgICB2YXIgQUdQb2xpY3kgPSBmdW5jdGlvbiBjcmVhdGVQb2xpY3koKSB7XG4gICAgICAgIHZhciBkZWZhdWx0UG9saWN5ID0ge1xuICAgICAgICAgIGNyZWF0ZUhUTUw6IGZ1bmN0aW9uIGNyZWF0ZUhUTUwoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNyZWF0ZVNjcmlwdDogZnVuY3Rpb24gY3JlYXRlU2NyaXB0KGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjcmVhdGVTY3JpcHRVUkw6IGZ1bmN0aW9uIGNyZWF0ZVNjcmlwdFVSTChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAod2luZG93LnRydXN0ZWRUeXBlcyAmJiB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcIkFHUG9saWN5XCIsIGRlZmF1bHRQb2xpY3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQb2xpY3k7XG4gICAgICB9KCk7XG4gICAgICAvKipcbiAgICAgICAqIFtBZEd1YXJkIFBhdGNoXTpcbiAgICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgc3BhY2VzIGZyb20gdGhlIHRva2VucyBsaXN0XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSB0b2tlbnMgQW4gYXJyYXkgb2YgU2l6emxlIHRva2VucyB0byBwb3N0LXByb2Nlc3NcbiAgICAgICAqL1xuXG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU3BhY2VzKHRva2Vucykge1xuICAgICAgICB2YXIgaVRva2VucyA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGlUb2tlbnMtLSkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpVG9rZW5zXTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcIiBcIikge1xuICAgICAgICAgICAgdG9rZW5zLmxlbmd0aCA9IGlUb2tlbnM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBbQWRHdWFyZCBQYXRjaF06XG4gICAgICAgKiBBbiBvYmplY3Qgd2l0aCB0aGUgaW5mb3JtYXRpb24gYWJvdXQgc2VsZWN0b3JzIGFuZCB0aGVpciB0b2tlbiByZXByZXNlbnRhdGlvblxuICAgICAgICogQHR5cGVkZWYge3tzZWxlY3RvclRleHQ6IHN0cmluZywgZ3JvdXBzOiBBcnJheX19IFNlbGVjdG9yRGF0YVxuICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdG9yVGV4dCBBIENTUyBzZWxlY3RvciB0ZXh0XG4gICAgICAgKiBAcHJvcGVydHkge0FycmF5fSBncm91cHMgQW4gYXJyYXkgb2YgdG9rZW4gZ3JvdXBzIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBzZWxlY3RvclxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogW0FkR3VhcmQgUGF0Y2hdOlxuICAgICAgICogVGhpcyBtZXRob2QgcHJvY2Vzc2VzIHBhcnNlZCB0b2tlbiBncm91cHMsIGRpdmlkZXMgdGhlbSBpbnRvIGEgbnVtYmVyIG9mIHNlbGVjdG9yc1xuICAgICAgICogYW5kIG1ha2VzIHN1cmUgdGhhdCBlYWNoIHNlbGVjdG9yJ3MgdG9rZW5zIGFyZSBjYWNoZWQgcHJvcGVybHkgaW4gU2l6emxlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gZ3JvdXBzIFRva2VuIGdyb3VwcyAoc2VlIHtAbGluayBTaXp6bGUudG9rZW5pemV9KVxuICAgICAgICogQHJldHVybnMge0FycmF5LjxTZWxlY3RvckRhdGE+fSBBbiBhcnJheSBvZiBzZWxlY3RvcnMgZGF0YSB3ZSBnb3QgZnJvbSB0aGUgZ3JvdXBzXG4gICAgICAgKi9cblxuXG4gICAgICBmdW5jdGlvbiB0b2tlbkdyb3Vwc1RvU2VsZWN0b3JzKGdyb3Vwcykge1xuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgc3BhY2VzIHdoaWNoIHdlIGNhbiBlbmNvdW50ZXIgaW4gdG9sZXJhbnQgbW9kZVxuICAgICAgICAvLyBXZSdyZSBkb2luZyBpdCBpbiB0b2xlcmFudCBtb2RlIG9ubHkgYXMgdGhpcyBpcyB0aGUgb25seSBjYXNlIHdoZW5cbiAgICAgICAgLy8gZW5jb3VudGVyaW5nIHRyYWlsaW5nIHNwYWNlcyBpcyBleHBlY3RlZFxuICAgICAgICByZW1vdmVUcmFpbGluZ1NwYWNlcyhncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdKTsgLy8gV2UgbmVlZCBzb3J0ZWQgdG9rZW5zIHRvIG1ha2UgY2FjaGUgd29yayBwcm9wZXJseVxuXG4gICAgICAgIHZhciBzb3J0ZWRHcm91cHMgPSBzb3J0VG9rZW5Hcm91cHMoZ3JvdXBzKTtcbiAgICAgICAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRva2VuR3JvdXBzID0gZ3JvdXBzW2ldO1xuICAgICAgICAgIHZhciBzZWxlY3RvclRleHQgPSB0b1NlbGVjdG9yKHRva2VuR3JvdXBzKTtcbiAgICAgICAgICBzZWxlY3RvcnMucHVzaCh7XG4gICAgICAgICAgICAvLyBTaXp6bGUgZXhwZWN0cyBhbiBhcnJheSBvZiB0b2tlbiBncm91cHMgd2hlbiBjb21waWxpbmcgYSBzZWxlY3RvclxuICAgICAgICAgICAgZ3JvdXBzOiBbdG9rZW5Hcm91cHNdLFxuICAgICAgICAgICAgc2VsZWN0b3JUZXh0OiBzZWxlY3RvclRleHRcbiAgICAgICAgICB9KTsgLy8gTm93IG1ha2Ugc3VyZSB0aGF0IHNlbGVjdG9yIHRva2VucyBhcmUgY2FjaGVkXG5cbiAgICAgICAgICB2YXIgdG9rZW5zQ2FjaGVJdGVtID0ge1xuICAgICAgICAgICAgZ3JvdXBzOiB0b2tlbkdyb3VwcyxcbiAgICAgICAgICAgIHNvcnRlZEdyb3VwczogW3NvcnRlZEdyb3Vwc1tpXV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRva2VuQ2FjaGUoc2VsZWN0b3JUZXh0LCB0b2tlbnNDYWNoZUl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9ycztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogW0FkR3VhcmQgUGF0Y2hdOlxuICAgICAgICogQWRkIGFuIGFkZGl0aW9uYWwgYXJndW1lbnQgZm9yIFNpenpsZS50b2tlbml6ZSB3aGljaCBpbmRpY2F0ZXMgdGhhdCBpdFxuICAgICAgICogc2hvdWxkIG5vdCB0aHJvdyBvbiBpbnZhbGlkIHRva2VucywgYW5kIGluc3RlYWQgc2hvdWxkIHJldHVybiB0b2tlbnNcbiAgICAgICAqIHRoYXQgaXQgaGFzIHByb2R1Y2VkIHNvIGZhci5cbiAgICAgICAqXG4gICAgICAgKiBPbmUgbW9yZSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRoYXQgYWxsb3cgdG8gY2hvb3NlIGlmIHlvdSB3YW50IHRvIHJlY2VpdmUgc29ydGVkIG9yIHVuc29ydGVkIHRva2Vuc1xuICAgICAgICogVGhlIHByb2JsZW0gaXMgdGhhdCB0aGUgcmUtc29ydGVkIHNlbGVjdG9ycyBhcmUgdmFsaWQgZm9yIFNpenpsZSwgYnV0IG5vdCBmb3IgdGhlIGJyb3dzZXIuXG4gICAgICAgKiBvcHRpb25zLnJldHVyblVuc29ydGVkIC0tIHJldHVybiB1bnNvcnRlZCB0b2tlbnMgaWYgdHJ1ZS5cbiAgICAgICAqIG9wdGlvbnMuY2FjaGVPbmx5IC0tIHJldHVybiBjYWNoZWQgcmVzdWx0IG9ubHkuIFJlcXVpcmVkIGZvciB1bml0LXRlc3RzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9ucyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIHR3byBhZGRpdGlvbmFsIGZsYWdzXG4gICAgICAgKiAob3B0aW9ucy50b2xlcmFudCwgb3B0aW9ucy5yZXR1cm5VbnNvcnRlZCwgb3B0aW9ucy5jYWNoZU9ubHkpIC0tIHNlZSBwYXRjaGVzICM1IGFuZCAjNiBub3Rlc1xuICAgICAgICovXG5cblxuICAgICAgdG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHBhcnNlT25seSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWF0Y2hlZCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHNvRmFyLFxuICAgICAgICAgICAgZ3JvdXBzLFxuICAgICAgICAgICAgcHJlRmlsdGVycyxcbiAgICAgICAgICAgIGNhY2hlZCA9IHRva2VuQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl07XG4gICAgICAgIHZhciB0b2xlcmFudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50b2xlcmFudDtcbiAgICAgICAgdmFyIHJldHVyblVuc29ydGVkID0gb3B0aW9ucyAmJiBvcHRpb25zLnJldHVyblVuc29ydGVkO1xuICAgICAgICB2YXIgY2FjaGVPbmx5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlT25seTtcblxuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgaWYgKHBhcnNlT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocmV0dXJuVW5zb3J0ZWQgPyBjYWNoZWQuZ3JvdXBzIDogY2FjaGVkLnNvcnRlZEdyb3Vwcykuc2xpY2UoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlT25seSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc29GYXIgPSBzZWxlY3RvcjtcbiAgICAgICAgZ3JvdXBzID0gW107XG4gICAgICAgIHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuICAgICAgICB3aGlsZSAoc29GYXIpIHtcbiAgICAgICAgICAvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG4gICAgICAgICAgaWYgKCFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKHNvRmFyKSkpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCkgfHwgc29GYXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHRva2VucyA9IFtdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRjaGVkID0gZmFsc2U7IC8vIENvbWJpbmF0b3JzXG5cbiAgICAgICAgICBpZiAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyhzb0ZhcikpIHtcbiAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgLy8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG4gICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UocnRyaW0sIFwiIFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgICB9IC8vIEZpbHRlcnNcblxuXG4gICAgICAgICAgZm9yICh0eXBlIGluIEV4cHIuZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hFeHByW3R5cGVdLmV4ZWMoc29GYXIpKSAmJiAoIXByZUZpbHRlcnNbdHlwZV0gfHwgKG1hdGNoID0gcHJlRmlsdGVyc1t0eXBlXShtYXRjaCkpKSkge1xuICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hlZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuICAgICAgICAvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cblxuICAgICAgICB2YXIgaW52YWxpZExlbiA9IHNvRmFyLmxlbmd0aDtcblxuICAgICAgICBpZiAocGFyc2VPbmx5KSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRMZW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52YWxpZExlbiAhPT0gMCAmJiAhdG9sZXJhbnQpIHtcbiAgICAgICAgICBTaXp6bGUuZXJyb3Ioc2VsZWN0b3IpOyAvLyBUaHJvd3MgYW4gZXJyb3IuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9sZXJhbnQpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBbQWRHdWFyZCBQYXRjaF06XG4gICAgICAgICAgICogSW4gdG9sZXJhbnQgbW9kZSB3ZSByZXR1cm4gYSBzcGVjaWFsIG9iamVjdCB0aGF0IGNvbnN0aXN0cyBvZlxuICAgICAgICAgICAqIGFuIGFycmF5IG9mIHBhcnNlZCBzZWxlY3RvcnMgKGFuZCB0aGVpciB0b2tlbnMpIGFuZCBhIFwibmV4dEluZGV4XCIgZmllbGRcbiAgICAgICAgICAgKiB0aGF0IHBvaW50cyB0byBhbiBpbmRleCBhZnRlciB3aGljaCB3ZSdyZSBub3QgYWJsZSB0byBwYXJzZSBzZWxlY3RvcnMgZmFydGhlci5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gc2VsZWN0b3IubGVuZ3RoIC0gaW52YWxpZExlbjtcbiAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gdG9rZW5Hcm91cHNUb1NlbGVjdG9ycyhncm91cHMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9ycyxcbiAgICAgICAgICAgIG5leHRJbmRleDogbmV4dEluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvKiogW0FkR3VhcmQgUGF0Y2hdOiBTb3J0aW5nIHRva2VucyAqL1xuXG5cbiAgICAgICAgdmFyIHNvcnRlZEdyb3VwcyA9IHNvcnRUb2tlbkdyb3Vwcyhncm91cHMpO1xuICAgICAgICAvKiogW0FkR3VhcmQgUGF0Y2hdOiBDaGFuZ2UgdGhlIHdheSB0b2tlbnMgYXJlIGNhY2hlZCAqL1xuXG4gICAgICAgIHZhciB0b2tlbnNDYWNoZUl0ZW0gPSB7XG4gICAgICAgICAgZ3JvdXBzOiBncm91cHMsXG4gICAgICAgICAgc29ydGVkR3JvdXBzOiBzb3J0ZWRHcm91cHNcbiAgICAgICAgfTtcbiAgICAgICAgdG9rZW5zQ2FjaGVJdGVtID0gdG9rZW5DYWNoZShzZWxlY3RvciwgdG9rZW5zQ2FjaGVJdGVtKTtcbiAgICAgICAgcmV0dXJuIChyZXR1cm5VbnNvcnRlZCA/IHRva2Vuc0NhY2hlSXRlbS5ncm91cHMgOiB0b2tlbnNDYWNoZUl0ZW0uc29ydGVkR3JvdXBzKS5zbGljZSgwKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHRvU2VsZWN0b3IodG9rZW5zKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgICBzZWxlY3RvciA9IFwiXCI7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkQ29tYmluYXRvcihtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlKSB7XG4gICAgICAgIHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcbiAgICAgICAgICAgIHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG4gICAgICAgICAgICBrZXkgPSBza2lwIHx8IGRpcixcbiAgICAgICAgICAgIGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG4gICAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcbiAgICAgICAgcmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgPyAvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcbiAgICAgICAgZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgIHdoaWxlIChlbGVtID0gZWxlbVtkaXJdKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IDogLy8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG4gICAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICB2YXIgb2xkQ2FjaGUsXG4gICAgICAgICAgICAgIHVuaXF1ZUNhY2hlLFxuICAgICAgICAgICAgICBvdXRlckNhY2hlLFxuICAgICAgICAgICAgICBuZXdDYWNoZSA9IFtkaXJydW5zLCBkb25lTmFtZV07IC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXG4gICAgICAgICAgaWYgKHhtbCkge1xuICAgICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoZWxlbSA9IGVsZW1bZGlyXSkge1xuICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IGVsZW1bZXhwYW5kb10gfHwgKGVsZW1bZXhwYW5kb10gPSB7fSk7IC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcbiAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblxuICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVtlbGVtLnVuaXF1ZUlEXSB8fCAob3V0ZXJDYWNoZVtlbGVtLnVuaXF1ZUlEXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgIGlmIChza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgZWxlbSA9IGVsZW1bZGlyXSB8fCBlbGVtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVba2V5XSkgJiYgb2xkQ2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbMV0gPT09IGRvbmVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NhY2hlWzJdID0gb2xkQ2FjaGVbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlW2tleV0gPSBuZXdDYWNoZTsgLy8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cbiAgICAgICAgICAgICAgICAgIGlmIChuZXdDYWNoZVsyXSA9IG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID8gZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgIHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVyc1tpXShlbGVtLCBjb250ZXh0LCB4bWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSA6IG1hdGNoZXJzWzBdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cykge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIFNpenpsZShzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbmRlbnNlKHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCkge1xuICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgIG5ld1VubWF0Y2hlZCA9IFtdLFxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuICAgICAgICAgICAgbWFwcGVkID0gbWFwICE9IG51bGw7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChlbGVtID0gdW5tYXRjaGVkW2ldKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICBuZXdVbm1hdGNoZWQucHVzaChlbGVtKTtcblxuICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgbWFwLnB1c2goaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRNYXRjaGVyKHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3Rvcikge1xuICAgICAgICBpZiAocG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlcltleHBhbmRvXSkge1xuICAgICAgICAgIHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKHBvc3RGaWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbZXhwYW5kb10pIHtcbiAgICAgICAgICBwb3N0RmluZGVyID0gc2V0TWF0Y2hlcihwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgdmFyIHRlbXAsXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgIHByZU1hcCA9IFtdLFxuICAgICAgICAgICAgICBwb3N0TWFwID0gW10sXG4gICAgICAgICAgICAgIHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG4gICAgICAgICAgICAgIC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG4gICAgICAgICAgZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbY29udGV4dF0gOiBjb250ZXh0LCBbXSksXG4gICAgICAgICAgICAgIC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuICAgICAgICAgIG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoc2VlZCB8fCAhc2VsZWN0b3IpID8gY29uZGVuc2UoZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwpIDogZWxlbXMsXG4gICAgICAgICAgICAgIG1hdGNoZXJPdXQgPSBtYXRjaGVyID8gLy8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcbiAgICAgICAgICBwb3N0RmluZGVyIHx8IChzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlcikgPyAvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcbiAgICAgICAgICBbXSA6IC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuICAgICAgICAgIHJlc3VsdHMgOiBtYXRjaGVySW47IC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cbiAgICAgICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlcihtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgfSAvLyBBcHBseSBwb3N0RmlsdGVyXG5cblxuICAgICAgICAgIGlmIChwb3N0RmlsdGVyKSB7XG4gICAgICAgICAgICB0ZW1wID0gY29uZGVuc2UobWF0Y2hlck91dCwgcG9zdE1hcCk7XG4gICAgICAgICAgICBwb3N0RmlsdGVyKHRlbXAsIFtdLCBjb250ZXh0LCB4bWwpOyAvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cbiAgICAgICAgICAgIGkgPSB0ZW1wLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBpZiAoZWxlbSA9IHRlbXBbaV0pIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVyT3V0W3Bvc3RNYXBbaV1dID0gIShtYXRjaGVySW5bcG9zdE1hcFtpXV0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWVkKSB7XG4gICAgICAgICAgICBpZiAocG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcbiAgICAgICAgICAgICAgICB0ZW1wID0gW107XG4gICAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIHRlbXAucHVzaChtYXRjaGVySW5baV0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwb3N0RmluZGVyKG51bGwsIG1hdGNoZXJPdXQgPSBbXSwgdGVtcCwgeG1sKTtcbiAgICAgICAgICAgICAgfSAvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXG5cbiAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJiAodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKHNlZWQsIGVsZW0pIDogcHJlTWFwW2ldKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoZXJPdXQgPSBjb25kZW5zZShtYXRjaGVyT3V0ID09PSByZXN1bHRzID8gbWF0Y2hlck91dC5zcGxpY2UocHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoKSA6IG1hdGNoZXJPdXQpO1xuXG4gICAgICAgICAgICBpZiAocG9zdEZpbmRlcikge1xuICAgICAgICAgICAgICBwb3N0RmluZGVyKG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIG1hdGNoZXJPdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKHRva2Vucykge1xuICAgICAgICB2YXIgY2hlY2tDb250ZXh0LFxuICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxuICAgICAgICAgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbMF0udHlwZV0sXG4gICAgICAgICAgICBpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuICAgICAgICAgICAgaSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuICAgICAgICAgICAgLy8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcbiAgICAgICAgbWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG4gICAgICAgIH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUpLFxuICAgICAgICAgICAgbWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgIHJldHVybiBpbmRleE9mKGNoZWNrQ29udGV4dCwgZWxlbSkgPiAtMTtcbiAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSksXG4gICAgICAgICAgICBtYXRjaGVycyA9IFtmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgdmFyIHJldCA9ICFsZWFkaW5nUmVsYXRpdmUgJiYgKHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0KSB8fCAoKGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID8gbWF0Y2hDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkgOiBtYXRjaEFueUNvbnRleHQoZWxlbSwgY29udGV4dCwgeG1sKSk7IC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXG4gICAgICAgICAgY2hlY2tDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XTtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlW3Rva2Vuc1tpXS50eXBlXSkge1xuICAgICAgICAgICAgbWF0Y2hlcnMgPSBbYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIG1hdGNoZXIpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlciA9IEV4cHIuZmlsdGVyW3Rva2Vuc1tpXS50eXBlXS5hcHBseShudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyk7IC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVyW2V4cGFuZG9dKSB7XG4gICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuICAgICAgICAgICAgICBqID0gKytpO1xuXG4gICAgICAgICAgICAgIGZvciAoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRXhwci5yZWxhdGl2ZVt0b2tlbnNbal0udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBzZXRNYXRjaGVyKGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSwgaSA+IDEgJiYgdG9TZWxlY3RvciggLy8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcbiAgICAgICAgICAgICAgdG9rZW5zLnNsaWNlKDAsIGkgLSAxKS5jb25jYXQoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0b2tlbnNbaSAtIDJdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiXG4gICAgICAgICAgICAgIH0pKS5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLCBtYXRjaGVyLCBpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMuc2xpY2UoaSwgaikpLCBqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKHRva2VucyA9IHRva2Vucy5zbGljZShqKSksIGogPCBsZW4gJiYgdG9TZWxlY3Rvcih0b2tlbnMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykge1xuICAgICAgICB2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgYnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICBzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiBzdXBlck1hdGNoZXIoc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QpIHtcbiAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgICAgbWF0Y2hlZENvdW50ID0gMCxcbiAgICAgICAgICAgICAgaSA9IFwiMFwiLFxuICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gW10sXG4gICAgICAgICAgICAgIGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgICAgICAvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG4gICAgICAgICAgZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oXCIqXCIsIG91dGVybW9zdCksXG4gICAgICAgICAgICAgIC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG4gICAgICAgICAgZGlycnVuc1VuaXF1ZSA9IGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xLFxuICAgICAgICAgICAgICBsZW4gPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG4gICAgICAgICAgfSAvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuICAgICAgICAgIC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXG5cbiAgICAgICAgICBmb3IgKDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJ5RWxlbWVudCAmJiBlbGVtKSB7XG4gICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIGlmICghY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XG4gICAgICAgICAgICAgICAgeG1sID0gIWRvY3VtZW50SXNIVE1MO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgd2hpbGUgKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcbiAgICAgICAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cblxuICAgICAgICAgICAgaWYgKGJ5U2V0KSB7XG4gICAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcbiAgICAgICAgICAgICAgaWYgKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZENvdW50LS07XG4gICAgICAgICAgICAgIH0gLy8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXG5cbiAgICAgICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuICAgICAgICAgIC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cblxuICAgICAgICAgIG1hdGNoZWRDb3VudCArPSBpOyAvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcbiAgICAgICAgICAvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG4gICAgICAgICAgLy8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG4gICAgICAgICAgLy8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cbiAgICAgICAgICAvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG4gICAgICAgICAgLy8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG4gICAgICAgICAgLy8gbnVtZXJpY2FsbHkgemVyby5cblxuICAgICAgICAgIGlmIChieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQpIHtcbiAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcih1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWVkKSB7XG4gICAgICAgICAgICAgIC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXG5cbiAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IGNvbmRlbnNlKHNldE1hdGNoZWQpO1xuICAgICAgICAgICAgfSAvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cblxuICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzZXRNYXRjaGVkKTsgLy8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cbiAgICAgICAgICAgIGlmIChvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgU2l6emxlLnVuaXF1ZVNvcnQocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblxuXG4gICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG4gICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdW5tYXRjaGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBieVNldCA/IG1hcmtGdW5jdGlvbihzdXBlck1hdGNoZXIpIDogc3VwZXJNYXRjaGVyO1xuICAgICAgfVxuXG4gICAgICBjb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG1hdGNoXG4gICAgICAvKiBJbnRlcm5hbCBVc2UgT25seSAqL1xuICAgICAgKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuICAgICAgICAgICAgY2FjaGVkID0gY29tcGlsZXJDYWNoZVtzZWxlY3RvciArIFwiIFwiXTtcblxuICAgICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAgIC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIG1hdGNoID0gdG9rZW5pemUoc2VsZWN0b3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgPSBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyhtYXRjaFtpXSk7XG5cbiAgICAgICAgICAgIGlmIChjYWNoZWRbZXhwYW5kb10pIHtcbiAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXG5cbiAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlKHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykpOyAvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblxuICAgICAgICAgIGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAgICAgICAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gICAgICAgKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICAgKi9cblxuXG4gICAgICBzZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZmluZCxcbiAgICAgICAgICAgIGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG4gICAgICAgICAgICBtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpO1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTsgLy8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcbiAgICAgICAgLy8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICAgIHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoMCk7XG5cbiAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlW3Rva2Vuc1sxXS50eXBlXSkge1xuICAgICAgICAgICAgY29udGV4dCA9IChFeHByLmZpbmRbXCJJRFwiXSh0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0KSB8fCBbXSlbMF07XG5cbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0czsgLy8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21waWxlZCkge1xuICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgfSAvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cblxuICAgICAgICAgIGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdChzZWxlY3RvcikgPyAwIDogdG9rZW5zLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldOyAvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cbiAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlW3R5cGUgPSB0b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpbmQgPSBFeHByLmZpbmRbdHlwZV0pIHtcbiAgICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG4gICAgICAgICAgICAgIGlmIChzZWVkID0gZmluZCh0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCByc2libGluZy50ZXN0KHRva2Vuc1swXS50eXBlKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IodG9rZW5zKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2VlZCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgLy8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXG5cbiAgICAgICAgKGNvbXBpbGVkIHx8IGNvbXBpbGUoc2VsZWN0b3IsIG1hdGNoKSkoc2VlZCwgY29udGV4dCwgIWRvY3VtZW50SXNIVE1MLCByZXN1bHRzLCAhY29udGV4dCB8fCByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH07IC8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG4gICAgICAvLyBTb3J0IHN0YWJpbGl0eVxuXG5cbiAgICAgIHN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydChzb3J0T3JkZXIpLmpvaW4oXCJcIikgPT09IGV4cGFuZG87IC8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbiAgICAgIC8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cblxuICAgICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7IC8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuXG4gICAgICBzZXREb2N1bWVudCgpOyAvLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuICAgICAgLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5cbiAgICAgIHN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcbiAgICAgICAgcmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSkgJiAxO1xuICAgICAgfSk7IC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgIC8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4gICAgICAvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuXG4gICAgICBpZiAoIWFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gQUdQb2xpY3kuY3JlYXRlSFRNTChcIjxhIGhyZWY9JyMnPjwvYT5cIik7XG4gICAgICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiO1xuICAgICAgfSkpIHtcbiAgICAgICAgYWRkSGFuZGxlKFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgICBpZiAoIWlzWE1MKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAvLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5cblxuICAgICAgaWYgKCFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gQUdQb2xpY3kuY3JlYXRlSFRNTChcIjxpbnB1dC8+XCIpO1xuICAgICAgICBlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSA9PT0gXCJcIjtcbiAgICAgIH0pKSB7XG4gICAgICAgIGFkZEhhbmRsZShcInZhbHVlXCIsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBpc1hNTCkge1xuICAgICAgICAgIGlmICghaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAvLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5cblxuICAgICAgaWYgKCFhc3NlcnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xuICAgICAgfSkpIHtcbiAgICAgICAgYWRkSGFuZGxlKGJvb2xlYW5zLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgICB2YXIgdmFsO1xuXG4gICAgICAgICAgaWYgKCFpc1hNTCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1bbmFtZV0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID8gdmFsLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBFWFBPU0VcbiAgICAgIC8vIERvIG5vdCBleHBvc2UgU2l6emxlIHRvIHRoZSBnbG9iYWwgc2NvcGUgaW4gdGhlIGNhc2Ugb2YgQWRHdWFyZCBFeHRlbmRlZENzcyBidWlsZFxuXG5cbiAgICAgIHJldHVybiBTaXp6bGU7IC8vIEVYUE9TRVxuICAgIH0od2luZG93KTsgLy8+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj5cblxuICB9XG5cbiAgcmV0dXJuIFNpenpsZTtcbn07XG5cbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgQWRndWFyZCBTb2Z0d2FyZSBMdGRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgU2l6emxlIGFuZCBhZGRzIHN1cHBvcnQgZm9yIFwibWF0Y2hlcy1jc3NcIiBwc2V1ZG8gZWxlbWVudC5cbiAqL1xuXG52YXIgU3R5bGVQcm9wZXJ0eU1hdGNoZXIgPSBmdW5jdGlvbiAod2luZG93KSB7XG4gIHZhciBpc1BoYW50b20gPSAhIXdpbmRvdy5fcGhhbnRvbTtcbiAgdmFyIHVzZUZhbGxiYWNrID0gaXNQaGFudG9tICYmICEhd2luZG93LmdldE1hdGNoZWRDU1NSdWxlcztcbiAgLyoqXG4gICAqIFVucXVvdGVzIHNwZWNpZmllZCB2YWx1ZVxuICAgKiBXZWJraXQtYmFzZWQgYnJvd3NlcnMgc2luZ2xlcXVvdGVzIDxzdHJpbmc+IGNvbnRlbnQgcHJvcGVydHkgdmFsdWVzXG4gICAqIE90aGVyIGJyb3dzZXJzIGRvdWJsZXF1b3RlcyBjb250ZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG5cbiAgdmFyIHJlbW92ZUNvbnRlbnRRdW90ZXMgPSBmdW5jdGlvbiByZW1vdmVDb250ZW50UXVvdGVzKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9eKFtcIiddKShbXFxzXFxTXSopXFwxJC8sICckMicpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgZ2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlLmJpbmQod2luZG93KTtcbiAgdmFyIGdldE1hdGNoZWRDU1NSdWxlcyA9IHVzZUZhbGxiYWNrID8gd2luZG93LmdldE1hdGNoZWRDU1NSdWxlcy5iaW5kKHdpbmRvdykgOiBudWxsO1xuICAvKipcbiAgICogVGhlcmUgaXMgYW4gaXNzdWUgaW4gYnJvd3NlcnMgYmFzZWQgb24gb2xkIHdlYmtpdDpcbiAgICogZ2V0Q29tcHV0ZWRTdHlsZShlbCwgXCI6YmVmb3JlXCIpIGlzIGVtcHR5IGlmIGVsZW1lbnQgaXMgbm90IHZpc2libGUuXG4gICAqXG4gICAqIFRvIGNpcmN1bXZlbnQgdGhpcyBpc3N1ZSB3ZSB1c2UgZ2V0TWF0Y2hlZENTU1J1bGVzIGluc3RlYWQuXG4gICAqXG4gICAqIEl0IGFwcGVhcnMgdGhhdCBnZXRNYXRjaGVkQ1NTUnVsZXMgc29ydHMgdGhlIENTUyBydWxlc1xuICAgKiBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIHNwZWNpZml0aWVzIG9mIGNvcnJlc3BvbmRpbmcgc2VsZWN0b3JzLlxuICAgKiBXZSBwaWNrIHRoZSBjc3MgcnVsZSB0aGF0IGlzIGJlaW5nIGFwcGxpZWQgdG8gYW4gZWxlbWVudCBiYXNlZCBvbiB0aGlzIGFzc3VtcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50ICAgICAgIERPTSBub2RlXG4gICAqIEBwYXJhbSBwc2V1ZG9FbGVtZW50IE9wdGlvbmFsIHBzZXVkb0VsZW1lbnQgbmFtZVxuICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lICBDU1MgcHJvcGVydHkgbmFtZVxuICAgKi9cblxuICB2YXIgZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlUHJvcGVydHlWYWx1ZShlbGVtZW50LCBwc2V1ZG9FbGVtZW50LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgdmFsdWUgPSAnJztcblxuICAgIGlmICh1c2VGYWxsYmFjayAmJiBwc2V1ZG9FbGVtZW50KSB7XG4gICAgICB2YXIgY3NzUnVsZXMgPSBnZXRNYXRjaGVkQ1NTUnVsZXMoZWxlbWVudCwgcHNldWRvRWxlbWVudCkgfHwgW107XG4gICAgICB2YXIgaSA9IGNzc1J1bGVzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSA+IDAgJiYgIXZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gY3NzUnVsZXNbaV0uc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIHBzZXVkb0VsZW1lbnQpO1xuXG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgdmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSk7IC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD05MzQ0NVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdvcGFjaXR5JyAmJiB1dGlscy5pc1NhZmFyaUJyb3dzZXIpIHtcbiAgICAgICAgICB2YWx1ZSA9IChNYXRoLnJvdW5kKHBhcnNlRmxvYXQodmFsdWUpICogMTAwKSAvIDEwMCkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdjb250ZW50Jykge1xuICAgICAgdmFsdWUgPSByZW1vdmVDb250ZW50UXVvdGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiBBZGRzIHVybCBwYXJhbWV0ZXIgcXVvdGVzIGZvciBub24tcmVnZXggcGF0dGVyblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICAgKi9cblxuXG4gIHZhciBhZGRVcmxRdW90ZXMgPSBmdW5jdGlvbiBhZGRVcmxRdW90ZXMocGF0dGVybikge1xuICAgIC8vIGZvciByZWdleCBwYXR0ZXJuc1xuICAgIGlmIChwYXR0ZXJuWzBdID09PSAnLycgJiYgcGF0dGVybltwYXR0ZXJuLmxlbmd0aCAtIDFdID09PSAnLycgJiYgcGF0dGVybi5pbmRleE9mKCdcXFxcXCInKSA8IDEwKSB7XG4gICAgICAvLyBlLmcuIC9edXJsXFxcXChbYS16XXs0fTpbYS16XXs1fS9cbiAgICAgIC8vIG9yIC9edXJsXFxcXChkYXRhXFxcXDpcXFxcaW1hZ2VcXFxcL2dpZjtiYXNlNjQuKy9cbiAgICAgIHZhciByZSA9IC8oXFxeKT91cmwoXFxcXCk/XFxcXFxcKChcXHd8XFxbXFx3KS9nO1xuICAgICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZShyZSwgJyQxdXJsJDJcXFxcXFwoXFxcXFwiPyQzJyk7XG4gICAgfSAvLyBmb3Igbm9uLXJlZ2V4IHBhdHRlcm5zXG5cblxuICAgIGlmIChwYXR0ZXJuLmluZGV4T2YoJ3VybChcIicpID09PSAtMSkge1xuICAgICAgdmFyIF9yZSA9IC91cmxcXCgoLio/KVxcKS9nO1xuICAgICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZShfcmUsICd1cmwoXCIkMVwiKScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9O1xuICAvKipcbiAgICogQ2xhc3MgdGhhdCBtYXRjaGVzIGVsZW1lbnQgc3R5bGUgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIGV4cHJlc3Npb25cbiAgICogQG1lbWJlciB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQG1lbWJlciB7c3RyaW5nfSBwc2V1ZG9FbGVtZW50XG4gICAqIEBtZW1iZXIge1JlZ0V4cH0gcmVnZXhcbiAgICovXG5cblxuICB2YXIgTWF0Y2hlciA9IGZ1bmN0aW9uIE1hdGNoZXIocHJvcGVydHlGaWx0ZXIsIHBzZXVkb0VsZW1lbnQpIHtcbiAgICB0aGlzLnBzZXVkb0VsZW1lbnQgPSBwc2V1ZG9FbGVtZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpbmRleCA9IHByb3BlcnR5RmlsdGVyLmluZGV4T2YoJzonKTtcbiAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlGaWx0ZXIuc3Vic3RyaW5nKDAsIGluZGV4KS50cmltKCk7XG4gICAgICB2YXIgcGF0dGVybiA9IHByb3BlcnR5RmlsdGVyLnN1YnN0cmluZyhpbmRleCArIDEpLnRyaW0oKTtcbiAgICAgIHBhdHRlcm4gPSBhZGRVcmxRdW90ZXMocGF0dGVybik7IC8vIFVuZXNjYXBpbmcgcGF0dGVyblxuICAgICAgLy8gRm9yIG5vbi1yZWdleCBwYXR0ZXJucywgKCwpLFssXSBzaG91bGQgYmUgdW5lc2NhcGVkLCBiZWNhdXNlIHdlIHJlcXVpcmUgZXNjYXBpbmcgdGhlbSBpbiBmaWx0ZXIgcnVsZXMuXG4gICAgICAvLyBGb3IgcmVnZXggcGF0dGVybnMsIFwiLFxcIHNob3VsZCBiZSBlc2NhcGVkLCBiZWNhdXNlIHdlIG1hbnVhbGx5IGVzY2FwZSB0aG9zZSBpbiBleHRlbmRlZC1jc3Mtc2VsZWN0b3IuanMuXG5cbiAgICAgIGlmICgvXlxcLy4qXFwvJC8udGVzdChwYXR0ZXJuKSkge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxLCAtMSk7XG4gICAgICAgIHRoaXMucmVnZXggPSB1dGlscy5wc2V1ZG9BcmdUb1JlZ2V4KHBhdHRlcm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFxcXChbXFxcXCgpW1xcXVwiXSkvZywgJyQxJyk7XG4gICAgICAgIHRoaXMucmVnZXggPSB1dGlscy5jcmVhdGVVUkxSZWdleChwYXR0ZXJuKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdXRpbHMubG9nRXJyb3IoXCJTdHlsZVByb3BlcnR5TWF0Y2hlcjogaW52YWxpZCBtYXRjaCBzdHJpbmcgXCIuY29uY2F0KHByb3BlcnR5RmlsdGVyKSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRnVuY3Rpb24gdG8gY2hlY2sgaWYgZWxlbWVudCBDU1MgcHJvcGVydHkgbWF0Y2hlcyBmaWx0ZXIgcGF0dGVyblxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2tcbiAgICovXG5cblxuICBNYXRjaGVyLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMucmVnZXggfHwgIXRoaXMucHJvcGVydHlOYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgdGhpcy5wc2V1ZG9FbGVtZW50LCB0aGlzLnByb3BlcnR5TmFtZSk7XG4gICAgcmV0dXJuIHZhbHVlICYmIHRoaXMucmVnZXgudGVzdCh2YWx1ZSk7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBzZXVkby1jbGFzcyBhbmQgcmVnaXN0ZXJzIGl0IGluIFNpenpsZVxuICAgKi9cblxuXG4gIHZhciBleHRlbmRTaXp6bGUgPSBmdW5jdGlvbiBleHRlbmRTaXp6bGUoc2l6emxlKSB7XG4gICAgLy8gRmlyc3Qgb2YgYWxsIHdlIHNob3VsZCBwcmVwYXJlIFNpenpsZSBlbmdpbmVcbiAgICBzaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ21hdGNoZXMtY3NzJ10gPSBzaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAocHJvcGVydHlGaWx0ZXIpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIocHJvcGVydHlGaWx0ZXIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLm1hdGNoZXMoZWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snbWF0Y2hlcy1jc3MtYmVmb3JlJ10gPSBzaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAocHJvcGVydHlGaWx0ZXIpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIocHJvcGVydHlGaWx0ZXIsICc6YmVmb3JlJyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2hlcyhlbGVtZW50KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgc2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydtYXRjaGVzLWNzcy1hZnRlciddID0gc2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHByb3BlcnR5RmlsdGVyKSB7XG4gICAgICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKHByb3BlcnR5RmlsdGVyLCAnOmFmdGVyJyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2hlcyhlbGVtZW50KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07IC8vIEVYUE9TRVxuXG5cbiAgcmV0dXJuIHtcbiAgICBleHRlbmRTaXp6bGU6IGV4dGVuZFNpenpsZVxuICB9O1xufSh3aW5kb3cpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEFkZ3VhcmQgU29mdHdhcmUgTHRkXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBtYXRjaGVyVXRpbHMgPSB7fTtcbm1hdGNoZXJVdGlscy5NdXRhdGlvbk9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG4vKipcbiAqIFBhcnNlcyBhcmd1bWVudCBvZiBtYXRjaGVyIHBzZXVkbyAoZm9yIG1hdGNoZXMtYXR0ciBhbmQgbWF0Y2hlcy1wcm9wZXJ0eSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaGVyRmlsdGVyIGFyZ3VtZW50IG9mIHBzZXVkbyBjbGFzc1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5cbm1hdGNoZXJVdGlscy5wYXJzZU1hdGNoZXJGaWx0ZXIgPSBmdW5jdGlvbiAobWF0Y2hlckZpbHRlcikge1xuICB2YXIgRlVMTF9NQVRDSF9NQVJLRVIgPSAnXCI9XCInO1xuICB2YXIgcmF3QXJncyA9IFtdO1xuXG4gIGlmIChtYXRjaGVyRmlsdGVyLmluZGV4T2YoRlVMTF9NQVRDSF9NQVJLRVIpID09PSAtMSkge1xuICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIHBzZXVkbyBhcmdcbiAgICAvLyBlLmcuIDptYXRjaGVzLWF0dHIoXCJkYXRhLW5hbWVcIikgb3IgOm1hdGNoZXMtcHJvcGVydHkoXCJpbm5lci5wcm9wXCIpXG4gICAgLy8gU2l6emxlIHdpbGwgcGFyc2UgaXQgYW5kIGdldCByaWQgb2YgcXVvdGVzXG4gICAgLy8gc28gaXQgbWlnaHQgYmUgdmFsaWQgYXJnIGFscmVhZHkgd2l0aG91dCB0aGVtXG4gICAgcmF3QXJncy5wdXNoKG1hdGNoZXJGaWx0ZXIpO1xuICB9IGVsc2Uge1xuICAgIG1hdGNoZXJGaWx0ZXIuc3BsaXQoJz0nKS5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIGlmIChhcmdbMF0gPT09ICdcIicgJiYgYXJnW2FyZy5sZW5ndGggLSAxXSA9PT0gJ1wiJykge1xuICAgICAgICByYXdBcmdzLnB1c2goYXJnLnNsaWNlKDEsIC0xKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmF3QXJncztcbn07XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFyZ0RhdGFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhcmdcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNSZWdleHBcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyByYXcgbWF0Y2hlciBhcmdcbiAqIEBwYXJhbSB7c3RyaW5nfSByYXdBcmdcbiAqIEByZXR1cm5zIHtBcmdEYXRhfVxuICovXG5cblxubWF0Y2hlclV0aWxzLnBhcnNlUmF3TWF0Y2hlckFyZyA9IGZ1bmN0aW9uIChyYXdBcmcpIHtcbiAgdmFyIGFyZyA9IHJhd0FyZztcbiAgdmFyIGlzUmVnZXhwID0gISFyYXdBcmcgJiYgcmF3QXJnWzBdID09PSAnLycgJiYgcmF3QXJnW3Jhd0FyZy5sZW5ndGggLSAxXSA9PT0gJy8nO1xuXG4gIGlmIChpc1JlZ2V4cCkge1xuICAgIC8vIHRvIGF2b2lkIGF0IGxlYXN0IHN1Y2ggY2FzZSDigJQgOm1hdGNoZXMtcHJvcGVydHkoXCIvL1wiKVxuICAgIGlmIChyYXdBcmcubGVuZ3RoID4gMikge1xuICAgICAgYXJnID0gdXRpbHMudG9SZWdFeHAocmF3QXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWdleHA6IFwiLmNvbmNhdChyYXdBcmcpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFyZzogYXJnLFxuICAgIGlzUmVnZXhwOiBpc1JlZ2V4cFxuICB9O1xufTtcbi8qKlxuICogQHR5cGVkZWYgQ2hhaW5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBiYXNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJvcFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3BlcnR5IGV4aXN0cyBpbiB0aGUgYmFzZSBvYmplY3QgKHJlY3Vyc2l2ZWx5KS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBiYXNlXG4gKiBAcGFyYW0ge0FyZ0RhdGFbXX0gY2hhaW4gYXJyYXkgb2Ygb2JqZWN0cyAtIHBhcnNlZCBzdHJpbmcgcHJvcGVydHkgY2hhaW5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvdXRwdXQ9W11dIHJlc3VsdCBhY2NcbiAqIEByZXR1cm5zIHtDaGFpbltdfSBhcnJheSBvZiBvYmplY3RzXG4gKi9cblxuXG5tYXRjaGVyVXRpbHMuZmlsdGVyUm9vdHNCeVJlZ2V4cENoYWluID0gZnVuY3Rpb24gKGJhc2UsIGNoYWluKSB7XG4gIHZhciBvdXRwdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICB2YXIgdGVtcFByb3AgPSBjaGFpblswXTtcblxuICBpZiAoY2hhaW4ubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgZm9yICh2YXIga2V5IGluIGJhc2UpIHtcbiAgICAgIGlmICh0ZW1wUHJvcC5pc1JlZ2V4cCkge1xuICAgICAgICBpZiAodGVtcFByb3AuYXJnLnRlc3Qoa2V5KSkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHtcbiAgICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgICBwcm9wOiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogYmFzZVtrZXldXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcFByb3AuYXJnID09PSBrZXkpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goe1xuICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgcHJvcDogdGVtcFByb3AuYXJnLFxuICAgICAgICAgIHZhbHVlOiBiYXNlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSAvLyBpZiB0aGVyZSBpcyBhIHJlZ2V4cCBwcm9wIGluIGlucHV0IGNoYWluXG4gIC8vIGUuZy4gJ3VuaXQuL15hZC4rLy5zcmMnIGZvciAndW5pdC5hZC0xZ2YyLnNyYyB1bml0LmFkLWZnZDM0LnNyYycpLFxuICAvLyBldmVyeSBiYXNlIGtleXMgc2hvdWxkIGJlIHRlc3RlZCBieSByZWdleHAgYW5kIGl0IGNhbiBiZSBtb3JlIHRoYXQgb25lIHJlc3VsdHNcblxuXG4gIGlmICh0ZW1wUHJvcC5pc1JlZ2V4cCkge1xuICAgIHZhciBuZXh0UHJvcCA9IGNoYWluLnNsaWNlKDEpO1xuICAgIHZhciBiYXNlS2V5cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblxuICAgIGZvciAodmFyIF9rZXkgaW4gYmFzZSkge1xuICAgICAgaWYgKHRlbXBQcm9wLmFyZy50ZXN0KF9rZXkpKSB7XG4gICAgICAgIGJhc2VLZXlzLnB1c2goX2tleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmFzZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgaXRlbSA9IGJhc2Vba2V5XTtcbiAgICAgIG1hdGNoZXJVdGlscy5maWx0ZXJSb290c0J5UmVnZXhwQ2hhaW4oaXRlbSwgbmV4dFByb3AsIG91dHB1dCk7XG4gICAgfSk7XG4gIH0gLy8gYXZvaWQgVHlwZUVycm9yIHdoaWxlIGFjY2Vzc2luZyB0byBudWxsLXByb3AncyBjaGlsZFxuXG5cbiAgaWYgKGJhc2UgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV4dEJhc2UgPSBiYXNlW3RlbXBQcm9wLmFyZ107XG4gIGNoYWluID0gY2hhaW4uc2xpY2UoMSk7XG5cbiAgaWYgKG5leHRCYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtYXRjaGVyVXRpbHMuZmlsdGVyUm9vdHNCeVJlZ2V4cENoYWluKG5leHRCYXNlLCBjaGFpbiwgb3V0cHV0KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgcGFyc2VkIGFyZ3Mgb2YgbWF0Y2hlcy1wcm9wZXJ0eSBwc2V1ZG9cbiAqIEBwYXJhbSB7Li4uQXJnRGF0YX0gYXJnc1xuICovXG5cblxubWF0Y2hlclV0aWxzLnZhbGlkYXRlUHJvcE1hdGNoZXJBcmdzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW47IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJnc1tpXS5pc1JlZ2V4cCkge1xuICAgICAgaWYgKCF1dGlscy5zdGFydHNXaXRoKGFyZ3NbaV0uYXJnLnRvU3RyaW5nKCksICcvJykgfHwgIXV0aWxzLmVuZHNXaXRoKGFyZ3NbaV0uYXJnLnRvU3RyaW5nKCksICcvJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBzaW1wbGUgYXJnIGNoZWNrIGlmIGl0IGlzIG5vdCBhIHJlZ2V4cFxuXG4gICAgfSBlbHNlIGlmICghL15bXFx3LV0rJC8udGVzdChhcmdzW2ldLmFyZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIFNpenpsZSBhbmQgYWRkcyBzdXBwb3J0IGZvciBcIm1hdGNoZXMtYXR0clwiIHBzZXVkbyBlbGVtZW50LlxuICovXG5cbnZhciBBdHRyaWJ1dGVzTWF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENsYXNzIHRoYXQgbWF0Y2hlcyBlbGVtZW50IGF0dHJpYnV0ZXMgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIGV4cHJlc3Npb25zXG4gICAqIEBwYXJhbSB7QXJnRGF0YX0gbmFtZUFyZyAtIHBhcnNlZCBuYW1lIGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7QXJnRGF0YX0gdmFsdWVBcmcgLSBwYXJzZWQgdmFsdWUgYXJndW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBzZXVkb0VsZW1lbnRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBtZW1iZXIge3N0cmluZ3xSZWdFeHB9IGF0dHJOYW1lXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59IGlzUmVnZXhwTmFtZVxuICAgKiBAbWVtYmVyIHtzdHJpbmd8UmVnRXhwfSBhdHRyVmFsdWVcbiAgICogQG1lbWJlciB7Ym9vbGVhbn0gaXNSZWdleHBWYWx1ZVxuICAgKi9cbiAgdmFyIEF0dHJNYXRjaGVyID0gZnVuY3Rpb24gQXR0ck1hdGNoZXIobmFtZUFyZywgdmFsdWVBcmcsIHBzZXVkb0VsZW1lbnQpIHtcbiAgICB0aGlzLnBzZXVkb0VsZW1lbnQgPSBwc2V1ZG9FbGVtZW50O1xuICAgIHRoaXMuYXR0ck5hbWUgPSBuYW1lQXJnLmFyZztcbiAgICB0aGlzLmlzUmVnZXhwTmFtZSA9IG5hbWVBcmcuaXNSZWdleHA7XG4gICAgdGhpcy5hdHRyVmFsdWUgPSB2YWx1ZUFyZy5hcmc7XG4gICAgdGhpcy5pc1JlZ2V4cFZhbHVlID0gdmFsdWVBcmcuaXNSZWdleHA7XG4gIH07XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBjaGVjayBpZiBlbGVtZW50IGF0dHJpYnV0ZXMgbWF0Y2hlcyBmaWx0ZXIgcGF0dGVyblxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2tcbiAgICovXG5cblxuICBBdHRyTWF0Y2hlci5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGVsQXR0cnMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cbiAgICBpZiAoZWxBdHRycy5sZW5ndGggPT09IDAgfHwgIXRoaXMuYXR0ck5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGVsQXR0cnMubGVuZ3RoKSB7XG4gICAgICB2YXIgYXR0ciA9IGVsQXR0cnNbaV07XG4gICAgICB2YXIgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgdmFyIGF0dHJOYW1lTWF0Y2hlZCA9IHRoaXMuaXNSZWdleHBOYW1lID8gdGhpcy5hdHRyTmFtZS50ZXN0KGF0dHIubmFtZSkgOiB0aGlzLmF0dHJOYW1lID09PSBhdHRyLm5hbWU7XG5cbiAgICAgIGlmICghdGhpcy5hdHRyVmFsdWUpIHtcbiAgICAgICAgLy8gZm9yIDptYXRjaGVzLWF0dHIoXCIvcmVnZXgvXCIpIG9yIDptYXRjaGVzLWF0dHIoXCJhdHRyLW5hbWVcIilcbiAgICAgICAgbWF0Y2hlZCA9IGF0dHJOYW1lTWF0Y2hlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyVmFsdWVNYXRjaGVkID0gdGhpcy5pc1JlZ2V4cFZhbHVlID8gdGhpcy5hdHRyVmFsdWUudGVzdChhdHRyLnZhbHVlKSA6IHRoaXMuYXR0clZhbHVlID09PSBhdHRyLnZhbHVlO1xuICAgICAgICBtYXRjaGVkID0gYXR0ck5hbWVNYXRjaGVkICYmIGF0dHJWYWx1ZU1hdGNoZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwc2V1ZG8tY2xhc3MgYW5kIHJlZ2lzdGVycyBpdCBpbiBTaXp6bGVcbiAgICovXG5cblxuICB2YXIgZXh0ZW5kU2l6emxlID0gZnVuY3Rpb24gZXh0ZW5kU2l6emxlKHNpenpsZSkge1xuICAgIC8vIEZpcnN0IG9mIGFsbCB3ZSBzaG91bGQgcHJlcGFyZSBTaXp6bGUgZW5naW5lXG4gICAgc2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydtYXRjaGVzLWF0dHInXSA9IHNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChhdHRyRmlsdGVyKSB7XG4gICAgICB2YXIgX21hdGNoZXJVdGlscyRwYXJzZU1hID0gbWF0Y2hlclV0aWxzLnBhcnNlTWF0Y2hlckZpbHRlcihhdHRyRmlsdGVyKSxcbiAgICAgICAgICBfbWF0Y2hlclV0aWxzJHBhcnNlTWEyID0gX3NsaWNlZFRvQXJyYXkoX21hdGNoZXJVdGlscyRwYXJzZU1hLCAyKSxcbiAgICAgICAgICByYXdOYW1lID0gX21hdGNoZXJVdGlscyRwYXJzZU1hMlswXSxcbiAgICAgICAgICByYXdWYWx1ZSA9IF9tYXRjaGVyVXRpbHMkcGFyc2VNYTJbMV07XG5cbiAgICAgIHZhciBuYW1lQXJnID0gbWF0Y2hlclV0aWxzLnBhcnNlUmF3TWF0Y2hlckFyZyhyYXdOYW1lKTtcbiAgICAgIHZhciB2YWx1ZUFyZyA9IG1hdGNoZXJVdGlscy5wYXJzZVJhd01hdGNoZXJBcmcocmF3VmFsdWUpO1xuXG4gICAgICBpZiAoIWF0dHJGaWx0ZXIgfHwgIW1hdGNoZXJVdGlscy52YWxpZGF0ZVByb3BNYXRjaGVyQXJncyhuYW1lQXJnLCB2YWx1ZUFyZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBvZiA6bWF0Y2hlcy1hdHRyIHBzZXVkbyBjbGFzczogXCIuY29uY2F0KGF0dHJGaWx0ZXIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgQXR0ck1hdGNoZXIobmFtZUFyZywgdmFsdWVBcmcpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLm1hdGNoZXMoZWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9OyAvLyBFWFBPU0VcblxuXG4gIHJldHVybiB7XG4gICAgZXh0ZW5kU2l6emxlOiBleHRlbmRTaXp6bGVcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBQYXJzZXMgcmF3IHByb3BlcnR5IGFyZ1xuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcmV0dXJucyB7QXJnRGF0YVtdfSBhcnJheSBvZiBvYmplY3RzXG4gKi9cblxudmFyIHBhcnNlUmF3UHJvcENoYWluID0gZnVuY3Rpb24gcGFyc2VSYXdQcm9wQ2hhaW4oaW5wdXQpIHtcbiAgdmFyIFBST1BTX0RJVklERVIgPSAnLic7XG4gIHZhciBSRUdFWFBfTUFSS0VSID0gJy8nO1xuICB2YXIgcHJvcHNBcnIgPSBbXTtcbiAgdmFyIHN0ciA9IGlucHV0O1xuXG4gIHdoaWxlIChzdHIubGVuZ3RoID4gMCkge1xuICAgIGlmICh1dGlscy5zdGFydHNXaXRoKHN0ciwgUFJPUFNfRElWSURFUikpIHtcbiAgICAgIC8vIGZvciBjYXNlcyBsaWtlICcucHJvcC5pZCcgYW5kICduZXN0ZWQuLnRlc3QnXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYWluIHByb3BlcnR5OiBcIi5jb25jYXQoaW5wdXQpKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWxzLnN0YXJ0c1dpdGgoc3RyLCBSRUdFWFBfTUFSS0VSKSkge1xuICAgICAgdmFyIGlzUmVnZXhwID0gZmFsc2U7XG4gICAgICB2YXIgZGl2aWRlckluZGV4ID0gc3RyLmluZGV4T2YoUFJPUFNfRElWSURFUik7XG5cbiAgICAgIGlmIChzdHIuaW5kZXhPZihQUk9QU19ESVZJREVSKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gJy4nIGxlZnQgaW4gc3RyXG4gICAgICAgIC8vIHRha2UgdGhlIHJlc3Qgb2Ygc3RyIGFzIHByb3BcbiAgICAgICAgcHJvcHNBcnIucHVzaCh7XG4gICAgICAgICAgYXJnOiBzdHIsXG4gICAgICAgICAgaXNSZWdleHA6IGlzUmVnZXhwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvcHNBcnI7XG4gICAgICB9IC8vIGVsc2UgdGFrZSBwcm9wIGZyb20gc3RyXG5cblxuICAgICAgdmFyIHByb3AgPSBzdHIuc2xpY2UoMCwgZGl2aWRlckluZGV4KTsgLy8gZm9yIGNhc2VzIGxpa2UgJ2FzYWRmLj8rLy50ZXN0J1xuXG4gICAgICBpZiAocHJvcC5pbmRleE9mKFJFR0VYUF9NQVJLRVIpID4gLTEpIHtcbiAgICAgICAgLy8gcHJvcCBpcyAnPysvJ1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYWluIHByb3BlcnR5OiBcIi5jb25jYXQocHJvcCkpO1xuICAgICAgfVxuXG4gICAgICBwcm9wc0Fyci5wdXNoKHtcbiAgICAgICAgYXJnOiBwcm9wLFxuICAgICAgICBpc1JlZ2V4cDogaXNSZWdleHBcbiAgICAgIH0pOyAvLyBkZWxldGUgcHJvcCBmcm9tIHN0clxuXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoZGl2aWRlckluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVhbCB3aXRoIHJlZ2V4cFxuICAgICAgdmFyIHByb3BDaHVua3MgPSBbXTtcbiAgICAgIHByb3BDaHVua3MucHVzaChzdHIuc2xpY2UoMCwgMSkpOyAvLyBpZiBzdHIgc3RhcnRzIHdpdGggJy8nLCBkZWxldGUgaXQgZnJvbSBzdHIgYW5kIGZpbmQgY2xvc2luZyByZWdleHAgc2xhc2guXG4gICAgICAvLyBub3RlIHRoYXQgY2hhaW5lZCBwcm9wZXJ0eSBuYW1lIGNhbiBub3QgaW5jbHVkZSAnLycgb3IgJy4nXG4gICAgICAvLyBzbyB0aGVyZSBpcyBubyBjaGVja2luZyBmb3IgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbiAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgICAgIHZhciByZWdleEVuZEluZGV4ID0gc3RyLmluZGV4T2YoUkVHRVhQX01BUktFUik7XG5cbiAgICAgIGlmIChyZWdleEVuZEluZGV4IDwgMSkge1xuICAgICAgICAvLyByZWdleHAgc2hvdWxkIGJlIGF0IGxlYXN0ID09PSAnLy4vJ1xuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgYXZvaWQgYXJncyBsaWtlICcvaWQnIGFuZCAndGVzdC4vLy5pZCdcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZWdleHA6IFwiLmNvbmNhdChSRUdFWFBfTUFSS0VSKS5jb25jYXQoc3RyKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXNSZWdleHAgPSB0cnVlOyAvLyB0YWtlIHRoZSByZXN0IHJlZ2V4cCBwYXJ0XG5cbiAgICAgIHByb3BDaHVua3MucHVzaChzdHIuc2xpY2UoMCwgcmVnZXhFbmRJbmRleCArIDEpKTtcblxuICAgICAgdmFyIF9wcm9wID0gdXRpbHMudG9SZWdFeHAocHJvcENodW5rcy5qb2luKCcnKSk7XG5cbiAgICAgIHByb3BzQXJyLnB1c2goe1xuICAgICAgICBhcmc6IF9wcm9wLFxuICAgICAgICBpc1JlZ2V4cDogX2lzUmVnZXhwXG4gICAgICB9KTsgLy8gZGVsZXRlIHByb3AgZnJvbSBzdHJcblxuICAgICAgc3RyID0gc3RyLnNsaWNlKHJlZ2V4RW5kSW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICBpZiAoIXN0cikge1xuICAgICAgcmV0dXJuIHByb3BzQXJyO1xuICAgIH0gLy8gc3RyIHNob3VsZCBiZSBsaWtlICcubmV4dFByb3AnIG5vd1xuICAgIC8vIHNvICd6eC5wcm9wJyBvciAnLicgaXMgaW52YWxpZFxuXG5cbiAgICBpZiAoIXV0aWxzLnN0YXJ0c1dpdGgoc3RyLCBQUk9QU19ESVZJREVSKSB8fCB1dGlscy5zdGFydHNXaXRoKHN0ciwgUFJPUFNfRElWSURFUikgJiYgc3RyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFpbiBwcm9wZXJ0eTogXCIuY29uY2F0KGlucHV0KSk7XG4gICAgfVxuXG4gICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICB9XG59O1xuXG52YXIgY29udmVydFR5cGVGcm9tU3RyID0gZnVuY3Rpb24gY29udmVydFR5cGVGcm9tU3RyKHZhbHVlKSB7XG4gIHZhciBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gIHZhciBvdXRwdXQ7XG5cbiAgaWYgKCFOdW1iZXIuaXNOYU4obnVtVmFsdWUpKSB7XG4gICAgb3V0cHV0ID0gbnVtVmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgIG91dHB1dCA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgb3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgb3V0cHV0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvdXRwdXQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxudmFyIGNvbnZlcnRUeXBlSW50b1N0ciA9IGZ1bmN0aW9uIGNvbnZlcnRUeXBlSW50b1N0cih2YWx1ZSkge1xuICB2YXIgb3V0cHV0O1xuXG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIG91dHB1dCA9ICd1bmRlZmluZWQnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIG51bGw6XG4gICAgICBvdXRwdXQgPSAnbnVsbCc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvdXRwdXQgPSB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyBTaXp6bGUgYW5kIGFkZHMgc3VwcG9ydCBmb3IgXCJtYXRjaGVzLXByb3BlcnR5XCIgcHNldWRvIGVsZW1lbnQuXG4gKi9cblxuXG52YXIgRWxlbWVudFByb3BlcnR5TWF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENsYXNzIHRoYXQgbWF0Y2hlcyBlbGVtZW50IHByb3BlcnRpZXMgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIGV4cHJlc3Npb25zXG4gICAqIEBwYXJhbSB7QXJnRGF0YVtdfSBwcm9wc0NoYWluQXJnIC0gYXJyYXkgb2YgcGFyc2VkIHByb3BzIGNoYWluIG9iamVjdHNcbiAgICogQHBhcmFtIHtBcmdEYXRhfSB2YWx1ZUFyZyAtIHBhcnNlZCB2YWx1ZSBhcmd1bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHNldWRvRWxlbWVudFxuICAgKiBAY29uc3RydWN0b3JcbiAgICpcbiAgICogQG1lbWJlciB7QXJyYXl9IGNoYWluZWRQcm9wc1xuICAgKiBAbWVtYmVyIHtib29sZWFufSBpc1JlZ2V4cE5hbWVcbiAgICogQG1lbWJlciB7c3RyaW5nfFJlZ0V4cH0gcHJvcFZhbHVlXG4gICAqIEBtZW1iZXIge2Jvb2xlYW59IGlzUmVnZXhwVmFsdWVcbiAgICovXG4gIHZhciBQcm9wTWF0Y2hlciA9IGZ1bmN0aW9uIFByb3BNYXRjaGVyKHByb3BzQ2hhaW5BcmcsIHZhbHVlQXJnLCBwc2V1ZG9FbGVtZW50KSB7XG4gICAgdGhpcy5wc2V1ZG9FbGVtZW50ID0gcHNldWRvRWxlbWVudDtcbiAgICB0aGlzLmNoYWluZWRQcm9wcyA9IHByb3BzQ2hhaW5Bcmc7XG4gICAgdGhpcy5wcm9wVmFsdWUgPSB2YWx1ZUFyZy5hcmc7XG4gICAgdGhpcy5pc1JlZ2V4cFZhbHVlID0gdmFsdWVBcmcuaXNSZWdleHA7XG4gIH07XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBjaGVjayBpZiBlbGVtZW50IHByb3BlcnRpZXMgbWF0Y2hlcyBmaWx0ZXIgcGF0dGVyblxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2tcbiAgICovXG5cblxuICBQcm9wTWF0Y2hlci5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIG93bmVyT2JqQXJyID0gbWF0Y2hlclV0aWxzLmZpbHRlclJvb3RzQnlSZWdleHBDaGFpbihlbGVtZW50LCB0aGlzLmNoYWluZWRQcm9wcyk7XG5cbiAgICBpZiAob3duZXJPYmpBcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMucHJvcFZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG93bmVyT2JqQXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciByZWFsVmFsdWUgPSBvd25lck9iakFycltpXS52YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5pc1JlZ2V4cFZhbHVlKSB7XG4gICAgICAgICAgbWF0Y2hlZCA9IHRoaXMucHJvcFZhbHVlLnRlc3QoY29udmVydFR5cGVJbnRvU3RyKHJlYWxWYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGhhbmRsZSAnbnVsbCcgYW5kICd1bmRlZmluZWQnIHByb3BlcnR5IHZhbHVlcyBzZXQgYXMgc3RyaW5nXG4gICAgICAgICAgaWYgKHJlYWxWYWx1ZSA9PT0gJ251bGwnIHx8IHJlYWxWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1hdGNoZWQgPSB0aGlzLnByb3BWYWx1ZSA9PT0gcmVhbFZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF0Y2hlZCA9IGNvbnZlcnRUeXBlRnJvbVN0cih0aGlzLnByb3BWYWx1ZSkgPT09IHJlYWxWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcHNldWRvLWNsYXNzIGFuZCByZWdpc3RlcnMgaXQgaW4gU2l6emxlXG4gICAqL1xuXG5cbiAgdmFyIGV4dGVuZFNpenpsZSA9IGZ1bmN0aW9uIGV4dGVuZFNpenpsZShzaXp6bGUpIHtcbiAgICAvLyBGaXJzdCBvZiBhbGwgd2Ugc2hvdWxkIHByZXBhcmUgU2l6emxlIGVuZ2luZVxuICAgIHNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snbWF0Y2hlcy1wcm9wZXJ0eSddID0gc2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHByb3BlcnR5RmlsdGVyKSB7XG4gICAgICBpZiAoIXByb3BlcnR5RmlsdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXJndW1lbnQgaXMgZ2l2ZW4gZm9yIDptYXRjaGVzLXByb3BlcnR5IHBzZXVkbyBjbGFzcycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX21hdGNoZXJVdGlscyRwYXJzZU1hID0gbWF0Y2hlclV0aWxzLnBhcnNlTWF0Y2hlckZpbHRlcihwcm9wZXJ0eUZpbHRlciksXG4gICAgICAgICAgX21hdGNoZXJVdGlscyRwYXJzZU1hMiA9IF9zbGljZWRUb0FycmF5KF9tYXRjaGVyVXRpbHMkcGFyc2VNYSwgMiksXG4gICAgICAgICAgcmF3UHJvcCA9IF9tYXRjaGVyVXRpbHMkcGFyc2VNYTJbMF0sXG4gICAgICAgICAgcmF3VmFsdWUgPSBfbWF0Y2hlclV0aWxzJHBhcnNlTWEyWzFdOyAvLyBjaGFpbmVkIHByb3BlcnR5IG5hbWUgY2FuIG5vdCBpbmNsdWRlICcvJyBvciAnLidcbiAgICAgIC8vIHNvIHJlZ2V4IHByb3AgbmFtZXMgd2l0aCBzdWNoIGVzY2FwZWQgY2hhcmFjdGVycyBhcmUgaW52YWxpZFxuXG5cbiAgICAgIGlmIChyYXdQcm9wLmluZGV4T2YoJ1xcXFwvJykgPiAtMSB8fCByYXdQcm9wLmluZGV4T2YoJ1xcXFwuJykgPiAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWU6IFwiLmNvbmNhdChyYXdQcm9wKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc0NoYWluQXJnID0gcGFyc2VSYXdQcm9wQ2hhaW4ocmF3UHJvcCk7XG4gICAgICB2YXIgdmFsdWVBcmcgPSBtYXRjaGVyVXRpbHMucGFyc2VSYXdNYXRjaGVyQXJnKHJhd1ZhbHVlKTtcbiAgICAgIHZhciBwcm9wc1RvVmFsaWRhdGUgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHByb3BzQ2hhaW5BcmcpLCBbdmFsdWVBcmddKTtcblxuICAgICAgaWYgKCFtYXRjaGVyVXRpbHMudmFsaWRhdGVQcm9wTWF0Y2hlckFyZ3MocHJvcHNUb1ZhbGlkYXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDptYXRjaGVzLXByb3BlcnR5IHBzZXVkbyBjbGFzczogXCIuY29uY2F0KHByb3BlcnR5RmlsdGVyKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVyID0gbmV3IFByb3BNYXRjaGVyKHByb3BzQ2hhaW5BcmcsIHZhbHVlQXJnKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlci5tYXRjaGVzKGVsZW1lbnQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTsgLy8gRVhQT1NFXG5cblxuICByZXR1cm4ge1xuICAgIGV4dGVuZFNpenpsZTogZXh0ZW5kU2l6emxlXG4gIH07XG59KCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjAgQWRndWFyZCBTb2Z0d2FyZSBMdGRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDbGFzcyB0aGF0IGV4dGVuZHMgU2l6emxlIGFuZCBhZGRzIHN1cHBvcnQgZm9yIDppcygpIHBzZXVkbyBlbGVtZW50LlxuICovXG5cbnZhciBJc0FueU1hdGNoZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDbGFzcyB0aGF0IG1hdGNoZXMgZWxlbWVudCBieSBvbmUgb2YgdGhlIHNlbGVjdG9yc1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvOmlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdG9yc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcHNldWRvRWxlbWVudFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIHZhciBJc01hdGNoZXIgPSBmdW5jdGlvbiBJc01hdGNoZXIoc2VsZWN0b3JzLCBwc2V1ZG9FbGVtZW50KSB7XG4gICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgdGhpcy5wc2V1ZG9FbGVtZW50ID0gcHNldWRvRWxlbWVudDtcbiAgfTtcbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIGVsZW1lbnQgY2FuIGJlIG1hdGNoZWQgYnkgYW55IHBhc3NlZCBzZWxlY3RvclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2tcbiAgICovXG5cblxuICBJc01hdGNoZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBpc01hdGNoZWQgPSAhIXRoaXMuc2VsZWN0b3JzLmZpbmQoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKG5vZGVzKS5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzTWF0Y2hlZDtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcHNldWRvLWNsYXNzIGFuZCByZWdpc3RlcnMgaXQgaW4gU2l6emxlXG4gICAqL1xuXG5cbiAgdmFyIGV4dGVuZFNpenpsZSA9IGZ1bmN0aW9uIGV4dGVuZFNpenpsZShzaXp6bGUpIHtcbiAgICAvLyBGaXJzdCBvZiBhbGwgd2Ugc2hvdWxkIHByZXBhcmUgU2l6emxlIGVuZ2luZVxuICAgIHNpenpsZS5zZWxlY3RvcnMucHNldWRvc1snaXMnXSA9IHNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDppcyBwc2V1ZG8tY2xhc3M6IFwiLmNvbmNhdChpbnB1dCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZWN0b3JzID0gaW5wdXQuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMudHJpbSgpO1xuICAgICAgfSk7IC8vIGNvbGxlY3QgdmFsaWQgc2VsZWN0b3JzIGFuZCBsb2cgYWJvdXQgaW52YWxpZCBvbmVzXG5cbiAgICAgIHZhciB2YWxpZFNlbGVjdG9ycyA9IHNlbGVjdG9ycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGNzc1V0aWxzLmlzU2ltcGxlU2VsZWN0b3JWYWxpZChzZWxlY3RvcikpIHtcbiAgICAgICAgICBhY2MucHVzaChzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXRpbHMubG9nSW5mbyhcIkludmFsaWQgc2VsZWN0b3IgcGFzc2VkIHRvIDppcygpIHBzZXVkby1jbGFzczogJ1wiLmNvbmNhdChzZWxlY3RvciwgXCInXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgbWF0Y2hlciA9IG5ldyBJc01hdGNoZXIodmFsaWRTZWxlY3RvcnMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLm1hdGNoZXMoZWxlbWVudCk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZXh0ZW5kU2l6emxlOiBleHRlbmRTaXp6bGVcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBBZGd1YXJkIFNvZnR3YXJlIEx0ZFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEV4dGVuZGVkIHNlbGVjdG9yIGZhY3RvcnkgbW9kdWxlLCBmb3IgY3JlYXRpbmcgZXh0ZW5kZWQgc2VsZWN0b3IgY2xhc3Nlcy5cbiAqXG4gKiBFeHRlbmRlZCBzZWxlY3Rpb24gY2FwYWJpbGl0aWVzIGRlc2NyaXB0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL0V4dGVuZGVkQ3NzL2Jsb2IvbWFzdGVyL1JFQURNRS5tZFxuICovXG5cbnZhciBFeHRlbmRlZFNlbGVjdG9yRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gd2hpbGUgYWRkaW5nIG5ldyBtYXJrZXJzLCBjb25zdGFudHMgaW4gb3RoZXIgQWRHdWFyZCByZXBvcyBzaG91bGQgYmUgY29ycmVjdGVkXG4gIC8vIEFkR3VhcmQgYnJvd3NlciBleHRlbnNpb24gOiBDc3NGaWx0ZXJSdWxlLlNVUFBPUlRFRF9QU0VVRE9fQ0xBU1NFUyBhbmQgQ3NzRmlsdGVyUnVsZS5FWFRFTkRFRF9DU1NfTUFSS0VSU1xuICAvLyB0c3VybGZpbHRlciwgU2FmYXJpQ29udmVydGVyTGliIDogRVhUX0NTU19QU0VVRE9fSU5ESUNBVE9SU1xuICB2YXIgUFNFVURPX0VYVEVOU0lPTlNfTUFSS0VSUyA9IFsnOmhhcycsICc6Y29udGFpbnMnLCAnOmhhcy10ZXh0JywgJzptYXRjaGVzLWNzcycsICc6LWFicC1oYXMnLCAnOi1hYnAtaGFzLXRleHQnLCAnOmlmJywgJzppZi1ub3QnLCAnOnhwYXRoJywgJzpudGgtYW5jZXN0b3InLCAnOnVwd2FyZCcsICc6cmVtb3ZlJywgJzptYXRjaGVzLWF0dHInLCAnOm1hdGNoZXMtcHJvcGVydHknLCAnOi1hYnAtY29udGFpbnMnLCAnOmlzJ107XG4gIHZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xuICB2YXIgU2l6emxlO1xuICAvKipcbiAgICogTGF6eSBpbml0aWFsaXphdGlvbiBvZiB0aGUgRXh0ZW5kZWRTZWxlY3RvckZhY3RvcnkgYW5kIG9iamVjdHMgdGhhdCBtaWdodCBiZSBuZWNlc3NhcnkgZm9yIGNyZWF0aW5nIGFuZCBhcHBseWluZyBzdHlsZXMuXG4gICAqIFRoaXMgbWV0aG9kIGV4dGVuZHMgU2l6emxlIGVuZ2luZSB0aGF0IHdlIHVzZSB1bmRlciB0aGUgaG9vZCB3aXRoIG91ciBjdXN0b20gcHNldWRvLWNsYXNzZXMuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlOyAvLyBPdXIgdmVyc2lvbiBvZiBTaXp6bGUgaXMgaW5pdGlhbGl6ZWQgbGF6aWx5IGFzIHdlbGxcblxuICAgIFNpenpsZSA9IGluaXRpYWxpemVTaXp6bGUoKTsgLy8gQWRkIDptYXRjaGVzLWNzcy0qKCkgc3VwcG9ydFxuXG4gICAgU3R5bGVQcm9wZXJ0eU1hdGNoZXIuZXh0ZW5kU2l6emxlKFNpenpsZSk7IC8vIEFkZCA6bWF0Y2hlcy1hdHRyKCkgc3VwcG9ydFxuXG4gICAgQXR0cmlidXRlc01hdGNoZXIuZXh0ZW5kU2l6emxlKFNpenpsZSk7IC8vIEFkZCA6bWF0Y2hlcy1wcm9wZXJ0eSgpIHN1cHBvcnRcblxuICAgIEVsZW1lbnRQcm9wZXJ0eU1hdGNoZXIuZXh0ZW5kU2l6emxlKFNpenpsZSk7IC8vIEFkZCA6aXMoKSBzdXBwb3J0XG5cbiAgICBJc0FueU1hdGNoZXIuZXh0ZW5kU2l6emxlKFNpenpsZSk7IC8vIEFkZCA6Y29udGFpbnMsIDpoYXMtdGV4dCwgOi1hYnAtY29udGFpbnMgc3VwcG9ydFxuXG4gICAgdmFyIGNvbnRhaW5zUHNldWRvID0gU2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIGlmICgvXlxccypcXC8uKlxcL1tnbWlzdXldKlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgdmFyIGZsYWdzSW5kZXggPSB0ZXh0Lmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIHZhciBmbGFncyA9IHRleHQuc3Vic3RyaW5nKGZsYWdzSW5kZXggKyAxKTtcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDAsIGZsYWdzSW5kZXggKyAxKS5zbGljZSgxLCAtMSkucmVwbGFjZSgvXFxcXChbXFxcXFwiXSkvZywgJyQxJyk7XG4gICAgICAgIHZhciByZWdleDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cCh0ZXh0LCBmbGFncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDpjb250YWlucyBwc2V1ZG8gY2xhc3M6IFwiLmNvbmNhdCh0ZXh0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICB2YXIgZWxlbVRleHRDb250ZW50ID0gdXRpbHMubm9kZVRleHRDb250ZW50R2V0dGVyLmFwcGx5KGVsZW0pO1xuICAgICAgICAgIHJldHVybiByZWdleC50ZXN0KGVsZW1UZXh0Q29udGVudCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcXFwoW1xcXFwoKVtcXF1cIl0pL2csICckMScpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBlbGVtVGV4dENvbnRlbnQgPSB1dGlscy5ub2RlVGV4dENvbnRlbnRHZXR0ZXIuYXBwbHkoZWxlbSk7XG4gICAgICAgIHJldHVybiBlbGVtVGV4dENvbnRlbnQuaW5kZXhPZih0ZXh0KSA+IC0xO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ2NvbnRhaW5zJ10gPSBjb250YWluc1BzZXVkbztcbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ2hhcy10ZXh0J10gPSBjb250YWluc1BzZXVkbztcbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJy1hYnAtY29udGFpbnMnXSA9IGNvbnRhaW5zUHNldWRvOyAvLyBBZGQgOmlmLCA6LWFicC1oYXMgc3VwcG9ydFxuXG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydpZiddID0gU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydoYXMnXTtcbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJy1hYnAtaGFzJ10gPSBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ2hhcyddOyAvLyBBZGQgOmlmLW5vdCBzdXBwb3J0XG5cbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ2lmLW5vdCddID0gU2l6emxlLnNlbGVjdG9ycy5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBTaXp6bGUuY29tcGlsZShzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPT09IDA7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJlZ2lzdGVyUGFyc2VyT25seVRva2VucygpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RyYXRlIGN1c3RvbSB0b2tlbnMgZm9yIHBhcnNlci5cbiAgICogTmVlZGVkIGZvciBwcm9wZXIgd29yayBvZiBwc2V1ZG9zOlxuICAgKiBmb3IgY2hlY2tpbmcgaWYgdGhlIHRva2VuIGlzIGxhc3QgYW5kIHBzZXVkby1jbGFzcyBhcmd1bWVudHMgdmFsaWRhdGlvblxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyUGFyc2VyT25seVRva2VucygpIHtcbiAgICBTaXp6bGUuc2VsZWN0b3JzLnBzZXVkb3NbJ3hwYXRoJ10gPSBTaXp6bGUuc2VsZWN0b3JzLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUV4cHJlc3Npb24oc2VsZWN0b3IsIG51bGwpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDp4cGF0aCBwc2V1ZG8gY2xhc3M6IFwiLmNvbmNhdChzZWxlY3RvcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydudGgtYW5jZXN0b3InXSA9IFNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGRlZXAgPSBOdW1iZXIoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGRlZXApIHx8IGRlZXAgPCAxIHx8IGRlZXAgPj0gMjU2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOm50aC1hbmNlc3RvciBwc2V1ZG8gY2xhc3M6IFwiLmNvbmNhdChzZWxlY3RvcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWyd1cHdhcmQnXSA9IFNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDp1cHdhcmQgcHNldWRvIGNsYXNzOiBcIi5jb25jYXQoaW5wdXQpKTtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcigraW5wdXQpICYmICgraW5wdXQgPCAxIHx8ICtpbnB1dCA+PSAyNTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnQgb2YgOnVwd2FyZCBwc2V1ZG8gY2xhc3M6IFwiLmNvbmNhdChpbnB1dCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgU2l6emxlLnNlbGVjdG9ycy5wc2V1ZG9zWydyZW1vdmUnXSA9IFNpenpsZS5zZWxlY3RvcnMuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaWYgKGlucHV0ICE9PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50IG9mIDpyZW1vdmUgcHNldWRvIGNsYXNzOiBcIi5jb25jYXQoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIHRva2VuIGNhbiBiZSB1c2VkIGJ5IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNTaW1wbGVUb2tlbih0b2tlbikge1xuICAgIHZhciB0eXBlID0gdG9rZW4udHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnSUQnIHx8IHR5cGUgPT09ICdDTEFTUycgfHwgdHlwZSA9PT0gJ0FUVFInIHx8IHR5cGUgPT09ICdUQUcnIHx8IHR5cGUgPT09ICdDSElMRCcpIHtcbiAgICAgIC8vIGtub3duIHNpbXBsZSB0b2tlbnNcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnUFNFVURPJykge1xuICAgICAgLy8gY2hlY2sgaWYgdmFsdWUgY29udGFpbnMgYW55IG9mIGV4dGVuZGVkIHBzZXVkbyBjbGFzc2VzXG4gICAgICB2YXIgaSA9IFBTRVVET19FWFRFTlNJT05TX01BUktFUlMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh0b2tlbi52YWx1ZS5pbmRleE9mKFBTRVVET19FWFRFTlNJT05TX01BUktFUlNbaV0pID49IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBhbGwgb3RoZXJzIGFyZW4ndCBzaW1wbGVcblxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgc3BlY2lmaWVkIHRva2VuIGlzIGEgY29tYmluYXRvclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzUmVsYXRpb25Ub2tlbih0b2tlbikge1xuICAgIHZhciB0eXBlID0gdG9rZW4udHlwZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJyAnIHx8IHR5cGUgPT09ICc+JyB8fCB0eXBlID09PSAnKycgfHwgdHlwZSA9PT0gJ34nO1xuICB9XG4gIC8qKlxuICAgKiBFeHRlbmRlZFNlbGVjdG9yUGFyc2VyIGlzIGEgaGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyB2YXJpb3VzIHNlbGVjdG9yIGluc3RhbmNlcyB3aGljaFxuICAgKiBhbGwgc2hhcmVzIGEgbWV0aG9kIGBxdWVyeVNlbGVjdG9yQWxsKClgIGFuZCBgbWF0Y2hlcygpYCBpbXBsZW1lbnRpbmcgZGlmZmVyZW50IHNlYXJjaCBzdHJhdGVnaWVzXG4gICAqIGRlcGVuZGluZyBvbiBhIHR5cGUgb2Ygc2VsZWN0b3IuXG4gICAqXG4gICAqIEN1cnJlbnRseSwgdGhlcmUgYXJlIDMgdHlwZXM6XG4gICAqICBBIHRyYWl0LWxlc3MgZXh0ZW5kZWQgc2VsZWN0b3JcbiAgICogICAgLSB3ZSBkaXJlY3RseSBmZWVkIHNlbGVjdG9yIHN0cmluZ3MgdG8gU2l6emxlLlxuICAgKiAgQSBzcGxpdHRlZCBleHRlbmRlZCBzZWxlY3RvclxuICAgKiAgICAtIHN1Y2ggYXMgI2NvbnRhaW5lciAjZmVlZEl0ZW06aGFzKC5hZHMpLCB3aGVyZSBpdCBpcyBzcGxpdHRlZCB0byBgI2NvbnRhaW5lcmAgYW5kIGAjZmVlZEl0ZW06aGFzKC5hZHMpYC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBFeHRlbmRlZFNlbGVjdG9yUGFyc2VyKHNlbGVjdG9yVGV4dCwgdG9rZW5zLCBkZWJ1Zykge1xuICAgIGluaXRpYWxpemUoKTtcblxuICAgIGlmICh0eXBlb2YgdG9rZW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zZWxlY3RvclRleHQgPSBjc3NVdGlscy5ub3JtYWxpemUoc2VsZWN0b3JUZXh0KTsgLy8gUGFzc2luZyBgcmV0dXJuVW5zb3J0ZWRgIGluIG9yZGVyIHRvIHJlY2VpdmUgdG9rZW5zIGluIHRoZSBvcmRlciB0aGF0J3MgdmFsaWQgZm9yIHRoZSBicm93c2VyXG4gICAgICAvLyBJbiBTaXp6bGUgaW50ZXJuYWxseSwgdGhlIHRva2VucyBhcmUgcmUtc29ydGVkOiBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vRXh0ZW5kZWRDc3MvaXNzdWVzLzU1XG5cbiAgICAgIHRoaXMudG9rZW5zID0gU2l6emxlLnRva2VuaXplKHRoaXMuc2VsZWN0b3JUZXh0LCBmYWxzZSwge1xuICAgICAgICByZXR1cm5VbnNvcnRlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0O1xuICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxuXG4gICAgaWYgKGRlYnVnID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmRlYnVnID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBFeHRlbmRlZFNlbGVjdG9yUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBtZXRob2QsIGNyZWF0ZXMgYSBzZWxlY3RvciBpbnN0YW5jZSBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYSBzZWxlY3Rvci5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY3JlYXRlU2VsZWN0b3I6IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yKCkge1xuICAgICAgdmFyIGRlYnVnID0gdGhpcy5kZWJ1ZztcbiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VucztcbiAgICAgIHZhciBzZWxlY3RvclRleHQgPSB0aGlzLnNlbGVjdG9yVGV4dDtcblxuICAgICAgaWYgKHRva2Vucy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgLy8gQ29tbWEtc2VwYXJhdGUgc2VsZWN0b3IgLSBjYW4ndCBvcHRpbWl6ZSBmdXJ0aGVyXG4gICAgICAgIHJldHVybiBuZXcgVHJhaXRMZXNzU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBkZWJ1Zyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB4cGF0aFBhcnQgPSB0aGlzLmdldFhwYXRoUGFydCgpO1xuXG4gICAgICBpZiAodHlwZW9mIHhwYXRoUGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYcGF0aFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgeHBhdGhQYXJ0LCBkZWJ1Zyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cHdhcmRQYXJ0ID0gdGhpcy5nZXRVcHdhcmRQYXJ0KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgdXB3YXJkUGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgdmFyIHVwd2FyZERlZXAgPSBwYXJzZUludCh1cHdhcmRQYXJ0LCAxMCk7IC8vIGlmIHVwd2FyZCBwYXJhbWV0ZXIgaXMgbm90IGEgbnVtYmVyLCB3ZSBjb25zaWRlciBpdCBhcyBhIHNlbGVjdG9yXG5cbiAgICAgICAgaWYgKE51bWJlci5pc05hTih1cHdhcmREZWVwKSkge1xuICAgICAgICAgIG91dHB1dCA9IG5ldyBVcHdhcmRTZWxlY3RvcihzZWxlY3RvclRleHQsIHVwd2FyZFBhcnQsIGRlYnVnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cHdhcmQgd29ya3MgbGlrZSBudGgtYW5jZXN0b3JcbiAgICAgICAgICB2YXIgeHBhdGggPSB0aGlzLmNvbnZlcnROdGhBbmNlc3RvclRva2VuKHVwd2FyZERlZXApO1xuICAgICAgICAgIG91dHB1dCA9IG5ldyBYcGF0aFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgeHBhdGgsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9IC8vIGFyZ3VtZW50IG9mIHBzZXVkby1jbGFzcyByZW1vdmU7XG4gICAgICAvLyBpdCdzIGRlZmluZWQgb25seSBpZiByZW1vdmUgaXMgcGFyc2VkIGFzIGxhc3QgdG9rZW5cbiAgICAgIC8vIGFuZCBpdCdzIHZhbGlkIG9ubHkgaWYgcmVtb3ZlIGFyZyBpcyBlbXB0eSBzdHJpbmdcblxuXG4gICAgICB2YXIgcmVtb3ZlUGFydCA9IHRoaXMuZ2V0UmVtb3ZlUGFydCgpO1xuXG4gICAgICBpZiAodHlwZW9mIHJlbW92ZVBhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBoYXNWYWxpZFJlbW92ZVBhcnQgPSByZW1vdmVQYXJ0ID09PSAnJztcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVTZWxlY3RvcihzZWxlY3RvclRleHQsIGhhc1ZhbGlkUmVtb3ZlUGFydCwgZGVidWcpO1xuICAgICAgfVxuXG4gICAgICB0b2tlbnMgPSB0b2tlbnNbMF07XG4gICAgICB2YXIgbCA9IHRva2Vucy5sZW5ndGg7XG4gICAgICB2YXIgbGFzdFJlbFRva2VuSW5kID0gdGhpcy5nZXRTcGxpdFBvaW50KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgbGFzdFJlbFRva2VuSW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JUZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVHJhaXRMZXNzU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE5vdEFuRXh0ZW5kZWRTZWxlY3RvcihzZWxlY3RvclRleHQsIGRlYnVnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbXBsZSA9ICcnO1xuICAgICAgdmFyIHJlbGF0aW9uID0gbnVsbDtcbiAgICAgIHZhciBjb21wbGV4ID0gJyc7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbGFzdFJlbFRva2VuSW5kOyBpKyspIHtcbiAgICAgICAgLy8gYnVpbGQgc2ltcGxlIHBhcnRcbiAgICAgICAgc2ltcGxlICs9IHRva2Vuc1tpXS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIC8vIGJ1aWxkIHJlbGF0aW9uIHBhcnRcbiAgICAgICAgcmVsYXRpb24gPSB0b2tlbnNbaSsrXS50eXBlO1xuICAgICAgfSAvLyBpIGlzIHBvaW50aW5nIHRvIHRoZSBzdGFydCBvZiBhIGNvbXBsZXggcGFydC5cblxuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb21wbGV4ICs9IHRva2Vuc1tpXS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhc3RSZWxUb2tlbkluZCA9PT0gLTEgPyBuZXcgVHJhaXRMZXNzU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCBkZWJ1ZykgOiBuZXcgU3BsaXR0ZWRTZWxlY3RvcihzZWxlY3RvclRleHQsIHNpbXBsZSwgcmVsYXRpb24sIGNvbXBsZXgsIGRlYnVnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBBbiBpbmRleCBvZiBhIHRva2VuIHRoYXQgaXMgc3BsaXQgcG9pbnQuXG4gICAgICogcmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIHNlbGVjdG9yIGRvZXMgbm90IGNvbnRhaW4gYW55IGNvbXBsZXggdG9rZW5zXG4gICAgICogb3IgaXQgaXMgbm90IGVsaWdpYmxlIGZvciBzcGxpdHRpbmcuXG4gICAgICogT3RoZXJ3aXNlIHJldHVybnMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBpbmRleCBvZiB0aGUgbGFzdCByZWxhdGlvbiB0b2tlbi5cbiAgICAgKi9cbiAgICBnZXRTcGxpdFBvaW50OiBmdW5jdGlvbiBnZXRTcGxpdFBvaW50KCkge1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zWzBdOyAvLyBXZSBzcGxpdCBzZWxlY3RvciBvbmx5IHdoZW4gdGhlIGxhc3QgY29tcG91bmQgc2VsZWN0b3JcbiAgICAgIC8vIGlzIHRoZSBvbmx5IGV4dGVuZGVkIHNlbGVjdG9yLlxuXG4gICAgICB2YXIgbGF0ZXN0UmVsYXRpb25Ub2tlbkluZGV4ID0gLTE7XG4gICAgICB2YXIgaGF2ZU1ldENvbXBsZXhUb2tlbiA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmIChpc1JlbGF0aW9uVG9rZW4odG9rZW4pKSB7XG4gICAgICAgICAgaWYgKGhhdmVNZXRDb21wbGV4VG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYXRlc3RSZWxhdGlvblRva2VuSW5kZXggPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc1NpbXBsZVRva2VuKHRva2VuKSkge1xuICAgICAgICAgIGhhdmVNZXRDb21wbGV4VG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGF2ZU1ldENvbXBsZXhUb2tlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXRlc3RSZWxhdGlvblRva2VuSW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0geHBhdGggc2VsZWN0b3IgcGFydCBpZiBleGlzdHNcbiAgICAgKiByZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgc2VsZWN0b3IgZG9lcyBub3QgY29udGFpbiB4cGF0aCB0b2tlbnNcbiAgICAgKi9cbiAgICBnZXRYcGF0aFBhcnQ6IGZ1bmN0aW9uIGdldFhwYXRoUGFydCgpIHtcbiAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2Vuc1swXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIHRva2Vuc0xlbmd0aCA9IHRva2Vucy5sZW5ndGg7IGkgPCB0b2tlbnNMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdQU0VVRE8nKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSB0b2tlbi5tYXRjaGVzO1xuXG4gICAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlc1swXSA9PT0gJ3hwYXRoJykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc0xhc3RUb2tlbih0b2tlbnMsIGkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBzZXVkbzogXFwnOnhwYXRoXFwnIHNob3VsZCBiZSBhdCB0aGUgZW5kIG9mIHRoZSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVzWzBdID09PSAnbnRoLWFuY2VzdG9yJykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc0xhc3RUb2tlbih0b2tlbnMsIGkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBzZXVkbzogXFwnOm50aC1hbmNlc3RvclxcJyBzaG91bGQgYmUgYXQgdGhlIGVuZCBvZiB0aGUgc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBkZWVwID0gbWF0Y2hlc1sxXTtcblxuICAgICAgICAgICAgICBpZiAoZGVlcCA+IDAgJiYgZGVlcCA8IDI1Nikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnROdGhBbmNlc3RvclRva2VuKGRlZXApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIG50aC1hbmNlc3Rvci91cHdhcmQgZGVlcCB2YWx1ZSB0byB4cGF0aCBlcXVpdmFsZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZXBcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgY29udmVydE50aEFuY2VzdG9yVG9rZW46IGZ1bmN0aW9uIGNvbnZlcnROdGhBbmNlc3RvclRva2VuKGRlZXApIHtcbiAgICAgIHZhciByZXN1bHQgPSAnLi4nO1xuXG4gICAgICB3aGlsZSAoZGVlcCA+IDEpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcvLi4nO1xuICAgICAgICBkZWVwLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgdG9rZW4gaXMgbGFzdCxcbiAgICAgKiBleGNlcHQgb2YgcmVtb3ZlIHBzZXVkby1jbGFzc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2Vuc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIGluZGV4IG9mIHRva2VuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNMYXN0VG9rZW46IGZ1bmN0aW9uIGlzTGFzdFRva2VuKHRva2VucywgaSkge1xuICAgICAgLy8gY2hlY2sgaWQgdGhlIG5leHQgcGFyc2VkIHRva2VuIGlzIHJlbW92ZSBwc2V1ZG9cbiAgICAgIHZhciBpc05leHRSZW1vdmVUb2tlbiA9IHRva2Vuc1tpICsgMV0gJiYgdG9rZW5zW2kgKyAxXS50eXBlID09PSAnUFNFVURPJyAmJiB0b2tlbnNbaSArIDFdLm1hdGNoZXMgJiYgdG9rZW5zW2kgKyAxXS5tYXRjaGVzWzBdID09PSAncmVtb3ZlJzsgLy8gY2hlY2sgaWYgdGhlIHRva2VuIGlzIGxhc3RcbiAgICAgIC8vIGFuZCBpZiBpdCBpcyBub3QgY2hlY2sgaWYgaXQgaXMgcmVtb3ZlIG9uZVxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIHNraXBwZWRcblxuICAgICAgcmV0dXJuIGkgKyAxICE9PSB0b2tlbnMubGVuZ3RoICYmICFpc05leHRSZW1vdmVUb2tlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSB1cHdhcmQgcGFyYW1ldGVyXG4gICAgICogb3IgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCBkb2VzIG5vdCBjb250YWluIHVwd2FyZCB0b2tlbnNcbiAgICAgKi9cbiAgICBnZXRVcHdhcmRQYXJ0OiBmdW5jdGlvbiBnZXRVcHdhcmRQYXJ0KCkge1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgdG9rZW5zTGVuZ3RoID0gdG9rZW5zLmxlbmd0aDsgaSA8IHRva2Vuc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ1BTRVVETycpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRva2VuLm1hdGNoZXM7XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzWzBdID09PSAndXB3YXJkJykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pc0xhc3RUb2tlbih0b2tlbnMsIGkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBzZXVkbzogXFwnOnVwd2FyZFxcJyBzaG91bGQgYmUgYXQgdGhlIGVuZCBvZiB0aGUgc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IHJlbW92ZSBwYXJhbWV0ZXJcbiAgICAgKiBvciB1bmRlZmluZWQgaWYgdGhlIGlucHV0IGRvZXMgbm90IGNvbnRhaW4gcmVtb3ZlIHRva2Vuc1xuICAgICAqL1xuICAgIGdldFJlbW92ZVBhcnQ6IGZ1bmN0aW9uIGdldFJlbW92ZVBhcnQoKSB7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnNbMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCB0b2tlbnNMZW5ndGggPSB0b2tlbnMubGVuZ3RoOyBpIDwgdG9rZW5zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnUFNFVURPJykge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gdG9rZW4ubWF0Y2hlcztcblxuICAgICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNbMF0gPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICAgIGlmIChpICsgMSAhPT0gdG9rZW5zTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBzZXVkbzogXFwnOnJlbW92ZVxcJyBzaG91bGQgYmUgYXQgdGhlIGVuZCBvZiB0aGUgc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGdsb2JhbERlYnVnZ2luZ0ZsYWcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBpc0RlYnVnZ2luZygpIHtcbiAgICByZXR1cm4gZ2xvYmFsRGVidWdnaW5nRmxhZyB8fCB0aGlzLmRlYnVnO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBzZWxlY3RvciB3aGljaCBpcyBub3QgYW4gZXh0ZW5kZWQgc2VsZWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclRleHRcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZGVidWdcbiAgICogQGZpbmFsXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gTm90QW5FeHRlbmRlZFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgZGVidWcpIHtcbiAgICB0aGlzLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDtcbiAgICB0aGlzLmRlYnVnID0gZGVidWc7XG4gIH1cblxuICBOb3RBbkV4dGVuZGVkU2VsZWN0b3IucHJvdG90eXBlID0ge1xuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwoKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9yVGV4dCk7XG4gICAgfSxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50W3V0aWxzLm1hdGNoZXNQcm9wZXJ0eU5hbWVdKHRoaXMuc2VsZWN0b3JUZXh0KTtcbiAgICB9LFxuICAgIGlzRGVidWdnaW5nOiBpc0RlYnVnZ2luZ1xuICB9O1xuICAvKipcbiAgICogQSB0cmFpdC1sZXNzIGV4dGVuZGVkIHNlbGVjdG9yIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JUZXh0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlYnVnXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBUcmFpdExlc3NTZWxlY3RvcihzZWxlY3RvclRleHQsIGRlYnVnKSB7XG4gICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnO1xuICAgIFNpenpsZS5jb21waWxlKHNlbGVjdG9yVGV4dCk7XG4gIH1cblxuICBUcmFpdExlc3NTZWxlY3Rvci5wcm90b3R5cGUgPSB7XG4gICAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbCgpIHtcbiAgICAgIHJldHVybiBTaXp6bGUodGhpcy5zZWxlY3RvclRleHQpO1xuICAgIH0sXG5cbiAgICAvKiogQGZpbmFsICovXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50KSB7XG4gICAgICByZXR1cm4gU2l6emxlLm1hdGNoZXNTZWxlY3RvcihlbGVtZW50LCB0aGlzLnNlbGVjdG9yVGV4dCk7XG4gICAgfSxcblxuICAgIC8qKiBAZmluYWwgKi9cbiAgICBpc0RlYnVnZ2luZzogaXNEZWJ1Z2dpbmdcbiAgfTtcbiAgLyoqXG4gICAqIFBhcmVudGFsIGNsYXNzIGZvciBzdWNoIHBzZXVkby1jbGFzc2VzIGFzIHhwYXRoLCB1cHdhcmQsIHJlbW92ZVxuICAgKiB3aGljaCBhcmUgbGltaXRlZCB0byBiZSB0aGUgbGFzdCBvbmUgdG9rZW4gaW4gc2VsZWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yVGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHNldWRvQ2xhc3NBcmcgcHNldWRvLWNsYXNzIGFyZ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWJ1Z1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZnVuY3Rpb24gQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgcHNldWRvQ2xhc3NBcmcsIGRlYnVnKSB7XG4gICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvclRleHQ7XG4gICAgdGhpcy5wc2V1ZG9DbGFzc0FyZyA9IHBzZXVkb0NsYXNzQXJnO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZztcbiAgICBTaXp6bGUuY29tcGlsZSh0aGlzLnNlbGVjdG9yVGV4dCk7XG4gIH1cblxuICBCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3IucHJvdG90eXBlID0ge1xuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVzdWx0Tm9kZXMgPSBbXTtcbiAgICAgIHZhciBzaW1wbGVOb2RlcztcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0b3JUZXh0KSB7XG4gICAgICAgIHNpbXBsZU5vZGVzID0gU2l6emxlKHRoaXMuc2VsZWN0b3JUZXh0KTtcblxuICAgICAgICBpZiAoIXNpbXBsZU5vZGVzIHx8ICFzaW1wbGVOb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0Tm9kZXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbXBsZU5vZGVzID0gW2RvY3VtZW50XTtcbiAgICAgIH1cblxuICAgICAgc2ltcGxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBfdGhpcy5zZWFyY2hSZXN1bHROb2Rlcyhub2RlLCBfdGhpcy5wc2V1ZG9DbGFzc0FyZywgcmVzdWx0Tm9kZXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gU2l6emxlLnVuaXF1ZVNvcnQocmVzdWx0Tm9kZXMpO1xuICAgIH0sXG5cbiAgICAvKiogQGZpbmFsICovXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50KSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IHRoaXMucXVlcnlTZWxlY3RvckFsbCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdHMuaW5kZXhPZihlbGVtZW50KSA+IC0xO1xuICAgIH0sXG5cbiAgICAvKiogQGZpbmFsICovXG4gICAgaXNEZWJ1Z2dpbmc6IGlzRGVidWdnaW5nLFxuXG4gICAgLyoqXG4gICAgICogUHJpbWl0aXZlIG1ldGhvZCB0aGF0IHJldHVybnMgYWxsIG5vZGVzIGlmIHBzZXVkby1jbGFzcyBhcmcgaXMgZGVmaW5lZC5cbiAgICAgKiBUaGF0IGxvZ2ljIHdvcmtzIGZvciByZW1vdmUgcHNldWRvLWNsYXNzLFxuICAgICAqIGJ1dCBmb3Igb3RoZXJzIGl0IHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIGNvbnRleHQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwc2V1ZG9DbGFzc0FyZyBwc2V1ZG8tY2xhc3MgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSByZXN1bHRcbiAgICAgKi9cbiAgICBzZWFyY2hSZXN1bHROb2RlczogZnVuY3Rpb24gc2VhcmNoUmVzdWx0Tm9kZXMobm9kZSwgcHNldWRvQ2xhc3NBcmcsIHJlc3VsdCkge1xuICAgICAgaWYgKHBzZXVkb0NsYXNzQXJnKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFhwYXRoIHNlbGVjdG9yIGNsYXNzXG4gICAqIExpbWl0ZWQgdG8gc3VwcG9ydCAneHBhdGgnIHRvIGJlIG9ubHkgdGhlIGxhc3Qgb25lIHRva2VuIGluIHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHhwYXRoIHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlYnVnXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAYXVnbWVudHMgQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFhwYXRoU2VsZWN0b3Ioc2VsZWN0b3JUZXh0LCB4cGF0aCwgZGVidWcpIHtcbiAgICB2YXIgTk9fU0VMRUNUT1JfTUFSS0VSID0gJzp4cGF0aCgvLyc7XG4gICAgdmFyIEJPRFlfU0VMRUNUT1JfUkVQTEFDRVIgPSAnYm9keTp4cGF0aCgvLyc7XG4gICAgdmFyIG1vZGlmaWVkU2VsZWN0b3JUZXh0ID0gc2VsZWN0b3JUZXh0OyAvLyBOb3JtYWxseSwgYSBwc2V1ZG8tY2xhc3MgaXMgYXBwbGllZCB0byBub2RlcyBzZWxlY3RlZCBieSBhIHNlbGVjdG9yIC0tIHNlbGVjdG9yOnhwYXRoKC4uLikuXG4gICAgLy8gSG93ZXZlciwgOnhwYXRoIGlzIHNwZWNpYWwgYXMgdGhlIHNlbGVjdG9yIGNhbiBiZSBvbW1pdGVkLlxuICAgIC8vIEZvciBhbnkgb3RoZXIgcHNldWRvLWNsYXNzIHRoYXQgd291bGQgbWVhbiBcImFwcGx5IHRvIEFMTCBET00gbm9kZXNcIixcbiAgICAvLyBidXQgaW4gY2FzZSBvZiA6eHBhdGggaXQganVzdCBtZWFucyBcImFwcGx5IG1lIHRvIHRoZSBkb2N1bWVudFwiLlxuXG4gICAgaWYgKHV0aWxzLnN0YXJ0c1dpdGgoc2VsZWN0b3JUZXh0LCBOT19TRUxFQ1RPUl9NQVJLRVIpKSB7XG4gICAgICBtb2RpZmllZFNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dC5yZXBsYWNlKE5PX1NFTEVDVE9SX01BUktFUiwgQk9EWV9TRUxFQ1RPUl9SRVBMQUNFUik7XG4gICAgfVxuXG4gICAgQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yLmNhbGwodGhpcywgbW9kaWZpZWRTZWxlY3RvclRleHQsIHhwYXRoLCBkZWJ1Zyk7XG4gIH1cblxuICBYcGF0aFNlbGVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yLnByb3RvdHlwZSk7XG4gIFhwYXRoU2VsZWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWHBhdGhTZWxlY3RvcjtcbiAgLyoqXG4gICAqIEFwcGxpZXMgeHBhdGggcHNldWRvLWNsYXNzIHRvIHByb3ZpZGVkIGNvbnRleHQgbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBjb250ZXh0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBzZXVkb0NsYXNzQXJnIHhwYXRoXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cbiAgWHBhdGhTZWxlY3Rvci5wcm90b3R5cGUuc2VhcmNoUmVzdWx0Tm9kZXMgPSBmdW5jdGlvbiAobm9kZSwgcHNldWRvQ2xhc3NBcmcsIHJlc3VsdCkge1xuICAgIHZhciB4cGF0aFJlc3VsdCA9IGRvY3VtZW50LmV2YWx1YXRlKHBzZXVkb0NsYXNzQXJnLCBub2RlLCBudWxsLCBYUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFLCBudWxsKTtcbiAgICB2YXIgaU5vZGU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuXG4gICAgd2hpbGUgKGlOb2RlID0geHBhdGhSZXN1bHQuaXRlcmF0ZU5leHQoKSkge1xuICAgICAgcmVzdWx0LnB1c2goaU5vZGUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFVwd2FyZCBzZWxlY3RvciBjbGFzc1xuICAgKiBMaW1pdGVkIHRvIHN1cHBvcnQgJ3Vwd2FyZCcgdG8gYmUgb25seSB0aGUgbGFzdCBvbmUgdG9rZW4gaW4gc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yVGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXB3YXJkU2VsZWN0b3IgdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZGVidWdcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhdWdtZW50cyBCYXNlTGFzdEFyZ3VtZW50U2VsZWN0b3JcbiAgICovXG5cblxuICBmdW5jdGlvbiBVcHdhcmRTZWxlY3RvcihzZWxlY3RvclRleHQsIHVwd2FyZFNlbGVjdG9yLCBkZWJ1Zykge1xuICAgIEJhc2VMYXN0QXJndW1lbnRTZWxlY3Rvci5jYWxsKHRoaXMsIHNlbGVjdG9yVGV4dCwgdXB3YXJkU2VsZWN0b3IsIGRlYnVnKTtcbiAgfVxuXG4gIFVwd2FyZFNlbGVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yLnByb3RvdHlwZSk7XG4gIFVwd2FyZFNlbGVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVwd2FyZFNlbGVjdG9yO1xuICAvKipcbiAgICogQXBwbGllcyB1cHdhcmQgcHNldWRvLWNsYXNzIHRvIHByb3ZpZGVkIGNvbnRleHQgbm9kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBjb250ZXh0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVwd2FyZFNlbGVjdG9yIHVwd2FyZCBzZWxlY3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSByZXN1bHRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG4gIFVwd2FyZFNlbGVjdG9yLnByb3RvdHlwZS5zZWFyY2hSZXN1bHROb2RlcyA9IGZ1bmN0aW9uIChub2RlLCB1cHdhcmRTZWxlY3RvciwgcmVzdWx0KSB7XG4gICAgaWYgKHVwd2FyZFNlbGVjdG9yICE9PSAnJykge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBwYXJlbnQuY2xvc2VzdCh1cHdhcmRTZWxlY3Rvcik7XG5cbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChub2RlKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxlY3RvciBjbGFzc1xuICAgKiBMaW1pdGVkIHRvIHN1cHBvcnQgJ3JlbW92ZScgdG8gYmUgb25seSB0aGUgbGFzdCBvbmUgdG9rZW4gaW4gc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yVGV4dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1ZhbGlkUmVtb3ZlUGFydFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWJ1Z1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGF1Z21lbnRzIEJhc2VMYXN0QXJndW1lbnRTZWxlY3RvclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFJlbW92ZVNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgaGFzVmFsaWRSZW1vdmVQYXJ0LCBkZWJ1Zykge1xuICAgIHZhciBSRU1PVkVfUFNFVURPX01BUktFUiA9ICc6cmVtb3ZlKCknO1xuICAgIHZhciByZW1vdmVNYXJrZXJJbmRleCA9IHNlbGVjdG9yVGV4dC5pbmRleE9mKFJFTU9WRV9QU0VVRE9fTUFSS0VSKTsgLy8gZGVsZXRpbmcgcmVtb3ZlIHBhcnQgb2YgcnVsZSBpbnN0ZWFkIG9mIHdoaWNoXG4gICAgLy8gcHNldWRvLXByb3BlcnR5IHByb3BlcnR5ICdyZW1vdmUnIHdpbGwgYmUgYWRkZWQgYnkgRXh0ZW5kZWRDc3NQYXJzZXJcblxuICAgIHZhciBtb2RpZmllZFNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dC5zbGljZSgwLCByZW1vdmVNYXJrZXJJbmRleCk7XG4gICAgQmFzZUxhc3RBcmd1bWVudFNlbGVjdG9yLmNhbGwodGhpcywgbW9kaWZpZWRTZWxlY3RvclRleHQsIGhhc1ZhbGlkUmVtb3ZlUGFydCwgZGVidWcpOyAvLyBtYXJrIGV4dGVuZGVkU2VsZWN0b3IgYXMgUmVtb3ZlIG9uZSBmb3IgRXh0ZW5kZWRDc3NQYXJzZXJcblxuICAgIHRoaXMuaXNSZW1vdmVTZWxlY3RvciA9IHRydWU7XG4gIH1cblxuICBSZW1vdmVTZWxlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VMYXN0QXJndW1lbnRTZWxlY3Rvci5wcm90b3R5cGUpO1xuICBSZW1vdmVTZWxlY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZW1vdmVTZWxlY3RvcjtcbiAgLyoqXG4gICAqIEEgc3BsaXR0ZWQgZXh0ZW5kZWQgc2VsZWN0b3IgY2xhc3MuXG4gICAqXG4gICAqICNjb250YWluZXIgI2ZlZWRJdGVtOmhhcyguYWRzKVxuICAgKiArLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgc2ltcGxlXG4gICAqICAgICAgICAgICArICAgICAgICAgICAgICAgICAgICByZWxhdGlvblxuICAgKiAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLSsgY29tcGxleFxuICAgKiBXZSBzcGxpdCBzZWxlY3RvciBvbmx5IHdoZW4gdGhlIGxhc3Qgc2VsZWN0b3IgaXMgY29tcGxleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaW1wbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wbGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlYnVnXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyBUcmFpdExlc3NTZWxlY3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBTcGxpdHRlZFNlbGVjdG9yKHNlbGVjdG9yVGV4dCwgc2ltcGxlLCByZWxhdGlvbiwgY29tcGxleCwgZGVidWcpIHtcbiAgICBUcmFpdExlc3NTZWxlY3Rvci5jYWxsKHRoaXMsIHNlbGVjdG9yVGV4dCwgZGVidWcpO1xuICAgIHRoaXMuc2ltcGxlID0gc2ltcGxlO1xuICAgIHRoaXMucmVsYXRpb24gPSByZWxhdGlvbjtcbiAgICB0aGlzLmNvbXBsZXggPSBjb21wbGV4O1xuICAgIFNpenpsZS5jb21waWxlKGNvbXBsZXgpO1xuICB9XG5cbiAgU3BsaXR0ZWRTZWxlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYWl0TGVzc1NlbGVjdG9yLnByb3RvdHlwZSk7XG4gIFNwbGl0dGVkU2VsZWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BsaXR0ZWRTZWxlY3RvcjtcbiAgLyoqIEBvdmVycmlkZSAqL1xuXG4gIFNwbGl0dGVkU2VsZWN0b3IucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgcmVzdWx0Tm9kZXMgPSBbXTtcbiAgICB2YXIgc2ltcGxlTm9kZXM7XG4gICAgdmFyIHNpbXBsZSA9IHRoaXMuc2ltcGxlO1xuICAgIHZhciByZWxhdGlvbjtcblxuICAgIGlmIChzaW1wbGUpIHtcbiAgICAgIC8vIEZpcnN0IHdlIHVzZSBzaW1wbGUgc2VsZWN0b3IgdG8gbmFycm93IG91ciBzZWFyY2hcbiAgICAgIHNpbXBsZU5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzaW1wbGUpO1xuXG4gICAgICBpZiAoIXNpbXBsZU5vZGVzIHx8ICFzaW1wbGVOb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdE5vZGVzO1xuICAgICAgfVxuXG4gICAgICByZWxhdGlvbiA9IHRoaXMucmVsYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpbXBsZU5vZGVzID0gW2RvY3VtZW50XTtcbiAgICAgIHJlbGF0aW9uID0gJyAnO1xuICAgIH1cblxuICAgIHN3aXRjaCAocmVsYXRpb24pIHtcbiAgICAgIGNhc2UgJyAnOlxuICAgICAgICBzaW1wbGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgX3RoaXMyLnJlbGF0aXZlU2VhcmNoKG5vZGUsIHJlc3VsdE5vZGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc+JzpcbiAgICAgICAge1xuICAgICAgICAgIHNpbXBsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMobm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczIubWF0Y2hlcyhjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Tm9kZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICcrJzpcbiAgICAgICAge1xuICAgICAgICAgIHNpbXBsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhwYXJlbnROb2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzMi5tYXRjaGVzKGNoaWxkTm9kZSkgJiYgY2hpbGROb2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHROb2Rlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ34nOlxuICAgICAgICB7XG4gICAgICAgICAgc2ltcGxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKHBhcmVudE5vZGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLm1hdGNoZXMoY2hpbGROb2RlKSAmJiBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGNoaWxkTm9kZSkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHROb2Rlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdE5vZGVzKTtcbiAgfTtcbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgc2VhcmNoIG9mIFwiY29tcGxleFwiIHBhcnQgcmVsYXRpdmUgdG8gcmVzdWx0cyBmb3IgdGhlIFwic2ltcGxlXCIgcGFydC5cbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIGEgbm9kZSBtYXRjaGluZyB0aGUgXCJzaW1wbGVcIiBwYXJ0LlxuICAgKiBAcGFyYW0ge05vZGVbXX0gcmVzdWx0IGFuIGFycmF5IHRvIGFwcGVuZCBzZWFyY2ggcmVzdWx0LlxuICAgKi9cblxuXG4gIFNwbGl0dGVkU2VsZWN0b3IucHJvdG90eXBlLnJlbGF0aXZlU2VhcmNoID0gZnVuY3Rpb24gKG5vZGUsIHJlc3VsdHMpIHtcbiAgICBTaXp6bGUodGhpcy5jb21wbGV4LCBub2RlLCByZXN1bHRzKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFdyYXBzIHRoZSBpbm5lciBjbGFzcyBzbyB0aGF0IHRoZSBpbnN0YW5jZSBpcyBub3QgZXhwb3NlZC5cbiAgICAgKi9cbiAgICBjcmVhdGVTZWxlY3RvcjogZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3Ioc2VsZWN0b3IsIHRva2VucywgZGVidWcpIHtcbiAgICAgIHJldHVybiBuZXcgRXh0ZW5kZWRTZWxlY3RvclBhcnNlcihzZWxlY3RvciwgdG9rZW5zLCBkZWJ1ZykuY3JlYXRlU2VsZWN0b3IoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFyayBldmVyeSBzZWxlY3RvciBhcyBhIHNlbGVjdG9yIGJlaW5nIGRlYnVnZ2VkLCBzbyB0aGF0IHRpbWluZyBpbmZvcm1hdGlvblxuICAgICAqIGZvciB0aGUgc2VsZWN0b3IgaXMgcHJpbnRlZCB0byB0aGUgY29uc29sZS5cbiAgICAgKi9cbiAgICBlbmFibGVHbG9iYWxEZWJ1Z2dpbmc6IGZ1bmN0aW9uIGVuYWJsZUdsb2JhbERlYnVnZ2luZygpIHtcbiAgICAgIGdsb2JhbERlYnVnZ2luZ0ZsYWcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBBZGd1YXJkIFNvZnR3YXJlIEx0ZFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEEgaGVscGVyIGNsYXNzIHRoYXQgcGFyc2VzIHN0eWxlc2hlZXRzIGNvbnRhaW5pbmcgZXh0ZW5kZWQgc2VsZWN0b3JzXG4gKiBpbnRvIEV4dGVuZGVkU2VsZWN0b3IgaW5zdGFuY2VzIGFuZCBrZXktdmFsdWUgbWFwcyBvZiBzdHlsZSBkZWNsYXJhdGlvbnMuXG4gKiBQbGVhc2Ugbm90ZSwgdGhhdCBpdCBkb2VzIG5vdCBzdXBwb3J0IGFueSBjb21wbGV4IHRoaW5ncyBsaWtlIG1lZGlhIHF1ZXJpZXMgYW5kIHN1Y2guXG4gKi9cblxudmFyIEV4dGVuZGVkQ3NzUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVEZWNsRW5kID0gL1s7fV0vZztcbiAgdmFyIHJlRGVjbERpdmlkZXIgPSAvWzs6fV0vZztcbiAgdmFyIHJlTm9uV2hpdGVzcGFjZSA9IC9cXFMvZztcbiAgdmFyIFNpenpsZTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cblxuICBmdW5jdGlvbiBQYXJzZXIoY3NzVGV4dCkge1xuICAgIHRoaXMuY3NzVGV4dCA9IGNzc1RleHQ7XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihwb3NpdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3NzUGFyc2VyOiBwYXJzZSBlcnJvciBhdCBwb3NpdGlvbiBcIi5jb25jYXQodGhpcy5wb3NPZmZzZXQgKyBwb3NpdGlvbikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdG9rZW5zIGNvcnJlc3BvbmQgdG8gYSB2YWxpZCBzZWxlY3Rvci5cbiAgICAgKiBTaXp6bGUgaXMgZGlmZmVyZW50IGZyb20gYnJvd3NlcnMgYW5kIHNvbWUgc2VsZWN0b3JzIHRoYXQgaXQgdG9sZXJhdGVzIGFyZW4ndCBhY3R1YWxseSB2YWxpZC5cbiAgICAgKiBGb3IgaW5zdGFuY2UsIFwiZGl2ID5cIiB3b24ndCB3b3JrIGluIGEgYnJvd3NlciwgYnV0IGl0IHdpbGwgaW4gU2l6emxlIChpdCdkIGJlIHRoZSBzYW1lIGFzIFwiZGl2ID4gKlwiKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc2VsZWN0b3JzIEFuIGFycmF5IG9mIFNlbGVjdG9yRGF0YSAoc2VsZWN0b3IsIGdyb3VwcylcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBncm91cHMgYXJlIGludmFsaWRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZVNlbGVjdG9yczogZnVuY3Rpb24gdmFsaWRhdGVTZWxlY3RvcnMoc2VsZWN0b3JzKSB7XG4gICAgICB2YXIgaVNlbGVjdG9ycyA9IHNlbGVjdG9ycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpU2VsZWN0b3JzLS0pIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHNlbGVjdG9yc1tpU2VsZWN0b3JzXS5ncm91cHM7XG4gICAgICAgIHZhciBpR3JvdXBzID0gZ3JvdXBzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaUdyb3Vwcy0tKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IGdyb3Vwc1tpR3JvdXBzXTtcbiAgICAgICAgICB2YXIgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmIChTaXp6bGUuc2VsZWN0b3JzLnJlbGF0aXZlW2xhc3RUb2tlbi50eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc3R5bGVzaGVldCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgcGFpcnMgb2YgYW4gRXh0ZW5kZWRTZWxlY3RvciBhbmQgYSBzdHlsZXMgbWFwLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gY2FzZSBvZiBhbiBvYnZpb3VzbHkgaW52YWxpZCBpbnB1dC5cbiAgICAgKiBJZiBhbnkgb2YgdGhlIHNlbGVjdG9ycyB1c2VkIGluIHRoZSBzdHlsZXNoZWV0IGNhbm5vdCBiZSBjb21waWxlZCBpbnRvIGFuIEV4dGVuZGVkU2VsZWN0b3IsXG4gICAgICogaXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gRXh0ZW5kZWRTdHlsZVxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZWxlY3RvciBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV4dGVuZGVkU2VsZWN0b3J9IGNsYXNzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHN0eWxlTWFwIEEgbWFwIG9mIHN0eWxlcyBwYXJzZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48RXh0ZW5kZWRTdHlsZT59IEFuIGFycmF5IG9mIHRoZSBzdHlsZXMgcGFyc2VkXG4gICAgICovXG4gICAgcGFyc2VDc3M6IGZ1bmN0aW9uIHBhcnNlQ3NzKCkge1xuICAgICAgdGhpcy5wb3NPZmZzZXQgPSAwO1xuXG4gICAgICBpZiAoIXRoaXMuY3NzVGV4dCkge1xuICAgICAgICB0aGlzLmVycm9yKDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICB3aGlsZSAodGhpcy5jc3NUZXh0KSB7XG4gICAgICAgIC8vIEFwcGx5IHRvbGVyYW50IHRva2VuaXphdGlvbi5cbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gU2l6emxlLnRva2VuaXplKHRoaXMuY3NzVGV4dCwgZmFsc2UsIHtcbiAgICAgICAgICB0b2xlcmFudDogdHJ1ZSxcbiAgICAgICAgICByZXR1cm5VbnNvcnRlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlbGVjdG9yRGF0YSA9IHBhcnNlUmVzdWx0LnNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSBwYXJzZVJlc3VsdC5uZXh0SW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuY3NzVGV4dC5jaGFyQ29kZUF0KHRoaXMubmV4dEluZGV4KSAhPT0gMTIzIHx8XG4gICAgICAgIC8qIGNoYXJDb2RlIG9mICd7JyAqL1xuICAgICAgICAhdGhpcy52YWxpZGF0ZVNlbGVjdG9ycyhzZWxlY3RvckRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcih0aGlzLm5leHRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5leHRJbmRleCsrOyAvLyBNb3ZlIHRoZSBwb2ludGVyIHRvIHRoZSBzdGFydCBvZiBzdHlsZSBkZWNsYXJhdGlvbi5cblxuICAgICAgICB2YXIgc3R5bGVNYXAgPSB0aGlzLnBhcnNlTmV4dFN0eWxlKCk7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGZhbHNlOyAvLyBJZiB0aGVyZSBpcyBhIHN0eWxlIHByb3BlcnR5ICdkZWJ1ZycsIG1hcmsgdGhlIHNlbGVjdG9yXG4gICAgICAgIC8vIGFzIGEgZGVidWdnYWJsZSBzZWxlY3RvciwgYW5kIGRlbGV0ZSB0aGUgc3R5bGUgZGVjbGFyYXRpb24uXG5cbiAgICAgICAgdmFyIGRlYnVnUHJvcGVydHlWYWx1ZSA9IHN0eWxlTWFwWydkZWJ1ZyddO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGVidWdQcm9wZXJ0eVZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChkZWJ1Z1Byb3BlcnR5VmFsdWUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICBFeHRlbmRlZFNlbGVjdG9yRmFjdG9yeS5lbmFibGVHbG9iYWxEZWJ1Z2dpbmcoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWJ1ZyA9IHRydWU7XG4gICAgICAgICAgZGVsZXRlIHN0eWxlTWFwWydkZWJ1ZyddO1xuICAgICAgICB9IC8vIENyZWF0aW5nIGFuIEV4dGVuZGVkU2VsZWN0b3IgaW5zdGFuY2UgZm9yIGV2ZXJ5IHNlbGVjdG9yIHdlIGdvdCBmcm9tIFNpenpsZS50b2tlbml6ZS5cbiAgICAgICAgLy8gVGhpcyBpcyBxdWl0ZSBpbXBvcnRhbnQgYXMgU2l6emxlIGRvZXMgYSBwb29yIGpvYiBhdCBleGVjdXRpbmcgc2VsZWN0b3JzIGxpa2UgXCJzZWxlY3RvcjEsIHNlbGVjdG9yMlwiLlxuXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWxlY3RvckRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBzZWxlY3RvckRhdGFbaV07XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGV4dGVuZGVkU2VsZWN0b3IgPSBFeHRlbmRlZFNlbGVjdG9yRmFjdG9yeS5jcmVhdGVTZWxlY3RvcihkYXRhLnNlbGVjdG9yVGV4dCwgZGF0YS5ncm91cHMsIGRlYnVnKTtcblxuICAgICAgICAgICAgaWYgKGV4dGVuZGVkU2VsZWN0b3IucHNldWRvQ2xhc3NBcmcgJiYgZXh0ZW5kZWRTZWxlY3Rvci5pc1JlbW92ZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIHJlbW92ZSBwc2V1ZG8tY2xhc3MgaW4gcnVsZSxcbiAgICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgd2lsbCBiZSByZW1vdmVkIGFuZCBubyBvdGhlciBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgICAgICAgIHN0eWxlTWFwWydyZW1vdmUnXSA9ICd0cnVlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgc2VsZWN0b3I6IGV4dGVuZGVkU2VsZWN0b3IsXG4gICAgICAgICAgICAgIHN0eWxlOiBzdHlsZU1hcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHV0aWxzLmxvZ0Vycm9yKFwiRXh0ZW5kZWRDc3NQYXJzZXI6IGlnbm9yaW5nIGludmFsaWQgc2VsZWN0b3IgXCIuY29uY2F0KGRhdGEuc2VsZWN0b3JUZXh0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG4gICAgcGFyc2VOZXh0U3R5bGU6IGZ1bmN0aW9uIHBhcnNlTmV4dFN0eWxlKCkge1xuICAgICAgdmFyIHN0eWxlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBicmFja2V0UG9zID0gdGhpcy5wYXJzZVVudGlsQ2xvc2luZ0JyYWNrZXQoc3R5bGVNYXApOyAvLyBDdXQgb3V0IG1hdGNoZWQgcG9ydGlvbiBmcm9tIGNzc1RleHQuXG5cbiAgICAgIHJlTm9uV2hpdGVzcGFjZS5sYXN0SW5kZXggPSBicmFja2V0UG9zICsgMTtcbiAgICAgIHZhciBtYXRjaCA9IHJlTm9uV2hpdGVzcGFjZS5leGVjKHRoaXMuY3NzVGV4dCk7XG5cbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNzc1RleHQgPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlTWFwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hQb3MgPSBtYXRjaC5pbmRleDtcbiAgICAgIHRoaXMuY3NzVGV4dCA9IHRoaXMuY3NzVGV4dC5zbGljZShtYXRjaFBvcyk7XG4gICAgICB0aGlzLnBvc09mZnNldCArPSBtYXRjaFBvcztcbiAgICAgIHJldHVybiBzdHlsZU1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBhbiBpbmRleCBvZiB0aGUgbmV4dCAnfScgaW4gYHRoaXMuY3NzVGV4dGAuXG4gICAgICovXG4gICAgcGFyc2VVbnRpbENsb3NpbmdCcmFja2V0OiBmdW5jdGlvbiBwYXJzZVVudGlsQ2xvc2luZ0JyYWNrZXQoc3R5bGVNYXApIHtcbiAgICAgIC8vIEV4cGVjdHMgXCI6XCIsIFwiO1wiLCBhbmQgXCJ9XCIuXG4gICAgICByZURlY2xEaXZpZGVyLmxhc3RJbmRleCA9IHRoaXMubmV4dEluZGV4O1xuICAgICAgdmFyIG1hdGNoID0gcmVEZWNsRGl2aWRlci5leGVjKHRoaXMuY3NzVGV4dCk7XG5cbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVycm9yKHRoaXMubmV4dEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoUG9zID0gbWF0Y2guaW5kZXg7XG4gICAgICB2YXIgbWF0Y2hlZCA9IG1hdGNoWzBdO1xuXG4gICAgICBpZiAobWF0Y2hlZCA9PT0gJ30nKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFBvcztcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoZWQgPT09ICc6Jykge1xuICAgICAgICB2YXIgY29sb25JbmRleCA9IG1hdGNoUG9zOyAvLyBFeHBlY3RzIFwiO1wiIGFuZCBcIn1cIi5cblxuICAgICAgICByZURlY2xFbmQubGFzdEluZGV4ID0gY29sb25JbmRleDtcbiAgICAgICAgbWF0Y2ggPSByZURlY2xFbmQuZXhlYyh0aGlzLmNzc1RleHQpO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZXJyb3IoY29sb25JbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaFBvcyA9IG1hdGNoLmluZGV4O1xuICAgICAgICBtYXRjaGVkID0gbWF0Y2hbMF07IC8vIFBvcHVsYXRlcyB0aGUgYHN0eWxlTWFwYCBrZXktdmFsdWUgbWFwLlxuXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuY3NzVGV4dC5zbGljZSh0aGlzLm5leHRJbmRleCwgY29sb25JbmRleCkudHJpbSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmNzc1RleHQuc2xpY2UoY29sb25JbmRleCArIDEsIG1hdGNoUG9zKS50cmltKCk7XG4gICAgICAgIHN0eWxlTWFwW3Byb3BlcnR5XSA9IHZhbHVlOyAvLyBJZiBmb3VuZCBcIn1cIiwgcmUtcnVuIHRoZSBvdXRlciBsb29wLlxuXG4gICAgICAgIGlmIChtYXRjaGVkID09PSAnfScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hQb3M7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbWF0Y2hQb3MgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0ICc7Jy5cbiAgICAgIC8vIEluY3JlYXNlICduZXh0SW5kZXgnIGFuZCByZS1ydW4gdGhlIGxvb3AuXG5cblxuICAgICAgdGhpcy5uZXh0SW5kZXggPSBtYXRjaFBvcyArIDE7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVVudGlsQ2xvc2luZ0JyYWNrZXQoc3R5bGVNYXApOyAvLyBTaG91bGQgYmUgYSBzdWJqZWN0IG9mIHRhaWwtY2FsbCBvcHRpbWl6YXRpb24uXG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHBhcnNlQ3NzOiBmdW5jdGlvbiBwYXJzZUNzcyhjc3NUZXh0KSB7XG4gICAgICBTaXp6bGUgPSBpbml0aWFsaXplU2l6emxlKCk7XG4gICAgICByZXR1cm4gbmV3IFBhcnNlcihjc3NVdGlscy5ub3JtYWxpemUoY3NzVGV4dCkpLnBhcnNlQ3NzKCk7XG4gICAgfVxuICB9O1xufSgpO1xuXG4vKipcbiAqIFRoaXMgY2FsbGJhY2sgaXMgdXNlZCB0byBnZXQgYWZmZWN0ZWQgbm9kZSBlbGVtZW50cyBhbmQgaGFuZGxlIHN0eWxlIHByb3BlcnRpZXNcbiAqIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZW0gaWYgaXQgaXMgbmVjZXNzYXJ5XG4gKiBAY2FsbGJhY2sgYmVmb3JlU3R5bGVBcHBsaWVkXG4gKiBAcGFyYW0ge29iamVjdH0gYWZmZWN0ZWRFbGVtZW50IC0gT2JqZWN0IGNvbnRhaW5pbmcgRE9NIG5vZGUgYW5kIHJ1bGUgdG8gYmUgYXBwbGllZFxuICogQHJldHVybiB7b2JqZWN0fSBhZmZlY3RlZEVsZW1lbnQgLSBTYW1lIG9yIG1vZGlmaWVkIG9iamVjdCBjb250YWluaW5nIERPTSBub2RlIGFuZCBydWxlIHRvIGJlIGFwcGxpZWRcbiAqL1xuXG4vKipcbiAqIEV4dGVuZGVkIGNzcyBjbGFzc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlndXJhdGlvbi5zdHlsZVNoZWV0IC0gdGhlIENTUyBzdHlsZXNoZWV0IHRleHRcbiAqIEBwYXJhbSB7YmVmb3JlU3R5bGVBcHBsaWVkfSBbY29uZmlndXJhdGlvbi5iZWZvcmVTdHlsZUFwcGxpZWRdIC0gdGhlIGNhbGxiYWNrIHRoYXQgaGFuZGxlcyBhZmZlY3RlZCBlbGVtZW50c1xuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gRXh0ZW5kZWRDc3MoY29uZmlndXJhdGlvbikge1xuICBpZiAoIWNvbmZpZ3VyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZ3VyYXRpb24gaXMgbm90IHByb3ZpZGVkLicpO1xuICB9XG5cbiAgdmFyIHN0eWxlU2hlZXQgPSBjb25maWd1cmF0aW9uLnN0eWxlU2hlZXQ7XG4gIHZhciBiZWZvcmVTdHlsZUFwcGxpZWQgPSBjb25maWd1cmF0aW9uLmJlZm9yZVN0eWxlQXBwbGllZDtcblxuICBpZiAoYmVmb3JlU3R5bGVBcHBsaWVkICYmIHR5cGVvZiBiZWZvcmVTdHlsZUFwcGxpZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGNvbmZpZ3VyYXRpb24uIFR5cGUgb2YgJ2JlZm9yZVN0eWxlQXBwbGllZCcgZmllbGQgc2hvdWxkIGJlIGEgZnVuY3Rpb24sIHJlY2VpdmVkOiBcIi5jb25jYXQoX3R5cGVvZihiZWZvcmVTdHlsZUFwcGxpZWQpKSk7XG4gIH0gLy8gV2UgdXNlIEV2ZW50VHJhY2tlciB0byB0cmFjayB0aGUgZXZlbnQgdGhhdCBpcyBsaWtlbHkgdG8gY2F1c2UgdGhlIG11dGF0aW9uLlxuICAvLyBUaGUgcHJvYmxlbSBpcyB0aGF0IHdlIGNhbm5vdCB1c2UgYHdpbmRvdy5ldmVudGAgZGlyZWN0bHkgZnJvbSB0aGUgbXV0YXRpb24gb2JzZXJ2ZXIgY2FsbFxuICAvLyBhcyB3ZSdyZSBub3QgaW4gdGhlIGV2ZW50IGhhbmRsZXIgY29udGV4dCBhbnltb3JlLlxuXG5cbiAgdmFyIEV2ZW50VHJhY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWdub3JlZEV2ZW50VHlwZXMgPSBbJ21vdXNlb3ZlcicsICdtb3VzZWxlYXZlJywgJ21vdXNlZW50ZXInLCAnbW91c2VvdXQnXTtcbiAgICB2YXIgTEFTVF9FVkVOVF9USU1FT1VUX01TID0gMTA7XG4gICAgdmFyIEVWRU5UUyA9IFsvLyBrZXlib2FyZCBldmVudHNcbiAgICAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsIC8vIG1vdXNlIGV2ZW50c1xuICAgICdhdXhjbGljaycsICdjbGljaycsICdjb250ZXh0bWVudScsICdkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJywgJ21vdXNlbW92ZScsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdwb2ludGVybG9ja2NoYW5nZScsICdwb2ludGVybG9ja2Vycm9yJywgJ3NlbGVjdCcsICd3aGVlbCddOyAvLyAnd2hlZWwnIGV2ZW50IG1ha2VzIHNjcm9sbGluZyBpbiBTYWZhcmkgdHdpdGNoeVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9FeHRlbmRlZENzcy9pc3N1ZXMvMTIwXG5cbiAgICB2YXIgc2FmYXJpUHJvYmxlbWF0aWNFdmVudHMgPSBbJ3doZWVsJ107XG4gICAgdmFyIHRyYWNrZWRFdmVudHMgPSB1dGlscy5pc1NhZmFyaUJyb3dzZXIgPyBFVkVOVFMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuICEoc2FmYXJpUHJvYmxlbWF0aWNFdmVudHMuaW5kZXhPZihlbCkgPiAtMSk7XG4gICAgfSkgOiBFVkVOVFM7XG4gICAgdmFyIGxhc3RFdmVudFR5cGU7XG4gICAgdmFyIGxhc3RFdmVudFRpbWU7XG5cbiAgICB2YXIgdHJhY2tFdmVudCA9IGZ1bmN0aW9uIHRyYWNrRXZlbnQoZSkge1xuICAgICAgbGFzdEV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgIGxhc3RFdmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICB0cmFja2VkRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2TmFtZSkge1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZOYW1lLCB0cmFja0V2ZW50LCB0cnVlKTtcbiAgICB9KTtcblxuICAgIHZhciBnZXRMYXN0RXZlbnRUeXBlID0gZnVuY3Rpb24gZ2V0TGFzdEV2ZW50VHlwZSgpIHtcbiAgICAgIHJldHVybiBsYXN0RXZlbnRUeXBlO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VGltZVNpbmNlTGFzdEV2ZW50ID0gZnVuY3Rpb24gZ2V0VGltZVNpbmNlTGFzdEV2ZW50KCkge1xuICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBsYXN0RXZlbnRUaW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNJZ25vcmVkRXZlbnRUeXBlOiBmdW5jdGlvbiBpc0lnbm9yZWRFdmVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBpZ25vcmVkRXZlbnRUeXBlcy5pbmRleE9mKGdldExhc3RFdmVudFR5cGUoKSkgPiAtMSAmJiBnZXRUaW1lU2luY2VMYXN0RXZlbnQoKSA8IExBU1RfRVZFTlRfVElNRU9VVF9NUztcbiAgICAgIH1cbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHJ1bGVzID0gW107XG4gIHZhciBhZmZlY3RlZEVsZW1lbnRzID0gW107XG4gIHZhciByZW1vdmFsc1N0YXRpc3RpYyA9IHt9O1xuICB2YXIgZG9tT2JzZXJ2ZWQ7XG4gIHZhciBldmVudExpc3RlbmVyU3VwcG9ydGVkID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG4gIHZhciBkb21NdXRhdGlvbk9ic2VydmVyO1xuXG4gIGZ1bmN0aW9uIG9ic2VydmVEb2N1bWVudChjYWxsYmFjaykge1xuICAgIC8vIFdlIGFyZSB0cnlpbmcgdG8gbGltaXQgdGhlIG51bWJlciBvZiBjYWxsYmFjayBjYWxscyBieSBub3QgY2FsbGluZyBpdCBvbiBhbGwga2luZCBvZiBcImhvdmVyXCIgZXZlbnRzLlxuICAgIC8vIFRoZSByYXRpb25hbGUgYmVoaW5kIHRoaXMgaXMgdGhhdCBcImhvdmVyXCIgZXZlbnRzIG9mdGVuIGNhdXNlIGF0dHJpYnV0ZXMgbW9kaWZpY2F0aW9uLFxuICAgIC8vIGJ1dCByZS1hcHBseWluZyBleHRDU1MgcnVsZXMgd2lsbCBiZSB1c2VsZXNzIGFzIHRoZXNlIGF0dHJpYnV0ZSBjaGFuZ2VzIGFyZSB1c3VhbGx5IHRyYW5zaWVudC5cbiAgICB2YXIgaXNJZ25vcmVkTXV0YXRpb24gPSBmdW5jdGlvbiBpc0lnbm9yZWRNdXRhdGlvbihtdXRhdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChtdXRhdGlvbnMudHlwZSAhPT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBpZiAodXRpbHMuTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgZG9tTXV0YXRpb25PYnNlcnZlciA9IG5ldyB1dGlscy5NdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKCFtdXRhdGlvbnMgfHwgbXV0YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChFdmVudFRyYWNrZXIuaXNJZ25vcmVkRXZlbnRUeXBlKCkgJiYgaXNJZ25vcmVkTXV0YXRpb24obXV0YXRpb25zKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIGRvbU11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogWydpZCcsICdjbGFzcyddXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50TGlzdGVuZXJTdXBwb3J0ZWQpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01BdHRyTW9kaWZpZWQnLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2Nvbm5lY3REb2N1bWVudChjYWxsYmFjaykge1xuICAgIGlmIChkb21NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICBkb21NdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50TGlzdGVuZXJTdXBwb3J0ZWQpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01BdHRyTW9kaWZpZWQnLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBNQVhfU1RZTEVfUFJPVEVDVElPTl9DT1VOVCA9IDUwO1xuICB2YXIgcHJvdGVjdGlvbk9ic2VydmVyT3B0aW9uID0ge1xuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgYXR0cmlidXRlRmlsdGVyOiBbJ3N0eWxlJ11cbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgTXV0YXRpb25PYnNlcnZlciBwcm90ZWN0aW9uIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBzdHlsZXNcbiAgICogQHJldHVybiB7cHJvdGVjdGlvbkZ1bmN0aW9ufVxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVQcm90ZWN0aW9uRnVuY3Rpb24oc3R5bGVzKSB7XG4gICAgZnVuY3Rpb24gcHJvdGVjdGlvbkZ1bmN0aW9uKG11dGF0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgICAgIGlmICghbXV0YXRpb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtdXRhdGlvbiA9IG11dGF0aW9uc1swXTtcbiAgICAgIHZhciB0YXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgc2V0U3R5bGVUb0VsZW1lbnQodGFyZ2V0LCBzdHlsZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCsrb2JzZXJ2ZXIuc3R5bGVQcm90ZWN0aW9uQ291bnQgPCBNQVhfU1RZTEVfUFJPVEVDVElPTl9DT1VOVCkge1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldCwgcHJvdGVjdGlvbk9ic2VydmVyT3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLmxvZ0Vycm9yKCdFeHRlbmRlZENzczogaW5maW5pdGUgbG9vcCBwcm90ZWN0aW9uIGZvciBzdHlsZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm90ZWN0aW9uRnVuY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdXAgYSBNdXRhdGlvbk9ic2VydmVyIHdoaWNoIHByb3RlY3RzIHN0eWxlIGF0dHJpYnV0ZXMgZnJvbSBjaGFuZ2VzXG4gICAqIEBwYXJhbSBub2RlIERPTSBub2RlXG4gICAqIEBwYXJhbSBydWxlcyBydWxlc1xuICAgKiBAcmV0dXJucyBNdXRhdGlvbiBvYnNlcnZlciB1c2VkIHRvIHByb3RlY3QgYXR0cmlidXRlIG9yIG51bGwgaWYgdGhlcmUncyBub3RoaW5nIHRvIHByb3RlY3RcbiAgICovXG5cblxuICBmdW5jdGlvbiBwcm90ZWN0U3R5bGVBdHRyaWJ1dGUobm9kZSwgcnVsZXMpIHtcbiAgICBpZiAoIXV0aWxzLk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzdHlsZXMgPSBydWxlcy5tYXAoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiByLnN0eWxlO1xuICAgIH0pO1xuICAgIHZhciBwcm90ZWN0aW9uT2JzZXJ2ZXIgPSBuZXcgdXRpbHMuTXV0YXRpb25PYnNlcnZlcihjcmVhdGVQcm90ZWN0aW9uRnVuY3Rpb24oc3R5bGVzKSk7XG4gICAgcHJvdGVjdGlvbk9ic2VydmVyLm9ic2VydmUobm9kZSwgcHJvdGVjdGlvbk9ic2VydmVyT3B0aW9uKTsgLy8gQWRkcyBhbiBleHBhbmRvIHRvIHRoZSBvYnNlcnZlciB0byBrZWVwICdzdHlsZSBmaXggY291bnRzJy5cblxuICAgIHByb3RlY3Rpb25PYnNlcnZlci5zdHlsZVByb3RlY3Rpb25Db3VudCA9IDA7XG4gICAgcmV0dXJuIHByb3RlY3Rpb25PYnNlcnZlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVN1ZmZpeChzdHIsIHN1ZmZpeCkge1xuICAgIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kcyBhZmZlY3RlZEVsZW1lbnQgb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIERPTSBub2RlXG4gICAqIEBwYXJhbSBub2RlICBET00gbm9kZVxuICAgKiBAcmV0dXJucyAgICAgYWZmZWN0ZWRFbGVtZW50IGZvdW5kIG9yIG51bGxcbiAgICovXG5cblxuICBmdW5jdGlvbiBmaW5kQWZmZWN0ZWRFbGVtZW50KG5vZGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFmZmVjdGVkRWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChhZmZlY3RlZEVsZW1lbnRzW2ldLm5vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGFmZmVjdGVkRWxlbWVudHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGFmZmVjdGVkRWxlbWVudCkge1xuICAgIHZhciBub2RlID0gYWZmZWN0ZWRFbGVtZW50Lm5vZGU7XG4gICAgYWZmZWN0ZWRFbGVtZW50LnJlbW92ZWQgPSB0cnVlO1xuICAgIHZhciBlbGVtZW50U2VsZWN0b3IgPSB1dGlscy5nZXROb2RlU2VsZWN0b3Iobm9kZSk7IC8vIGNoZWNrIGlmIHRoZSBlbGVtZW50IGhhcyBiZWVuIGFscmVhZHkgcmVtb3ZlZCBlYXJsaWVyXG5cbiAgICB2YXIgZWxlbWVudFJlbW92YWxzQ291bnRlciA9IHJlbW92YWxzU3RhdGlzdGljW2VsZW1lbnRTZWxlY3Rvcl0gfHwgMDsgLy8gaWYgcmVtb3ZhbHMgYXR0ZW1wdHMgaGFwcGVuZWQgbW9yZSB0aGFuIHNwZWNpZmllZCB3ZSBkbyBub3QgdHJ5IHRvIHJlbW92ZSBub2RlIGFnYWluXG5cbiAgICBpZiAoZWxlbWVudFJlbW92YWxzQ291bnRlciA+IE1BWF9TVFlMRV9QUk9URUNUSU9OX0NPVU5UKSB7XG4gICAgICB1dGlscy5sb2dFcnJvcignRXh0ZW5kZWRDc3M6IGluZmluaXRlIGxvb3AgcHJvdGVjdGlvbiBmb3IgU0VMRUNUT1InLCBlbGVtZW50U2VsZWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIHJlbW92YWxzU3RhdGlzdGljW2VsZW1lbnRTZWxlY3Rvcl0gPSBlbGVtZW50UmVtb3ZhbHNDb3VudGVyICsgMTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgc3R5bGUgdG8gdGhlIHNwZWNpZmllZCBET00gbm9kZVxuICAgKiBAcGFyYW0gYWZmZWN0ZWRFbGVtZW50IE9iamVjdCBjb250YWluaW5nIERPTSBub2RlIGFuZCBydWxlIHRvIGJlIGFwcGxpZWRcbiAgICovXG5cblxuICBmdW5jdGlvbiBhcHBseVN0eWxlKGFmZmVjdGVkRWxlbWVudCkge1xuICAgIGlmIChhZmZlY3RlZEVsZW1lbnQucHJvdGVjdGlvbk9ic2VydmVyKSB7XG4gICAgICAvLyBTdHlsZSBpcyBhbHJlYWR5IGFwcGxpZWQgYW5kIHByb3RlY3RlZCBieSB0aGUgb2JzZXJ2ZXJcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYmVmb3JlU3R5bGVBcHBsaWVkKSB7XG4gICAgICBhZmZlY3RlZEVsZW1lbnQgPSBiZWZvcmVTdHlsZUFwcGxpZWQoYWZmZWN0ZWRFbGVtZW50KTtcblxuICAgICAgaWYgKCFhZmZlY3RlZEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfYWZmZWN0ZWRFbGVtZW50ID0gYWZmZWN0ZWRFbGVtZW50LFxuICAgICAgICBub2RlID0gX2FmZmVjdGVkRWxlbWVudC5ub2RlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZmZlY3RlZEVsZW1lbnQucnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdHlsZSA9IGFmZmVjdGVkRWxlbWVudC5ydWxlc1tpXS5zdHlsZTtcblxuICAgICAgaWYgKHN0eWxlWydyZW1vdmUnXSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHJlbW92ZUVsZW1lbnQoYWZmZWN0ZWRFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRTdHlsZVRvRWxlbWVudChub2RlLCBzdHlsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHN0eWxlIHRvIHRoZSBzcGVjaWZpZWQgRE9NIG5vZGVcbiAgICogQHBhcmFtIG5vZGUgZWxlbWVudFxuICAgKiBAcGFyYW0gc3R5bGUgc3R5bGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRTdHlsZVRvRWxlbWVudChub2RlLCBzdHlsZSkge1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAvLyBBcHBseSB0aGlzIHN0eWxlIG9ubHkgdG8gZXhpc3RpbmcgcHJvcGVydGllc1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIGhhc093blByb3BlcnR5IGhlcmUgKGRvZXMgbm90IHdvcmsgaW4gRkYpXG4gICAgICBpZiAodHlwZW9mIG5vZGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07IC8vIEZpcnN0IHdlIHNob3VsZCByZW1vdmUgIWltcG9ydGFudCBhdHRyaWJ1dGUgKG9yIGl0IHdvbid0IGJlIGFwcGxpZWQnKVxuXG4gICAgICAgIHZhbHVlID0gcmVtb3ZlU3VmZml4KHZhbHVlLnRyaW0oKSwgJyFpbXBvcnRhbnQnKS50cmltKCk7XG4gICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgdmFsdWUsICdpbXBvcnRhbnQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV2ZXJ0cyBzdHlsZSBmb3IgdGhlIGFmZmVjdGVkIG9iamVjdFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJldmVydFN0eWxlKGFmZmVjdGVkRWxlbWVudCkge1xuICAgIGlmIChhZmZlY3RlZEVsZW1lbnQucHJvdGVjdGlvbk9ic2VydmVyKSB7XG4gICAgICBhZmZlY3RlZEVsZW1lbnQucHJvdGVjdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBhZmZlY3RlZEVsZW1lbnQubm9kZS5zdHlsZS5jc3NUZXh0ID0gYWZmZWN0ZWRFbGVtZW50Lm9yaWdpbmFsU3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgc3BlY2lmaWVkIHJ1bGUgYW5kIHJldHVybnMgbGlzdCBvZiBlbGVtZW50cyBhZmZlY3RlZFxuICAgKiBAcGFyYW0gcnVsZSBSdWxlIHRvIGFwcGx5XG4gICAqIEByZXR1cm5zIExpc3Qgb2YgZWxlbWVudHMgYWZmZWN0ZWQgYnkgdGhpcyBydWxlXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXBwbHlSdWxlKHJ1bGUpIHtcbiAgICB2YXIgZGVidWcgPSBydWxlLnNlbGVjdG9yLmlzRGVidWdnaW5nKCk7XG4gICAgdmFyIHN0YXJ0O1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBzdGFydCA9IHV0aWxzLkFzeW5jV3JhcHBlci5ub3coKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yO1xuICAgIHZhciBub2RlcyA9IHNlbGVjdG9yLnF1ZXJ5U2VsZWN0b3JBbGwoKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgYWZmZWN0ZWRFbGVtZW50ID0gZmluZEFmZmVjdGVkRWxlbWVudChub2RlKTtcblxuICAgICAgaWYgKGFmZmVjdGVkRWxlbWVudCkge1xuICAgICAgICBhZmZlY3RlZEVsZW1lbnQucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgYXBwbHlTdHlsZShhZmZlY3RlZEVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXBwbHlpbmcgc3R5bGUgZmlyc3QgdGltZVxuICAgICAgICB2YXIgb3JpZ2luYWxTdHlsZSA9IG5vZGUuc3R5bGUuY3NzVGV4dDtcbiAgICAgICAgYWZmZWN0ZWRFbGVtZW50ID0ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgLy8gYWZmZWN0ZWQgRE9NIG5vZGVcbiAgICAgICAgICBydWxlczogW3J1bGVdLFxuICAgICAgICAgIC8vIHJ1bGVzIHRvIGJlIGFwcGxpZWRcbiAgICAgICAgICBvcmlnaW5hbFN0eWxlOiBvcmlnaW5hbFN0eWxlLFxuICAgICAgICAgIC8vIG9yaWdpbmFsIG5vZGUgc3R5bGVcbiAgICAgICAgICBwcm90ZWN0aW9uT2JzZXJ2ZXI6IG51bGwgLy8gc3R5bGUgYXR0cmlidXRlIG9ic2VydmVyXG5cbiAgICAgICAgfTtcbiAgICAgICAgYXBwbHlTdHlsZShhZmZlY3RlZEVsZW1lbnQpO1xuICAgICAgICBhZmZlY3RlZEVsZW1lbnRzLnB1c2goYWZmZWN0ZWRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgdmFyIGVsYXBzZWQgPSB1dGlscy5Bc3luY1dyYXBwZXIubm93KCkgLSBzdGFydDtcblxuICAgICAgaWYgKCEoJ3RpbWluZ1N0YXRzJyBpbiBydWxlKSkge1xuICAgICAgICBydWxlLnRpbWluZ1N0YXRzID0gbmV3IHV0aWxzLlN0YXRzKCk7XG4gICAgICB9XG5cbiAgICAgIHJ1bGUudGltaW5nU3RhdHMucHVzaChlbGFwc2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgZmlsdGVyaW5nIHJ1bGVzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXBwbHlSdWxlcygpIHtcbiAgICB2YXIgZWxlbWVudHNJbmRleCA9IFtdOyAvLyBzb21lIHJ1bGVzIGNvdWxkIG1ha2UgY2FsbCAtIHNlbGVjdG9yLnF1ZXJ5U2VsZWN0b3JBbGwoKSB0ZW1wb3JhcmlseSB0byBjaGFuZ2Ugbm9kZSBpZCBhdHRyaWJ1dGVcbiAgICAvLyB0aGlzIGNhdXNlZCBNdXRhdGlvbk9ic2VydmVyIHRvIGNhbGwgcmVjdXJzaXZlbHlcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vRXh0ZW5kZWRDc3MvaXNzdWVzLzgxXG5cbiAgICBzdG9wT2JzZXJ2ZSgpO1xuICAgIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgIHZhciBub2RlcyA9IGFwcGx5UnVsZShydWxlKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVsZW1lbnRzSW5kZXgsIG5vZGVzKTtcbiAgICB9KTsgLy8gTm93IHJldmVydCBzdHlsZXMgZm9yIGVsZW1lbnRzIHdoaWNoIGFyZSBubyBtb3JlIGFmZmVjdGVkXG5cbiAgICB2YXIgbCA9IGFmZmVjdGVkRWxlbWVudHMubGVuZ3RoOyAvLyBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vIGVsZW1lbnRzIHRvIHByb2Nlc3NcblxuICAgIGlmIChlbGVtZW50c0luZGV4Lmxlbmd0aCA+IDApIHtcbiAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgdmFyIG9iaiA9IGFmZmVjdGVkRWxlbWVudHNbbF07XG5cbiAgICAgICAgaWYgKGVsZW1lbnRzSW5kZXguaW5kZXhPZihvYmoubm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgLy8gVGltZSB0byByZXZlcnQgc3R5bGVcbiAgICAgICAgICByZXZlcnRTdHlsZShvYmopO1xuICAgICAgICAgIGFmZmVjdGVkRWxlbWVudHMuc3BsaWNlKGwsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKCFvYmoucmVtb3ZlZCkge1xuICAgICAgICAgIC8vIEFkZCBzdHlsZSBwcm90ZWN0aW9uIG9ic2VydmVyXG4gICAgICAgICAgLy8gUHJvdGVjdCBcInN0eWxlXCIgYXR0cmlidXRlIGZyb20gY2hhbmdlc1xuICAgICAgICAgIGlmICghb2JqLnByb3RlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgb2JqLnByb3RlY3Rpb25PYnNlcnZlciA9IHByb3RlY3RTdHlsZUF0dHJpYnV0ZShvYmoubm9kZSwgb2JqLnJ1bGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEFmdGVyIHN0eWxlcyBhcmUgYXBwbGllZCB3ZSBjYW4gc3RhcnQgb2JzZXJ2ZSBhZ2FpblxuXG5cbiAgICBvYnNlcnZlKCk7XG4gICAgcHJpbnRUaW1pbmdJbmZvKCk7XG4gIH1cblxuICB2YXIgQVBQTFlfUlVMRVNfREVMQVkgPSAxNTA7XG4gIHZhciBhcHBseVJ1bGVzU2NoZWR1bGVyID0gbmV3IHV0aWxzLkFzeW5jV3JhcHBlcihhcHBseVJ1bGVzLCBBUFBMWV9SVUxFU19ERUxBWSk7XG4gIHZhciBtYWluQ2FsbGJhY2sgPSBhcHBseVJ1bGVzU2NoZWR1bGVyLnJ1bi5iaW5kKGFwcGx5UnVsZXNTY2hlZHVsZXIpO1xuXG4gIGZ1bmN0aW9uIG9ic2VydmUoKSB7XG4gICAgaWYgKGRvbU9ic2VydmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBIYW5kbGUgZHluYW1pY2FsbHkgYWRkZWQgZWxlbWVudHNcblxuXG4gICAgZG9tT2JzZXJ2ZWQgPSB0cnVlO1xuICAgIG9ic2VydmVEb2N1bWVudChtYWluQ2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RvcE9ic2VydmUoKSB7XG4gICAgaWYgKCFkb21PYnNlcnZlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRvbU9ic2VydmVkID0gZmFsc2U7XG4gICAgZGlzY29ubmVjdERvY3VtZW50KG1haW5DYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseSgpIHtcbiAgICBhcHBseVJ1bGVzKCk7XG5cbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGFwcGx5UnVsZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzcG9zZXMgRXh0ZW5kZWRDc3MgYW5kIHJlbW92ZXMgb3VyIHN0eWxlcyBmcm9tIG1hdGNoZWQgZWxlbWVudHNcbiAgICovXG5cblxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHN0b3BPYnNlcnZlKCk7XG4gICAgYWZmZWN0ZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldmVydFN0eWxlKG9iaik7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdGltaW5nc1ByaW50ZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFByaW50cyB0aW1pbmcgaW5mb3JtYXRpb24gZm9yIGFsbCBzZWxlY3RvcnMgbWFya2VkIGFzIFwiZGVidWdcIlxuICAgKi9cblxuICBmdW5jdGlvbiBwcmludFRpbWluZ0luZm8oKSB7XG4gICAgaWYgKHRpbWluZ3NQcmludGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltaW5nc1ByaW50ZWQgPSB0cnVlO1xuICAgIHZhciB0aW1pbmdzID0gcnVsZXMuZmlsdGVyKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICByZXR1cm4gcnVsZS5zZWxlY3Rvci5pc0RlYnVnZ2luZygpO1xuICAgIH0pLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3JUZXh0OiBydWxlLnNlbGVjdG9yLnNlbGVjdG9yVGV4dCxcbiAgICAgICAgdGltaW5nU3RhdHM6IHJ1bGUudGltaW5nU3RhdHNcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBpZiAodGltaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEFkZCBsb2NhdGlvbi5ocmVmIHRvIHRoZSBtZXNzYWdlIHRvIGRpc3Rpbmd1aXNoIGZyYW1lc1xuXG5cbiAgICB1dGlscy5sb2dJbmZvKCdbRXh0ZW5kZWRDc3NdIFRpbWluZ3MgZm9yICVvOlxcbiVvIChpbiBtaWxsaXNlY29uZHMpJywgd2luZG93LmxvY2F0aW9uLmhyZWYsIHRpbWluZ3MpO1xuICB9IC8vIEZpcnN0IG9mIGFsbCBwYXJzZSB0aGUgc3R5bGVzaGVldFxuXG5cbiAgcnVsZXMgPSBFeHRlbmRlZENzc1BhcnNlci5wYXJzZUNzcyhzdHlsZVNoZWV0KTsgLy8gRVhQT1NFXG5cbiAgdGhpcy5kaXNwb3NlID0gZGlzcG9zZTtcbiAgdGhpcy5hcHBseSA9IGFwcGx5O1xuICAvKiogRXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5ICovXG5cbiAgdGhpcy5fZ2V0QWZmZWN0ZWRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWZmZWN0ZWRFbGVtZW50cztcbiAgfTtcbn1cbi8qKlxuICogRXhwb3NlIHF1ZXJ5U2VsZWN0b3JBbGwgZm9yIGRlYnVnZ2luZyBhbmQgdmFsaWRhdGluZyBzZWxlY3RvcnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JUZXh0IHNlbGVjdG9yIHRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbm9UaW1pbmcgaWYgdHJ1ZSAtLSBkbyBub3QgcHJpbnQgdGhlIHRpbWluZyB0byB0aGUgY29uc29sZVxuICogQHJldHVybnMge0FycmF5PE5vZGU+fE5vZGVMaXN0fSBhIGxpc3Qgb2YgZWxlbWVudHMgZm91bmRcbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgYXJndW1lbnQgaXMgbm90IGEgdmFsaWQgc2VsZWN0b3JcbiAqL1xuXG5cbkV4dGVuZGVkQ3NzLnF1ZXJ5ID0gZnVuY3Rpb24gKHNlbGVjdG9yVGV4dCwgbm9UaW1pbmcpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3RvclRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWxlY3RvciB0ZXh0IGlzIGVtcHR5Jyk7XG4gIH1cblxuICB2YXIgbm93ID0gdXRpbHMuQXN5bmNXcmFwcGVyLm5vdztcbiAgdmFyIHN0YXJ0ID0gbm93KCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gRXh0ZW5kZWRTZWxlY3RvckZhY3RvcnkuY3JlYXRlU2VsZWN0b3Ioc2VsZWN0b3JUZXh0KS5xdWVyeVNlbGVjdG9yQWxsKCk7XG4gIH0gZmluYWxseSB7XG4gICAgdmFyIGVuZCA9IG5vdygpO1xuXG4gICAgaWYgKCFub1RpbWluZykge1xuICAgICAgdXRpbHMubG9nSW5mbyhcIltFeHRlbmRlZENzc10gRWxhcHNlZDogXCIuY29uY2F0KE1hdGgucm91bmQoKGVuZCAtIHN0YXJ0KSAqIDEwMDApLCBcIiBcXHUwM0JDcy5cIikpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRXh0ZW5kZWRDc3M7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/extended-css/dist/extended-css.esm.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/OTZjZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0wsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUEwQixvQkFBb0IsQ0FBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js":
/*!************************************************************!*\
  !*** ./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n/**\n * AdGuard Scriptlets\n * Version 1.3.20\n */\n\n/**\n * Returns wildcard symbol\n * @returns {string} '*'\n */\nvar getWildcardSymbol = function getWildcardSymbol() {\n  return '*';\n};\n\n/**\n * Generate random six symbols id\n */\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n}\n\n/**\n * Set getter and setter to property if it's configurable\n * @param {Object} object target object with property\n * @param {string} property property name\n * @param {Object} descriptor contains getter and setter functions\n * @returns {boolean} is operation successful\n */\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\n\n/**\n * @typedef Chain\n * @property {Object} base\n * @property {string} prop\n * @property {string} [chain]\n */\n\n/**\n * Check if the property exists in the base object (recursively)\n *\n * If property doesn't exist in base object,\n * defines this property as 'undefined'\n * and returns base, property name and remaining part of property chain\n *\n * @param {Object} base\n * @param {string} chain\n * @returns {Chain}\n */\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos); // https://github.com/AdguardTeam/Scriptlets/issues/128\n\n  if (base === null) {\n    // if base is null, return 'null' as base.\n    // it's needed for triggering the reason logging while debugging\n    return {\n      base: base,\n      prop: prop,\n      chain: chain\n    };\n  }\n\n  var nextBase = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (nextBase !== undefined) {\n    return getPropertyInChain(nextBase, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: nextBase,\n    prop: prop,\n    chain: chain\n  };\n}\n\n/**\n * @typedef Chain\n * @property {Object} base\n * @property {string} prop\n * @property {string} [chain]\n */\n\n/**\n * Check if the property exists in the base object (recursively).\n * Similar to getPropertyInChain but upgraded for json-prune:\n * handle wildcard properties and does not define nonexistent base property as 'undefined'\n *\n * @param {Object} base\n * @param {string} chain\n * @param {boolean} [lookThrough=false]\n * should the method look through it's props in order to wildcard\n * @param {Array} [output=[]] result acc\n * @returns {Chain[]} array of objects\n */\n\nfunction getWildcardPropertyInChain(base, chain) {\n  var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    // for paths like 'a.b.*' every final nested prop should be processed\n    if (chain === getWildcardSymbol() || chain === '[]') {\n      // eslint-disable-next-line no-restricted-syntax\n      for (var key in base) {\n        // to process each key in base except inherited ones\n        if (Object.prototype.hasOwnProperty.call(base, key)) {\n          output.push({\n            base: base,\n            prop: key\n          });\n        }\n      }\n    } else {\n      output.push({\n        base: base,\n        prop: chain\n      });\n    }\n\n    return output;\n  }\n\n  var prop = chain.slice(0, pos);\n  var shouldLookThrough = prop === '[]' && Array.isArray(base) || prop === getWildcardSymbol() && base instanceof Object;\n\n  if (shouldLookThrough) {\n    var nextProp = chain.slice(pos + 1);\n    var baseKeys = Object.keys(base); // if there is a wildcard prop in input chain (e.g. 'ad.*.src' for 'ad.0.src ad.1.src'),\n    // each one of base keys should be considered as a potential chain prop in final path\n\n    baseKeys.forEach(function (key) {\n      var item = base[key];\n      getWildcardPropertyInChain(item, nextProp, lookThrough, output);\n    });\n  }\n\n  var nextBase = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (nextBase !== undefined) {\n    getWildcardPropertyInChain(nextBase, chain, lookThrough, output);\n  }\n\n  return output;\n}\n\n/**\n * Determines whether the passed value is NaN\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN\n * @param {*} num\n * @returns {boolean}\n */\nvar nativeIsNaN = function nativeIsNaN(num) {\n  var native = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat\n\n  return native(num);\n};\n/**\n * Determines whether the passed value is a finite number\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite\n * @param {*} num\n * @returns {boolean}\n */\n\nvar nativeIsFinite = function nativeIsFinite(num) {\n  var native = Number.isFinite || window.isFinite; // eslint-disable-line compat/compat\n\n  return native(num);\n};\n\n/**\n * Converts object to array of pairs.\n * Object.entries() polyfill because it is not supported by IE\n * https://caniuse.com/?search=Object.entries\n * @param {Object} object\n * @returns {Array} array of pairs\n */\nvar getObjectEntries = function getObjectEntries(object) {\n  var keys = Object.keys(object);\n  var entries = [];\n  keys.forEach(function (key) {\n    return entries.push([key, object[key]]);\n  });\n  return entries;\n};\n/**\n * Converts array of pairs to object.\n * Object.fromEntries() polyfill because it is not supported by IE\n * https://caniuse.com/?search=Object.fromEntries\n * @param {Array} entries - array of pairs\n * @returns {Object}\n */\n\nvar getObjectFromEntries = function getObjectFromEntries(entries) {\n  var output = entries.reduce(function (acc, el) {\n    var key = el[0];\n    var value = el[1];\n    acc[key] = value;\n    return acc;\n  }, {});\n  return output;\n};\n/**\n * Checks whether the obj is an empty object\n * @param {Object} obj\n * @returns {boolean}\n */\n\nvar isEmptyObject = function isEmptyObject(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * String.prototype.replaceAll polifill\n * @param {string} input input string\n * @param {string} substr to look for\n * @param {string} newSubstr replacement\n * @returns {string}\n */\n\nvar replaceAll = function replaceAll(input, substr, newSubstr) {\n  return input.split(substr).join(newSubstr);\n};\n/**\n * Escapes special chars in string\n * @param {string} str\n * @returns {string}\n */\n\nvar escapeRegExp = function escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n};\n/**\n * Converts search string to the regexp\n * TODO think about nested dependencies, but be careful with dependency loops\n * @param {string} str search string\n * @returns {RegExp}\n */\n\nvar toRegExp = function toRegExp(str) {\n  if (!str || str === '') {\n    var DEFAULT_VALUE = '.?';\n    return new RegExp(DEFAULT_VALUE);\n  }\n\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n/**\n * Get string before regexp first match\n * @param {string} str\n * @param {RegExp} rx\n */\n\nvar getBeforeRegExp = function getBeforeRegExp(str, rx) {\n  var index = str.search(rx);\n  return str.substring(0, index);\n};\n/**\n * Checks whether the string starts with the substring\n * @param {string} str full string\n * @param {string} prefix substring\n * @returns {boolean}\n */\n\nvar startsWith = function startsWith(str, prefix) {\n  // if str === '', (str && false) will return ''\n  // that's why it has to be !!str\n  return !!str && str.indexOf(prefix) === 0;\n};\n/**\n * Checks whether the string ends with the substring\n * @param {string} str full string\n * @param {string} ending substring\n * @returns {boolean}\n */\n\nvar endsWith = function endsWith(str, ending) {\n  // if str === '', (str && false) will return ''\n  // that's why it has to be !!str\n  return !!str && str.indexOf(ending) === str.length - ending.length;\n};\nvar substringAfter = function substringAfter(str, separator) {\n  if (!str) {\n    return str;\n  }\n\n  var index = str.indexOf(separator);\n  return index < 0 ? '' : str.substring(index + separator.length);\n};\nvar substringBefore = function substringBefore(str, separator) {\n  if (!str || !separator) {\n    return str;\n  }\n\n  var index = str.indexOf(separator);\n  return index < 0 ? str : str.substring(0, index);\n};\n/**\n * Wrap str in single qoutes and replaces single quotes to doudle one\n * @param {string} str\n */\n\nvar wrapInSingleQuotes = function wrapInSingleQuotes(str) {\n  if (str[0] === '\\'' && str[str.length - 1] === '\\'' || str[0] === '\"' && str[str.length - 1] === '\"') {\n    str = str.substring(1, str.length - 1);\n  } // eslint-disable-next-line no-useless-escape\n\n\n  str = str.replace(/\\'/g, '\"');\n  return \"'\".concat(str, \"'\");\n};\n/**\n * Returns substring enclosed in the widest braces\n * @param {string} str\n */\n\nvar getStringInBraces = function getStringInBraces(str) {\n  var firstIndex = str.indexOf('(');\n  var lastIndex = str.lastIndexOf(')');\n  return str.substring(firstIndex + 1, lastIndex);\n};\n/**\n * Prepares RTCPeerConnection config as string for proper logging\n * @param {*} config\n * @returns {string} stringified config\n*/\n\nvar convertRtcConfigToString = function convertRtcConfigToString(config) {\n  var UNDEF_STR = 'undefined';\n  var str = UNDEF_STR;\n\n  if (config === null) {\n    str = 'null';\n  } else if (config instanceof Object) {\n    var SERVERS_PROP_NAME = 'iceServers';\n    var URLS_PROP_NAME = 'urls';\n    /*\n        const exampleConfig = {\n            'iceServers': [\n                'urls': ['stun:35.66.206.188:443'],\n            ],\n        };\n    */\n\n    if (Object.prototype.hasOwnProperty.call(config, SERVERS_PROP_NAME) && Object.prototype.hasOwnProperty.call(config[SERVERS_PROP_NAME][0], URLS_PROP_NAME) && !!config[SERVERS_PROP_NAME][0][URLS_PROP_NAME]) {\n      str = config[SERVERS_PROP_NAME][0][URLS_PROP_NAME].toString();\n    }\n  }\n\n  return str;\n};\n/**\n * @typedef {Object} MatchData\n * @property {boolean} isInvertedMatch\n * @property {RegExp} matchRegexp\n */\n\n/**\n * Parses match arg with possible negation for no matching.\n * Needed for prevent-setTimeout, prevent-setInterval,\n * prevent-requestAnimationFrame and prevent-window-open\n * @param {string} match\n * @returns {MatchData}\n */\n\nvar parseMatchArg = function parseMatchArg(match) {\n  var INVERT_MARKER = '!';\n  var isInvertedMatch = startsWith(match, INVERT_MARKER);\n  var matchValue = isInvertedMatch ? match.slice(1) : match;\n  var matchRegexp = toRegExp(matchValue);\n  return {\n    isInvertedMatch: isInvertedMatch,\n    matchRegexp: matchRegexp\n  };\n};\n/**\n * @typedef {Object} DelayData\n * @property {boolean} isInvertedDelayMatch\n * @property {number|null} delayMatch\n */\n\n/**\n * Parses delay arg with possible negation for no matching.\n * Needed for prevent-setTimeout and prevent-setInterval\n * @param {string} delay\n * @returns {DelayData}\n */\n\nvar parseDelayArg = function parseDelayArg(delay) {\n  var INVERT_MARKER = '!';\n  var isInvertedDelayMatch = startsWith(delay, INVERT_MARKER);\n  var delayValue = isInvertedDelayMatch ? delay.slice(1) : delay;\n  delayValue = parseInt(delayValue, 10);\n  var delayMatch = nativeIsNaN(delayValue) ? null : delayValue;\n  return {\n    isInvertedDelayMatch: isInvertedDelayMatch,\n    delayMatch: delayMatch\n  };\n};\n/**\n * Converts object to string for logging\n * @param {Object} obj data object\n * @returns {string}\n */\n\nvar objectToString = function objectToString(obj) {\n  return isEmptyObject(obj) ? '{}' : getObjectEntries(obj).map(function (pair) {\n    var key = pair[0];\n    var value = pair[1];\n    var recordValueStr = value;\n\n    if (value instanceof Object) {\n      recordValueStr = \"{ \".concat(objectToString(value), \" }\");\n    }\n\n    return \"\".concat(key, \":\\\"\").concat(recordValueStr, \"\\\"\");\n  }).join(' ');\n};\n/**\n * Converts types into a string\n * @param {*} value\n * @returns {string}\n */\n\nvar convertTypeToString = function convertTypeToString(value) {\n  var output;\n\n  if (typeof value === 'undefined') {\n    output = 'undefined';\n  } else if (typeof value === 'object') {\n    if (value === null) {\n      output = 'null';\n    } else {\n      output = objectToString(value);\n    }\n  } else {\n    output = value.toString();\n  }\n\n  return output;\n};\n\n/**\n * Generates function which silents global errors on page generated by scriptlet\n * If error doesn't belong to our error we transfer it to the native onError handler\n * @param {string} rid - unique identifier of scriptlet\n * @return {onError}\n */\nfunction createOnErrorHandler(rid) {\n  // eslint-disable-next-line consistent-return\n  var nativeOnError = window.onerror;\n  return function onError(error) {\n    if (typeof error === 'string' && error.indexOf(rid) !== -1) {\n      return true;\n    }\n\n    if (nativeOnError instanceof Function) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOnError.apply(this, [error].concat(args));\n    }\n\n    return false;\n  };\n}\n\n/**\n * Noop function\n * @return {undefined} undefined\n */\nvar noopFunc = function noopFunc() {};\n/**\n * Function returns null\n * @return {null} null\n */\n\nvar noopNull = function noopNull() {\n  return null;\n};\n/**\n * Function returns true\n * @return {boolean} true\n */\n\nvar trueFunc = function trueFunc() {\n  return true;\n};\n/**\n * Function returns false\n * @return {boolean} false\n */\n\nvar falseFunc = function falseFunc() {\n  return false;\n};\n/**\n * Function returns this\n */\n\nfunction noopThis() {\n  return this;\n}\n/**\n * Function returns empty string\n * @return {string} empty string\n */\n\nvar noopStr = function noopStr() {\n  return '';\n};\n/**\n * Function returns empty array\n * @return {Array} empty array\n */\n\nvar noopArray = function noopArray() {\n  return [];\n};\n/**\n * Function returns empty object\n * @return {Object} empty object\n */\n\nvar noopObject = function noopObject() {\n  return {};\n};\n/**\n * Function returns Promise.reject()\n */\n\nvar noopPromiseReject = function noopPromiseReject() {\n  return Promise.reject();\n}; // eslint-disable-line compat/compat\n\n/**\n * Returns Promise object that is resolved with an empty response\n */\n// eslint-disable-next-line compat/compat\n\nvar noopPromiseResolve = function noopPromiseResolve() {\n  return Promise.resolve(new Response());\n};\n\n/* eslint-disable no-console, no-underscore-dangle */\n\n/**\n * Hit used only for debug purposes now\n * @param {Source} source\n * @param {string} [message] - optional message;\n * use LOG_MARKER = 'log: ' at the start of a message\n * for logging scriptlets\n */\nvar hit = function hit(source, message) {\n  if (source.verbose !== true) {\n    return;\n  }\n\n  try {\n    var log = console.log.bind(console);\n    var trace = console.trace.bind(console); // eslint-disable-line compat/compat\n\n    var prefix = source.ruleText || '';\n\n    if (source.domainName) {\n      var AG_SCRIPTLET_MARKER = '#%#//';\n      var UBO_SCRIPTLET_MARKER = '##+js';\n      var ruleStartIndex;\n\n      if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {\n        ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);\n      } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {\n        ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);\n      } // delete all domains from ruleText and leave just rule part\n\n\n      var rulePart = source.ruleText.slice(ruleStartIndex); // prepare applied scriptlet rule for specific domain\n\n      prefix = \"\".concat(source.domainName).concat(rulePart);\n    } // Used to check if scriptlet uses 'hit' function for logging\n\n\n    var LOG_MARKER = 'log: ';\n\n    if (message) {\n      if (message.indexOf(LOG_MARKER) === -1) {\n        log(\"\".concat(prefix, \" message:\\n\").concat(message));\n      } else {\n        log(message.slice(LOG_MARKER.length));\n      }\n    }\n\n    log(\"\".concat(prefix, \" trace start\"));\n\n    if (trace) {\n      trace();\n    }\n\n    log(\"\".concat(prefix, \" trace end\"));\n  } catch (e) {// try catch for Edge 15\n    // In according to this issue https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14495220/\n    // console.log throws an error\n  } // This is necessary for unit-tests only!\n\n\n  if (typeof window.__debug === 'function') {\n    window.__debug(source);\n  }\n};\n\n/**\n * DOM tree changes observer. Used for 'remove-attr' and 'remove-class' scriptlets\n * @param {Function} callback\n * @param {Boolean} observeAttrs - optional parameter - should observer check attibutes changes\n */\nvar observeDOMChanges = function observeDOMChanges(callback) {\n  var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var attrsToObserv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  /**\n   * Returns a wrapper, passing the call to 'method' at maximum once per 'delay' milliseconds.\n   * Those calls that fall into the \"cooldown\" period, are ignored\n   * @param {Function} method\n   * @param {Number} delay - milliseconds\n   */\n  var throttle = function throttle(method, delay) {\n    var wait = false;\n    var savedArgs;\n\n    var wrapper = function wrapper() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (wait) {\n        savedArgs = args;\n        return;\n      }\n\n      method.apply(void 0, args);\n      wait = true;\n      setTimeout(function () {\n        wait = false;\n\n        if (savedArgs) {\n          wrapper(savedArgs);\n          savedArgs = null;\n        }\n      }, delay);\n    };\n\n    return wrapper;\n  };\n  /**\n   * 'delay' in milliseconds for 'throttle' method\n   */\n\n\n  var THROTTLE_DELAY_MS = 20;\n  /**\n   * Used for remove-class\n   */\n  // eslint-disable-next-line no-use-before-define, compat/compat\n\n  var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));\n\n  var connect = function connect() {\n    if (attrsToObserv.length > 0) {\n      observer.observe(document.documentElement, {\n        childList: true,\n        subtree: true,\n        attributes: observeAttrs,\n        attributeFilter: attrsToObserv\n      });\n    } else {\n      observer.observe(document.documentElement, {\n        childList: true,\n        subtree: true,\n        attributes: observeAttrs\n      });\n    }\n  };\n\n  var disconnect = function disconnect() {\n    observer.disconnect();\n  };\n\n  function callbackWrapper() {\n    disconnect();\n    callback();\n    connect();\n  }\n\n  connect();\n};\n\n/**\n * Checks if the stackTrace contains stackRegexp\n * // https://github.com/AdguardTeam/Scriptlets/issues/82\n * @param {string|undefined} stackMatch - input stack value to match\n * @param {string} stackTrace - script error stack trace\n * @returns {boolean}\n */\n\nvar matchStackTrace = function matchStackTrace(stackMatch, stackTrace) {\n  if (!stackMatch || stackMatch === '') {\n    return true;\n  }\n\n  var stackRegexp = toRegExp(stackMatch);\n  var refinedStackTrace = stackTrace.split('\\n').slice(2) // get rid of our own functions in the stack trace\n  .map(function (line) {\n    return line.trim();\n  }) // trim the lines\n  .join('\\n');\n  return stackRegexp.test(refinedStackTrace);\n};\n\n/**\n * Some browsers do not support Array.prototype.flat()\n * for example, Opera 42 which is used for browserstack tests\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\n * @param {Array} input\n */\nvar flatten = function flatten(input) {\n  var stack = [];\n  input.forEach(function (el) {\n    return stack.push(el);\n  });\n  var res = [];\n\n  while (stack.length) {\n    // pop value from stack\n    var next = stack.pop();\n\n    if (Array.isArray(next)) {\n      // push back array items, won't modify the original input\n      next.forEach(function (el) {\n        return stack.push(el);\n      });\n    } else {\n      res.push(next);\n    }\n  } // reverse to restore input order\n\n\n  return res.reverse();\n};\n\n/**\n * Finds shadow-dom host (elements with shadowRoot property) in DOM of rootElement.\n * @param {HTMLElement} rootElement\n * @returns {HTMLElement[]} shadow-dom hosts\n */\n\nvar findHostElements = function findHostElements(rootElement) {\n  var hosts = []; // Element.querySelectorAll() returns list of elements\n  // which are defined in DOM of Element.\n  // Meanwhile, inner DOM of the element with shadowRoot property\n  // is absolutely another DOM and which can not be reached by querySelectorAll('*')\n\n  var domElems = rootElement.querySelectorAll('*');\n  domElems.forEach(function (el) {\n    if (el.shadowRoot) {\n      hosts.push(el);\n    }\n  });\n  return hosts;\n};\n/**\n * A collection of nodes.\n *\n * @external NodeList\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/NodeList NodeList}\n */\n\n/**\n * @typedef {Object} PierceData\n * @property {HTMLElement[]} targets found elements that match the specified selector\n * @property {HTMLElement[]} innerHosts inner shadow-dom hosts\n */\n\n/**\n * Pierces open shadow-dom in order to find:\n * - elements by 'selector' matching\n * - inner shadow-dom hosts\n * @param {string} selector\n * @param {HTMLElement[]|external:NodeList} hostElements\n * @returns {PierceData}\n */\n\nvar pierceShadowDom = function pierceShadowDom(selector, hostElements) {\n  var targets = [];\n  var innerHostsAcc = []; // it's possible to get a few hostElements found by baseSelector on the page\n\n  hostElements.forEach(function (host) {\n    // check presence of selector element inside base element if it's not in shadow-dom\n    var simpleElems = host.querySelectorAll(selector);\n    targets = targets.concat([].slice.call(simpleElems));\n    var shadowRootElem = host.shadowRoot;\n    var shadowChildren = shadowRootElem.querySelectorAll(selector);\n    targets = targets.concat([].slice.call(shadowChildren)); // find inner shadow-dom hosts inside processing shadow-dom\n\n    innerHostsAcc.push(findHostElements(shadowRootElem));\n  }); // if there were more than one host element,\n  // innerHostsAcc is an array of arrays and should be flatten\n\n  var innerHosts = flatten(innerHostsAcc);\n  return {\n    targets: targets,\n    innerHosts: innerHosts\n  };\n};\n\n/**\n * Prepares cookie string if given parameters are ok\n * @param {string} name cookie name to set\n * @param {string} value cookie value to set\n * @returns {string|null} cookie string if ok OR null if not\n */\n\nvar prepareCookie = function prepareCookie(name, value) {\n  if (!name || !value) {\n    return null;\n  }\n\n  var valueToSet;\n\n  if (value === 'true') {\n    valueToSet = 'true';\n  } else if (value === 'True') {\n    valueToSet = 'True';\n  } else if (value === 'false') {\n    valueToSet = 'false';\n  } else if (value === 'False') {\n    valueToSet = 'False';\n  } else if (value === 'yes') {\n    valueToSet = 'yes';\n  } else if (value === 'Yes') {\n    valueToSet = 'Yes';\n  } else if (value === 'Y') {\n    valueToSet = 'Y';\n  } else if (value === 'no') {\n    valueToSet = 'no';\n  } else if (value === 'ok') {\n    valueToSet = 'ok';\n  } else if (value === 'OK') {\n    valueToSet = 'OK';\n  } else if (/^\\d+$/.test(value)) {\n    valueToSet = parseFloat(value);\n\n    if (nativeIsNaN(valueToSet)) {\n      return null;\n    }\n\n    if (Math.abs(valueToSet) < 0 || Math.abs(valueToSet) > 15) {\n      return null;\n    }\n  } else {\n    return null;\n  }\n\n  var pathToSet = 'path=/;';\n  var cookieData = \"\".concat(encodeURIComponent(name), \"=\").concat(encodeURIComponent(valueToSet), \"; \").concat(pathToSet);\n  return cookieData;\n};\n\nvar shouldMatchAnyDelay = function shouldMatchAnyDelay(delay) {\n  return delay === getWildcardSymbol();\n};\n/**\n * Handles input delay value\n * @param {*} delay\n * @returns {number} proper number delay value\n */\n\nvar getMatchDelay = function getMatchDelay(delay) {\n  var DEFAULT_DELAY = 1000;\n  var parsedDelay = parseInt(delay, 10);\n  var delayMatch = nativeIsNaN(parsedDelay) ? DEFAULT_DELAY // default scriptlet value\n  : parsedDelay;\n  return delayMatch;\n};\n/**\n * Checks delay match condition\n * @param {*} inputDelay\n * @param {number} realDelay\n * @returns {boolean}\n */\n\nvar isDelayMatched = function isDelayMatched(inputDelay, realDelay) {\n  return shouldMatchAnyDelay(inputDelay) || realDelay === getMatchDelay(inputDelay);\n};\n/**\n * Handles input boost value\n * @param {*} boost\n * @returns {number} proper number boost multiplier value\n */\n\nvar getBoostMultiplier = function getBoostMultiplier(boost) {\n  var DEFAULT_MULTIPLIER = 0.05;\n  var MIN_MULTIPLIER = 0.02;\n  var MAX_MULTIPLIER = 50;\n  var parsedBoost = parseFloat(boost);\n  var boostMultiplier = nativeIsNaN(parsedBoost) || !nativeIsFinite(parsedBoost) ? DEFAULT_MULTIPLIER // default scriptlet value\n  : parsedBoost;\n\n  if (boostMultiplier < MIN_MULTIPLIER) {\n    boostMultiplier = MIN_MULTIPLIER;\n  }\n\n  if (boostMultiplier > MAX_MULTIPLIER) {\n    boostMultiplier = MAX_MULTIPLIER;\n  }\n\n  return boostMultiplier;\n};\n\n/**\n * Collects Request options to object\n * @param {Request} request\n * @returns {Object} data object\n */\n\nvar getRequestData = function getRequestData(request) {\n  var REQUEST_INIT_OPTIONS = ['url', 'method', 'headers', 'body', 'mode', 'credentials', 'cache', 'redirect', 'referrer', 'integrity'];\n  var entries = REQUEST_INIT_OPTIONS.map(function (key) {\n    // if request has no such option, value will be undefined\n    var value = request[key];\n    return [key, value];\n  });\n  return getObjectFromEntries(entries);\n};\n/**\n * Collects fetch args to object\n * @param {*} args fetch args\n * @returns {Object} data object\n */\n\nvar getFetchData = function getFetchData(args) {\n  var fetchPropsObj = {};\n  var fetchUrl;\n  var fetchInit;\n\n  if (args[0] instanceof Request) {\n    // if Request passed to fetch, it will be in array\n    var requestData = getRequestData(args[0]);\n    fetchUrl = requestData.url;\n    fetchInit = requestData;\n  } else {\n    fetchUrl = args[0]; // eslint-disable-line prefer-destructuring\n\n    fetchInit = args[1]; // eslint-disable-line prefer-destructuring\n  }\n\n  fetchPropsObj.url = fetchUrl;\n\n  if (fetchInit instanceof Object) {\n    Object.keys(fetchInit).forEach(function (prop) {\n      fetchPropsObj[prop] = fetchInit[prop];\n    });\n  }\n\n  return fetchPropsObj;\n};\n/**\n * Converts prevent-fetch propsToMatch input string to object\n * @param {string} propsToMatchStr\n * @returns {Object} object where 'key' is prop name and 'value' is prop value\n */\n\nvar convertMatchPropsToObj = function convertMatchPropsToObj(propsToMatchStr) {\n  var PROPS_DIVIDER = ' ';\n  var PAIRS_MARKER = ':';\n  var propsObj = {};\n  var props = propsToMatchStr.split(PROPS_DIVIDER);\n  props.forEach(function (prop) {\n    var dividerInd = prop.indexOf(PAIRS_MARKER);\n\n    if (dividerInd === -1) {\n      propsObj.url = toRegExp(prop);\n    } else {\n      var key = prop.slice(0, dividerInd);\n      var value = prop.slice(dividerInd + 1);\n      propsObj[key] = toRegExp(value);\n    }\n  });\n  return propsObj;\n};\n\nvar handleOldReplacement = function handleOldReplacement(replacement) {\n  var result; // defaults to return noopFunc instead of window.open\n\n  if (!replacement) {\n    result = noopFunc;\n  } else if (replacement === 'trueFunc') {\n    result = trueFunc;\n  } else if (replacement.indexOf('=') > -1) {\n    // We should return noopFunc instead of window.open\n    // but with some property if website checks it (examples 5, 6)\n    // https://github.com/AdguardTeam/Scriptlets/issues/71\n    var isProp = startsWith(replacement, '{') && endsWith(replacement, '}');\n\n    if (isProp) {\n      var propertyPart = replacement.slice(1, -1);\n      var propertyName = substringBefore(propertyPart, '=');\n      var propertyValue = substringAfter(propertyPart, '=');\n\n      if (propertyValue === 'noopFunc') {\n        result = {};\n        result[propertyName] = noopFunc;\n      }\n    }\n  }\n\n  return result;\n};\nvar createDecoy = function createDecoy(args) {\n  var OBJECT_TAG_NAME = 'object';\n  var OBJECT_URL_PROP_NAME = 'data';\n  var IFRAME_TAG_NAME = 'iframe';\n  var IFRAME_URL_PROP_NAME = 'src';\n  var replacement = args.replacement,\n      url = args.url,\n      delay = args.delay;\n  var tag;\n  var urlProp;\n\n  if (replacement === 'obj') {\n    tag = OBJECT_TAG_NAME;\n    urlProp = OBJECT_URL_PROP_NAME;\n  } else {\n    tag = IFRAME_TAG_NAME;\n    urlProp = IFRAME_URL_PROP_NAME;\n  }\n\n  var decoy = document.createElement(tag);\n  decoy[urlProp] = url;\n  decoy.style.setProperty('height', '1px', 'important');\n  decoy.style.setProperty('position', 'fixed', 'important');\n  decoy.style.setProperty('top', '-1px', 'important');\n  decoy.style.setProperty('width', '1px', 'important');\n  document.body.appendChild(decoy);\n  setTimeout(function () {\n    return decoy.remove();\n  }, delay * 1000);\n  return decoy;\n};\nvar getPreventGetter = function getPreventGetter(nativeGetter) {\n  var preventGetter = function preventGetter(target, prop) {\n    if (prop && prop === 'closed') {\n      return false;\n    }\n\n    if (typeof nativeGetter === 'function') {\n      return noopFunc;\n    }\n\n    return prop && target[prop];\n  };\n\n  return preventGetter;\n};\n\n/**\n * Validates event type\n * @param {*} type\n * @returns {boolean}\n */\nvar validateType = function validateType(type) {\n  // https://github.com/AdguardTeam/Scriptlets/issues/125\n  return typeof type !== 'undefined';\n};\n/**\n * Validates event listener\n * @param {*} listener\n * @returns {boolean}\n */\n\nvar validateListener = function validateListener(listener) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters\n  return typeof listener !== 'undefined' && (typeof listener === 'function' || typeof listener === 'object' // https://github.com/AdguardTeam/Scriptlets/issues/76\n  && listener !== null && typeof listener.handleEvent === 'function');\n};\n/**\n * Serialize valid event listener\n * https://developer.mozilla.org/en-US/docs/Web/API/EventListener\n * @param {EventListener} listener valid listener\n * @returns {string}\n */\n\nvar listenerToString = function listenerToString(listener) {\n  return typeof listener === 'function' ? listener.toString() : listener.handleEvent.toString();\n};\n\n/**\n * This file must export all used dependencies\n */\n\nvar dependencies = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    getWildcardSymbol: getWildcardSymbol,\n    randomId: randomId,\n    setPropertyAccess: setPropertyAccess,\n    getPropertyInChain: getPropertyInChain,\n    getWildcardPropertyInChain: getWildcardPropertyInChain,\n    replaceAll: replaceAll,\n    escapeRegExp: escapeRegExp,\n    toRegExp: toRegExp,\n    getBeforeRegExp: getBeforeRegExp,\n    startsWith: startsWith,\n    endsWith: endsWith,\n    substringAfter: substringAfter,\n    substringBefore: substringBefore,\n    wrapInSingleQuotes: wrapInSingleQuotes,\n    getStringInBraces: getStringInBraces,\n    convertRtcConfigToString: convertRtcConfigToString,\n    parseMatchArg: parseMatchArg,\n    parseDelayArg: parseDelayArg,\n    objectToString: objectToString,\n    convertTypeToString: convertTypeToString,\n    createOnErrorHandler: createOnErrorHandler,\n    noopFunc: noopFunc,\n    noopNull: noopNull,\n    trueFunc: trueFunc,\n    falseFunc: falseFunc,\n    noopThis: noopThis,\n    noopStr: noopStr,\n    noopArray: noopArray,\n    noopObject: noopObject,\n    noopPromiseReject: noopPromiseReject,\n    noopPromiseResolve: noopPromiseResolve,\n    hit: hit,\n    observeDOMChanges: observeDOMChanges,\n    matchStackTrace: matchStackTrace,\n    findHostElements: findHostElements,\n    pierceShadowDom: pierceShadowDom,\n    flatten: flatten,\n    prepareCookie: prepareCookie,\n    nativeIsNaN: nativeIsNaN,\n    nativeIsFinite: nativeIsFinite,\n    shouldMatchAnyDelay: shouldMatchAnyDelay,\n    getMatchDelay: getMatchDelay,\n    isDelayMatched: isDelayMatched,\n    getBoostMultiplier: getBoostMultiplier,\n    getRequestData: getRequestData,\n    getFetchData: getFetchData,\n    convertMatchPropsToObj: convertMatchPropsToObj,\n    getObjectEntries: getObjectEntries,\n    getObjectFromEntries: getObjectFromEntries,\n    isEmptyObject: isEmptyObject,\n    handleOldReplacement: handleOldReplacement,\n    createDecoy: createDecoy,\n    getPreventGetter: getPreventGetter,\n    validateType: validateType,\n    validateListener: validateListener,\n    listenerToString: listenerToString\n});\n\n/**\n * Concat dependencies to scriptlet code\n * @param {string} scriptlet string view of scriptlet\n */\n\nfunction attachDependencies(scriptlet) {\n  var _scriptlet$injections = scriptlet.injections,\n      injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;\n  return injections.reduce(function (accum, dep) {\n    return \"\".concat(accum, \"\\n\").concat(dependencies[dep.name]);\n  }, scriptlet.toString());\n}\n/**\n * Add scriptlet call to existing code\n * @param {Function} scriptlet\n * @param {string} code\n */\n\nfunction addCall(scriptlet, code) {\n  return \"\".concat(code, \";\\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\\n        \").concat(scriptlet.name, \".apply(this, updatedArgs);\\n    \");\n}\n/**\n * Wrap function into IIFE (Immediately invoked function expression)\n *\n * @param {Source} source - object with scriptlet properties\n * @param {string} code - scriptlet source code with dependencies\n *\n * @returns {string} full scriptlet code\n *\n * @example\n * const source = {\n *      args: [\"aaa\", \"bbb\"],\n *      name: 'noeval',\n * };\n * const code = \"function noeval(source, args) { alert(source); } noeval.apply(this, args);\"\n * const result = wrapInIIFE(source, code);\n *\n * // result\n * `(function(source, args) {\n *      function noeval(source) { alert(source); }\n *      noeval.apply(this, args);\n * )({\"args\": [\"aaa\", \"bbb\"], \"name\":\"noeval\"}, [\"aaa\", \"bbb\"])`\n */\n\nfunction passSourceAndProps(source, code) {\n  if (source.hit) {\n    source.hit = source.hit.toString();\n  }\n\n  var sourceString = JSON.stringify(source);\n  var argsString = source.args ? \"[\".concat(source.args.map(JSON.stringify), \"]\") : undefined;\n  var params = argsString ? \"\".concat(sourceString, \", \").concat(argsString) : sourceString;\n  return \"(function(source, args){\\n\".concat(code, \"\\n})(\").concat(params, \");\");\n}\n/**\n * Wrap code in no name function\n * @param {string} code which must be wrapped\n */\n\nfunction wrapInNonameFunc(code) {\n  return \"function(source, args){\\n\".concat(code, \"\\n}\");\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar defineProperty = _defineProperty;\n\n/**\n * Iterate over iterable argument and evaluate current state with transitions\n * @param {string} init first transition name\n * @param {Array|Collection|string} iterable\n * @param {Object} transitions transtion functions\n * @param {any} args arguments which should be passed to transition functions\n */\nfunction iterateWithTransitions(iterable, transitions, init, args) {\n  var state = init || Object.keys(transitions)[0];\n\n  for (var i = 0; i < iterable.length; i += 1) {\n    state = transitions[state](iterable, i, args);\n  }\n\n  return state;\n}\n/**\n * AdGuard scriptlet rule mask\n */\n\n\nvar ADG_SCRIPTLET_MASK = '#//scriptlet';\n/**\n * Helper to accumulate an array of strings char by char\n */\n\nvar wordSaver = function wordSaver() {\n  var str = '';\n  var strs = [];\n\n  var saveSymb = function saveSymb(s) {\n    str += s;\n    return str;\n  };\n\n  var saveStr = function saveStr() {\n    strs.push(str);\n    str = '';\n  };\n\n  var getAll = function getAll() {\n    return [].concat(strs);\n  };\n\n  return {\n    saveSymb: saveSymb,\n    saveStr: saveStr,\n    getAll: getAll\n  };\n};\n\nvar substringAfter$1 = function substringAfter(str, separator) {\n  if (!str) {\n    return str;\n  }\n\n  var index = str.indexOf(separator);\n  return index < 0 ? '' : str.substring(index + separator.length);\n};\n/**\n * Parse and validate scriptlet rule\n * @param {*} ruleText\n * @returns {{name: string, args: Array<string>}}\n */\n\n\nvar parseRule = function parseRule(ruleText) {\n  var _transitions;\n\n  ruleText = substringAfter$1(ruleText, ADG_SCRIPTLET_MASK);\n  /**\n   * Transition names\n   */\n\n  var TRANSITION = {\n    OPENED: 'opened',\n    PARAM: 'param',\n    CLOSED: 'closed'\n  };\n  /**\n   * Transition function: the current index position in start, end or between params\n   * @param {string} rule\n   * @param {number} index\n   * @param {Object} Object\n   * @property {Object} Object.sep contains prop symb with current separator char\n   */\n\n  var opened = function opened(rule, index, _ref) {\n    var sep = _ref.sep;\n    var char = rule[index];\n    var transition;\n\n    switch (char) {\n      case ' ':\n      case '(':\n      case ',':\n        {\n          transition = TRANSITION.OPENED;\n          break;\n        }\n\n      case '\\'':\n      case '\"':\n        {\n          sep.symb = char;\n          transition = TRANSITION.PARAM;\n          break;\n        }\n\n      case ')':\n        {\n          transition = index === rule.length - 1 ? TRANSITION.CLOSED : TRANSITION.OPENED;\n          break;\n        }\n\n      default:\n        {\n          throw new Error('The rule is not a scriptlet');\n        }\n    }\n\n    return transition;\n  };\n  /**\n   * Transition function: the current index position inside param\n   * @param {string} rule\n   * @param {number} index\n   * @param {Object} Object\n   * @property {Object} Object.sep contains prop `symb` with current separator char\n   * @property {Object} Object.saver helper which allow to save strings by car by char\n   */\n\n\n  var param = function param(rule, index, _ref2) {\n    var saver = _ref2.saver,\n        sep = _ref2.sep;\n    var char = rule[index];\n\n    switch (char) {\n      case '\\'':\n      case '\"':\n        {\n          var preIndex = index - 1;\n          var before = rule[preIndex];\n\n          if (char === sep.symb && before !== '\\\\') {\n            sep.symb = null;\n            saver.saveStr();\n            return TRANSITION.OPENED;\n          }\n        }\n      // eslint-disable-next-line no-fallthrough\n\n      default:\n        {\n          saver.saveSymb(char);\n          return TRANSITION.PARAM;\n        }\n    }\n  };\n\n  var transitions = (_transitions = {}, defineProperty(_transitions, TRANSITION.OPENED, opened), defineProperty(_transitions, TRANSITION.PARAM, param), defineProperty(_transitions, TRANSITION.CLOSED, function () {}), _transitions);\n  var sep = {\n    symb: null\n  };\n  var saver = wordSaver();\n  var state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, {\n    sep: sep,\n    saver: saver\n  });\n\n  if (state !== 'closed') {\n    throw new Error(\"Invalid scriptlet rule \".concat(ruleText));\n  }\n\n  var args = saver.getAll();\n  return {\n    name: args[0],\n    args: args.slice(1)\n  };\n};\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet abort-on-property-read\n *\n * @description\n * Aborts a script when it attempts to **read** the specified property.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-readjs-\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L864\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('abort-on-property-read', property[, stack])\n * ```\n *\n * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`\n * - `stack` - optional, string or regular expression that must match the current function call stack trace\n *\n * **Examples**\n * ```\n * ! Aborts script when it tries to access `window.alert`\n * example.org#%#//scriptlet('abort-on-property-read', 'alert')\n *\n * ! Aborts script when it tries to access `navigator.language`\n * example.org#%#//scriptlet('abort-on-property-read', 'navigator.language')\n *\n * ! Aborts script when it tries to access `window.adblock` and it's error stack trace contains `test.js`\n * example.org#%#//scriptlet('abort-on-property-read', 'adblock', 'test.js')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction abortOnPropertyRead(source, property, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var rid = randomId();\n\n  var abort = function abort() {\n    hit(source);\n    throw new ReferenceError(rid);\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    setPropertyAccess(base, prop, {\n      get: abort,\n      set: function set() {}\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\nabortOnPropertyRead.names = ['abort-on-property-read', // aliases are needed for matching the related scriptlet converted into our syntax\n'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'ubo-abort-on-property-read', 'ubo-aopr', 'abp-abort-on-property-read'];\nabortOnPropertyRead.injections = [randomId, toRegExp, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, matchStackTrace];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet abort-on-property-write\n *\n * @description\n * Aborts a script when it attempts to **write** the specified property.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-writejs-\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L896\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('abort-on-property-write', property[, stack])\n * ```\n *\n * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`\n * - `stack` - optional, string or regular expression that must match the current function call stack trace\n *\n * **Examples**\n * ```\n * ! Aborts script when it tries to set `window.adblock` value\n * example.org#%#//scriptlet('abort-on-property-write', 'adblock')\n *\n * ! Aborts script when it tries to set `window.adblock` value and it's error stack trace contains `checking.js`\n * example.org#%#//scriptlet('abort-on-property-write', 'adblock', 'checking.js')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction abortOnPropertyWrite(source, property, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var rid = randomId();\n\n  var abort = function abort() {\n    hit(source);\n    throw new ReferenceError(rid);\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    setPropertyAccess(base, prop, {\n      set: abort\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\nabortOnPropertyWrite.names = ['abort-on-property-write', // aliases are needed for matching the related scriptlet converted into our syntax\n'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'ubo-abort-on-property-write', 'ubo-aopw', 'abp-abort-on-property-write'];\nabortOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-setTimeout\n *\n * @description\n * Prevents a `setTimeout` call if:\n * 1) the text of the callback is matching the specified search string/regexp which does not start with `!`;\n * otherwise mismatched calls should be defused;\n * 2) the timeout is matching the specified delay; otherwise mismatched calls should be defused.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-settimeout-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-setTimeout'[, search[, delay]])\n * ```\n *\n * Call with no arguments will log calls to setTimeout while debugging (`log-setTimeout` superseding),\n * so production filter lists' rules definitely require at least one of the parameters:\n * - `search` - optional, string or regular expression.\n * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.\n * If do not start with `!`, the stringified callback will be matched.\n * If not set, prevents all `setTimeout` calls due to specified `delay`.\n * - `delay` - optional, must be an integer.\n * If starts with `!`, scriptlet will not match the delay but all other will be defused.\n * If do not start with `!`, the delay passed to the `setTimeout` call will be matched.\n *\n * > If `prevent-setTimeout` without parameters logs smth like `setTimeout(undefined, 1000)`,\n * it means that no callback was passed to setTimeout() and that's not scriptlet issue\n *\n * **Examples**\n * 1. Prevents `setTimeout` calls if the callback matches `/\\.test/` regardless of the delay.\n *     ```bash\n *     example.org#%#//scriptlet('prevent-setTimeout', '/\\.test/')\n *     ```\n *\n *     For instance, the following call will be prevented:\n *     ```javascript\n *     setTimeout(function () {\n *         window.test = \"value\";\n *     }, 100);\n *     ```\n *\n * 2. Prevents `setTimeout` calls if the callback does not contain `value`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setTimeout', '!value')\n *     ```\n *\n *     For instance, only the first of the following calls will be prevented:\n *     ```javascript\n *     setTimeout(function () {\n *         window.test = \"test -- prevented\";\n *     }, 300);\n *     setTimeout(function () {\n *         window.test = \"value -- executed\";\n *     }, 400);\n *     setTimeout(function () {\n *         window.value = \"test -- executed\";\n *     }, 500);\n *     ```\n *\n * 3. Prevents `setTimeout` calls if the callback contains `value` and the delay is not set to `300`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setTimeout', 'value', '!300')\n *     ```\n *\n *     For instance, only the first of the following calls will not be prevented:\n *     ```javascript\n *     setTimeout(function () {\n *         window.test = \"value 1 -- executed\";\n *     }, 300);\n *     setTimeout(function () {\n *         window.test = \"value 2 -- prevented\";\n *     }, 400);\n *     setTimeout(function () {\n *         window.test = \"value 3 -- prevented\";\n *     }, 500);\n *     ```\n *\n * 4. Prevents `setTimeout` calls if the callback does not contain `value` and the delay is not set to `300`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setTimeout', '!value', '!300')\n *     ```\n *\n *     For instance, only the second of the following calls will be prevented:\n *     ```javascript\n *     setTimeout(function () {\n *         window.test = \"test -- executed\";\n *     }, 300);\n *     setTimeout(function () {\n *         window.test = \"test -- prevented\";\n *     }, 400);\n *     setTimeout(function () {\n *         window.test = \"value -- executed\";\n *     }, 400);\n *     setTimeout(function () {\n *         window.value = \"test -- executed\";\n *     }, 500);\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventSetTimeout(source, match, delay) {\n  var nativeTimeout = window.setTimeout;\n  var log = console.log.bind(console); // eslint-disable-line no-console\n  // logs setTimeouts to console if no arguments have been specified\n\n  var shouldLog = typeof match === 'undefined' && typeof delay === 'undefined';\n\n  var _parseMatchArg = parseMatchArg(match),\n      isInvertedMatch = _parseMatchArg.isInvertedMatch,\n      matchRegexp = _parseMatchArg.matchRegexp;\n\n  var _parseDelayArg = parseDelayArg(delay),\n      isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,\n      delayMatch = _parseDelayArg.delayMatch;\n\n  var timeoutWrapper = function timeoutWrapper(callback, timeout) {\n    var shouldPrevent = false; // https://github.com/AdguardTeam/Scriptlets/issues/105\n\n    var cbString = String(callback);\n\n    if (shouldLog) {\n      hit(source);\n      log(\"setTimeout(\".concat(cbString, \", \").concat(timeout, \")\"));\n    } else if (!delayMatch) {\n      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch;\n    } else if (!match) {\n      shouldPrevent = timeout === delayMatch !== isInvertedDelayMatch;\n    } else {\n      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch && timeout === delayMatch !== isInvertedDelayMatch;\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return nativeTimeout(noopFunc, timeout);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeTimeout.apply(window, [callback, timeout].concat(args));\n  };\n\n  window.setTimeout = timeoutWrapper;\n}\npreventSetTimeout.names = ['prevent-setTimeout', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-setTimeout-if.js', // new implementation of setTimeout-defuser.js\n'ubo-no-setTimeout-if.js', 'nostif.js', // new short name of no-setTimeout-if\n'ubo-nostif.js', 'ubo-no-setTimeout-if', 'ubo-nostif', // old scriptlet names which should be supported as well.\n// should be removed eventually.\n// do not remove until other filter lists maintainers use them\n'setTimeout-defuser.js', 'ubo-setTimeout-defuser.js', 'ubo-setTimeout-defuser', 'std.js', 'ubo-std.js', 'ubo-std'];\npreventSetTimeout.injections = [hit, noopFunc, parseMatchArg, parseDelayArg, toRegExp, startsWith, nativeIsNaN];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-setInterval\n *\n * @description\n * Prevents a `setInterval` call if:\n * 1) the text of the callback is matching the specified `search` string/regexp which does not start with `!`;\n * otherwise mismatched calls should be defused;\n * 2) the interval is matching the specified `delay`; otherwise mismatched calls should be defused.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setinterval-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-setInterval'[, search[, delay]])\n * ```\n *\n * Call with no arguments will log calls to setInterval while debugging (`log-setInterval` superseding),\n * so production filter lists' rules definitely require at least one of the parameters:\n * - `search` - optional, string or regular expression.\n * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.\n * If do not start with `!`, the stringified callback will be matched.\n * If not set, prevents all `setInterval` calls due to specified `delay`.\n * - `delay` - optional, must be an integer.\n * If starts with `!`, scriptlet will not match the delay but all other will be defused.\n * If do not start with `!`, the delay passed to the `setInterval` call will be matched.\n *\n * > If `prevent-setInterval` without parameters logs smth like `setInterval(undefined, 1000)`,\n * it means that no callback was passed to setInterval() and that's not scriptlet issue\n\n *  **Examples**\n * 1. Prevents `setInterval` calls if the callback matches `/\\.test/` regardless of the delay.\n *     ```bash\n *     example.org#%#//scriptlet('prevent-setInterval', '/\\.test/')\n *     ```\n *\n *     For instance, the following call will be prevented:\n *     ```javascript\n *     setInterval(function () {\n *         window.test = \"value\";\n *     }, 100);\n *     ```\n *\n * 2. Prevents `setInterval` calls if the callback does not contain `value`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setInterval', '!value')\n *     ```\n *\n *     For instance, only the first of the following calls will be prevented:\n *     ```javascript\n *     setInterval(function () {\n *         window.test = \"test -- prevented\";\n *     }, 300);\n *     setInterval(function () {\n *         window.test = \"value -- executed\";\n *     }, 400);\n *     setInterval(function () {\n *         window.value = \"test -- executed\";\n *     }, 500);\n *     ```\n *\n * 3. Prevents `setInterval` calls if the callback contains `value` and the delay is not set to `300`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setInterval', 'value', '!300')\n *     ```\n *\n *     For instance, only the first of the following calls will not be prevented:\n *     ```javascript\n *     setInterval(function () {\n *         window.test = \"value 1 -- executed\";\n *     }, 300);\n *     setInterval(function () {\n *         window.test = \"value 2 -- prevented\";\n *     }, 400);\n *     setInterval(function () {\n *         window.test = \"value 3 -- prevented\";\n *     }, 500);\n *     ```\n *\n * 4. Prevents `setInterval` calls if the callback does not contain `value` and the delay is not set to `300`.\n *     ```\n *     example.org#%#//scriptlet('prevent-setInterval', '!value', '!300')\n *     ```\n *\n *     For instance, only the second of the following calls will be prevented:\n *     ```javascript\n *     setInterval(function () {\n *         window.test = \"test -- executed\";\n *     }, 300);\n *     setInterval(function () {\n *         window.test = \"test -- prevented\";\n *     }, 400);\n *     setInterval(function () {\n *         window.test = \"value -- executed\";\n *     }, 400);\n *     setInterval(function () {\n *         window.value = \"test -- executed\";\n *     }, 500);\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventSetInterval(source, match, delay) {\n  var nativeInterval = window.setInterval;\n  var log = console.log.bind(console); // eslint-disable-line no-console\n  // logs setIntervals to console if no arguments have been specified\n\n  var shouldLog = typeof match === 'undefined' && typeof delay === 'undefined';\n\n  var _parseMatchArg = parseMatchArg(match),\n      isInvertedMatch = _parseMatchArg.isInvertedMatch,\n      matchRegexp = _parseMatchArg.matchRegexp;\n\n  var _parseDelayArg = parseDelayArg(delay),\n      isInvertedDelayMatch = _parseDelayArg.isInvertedDelayMatch,\n      delayMatch = _parseDelayArg.delayMatch;\n\n  var intervalWrapper = function intervalWrapper(callback, interval) {\n    var shouldPrevent = false; // https://github.com/AdguardTeam/Scriptlets/issues/105\n\n    var cbString = String(callback);\n\n    if (shouldLog) {\n      hit(source);\n      log(\"setInterval(\".concat(cbString, \", \").concat(interval, \")\"));\n    } else if (!delayMatch) {\n      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch;\n    } else if (!match) {\n      shouldPrevent = interval === delayMatch !== isInvertedDelayMatch;\n    } else {\n      shouldPrevent = matchRegexp.test(cbString) !== isInvertedMatch && interval === delayMatch !== isInvertedDelayMatch;\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return nativeInterval(noopFunc, interval);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeInterval.apply(window, [callback, interval].concat(args));\n  };\n\n  window.setInterval = intervalWrapper;\n}\npreventSetInterval.names = ['prevent-setInterval', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-setInterval-if.js', // new implementation of setInterval-defuser.js\n'ubo-no-setInterval-if.js', 'setInterval-defuser.js', // old name should be supported as well\n'ubo-setInterval-defuser.js', 'nosiif.js', // new short name of no-setInterval-if\n'ubo-nosiif.js', 'sid.js', // old short scriptlet name\n'ubo-sid.js', 'ubo-no-setInterval-if', 'ubo-setInterval-defuser', 'ubo-nosiif', 'ubo-sid'];\npreventSetInterval.injections = [hit, noopFunc, parseMatchArg, parseDelayArg, toRegExp, startsWith, nativeIsNaN];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-window-open\n *\n * @description\n * Prevents `window.open` calls when URL either matches or not matches the specified string/regexp. Using it without parameters prevents all `window.open` calls.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#windowopen-defuserjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-window-open'[, match[, delay[, replacement]]])\n * ```\n *\n * - `match` - optional, string or regular expression. If not set, all window.open calls will be matched.\n * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.\n * If do not start with `!`, the stringified callback will be matched.\n * - `delay` - optional, number of seconds. If not set, scriptlet will return `null`,\n * otherwise valid sham window object as injected `iframe` will be returned\n * for accessing it's methods (blur(), focus() etc.) and will be removed after the delay.\n * - `replacement` - optional, string; one of the predefined constants:\n *     - `obj` - for returning an object instead of default iframe;\n *        for cases when the page requires a valid `window` instance to be returned\n *     - `log` - for logging window.open calls; permitted for production filter lists.\n *\n * **Examples**\n * 1. Prevent all `window.open` calls:\n * ```\n *     example.org#%#//scriptlet('prevent-window-open')\n * ```\n *\n * 2. Prevent `window.open` for all URLs containing `example`:\n * ```\n *     example.org#%#//scriptlet('prevent-window-open', 'example')\n * ```\n *\n * 3. Prevent `window.open` for all URLs matching RegExp `/example\\./`:\n * ```\n *     example.org#%#//scriptlet('prevent-window-open', '/example\\./')\n * ```\n *\n * 4. Prevent `window.open` for all URLs **NOT** containing `example`:\n * ```\n *     example.org#%#//scriptlet('prevent-window-open', '!example')\n * ```\n *\n * Old syntax of prevent-window-open parameters:\n * - `match` - optional, defaults to \"matching\", any positive number or nothing for \"matching\", 0 or empty string for \"not matching\"\n * - `search` - optional, string or regexp for matching the URL passed to `window.open` call; defaults to search all `window.open` call\n * - `replacement` - optional, string to return prop value or property instead of window.open; defaults to return noopFunc.\n * **Examples**\n * ```\n *     example.org#%#//scriptlet('prevent-window-open', '1', '/example\\./'\n *     example.org#%#//scriptlet('prevent-window-open', '0', 'example')\n *     example.org#%#//scriptlet('prevent-window-open', '', '', 'trueFunc')\n *     example.org#%#//scriptlet('prevent-window-open', '1', '', '{propName=noopFunc}')\n * ```\n *\n * > For better compatibility with uBO, old syntax is not recommended to use.\n */\n\n/* eslint-enable max-len */\n\nfunction preventWindowOpen(source) {\n  var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getWildcardSymbol();\n  var delay = arguments.length > 2 ? arguments[2] : undefined;\n  var replacement = arguments.length > 3 ? arguments[3] : undefined;\n  // default match value is needed for preventing all window.open calls\n  // if scriptlet runs without args\n  var nativeOpen = window.open;\n  var isNewSyntax = match !== '0' && match !== '1';\n\n  var oldOpenWrapper = function oldOpenWrapper(str) {\n    match = Number(match) > 0; // 'delay' was 'search' prop for matching in old syntax\n\n    var searchRegexp = toRegExp(delay);\n\n    if (match !== searchRegexp.test(str)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOpen.apply(window, [str].concat(args));\n    }\n\n    hit(source);\n    return handleOldReplacement(replacement);\n  };\n\n  var newOpenWrapper = function newOpenWrapper(url) {\n    var shouldLog = replacement && replacement.indexOf('log') > -1;\n\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    if (shouldLog) {\n      var argsStr = args && args.length > 0 ? \", \".concat(args.join(', ')) : '';\n      var logMessage = \"log: window-open: \".concat(url).concat(argsStr);\n      hit(source, logMessage);\n    }\n\n    var shouldPrevent = false;\n\n    if (match === getWildcardSymbol()) {\n      shouldPrevent = true;\n    } else {\n      var _parseMatchArg = parseMatchArg(match),\n          isInvertedMatch = _parseMatchArg.isInvertedMatch,\n          matchRegexp = _parseMatchArg.matchRegexp;\n\n      shouldPrevent = matchRegexp.test(url) !== isInvertedMatch;\n    }\n\n    if (shouldPrevent) {\n      var parsedDelay = parseInt(delay, 10);\n      var result;\n\n      if (nativeIsNaN(parsedDelay)) {\n        result = noopNull();\n      } else {\n        var decoyArgs = {\n          replacement: replacement,\n          url: url,\n          delay: parsedDelay\n        };\n        var decoy = createDecoy(decoyArgs);\n        var popup = decoy.contentWindow;\n\n        if (typeof popup === 'object' && popup !== null) {\n          Object.defineProperty(popup, 'closed', {\n            value: false\n          });\n        } else {\n          var nativeGetter = decoy.contentWindow && decoy.contentWindow.get;\n          Object.defineProperty(decoy, 'contentWindow', {\n            get: getPreventGetter(nativeGetter)\n          });\n          popup = decoy.contentWindow;\n        }\n\n        result = popup;\n      }\n\n      hit(source);\n      return result;\n    }\n\n    return nativeOpen.apply(window, [url].concat(args));\n  };\n\n  window.open = isNewSyntax ? newOpenWrapper : oldOpenWrapper;\n}\npreventWindowOpen.names = ['prevent-window-open', // aliases are needed for matching the related scriptlet converted into our syntax\n'window.open-defuser.js', 'ubo-window.open-defuser.js', 'ubo-window.open-defuser', 'nowoif.js', 'ubo-nowoif.js', 'ubo-nowoif'];\npreventWindowOpen.injections = [hit, toRegExp, nativeIsNaN, parseMatchArg, handleOldReplacement, createDecoy, getPreventGetter, noopNull, getWildcardSymbol, noopFunc, trueFunc, startsWith, endsWith, substringBefore, substringAfter];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet abort-current-inline-script\n *\n * @description\n * Aborts an inline script when it attempts to **read** the specified property\n * AND when the contents of the `<script>` element contains the specified\n * text or matches the regular expression.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-current-inline-scriptjs-\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L928\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('abort-current-inline-script', property[, search])\n * ```\n *\n * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`\n * - `search` - optional, string or regular expression that must match the inline script contents. If not set, abort all inline scripts which are trying to access the specified property\n *\n * > Note please that for inline script with addEventListener in it\n * `property` should be set as `EventTarget.prototype.addEventListener`,\n * not just `addEventListener`.\n *\n * **Examples**\n * 1. Aborts all inline scripts trying to access `window.alert`\n *     ```\n *     example.org#%#//scriptlet('abort-current-inline-script', 'alert')\n *     ```\n *\n * 2. Aborts inline scripts which are trying to access `window.alert` and contain `Hello, world`.\n *     ```\n *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', 'Hello, world')\n *     ```\n *\n *     For instance, the following script will be aborted\n *     ```html\n *     <script>alert(\"Hello, world\");</script>\n *     ```\n *\n * 3. Aborts inline scripts which are trying to access `window.alert` and match this regexp: `/Hello.+world/`.\n *     ```\n *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', '/Hello.+world/')\n *     ```\n *\n *     For instance, the following scripts will be aborted:\n *     ```html\n *     <script>alert(\"Hello, big world\");</script>\n *     ```\n *     ```html\n *     <script>alert(\"Hello, little world\");</script>\n *     ```\n *\n *     This script will not be aborted:\n *     ```html\n *     <script>alert(\"Hi, little world\");</script>\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction abortCurrentInlineScript(source, property, search) {\n  var searchRegexp = toRegExp(search);\n  var rid = randomId();\n\n  var getCurrentScript = function getCurrentScript() {\n    if ('currentScript' in document) {\n      return document.currentScript; // eslint-disable-line compat/compat\n    }\n\n    var scripts = document.getElementsByTagName('script');\n    return scripts[scripts.length - 1];\n  };\n\n  var ourScript = getCurrentScript();\n\n  var abort = function abort() {\n    var scriptEl = getCurrentScript();\n\n    if (!scriptEl) {\n      return;\n    }\n\n    var content = scriptEl.textContent; // We are using Node.prototype.textContent property descriptor\n    // to get the real script content\n    // even when document.currentScript.textContent is replaced.\n    // https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-593638991\n\n    try {\n      var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;\n      content = textContentGetter.call(scriptEl);\n    } catch (e) {} // eslint-disable-line no-empty\n\n\n    if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {\n      hit(source);\n      throw new ReferenceError(rid);\n    }\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain; // The scriptlet might be executed before the chain property has been created\n    // (for instance, document.body before the HTML body was loaded).\n    // In this case we're checking whether the base element exists or not\n    // and if not, we simply exit without overriding anything.\n    // e.g. https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-575841092\n\n    if (base instanceof Object === false && base === null) {\n      var props = property.split('.');\n      var propIndex = props.indexOf(prop);\n      var baseName = props[propIndex - 1];\n      console.log(\"The scriptlet had been executed before the \".concat(baseName, \" was loaded.\")); // eslint-disable-line no-console\n\n      return;\n    }\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    var currentValue = base[prop];\n    setPropertyAccess(base, prop, {\n      set: function set(value) {\n        abort();\n        currentValue = value;\n      },\n      get: function get() {\n        abort();\n        return currentValue;\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\nabortCurrentInlineScript.names = ['abort-current-inline-script', // aliases are needed for matching the related scriptlet converted into our syntax\n'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'ubo-abort-current-inline-script', 'ubo-acis', 'abp-abort-current-inline-script'];\nabortCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet set-constant\n *\n * @description\n * Creates a constant property and assigns it one of the values from the predefined list.\n *\n * > Actually, it's not a constant. Please note, that it can be rewritten with a value of a different type.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#set-constantjs-\n *\n * Related ABP snippet:\n * https://github.com/adblockplus/adblockpluscore/blob/adblockpluschrome-3.9.4/lib/content/snippets.js#L1361\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('set-constant', property, value[, stack])\n * ```\n *\n * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`.\n * - `value` - required. Possible values:\n *     - positive decimal integer `<= 32767`\n *     - one of the predefined constants:\n *         - `undefined`\n *         - `false`\n *         - `true`\n *         - `null`\n *         - `emptyObj` - empty object\n *         - `emptyArr` - empty array\n *         - `noopFunc` - function with empty body\n *         - `trueFunc` - function returning true\n *         - `falseFunc` - function returning false\n *         - `''` - empty string\n *         - `-1` - number value `-1`\n * - `stack` - optional, string or regular expression that must match the current function call stack trace\n *\n * **Examples**\n * ```\n * ! window.firstConst === false // this comparision will return false\n * example.org#%#//scriptlet('set-constant', 'firstConst', 'false')\n *\n * ! window.second() === trueFunc // 'second' call will return true\n * example.org#%#//scriptlet('set-constant', 'secondConst', 'trueFunc')\n *\n * ! document.third() === falseFunc  // 'third' call will return false if the method is related to checking.js\n * example.org#%#//scriptlet('set-constant', 'secondConst', 'trueFunc', 'checking.js')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction setConstant(source, property, value, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var emptyArr = noopArray();\n  var emptyObj = noopObject();\n  var constantValue;\n\n  if (value === 'undefined') {\n    constantValue = undefined;\n  } else if (value === 'false') {\n    constantValue = false;\n  } else if (value === 'true') {\n    constantValue = true;\n  } else if (value === 'null') {\n    constantValue = null;\n  } else if (value === 'emptyArr') {\n    constantValue = emptyArr;\n  } else if (value === 'emptyObj') {\n    constantValue = emptyObj;\n  } else if (value === 'noopFunc') {\n    constantValue = noopFunc;\n  } else if (value === 'trueFunc') {\n    constantValue = trueFunc;\n  } else if (value === 'falseFunc') {\n    constantValue = falseFunc;\n  } else if (/^\\d+$/.test(value)) {\n    constantValue = parseFloat(value);\n\n    if (nativeIsNaN(constantValue)) {\n      return;\n    }\n\n    if (Math.abs(constantValue) > 0x7FFF) {\n      return;\n    }\n  } else if (value === '-1') {\n    constantValue = -1;\n  } else if (value === '') {\n    constantValue = '';\n  } else {\n    return;\n  }\n\n  var canceled = false;\n\n  var mustCancel = function mustCancel(value) {\n    if (canceled) {\n      return canceled;\n    }\n\n    canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;\n    return canceled;\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain; // The scriptlet might be executed before the chain property has been created.\n    // In this case we're checking whether the base element exists or not\n    // and if not, we simply exit without overriding anything\n\n    if (base instanceof Object === false && base === null) {\n      // log the reason only while debugging\n      if (source.verbose) {\n        var props = property.split('.');\n        var propIndex = props.indexOf(prop);\n        var baseName = props[propIndex - 1];\n        console.log(\"set-constant failed because the property '\".concat(baseName, \"' does not exist\")); // eslint-disable-line no-console\n      }\n\n      return;\n    }\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    if (mustCancel(base[prop])) {\n      return;\n    }\n\n    hit(source);\n    setPropertyAccess(base, prop, {\n      get: function get() {\n        return constantValue;\n      },\n      set: function set(a) {\n        if (mustCancel(a)) {\n          constantValue = a;\n        }\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n}\nsetConstant.names = ['set-constant', // aliases are needed for matching the related scriptlet converted into our syntax\n'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set', 'abp-override-property-read'];\nsetConstant.injections = [hit, noopArray, noopObject, noopFunc, trueFunc, falseFunc, getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, nativeIsNaN];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet remove-cookie\n *\n * @description\n * Removes current page cookies by passed string matching with name. For current domain and subdomains. Runs on load and before unload.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#cookie-removerjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('remove-cookie'[, match])\n * ```\n *\n * - `match` - optional, string or regex matching the cookie name. If not specified all accessible cookies will be removed.\n *\n * **Examples**\n * 1. Removes all cookies:\n * ```\n *     example.org#%#//scriptlet('remove-cookie')\n * ```\n *\n * 2. Removes cookies which name contains `example` string.\n * ```\n *     example.org#%#//scriptlet('remove-cookie', 'example')\n * ```\n *\n *     For instance this cookie will be removed\n *     ```javascript\n *     document.cookie = '__example=randomValue';\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction removeCookie(source, match) {\n  var matchRegexp = toRegExp(match);\n\n  var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {\n    var cookieSpec = \"\".concat(cookieName, \"=\");\n    var domain1 = \"; domain=\".concat(hostName);\n    var domain2 = \"; domain=.\".concat(hostName);\n    var path = '; path=/';\n    var expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';\n    document.cookie = cookieSpec + expiration;\n    document.cookie = cookieSpec + domain1 + expiration;\n    document.cookie = cookieSpec + domain2 + expiration;\n    document.cookie = cookieSpec + path + expiration;\n    document.cookie = cookieSpec + domain1 + path + expiration;\n    document.cookie = cookieSpec + domain2 + path + expiration;\n    hit(source);\n  };\n\n  var rmCookie = function rmCookie() {\n    document.cookie.split(';').forEach(function (cookieStr) {\n      var pos = cookieStr.indexOf('=');\n\n      if (pos === -1) {\n        return;\n      }\n\n      var cookieName = cookieStr.slice(0, pos).trim();\n\n      if (!matchRegexp.test(cookieName)) {\n        return;\n      }\n\n      var hostParts = document.location.hostname.split('.');\n\n      for (var i = 0; i <= hostParts.length - 1; i += 1) {\n        var hostName = hostParts.slice(i).join('.');\n\n        if (hostName) {\n          removeCookieFromHost(cookieName, hostName);\n        }\n      }\n    });\n  };\n\n  rmCookie();\n  window.addEventListener('beforeunload', rmCookie);\n}\nremoveCookie.names = ['remove-cookie', // aliases are needed for matching the related scriptlet converted into our syntax\n'cookie-remover.js', 'ubo-cookie-remover.js', 'ubo-cookie-remover'];\nremoveCookie.injections = [toRegExp, hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-addEventListener\n *\n * @description\n * Prevents adding event listeners for the specified events and callbacks.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-defuserjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-addEventListener'[, eventSearch[, functionSearch]])\n * ```\n *\n * - `eventSearch` - optional, string or regex matching the event name. If not specified, the scriptlets prevents all event listeners\n * - `functionSearch` - optional, string or regex matching the event listener function body. If not set, the scriptlet prevents all event listeners with event name matching `eventSearch`\n *\n * **Examples**\n * 1. Prevent all `click` listeners:\n * ```\n *     example.org#%#//scriptlet('prevent-addEventListener', 'click')\n * ```\n\n2. Prevent 'click' listeners with the callback body containing `searchString`.\n * ```\n *     example.org#%#//scriptlet('prevent-addEventListener', 'click', 'searchString')\n * ```\n *\n *     For instance, this listener will not be called:\n * ```javascript\n *     el.addEventListener('click', () => {\n *         window.test = 'searchString';\n *     });\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventAddEventListener(source, eventSearch, funcSearch) {\n  var eventSearchRegexp = toRegExp(eventSearch);\n  var funcSearchRegexp = toRegExp(funcSearch);\n  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;\n\n  function addEventListenerWrapper(type, listener) {\n    var shouldPrevent = false;\n\n    if (validateType(type) && validateListener(listener)) {\n      shouldPrevent = eventSearchRegexp.test(type.toString()) && funcSearchRegexp.test(listenerToString(listener));\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return undefined;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeAddEventListener.apply(this, [type, listener].concat(args));\n  }\n\n  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;\n}\npreventAddEventListener.names = ['prevent-addEventListener', // aliases are needed for matching the related scriptlet converted into our syntax\n'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js', 'ubo-addEventListener-defuser', 'ubo-aeld'];\npreventAddEventListener.injections = [hit, toRegExp, validateType, validateListener, listenerToString];\n\n/* eslint-disable consistent-return, no-eval */\n/**\n * @scriptlet prevent-bab\n *\n * @description\n * Prevents BlockAdblock script from detecting an ad blocker.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#bab-defuserjs-\n *\n * It also can be used as `$redirect` sometimes.\n * See [redirect description](../wiki/about-redirects.md#prevent-bab).\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-bab')\n * ```\n */\n\nfunction preventBab(source) {\n  var nativeSetTimeout = window.setTimeout;\n  var babRegex = /\\.bab_elementid.$/;\n\n  var timeoutWrapper = function timeoutWrapper(callback) {\n    if (typeof callback !== 'string' || !babRegex.test(callback)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeSetTimeout.apply(window, [callback].concat(args));\n    }\n\n    hit(source);\n  };\n\n  window.setTimeout = timeoutWrapper;\n  var signatures = [['blockadblock'], ['babasbm'], [/getItem\\('babn'\\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];\n\n  var check = function check(str) {\n    for (var i = 0; i < signatures.length; i += 1) {\n      var tokens = signatures[i];\n      var match = 0;\n\n      for (var j = 0; j < tokens.length; j += 1) {\n        var token = tokens[j];\n        var found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;\n\n        if (found) {\n          match += 1;\n        }\n      }\n\n      if (match / tokens.length >= 0.8) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var nativeEval = window.eval;\n\n  var evalWrapper = function evalWrapper(str) {\n    if (!check(str)) {\n      return nativeEval(str);\n    }\n\n    hit(source);\n    var bodyEl = document.body;\n\n    if (bodyEl) {\n      bodyEl.style.removeProperty('visibility');\n    }\n\n    var el = document.getElementById('babasbmsgx');\n\n    if (el) {\n      el.parentNode.removeChild(el);\n    }\n  };\n\n  window.eval = evalWrapper.bind(window);\n}\npreventBab.names = ['prevent-bab', // aliases are needed for matching the related scriptlet converted into our syntax\n'nobab.js', 'ubo-nobab.js', 'bab-defuser.js', 'ubo-bab-defuser.js', 'ubo-nobab', 'ubo-bab-defuser'];\npreventBab.injections = [hit];\n\n/* eslint-disable no-unused-vars, no-extra-bind, func-names */\n/* eslint-disable max-len */\n\n/**\n * @scriptlet nowebrtc\n *\n * @description\n * Disables WebRTC by overriding `RTCPeerConnection`. The overriden function will log every attempt to create a new connection.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('nowebrtc')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction nowebrtc(source) {\n  var propertyName = '';\n\n  if (window.RTCPeerConnection) {\n    propertyName = 'RTCPeerConnection';\n  } else if (window.webkitRTCPeerConnection) {\n    propertyName = 'webkitRTCPeerConnection';\n  }\n\n  if (propertyName === '') {\n    return;\n  }\n\n  var rtcReplacement = function rtcReplacement(config) {\n    hit(source, \"Document tried to create an RTCPeerConnection: \".concat(convertRtcConfigToString(config)));\n  };\n\n  rtcReplacement.prototype = {\n    close: noopFunc,\n    createDataChannel: noopFunc,\n    createOffer: noopFunc,\n    setRemoteDescription: noopFunc\n  };\n  var rtc = window[propertyName];\n  window[propertyName] = rtcReplacement;\n\n  if (rtc.prototype) {\n    rtc.prototype.createDataChannel = function (a, b) {\n      return {\n        close: noopFunc,\n        send: noopFunc\n      };\n    }.bind(null);\n  }\n}\nnowebrtc.names = ['nowebrtc', // aliases are needed for matching the related scriptlet converted into our syntax\n'nowebrtc.js', 'ubo-nowebrtc.js', 'ubo-nowebrtc'];\nnowebrtc.injections = [hit, noopFunc, convertRtcConfigToString];\n\n/**\n * @scriptlet log-addEventListener\n *\n * @description\n * Logs all addEventListener calls to the console.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-loggerjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('log-addEventListener')\n * ```\n */\n\nfunction logAddEventListener(source) {\n  // eslint-disable-next-line no-console\n  var log = console.log.bind(console);\n  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;\n\n  function addEventListenerWrapper(type, listener) {\n    if (validateType(type) && validateListener(listener)) {\n      var logMessage = \"log: addEventListener(\\\"\".concat(type, \"\\\", \").concat(listenerToString(listener), \")\");\n      hit(source, logMessage);\n    } else if (source.verbose) {\n      // logging while debugging\n      var _logMessage = \"Invalid event type or listener passed to addEventListener:\\ntype: \".concat(convertTypeToString(type), \"\\nlistener: \").concat(convertTypeToString(listener));\n\n      log(_logMessage);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeAddEventListener.apply(this, [type, listener].concat(args));\n  }\n\n  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;\n}\nlogAddEventListener.names = ['log-addEventListener', // aliases are needed for matching the related scriptlet converted into our syntax\n'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js', 'ubo-addEventListener-logger', 'ubo-aell'];\nlogAddEventListener.injections = [hit, validateType, validateListener, listenerToString, convertTypeToString, objectToString, isEmptyObject, getObjectEntries];\n\n/* eslint-disable no-console, no-eval */\n/**\n * @scriptlet log-eval\n *\n * @description\n * Logs all `eval()` or `new Function()` calls to the console.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('log-eval')\n * ```\n */\n\nfunction logEval(source) {\n  var log = console.log.bind(console); // wrap eval function\n\n  var nativeEval = window.eval;\n\n  function evalWrapper(str) {\n    hit(source);\n    log(\"eval(\\\"\".concat(str, \"\\\")\"));\n    return nativeEval(str);\n  }\n\n  window.eval = evalWrapper; // wrap new Function\n\n  var nativeFunction = window.Function;\n\n  function FunctionWrapper() {\n    hit(source);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    log(\"new Function(\".concat(args.join(', '), \")\"));\n    return nativeFunction.apply(this, [].concat(args));\n  }\n\n  FunctionWrapper.prototype = Object.create(nativeFunction.prototype);\n  FunctionWrapper.prototype.constructor = FunctionWrapper;\n  window.Function = FunctionWrapper;\n}\nlogEval.names = ['log-eval'];\nlogEval.injections = [hit];\n\n/**\n * @scriptlet log\n *\n * @description\n * A simple scriptlet which only purpose is to print arguments to console.\n * This scriptlet can be helpful for debugging and troubleshooting other scriptlets.\n *\n * **Example**\n * ```\n * example.org#%#//scriptlet('log', 'arg1', 'arg2')\n * ```\n */\nfunction log() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  console.log(args); // eslint-disable-line no-console\n}\nlog.names = ['log'];\n\n/* eslint-disable no-eval, no-extra-bind */\n/**\n * @scriptlet noeval\n *\n * @description\n * Prevents page to use eval.\n * Notifies about attempts in the console\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#noevaljs-\n *\n * It also can be used as `$redirect` rules sometimes.\n * See [redirect description](../wiki/about-redirects.md#noeval).\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('noeval')\n * ```\n */\n\nfunction noeval(source) {\n  window.eval = function evalWrapper(s) {\n    hit(source, \"AdGuard has prevented eval:\\n\".concat(s));\n  }.bind();\n}\nnoeval.names = ['noeval', // aliases are needed for matching the related scriptlet converted into our syntax\n'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js', 'ubo-noeval', 'ubo-silent-noeval'];\nnoeval.injections = [hit];\n\n/* eslint-disable no-eval, no-extra-bind, func-names */\n/**\n * @scriptlet prevent-eval-if\n *\n * @description\n * Prevents page to use eval matching payload.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#noeval-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-eval-if'[, search])\n * ```\n *\n * - `search` - optional, string or regexp for matching stringified eval payload.\n * If 'search is not specified  all stringified eval payload will be matched\n *\n * **Examples**\n * ```\n * ! Prevents eval if it matches 'test'\n * example.org#%#//scriptlet('prevent-eval-if', 'test')\n * ```\n *\n * @param {string|RegExp} [search] string or regexp matching stringified eval payload\n */\n\nfunction preventEvalIf(source, search) {\n  var searchRegexp = toRegExp(search);\n  var nativeEval = window.eval;\n\n  window.eval = function (payload) {\n    if (!searchRegexp.test(payload.toString())) {\n      return nativeEval.call(window, payload);\n    }\n\n    hit(source, payload);\n    return undefined;\n  }.bind(window);\n}\npreventEvalIf.names = ['prevent-eval-if', // aliases are needed for matching the related scriptlet converted into our syntax\n'noeval-if.js', 'ubo-noeval-if.js', 'ubo-noeval-if'];\npreventEvalIf.injections = [toRegExp, hit];\n\n/* eslint-disable no-console, func-names, no-multi-assign */\n/**\n * @scriptlet prevent-fab-3.2.0\n *\n * @description\n * Prevents execution of the FAB script v3.2.0.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#fuckadblockjs-320-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-fab-3.2.0')\n * ```\n */\n\nfunction preventFab(source) {\n  hit(source); // redefines Fab function for adblock detection\n\n  var Fab = function Fab() {};\n\n  Fab.prototype.check = noopFunc;\n  Fab.prototype.clearEvent = noopFunc;\n  Fab.prototype.emitEvent = noopFunc;\n\n  Fab.prototype.on = function (a, b) {\n    if (!a) {\n      b();\n    }\n\n    return this;\n  };\n\n  Fab.prototype.onDetected = noopThis;\n\n  Fab.prototype.onNotDetected = function (a) {\n    a();\n    return this;\n  };\n\n  Fab.prototype.setOption = noopFunc;\n  Fab.prototype.options = {\n    set: noopFunc,\n    get: noopFunc\n  };\n  var fab = new Fab();\n  var getSetFab = {\n    get: function get() {\n      return Fab;\n    },\n    set: function set() {}\n  };\n  var getsetfab = {\n    get: function get() {\n      return fab;\n    },\n    set: function set() {}\n  }; // redefined Fab data properties which if 'FuckAdBlock' variable exists\n\n  if (Object.prototype.hasOwnProperty.call(window, 'FuckAdBlock')) {\n    window.FuckAdBlock = Fab;\n  } else {\n    // or redefined Fab accessor properties\n    Object.defineProperty(window, 'FuckAdBlock', getSetFab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'BlockAdBlock')) {\n    window.BlockAdBlock = Fab;\n  } else {\n    Object.defineProperty(window, 'BlockAdBlock', getSetFab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'SniffAdBlock')) {\n    window.SniffAdBlock = Fab;\n  } else {\n    Object.defineProperty(window, 'SniffAdBlock', getSetFab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'fuckAdBlock')) {\n    window.fuckAdBlock = fab;\n  } else {\n    Object.defineProperty(window, 'fuckAdBlock', getsetfab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'blockAdBlock')) {\n    window.blockAdBlock = fab;\n  } else {\n    Object.defineProperty(window, 'blockAdBlock', getsetfab);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(window, 'sniffAdBlock')) {\n    window.sniffAdBlock = fab;\n  } else {\n    Object.defineProperty(window, 'sniffAdBlock', getsetfab);\n  }\n}\npreventFab.names = ['prevent-fab-3.2.0', // aliases are needed for matching the related scriptlet converted into our syntax\n'nofab.js', 'ubo-nofab.js', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'ubo-nofab'];\npreventFab.injections = [hit, noopFunc, noopThis];\n\n/* eslint-disable no-console, func-names, no-multi-assign */\n/**\n * @scriptlet set-popads-dummy\n *\n * @description\n * Sets static properties PopAds and popns.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#popads-dummyjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('set-popads-dummy')\n * ```\n */\n\nfunction setPopadsDummy(source) {\n  delete window.PopAds;\n  delete window.popns;\n  Object.defineProperties(window, {\n    PopAds: {\n      get: function get() {\n        hit(source);\n        return {};\n      }\n    },\n    popns: {\n      get: function get() {\n        hit(source);\n        return {};\n      }\n    }\n  });\n}\nsetPopadsDummy.names = ['set-popads-dummy', // aliases are needed for matching the related scriptlet converted into our syntax\n'popads-dummy.js', 'ubo-popads-dummy.js', 'ubo-popads-dummy'];\nsetPopadsDummy.injections = [hit];\n\n/**\n * @scriptlet prevent-popads-net\n *\n * @description\n * Aborts on property write (PopAds, popns), throws reference error with random id.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#popadsnetjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-popads-net')\n * ```\n */\n\nfunction preventPopadsNet(source) {\n  var rid = randomId();\n\n  var throwError = function throwError() {\n    throw new ReferenceError(rid);\n  };\n\n  delete window.PopAds;\n  delete window.popns;\n  Object.defineProperties(window, {\n    PopAds: {\n      set: throwError\n    },\n    popns: {\n      set: throwError\n    }\n  });\n  window.onerror = createOnErrorHandler(rid).bind();\n  hit(source);\n}\npreventPopadsNet.names = ['prevent-popads-net', // aliases are needed for matching the related scriptlet converted into our syntax\n'popads.net.js', 'ubo-popads.net.js', 'ubo-popads.net'];\npreventPopadsNet.injections = [createOnErrorHandler, randomId, hit];\n\n/* eslint-disable func-names */\n/**\n * @scriptlet prevent-adfly\n *\n * @description\n * Prevents anti-adblock scripts on adfly short links.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#adfly-defuserjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-adfly')\n * ```\n */\n\nfunction preventAdfly(source) {\n  var isDigit = function isDigit(data) {\n    return /^\\d$/.test(data);\n  };\n\n  var handler = function handler(encodedURL) {\n    var evenChars = '';\n    var oddChars = '';\n\n    for (var i = 0; i < encodedURL.length; i += 1) {\n      if (i % 2 === 0) {\n        evenChars += encodedURL.charAt(i);\n      } else {\n        oddChars = encodedURL.charAt(i) + oddChars;\n      }\n    }\n\n    var data = (evenChars + oddChars).split('');\n\n    for (var _i = 0; _i < data.length; _i += 1) {\n      if (isDigit(data[_i])) {\n        for (var ii = _i + 1; ii < data.length; ii += 1) {\n          if (isDigit(data[ii])) {\n            // eslint-disable-next-line no-bitwise\n            var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);\n\n            if (temp < 10) {\n              data[_i] = temp.toString();\n            }\n\n            _i = ii;\n            break;\n          }\n        }\n      }\n    }\n\n    data = data.join('');\n    var decodedURL = window.atob(data).slice(16, -16);\n    /* eslint-disable compat/compat */\n\n    if (window.stop) {\n      window.stop();\n    }\n    /* eslint-enable compat/compat */\n\n\n    window.onbeforeunload = null;\n    window.location.href = decodedURL;\n  };\n\n  var val; // Do not apply handler more than one time\n\n  var applyHandler = true;\n  var result = setPropertyAccess(window, 'ysmm', {\n    configurable: false,\n    set: function set(value) {\n      if (applyHandler) {\n        applyHandler = false;\n\n        try {\n          if (typeof value === 'string') {\n            handler(value);\n          }\n        } catch (err) {} // eslint-disable-line no-empty\n\n      }\n\n      val = value;\n    },\n    get: function get() {\n      return val;\n    }\n  });\n\n  if (result) {\n    hit(source);\n  } else {\n    window.console.error('Failed to set up prevent-adfly scriptlet');\n  }\n}\npreventAdfly.names = ['prevent-adfly', // aliases are needed for matching the related scriptlet converted into our syntax\n'adfly-defuser.js', 'ubo-adfly-defuser.js', 'ubo-adfly-defuser'];\npreventAdfly.injections = [setPropertyAccess, hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet debug-on-property-read\n *\n * @description\n * This scriptlet is basically the same as [abort-on-property-read](#abort-on-property-read), but instead of aborting it starts the debugger.\n *\n * **It is not supposed to be used in production filter lists!**\n *\n * **Syntax**\n * ```\n * ! Debug script if it tries to access `window.alert`\n * example.org#%#//scriptlet('debug-on-property-read', 'alert')\n * ! of `window.open`\n * example.org#%#//scriptlet('debug-on-property-read', 'open')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction debugOnPropertyRead(source, property, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var rid = randomId();\n\n  var abort = function abort() {\n    hit(source);\n    debugger; // eslint-disable-line no-debugger\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    setPropertyAccess(base, prop, {\n      get: abort,\n      set: noopFunc\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\ndebugOnPropertyRead.names = ['debug-on-property-read'];\ndebugOnPropertyRead.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace, noopFunc];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet debug-on-property-write\n *\n * @description\n * This scriptlet is basically the same as [abort-on-property-write](#abort-on-property-write), but instead of aborting it starts the debugger.\n *\n * **It is not supposed to be used in production filter lists!**\n *\n * **Syntax**\n * ```\n * ! Aborts script when it tries to write in property `window.test`\n * example.org#%#//scriptlet('debug-on-property-write', 'test')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction debugOnPropertyWrite(source, property, stack) {\n  if (!property || !matchStackTrace(stack, new Error().stack)) {\n    return;\n  }\n\n  var rid = randomId();\n\n  var abort = function abort() {\n    hit(source);\n    debugger; // eslint-disable-line no-debugger\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    setPropertyAccess(base, prop, {\n      set: abort\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\ndebugOnPropertyWrite.names = ['debug-on-property-write'];\ndebugOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet debug-current-inline-script\n *\n * @description\n * This scriptlet is basically the same as [abort-current-inline-script](#abort-current-inline-script), but instead of aborting it starts the debugger.\n *\n * **It is not supposed to be used in production filter lists!**\n *\n * **Syntax**\n *```\n * ! Aborts script when it tries to access `window.alert`\n * example.org#%#//scriptlet('debug-current-inline-script', 'alert')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction debugCurrentInlineScript(source, property) {\n  var search = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var searchRegexp = toRegExp(search);\n  var rid = randomId();\n\n  var getCurrentScript = function getCurrentScript() {\n    if ('currentScript' in document) {\n      return document.currentScript; // eslint-disable-line compat/compat\n    }\n\n    var scripts = document.getElementsByTagName('script');\n    return scripts[scripts.length - 1];\n  };\n\n  var ourScript = getCurrentScript();\n\n  var abort = function abort() {\n    var scriptEl = getCurrentScript();\n\n    if (scriptEl instanceof HTMLScriptElement && scriptEl.textContent.length > 0 && scriptEl !== ourScript && (!search || searchRegexp.test(scriptEl.textContent))) {\n      hit(source);\n      debugger; // eslint-disable-line no-debugger\n    }\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = getPropertyInChain(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    var currentValue = base[prop];\n    setPropertyAccess(base, prop, {\n      set: function set(value) {\n        abort();\n        currentValue = value;\n      },\n      get: function get() {\n        abort();\n        return currentValue;\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = createOnErrorHandler(rid).bind();\n}\ndebugCurrentInlineScript.names = ['debug-current-inline-script'];\ndebugCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet remove-attr\n *\n * @description\n * Removes the specified attributes from DOM nodes. This scriptlet runs once when the page loads\n * and after that periodically in order to DOM tree changes.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-attrjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('remove-attr', attrs[, selector])\n * ```\n *\n * - `attrs`  required, attribute or list of attributes joined by '|'\n * - `selector`  optional, CSS selector, specifies DOM nodes from which the attributes will be removed\n *\n * **Examples**\n * 1.  Removes by attribute\n *     ```\n *     example.org#%#//scriptlet('remove-attr', 'example|test')\n *     ```\n *\n *     ```html\n *     <!-- before  -->\n *     <div example=\"true\" test=\"true\">Some text</div>\n *\n *     <!-- after -->\n *     <div>Some text</div>\n *     ```\n *\n * 2. Removes with specified selector\n *     ```\n *     example.org#%#//scriptlet('remove-attr', 'example', 'div[class=\"inner\"]')\n *     ```\n *\n *     ```html\n *     <!-- before -->\n *     <div class=\"wrapper\" example=\"true\">\n *         <div class=\"inner\" example=\"true\">Some text</div>\n *     </div>\n *\n *     <!-- after -->\n *     <div class=\"wrapper\" example=\"true\">\n *         <div class=\"inner\">Some text</div>\n *     </div>\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction removeAttr(source, attrs, selector) {\n  if (!attrs) {\n    return;\n  }\n\n  attrs = attrs.split(/\\s*\\|\\s*/);\n\n  if (!selector) {\n    selector = \"[\".concat(attrs.join('],['), \"]\");\n  }\n\n  var rmattr = function rmattr() {\n    var nodes = [].slice.call(document.querySelectorAll(selector));\n    var removed = false;\n    nodes.forEach(function (node) {\n      attrs.forEach(function (attr) {\n        node.removeAttribute(attr);\n        removed = true;\n      });\n    });\n\n    if (removed) {\n      hit(source);\n    }\n  };\n\n  rmattr(); // 'true' for observing attributes\n\n  observeDOMChanges(rmattr, true);\n}\nremoveAttr.names = ['remove-attr', // aliases are needed for matching the related scriptlet converted into our syntax\n'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js', 'ubo-remove-attr', 'ubo-ra'];\nremoveAttr.injections = [hit, observeDOMChanges];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet remove-class\n *\n * @description\n * Removes the specified classes from DOM nodes. This scriptlet runs once after the page loads\n * and after that periodically in order to DOM tree changes.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-classjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('remove-class', classes[, selector])\n * ```\n *\n * - `classes`  required, class or list of classes separated by '|'\n * - `selector`  optional, CSS selector, specifies DOM nodes from which the classes will be removed.\n * If there is no `selector`, each class of `classes` independently will be removed from all nodes which has one\n *\n * **Examples**\n * 1.  Removes by classes\n *     ```\n *     example.org#%#//scriptlet('remove-class', 'example|test')\n *     ```\n *\n *     ```html\n *     <!-- before  -->\n *     <div id=\"first\" class=\"nice test\">Some text</div>\n *     <div id=\"second\" class=\"rare example for test\">Some text</div>\n *     <div id=\"third\" class=\"testing better example\">Some text</div>\n *\n *     <!-- after -->\n *     <div id=\"first\" class=\"nice\">Some text</div>\n *     <div id=\"second\" class=\"rare for\">Some text</div>\n *     <div id=\"third\" class=\"testing better\">Some text</div>\n *     ```\n *\n * 2. Removes with specified selector\n *     ```\n *     example.org#%#//scriptlet('remove-class', 'branding', 'div[class^=\"inner\"]')\n *     ```\n *\n *     ```html\n *     <!-- before -->\n *     <div class=\"wrapper true branding\">\n *         <div class=\"inner bad branding\">Some text</div>\n *     </div>\n *\n *     <!-- after -->\n *     <div class=\"wrapper true branding\">\n *         <div class=\"inner bad\">Some text</div>\n *     </div>\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction removeClass(source, classNames, selector) {\n  if (!classNames) {\n    return;\n  }\n\n  classNames = classNames.split(/\\s*\\|\\s*/);\n  var selectors = [];\n\n  if (!selector) {\n    selectors = classNames.map(function (className) {\n      return \".\".concat(className);\n    });\n  }\n\n  var removeClassHandler = function removeClassHandler() {\n    var nodes = new Set();\n\n    if (selector) {\n      var foundedNodes = [].slice.call(document.querySelectorAll(selector));\n      foundedNodes.forEach(function (n) {\n        return nodes.add(n);\n      });\n    } else if (selectors.length > 0) {\n      selectors.forEach(function (s) {\n        var elements = document.querySelectorAll(s);\n\n        for (var i = 0; i < elements.length; i += 1) {\n          var element = elements[i];\n          nodes.add(element);\n        }\n      });\n    }\n\n    var removed = false;\n    nodes.forEach(function (node) {\n      classNames.forEach(function (className) {\n        if (node.classList.contains(className)) {\n          node.classList.remove(className);\n          removed = true;\n        }\n      });\n    });\n\n    if (removed) {\n      hit(source);\n    }\n  };\n\n  removeClassHandler();\n  var CLASS_ATTR_NAME = ['class']; // 'true' for observing attributes\n  // 'class' for observing only classes\n\n  observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);\n}\nremoveClass.names = ['remove-class', // aliases are needed for matching the related scriptlet converted into our syntax\n'remove-class.js', 'ubo-remove-class.js', 'rc.js', 'ubo-rc.js', 'ubo-remove-class', 'ubo-rc'];\nremoveClass.injections = [hit, observeDOMChanges];\n\n/**\n * @scriptlet disable-newtab-links\n *\n * @description\n * Prevents opening new tabs and windows if there is `target` attribute in element.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#disable-newtab-linksjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('disable-newtab-links')\n * ```\n */\n\nfunction disableNewtabLinks(source) {\n  document.addEventListener('click', function (ev) {\n    var target = ev.target;\n\n    while (target !== null) {\n      if (target.localName === 'a' && target.hasAttribute('target')) {\n        ev.stopPropagation();\n        ev.preventDefault();\n        hit(source);\n        break;\n      }\n\n      target = target.parentNode;\n    }\n  });\n}\ndisableNewtabLinks.names = ['disable-newtab-links', // aliases are needed for matching the related scriptlet converted into our syntax\n'disable-newtab-links.js', 'ubo-disable-newtab-links.js', 'ubo-disable-newtab-links'];\ndisableNewtabLinks.injections = [hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet adjust-setInterval\n *\n * @description\n * Adjusts interval for specified setInterval() callbacks.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-setinterval-boosterjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('adjust-setInterval'[, match [, interval[, boost]]])\n * ```\n *\n * - `match` - optional, string/regular expression, matching in stringified callback function\n * - `interval` - optional, defaults to 1000, matching setInterval delay; decimal integer OR '*' for any delay\n * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down (0.02...50), interval multiplier\n *\n * **Examples**\n * 1. Adjust all setInterval() x20 times where interval equal 1000ms:\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval')\n *     ```\n *\n * 2. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 1000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', 'example')\n *     ```\n *\n * 3. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 400ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', 'example', '400')\n *     ```\n *\n * 4. Slow down setInterval() x2 times where callback matched with `example` and interval equal 1000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', 'example', '', '2')\n *     ```\n * 5. Adjust all setInterval() x50 times where interval equal 2000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', '', '2000', '0.02')\n *     ```\n * 6. Adjust all setInterval() x50 times where interval is randomized\n *     ```\n *     example.org#%#//scriptlet('adjust-setInterval', '', '*', '0.02')\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction adjustSetInterval(source, match, interval, boost) {\n  var nativeSetInterval = window.setInterval;\n  var matchRegexp = toRegExp(match);\n\n  var intervalWrapper = function intervalWrapper(cb, d) {\n    if (matchRegexp.test(cb.toString()) && isDelayMatched(interval, d)) {\n      d *= getBoostMultiplier(boost);\n      hit(source);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeSetInterval.apply(window, [cb, d].concat(args));\n  };\n\n  window.setInterval = intervalWrapper;\n}\nadjustSetInterval.names = ['adjust-setInterval', // aliases are needed for matching the related scriptlet converted into our syntax\n'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js', 'ubo-nano-setInterval-booster', 'ubo-nano-sib'];\nadjustSetInterval.injections = [hit, toRegExp, getBoostMultiplier, isDelayMatched, nativeIsNaN, nativeIsFinite, getMatchDelay, getWildcardSymbol, shouldMatchAnyDelay];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet adjust-setTimeout\n *\n * @description\n * Adjusts timeout for specified setTimout() callbacks.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-settimeout-boosterjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('adjust-setTimeout'[, match [, timeout[, boost]]])\n * ```\n *\n * - `match` - optional, string/regular expression, matching in stringified callback function\n * - `timeout` - optional, defaults to 1000, matching setTimout delay; decimal integer OR '*' for any delay\n * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down (0.02...50), timeout multiplier\n *\n * **Examples**\n * 1. Adjust all setTimeout() x20 times where timeout equal 1000ms:\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout')\n *     ```\n *\n * 2. Adjust all setTimeout() x20 times where callback mathed with `example` and timeout equal 1000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', 'example')\n *     ```\n *\n * 3. Adjust all setTimeout() x20 times where callback mathed with `example` and timeout equal 400ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '400')\n *     ```\n *\n * 4. Slow down setTimeout() x2 times where callback matched with `example` and timeout equal 1000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '', '2')\n *     ```\n * 5. Adjust all setTimeout() x50 times where timeout equal 2000ms\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', '', '2000', '0.02')\n *     ```\n * 6. Adjust all setTimeout() x20 times where callback mathed with `test` and timeout is randomized\n *     ```\n *     example.org#%#//scriptlet('adjust-setTimeout', 'test', '*')\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction adjustSetTimeout(source, match, timeout, boost) {\n  var nativeSetTimeout = window.setTimeout;\n  var matchRegexp = toRegExp(match);\n\n  var timeoutWrapper = function timeoutWrapper(cb, d) {\n    if (matchRegexp.test(cb.toString()) && isDelayMatched(timeout, d)) {\n      d *= getBoostMultiplier(boost);\n      hit(source);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeSetTimeout.apply(window, [cb, d].concat(args));\n  };\n\n  window.setTimeout = timeoutWrapper;\n}\nadjustSetTimeout.names = ['adjust-setTimeout', // aliases are needed for matching the related scriptlet converted into our syntax\n'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js', 'ubo-nano-setTimeout-booster', 'ubo-nano-stb'];\nadjustSetTimeout.injections = [hit, toRegExp, getBoostMultiplier, isDelayMatched, nativeIsNaN, nativeIsFinite, getMatchDelay, getWildcardSymbol, shouldMatchAnyDelay];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet dir-string\n *\n * @description\n * Wraps the `console.dir` API to call the `toString` method of the argument.\n * There are several adblock circumvention systems that detect browser devtools\n * and hide themselves. Therefore, if we force them to think\n * that devtools are open (using this scrciptlet),\n * it will automatically disable the adblock circumvention script.\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L766\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('dir-string'[, times])\n * ```\n * - `times` - optional, the number of times to call the `toString` method of the argument to `console.dir`\n *\n * **Example**\n * ```\n * ! Run 2 times\n * example.org#%#//scriptlet('dir-string', '2')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction dirString(source, times) {\n  var _console = console,\n      dir = _console.dir;\n  times = parseInt(times, 10);\n\n  function dirWrapper(object) {\n    // eslint-disable-next-line no-unused-vars\n    var temp;\n\n    for (var i = 0; i < times; i += 1) {\n      // eslint-disable-next-line no-unused-expressions\n      temp = \"\".concat(object);\n    }\n\n    if (typeof dir === 'function') {\n      dir.call(this, object);\n    }\n\n    hit(source, temp);\n  } // eslint-disable-next-line no-console\n\n\n  console.dir = dirWrapper;\n}\ndirString.names = ['dir-string', 'abp-dir-string'];\ndirString.injections = [hit];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet json-prune\n *\n * @description\n * Removes specified properties from the result of calling JSON.parse and returns the caller\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prunejs-\n *\n * Related ABP source:\n * https://github.com/adblockplus/adblockpluscore/blob/master/lib/content/snippets.js#L1285\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('json-prune'[, propsToRemove [, obligatoryProps [, stack]]])\n * ```\n *\n * - `propsToRemove` - optional, string of space-separated properties to remove\n * - `obligatoryProps` - optional, string of space-separated properties which must be all present for the pruning to occur\n * - `stack` - optional, string or regular expression that must match the current function call stack trace\n *\n * > Note please that you can use wildcard `*` for chain property name.\n * e.g. 'ad.*.src' instead of 'ad.0.src ad.1.src ad.2.src ...'\n *\n * **Examples**\n * 1. Removes property `example` from the results of JSON.parse call\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'example')\n *     ```\n *\n *     For instance, the following call will return `{ one: 1}`\n *\n *     ```html\n *     JSON.parse('{\"one\":1,\"example\":true}')\n *     ```\n *\n * 2. If there are no specified properties in the result of JSON.parse call, pruning will NOT occur\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'one', 'obligatoryProp')\n *     ```\n *\n *     For instance, the following call will return `{ one: 1, two: 2}`\n *\n *     ```html\n *     JSON.parse('{\"one\":1,\"two\":2}')\n *     ```\n *\n * 3. A property in a list of properties can be a chain of properties\n *\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'a.b', 'adpath.url.first')\n *     ```\n *\n * 4. Removes property `content.ad` from the results of JSON.parse call it's error stack trace contains `test.js`\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'content.ad', '', 'test.js')\n *     ```\n *\n * 5. A property in a list of properties can be a chain of properties with wildcard in it\n *\n *     ```\n *     example.org#%#//scriptlet('json-prune', 'content.*.media.src', 'content.*.media.preroll')\n *     ```\n *\n * 6. Call with no arguments will log the current hostname and json payload at the console\n *     ```\n *     example.org#%#//scriptlet('json-prune')\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction jsonPrune(source, propsToRemove, requiredInitialProps, stack) {\n  if (!!stack && !matchStackTrace(stack, new Error().stack)) {\n    return;\n  } // eslint-disable-next-line no-console\n\n\n  var log = console.log.bind(console);\n  var prunePaths = propsToRemove !== undefined && propsToRemove !== '' ? propsToRemove.split(/ +/) : [];\n  var requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== '' ? requiredInitialProps.split(/ +/) : [];\n\n  function isPruningNeeded(root) {\n    if (!root) {\n      return false;\n    }\n\n    var shouldProcess;\n\n    for (var i = 0; i < requiredPaths.length; i += 1) {\n      var requiredPath = requiredPaths[i];\n      var lastNestedPropName = requiredPath.split('.').pop();\n      var hasWildcard = requiredPath.indexOf('.*.') > -1 || requiredPath.indexOf('*.') > -1 || requiredPath.indexOf('.*') > -1 || requiredPath.indexOf('.[].') > -1 || requiredPath.indexOf('[].') > -1 || requiredPath.indexOf('.[]') > -1; // if the path has wildcard, getPropertyInChain should 'look through' chain props\n\n      var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard); // start value of 'shouldProcess' due to checking below\n\n      shouldProcess = !hasWildcard;\n\n      for (var _i = 0; _i < details.length; _i += 1) {\n        if (hasWildcard) {\n          // if there is a wildcard,\n          // at least one (||) of props chain should be present in object\n          shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) || shouldProcess;\n        } else {\n          // otherwise each one (&&) of them should be there\n          shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) && shouldProcess;\n        }\n      }\n    }\n\n    return shouldProcess;\n  }\n  /**\n   * Prunes properties of 'root' object\n   * @param {Object} root\n   */\n\n\n  var jsonPruner = function jsonPruner(root) {\n    if (prunePaths.length === 0) {\n      log(window.location.hostname, root);\n      return root;\n    }\n\n    try {\n      if (isPruningNeeded(root) === false) {\n        return root;\n      } // if pruning is needed, we check every input pathToRemove\n      // and delete it if root has it\n\n\n      prunePaths.forEach(function (path) {\n        var ownerObjArr = getWildcardPropertyInChain(root, path, true);\n        ownerObjArr.forEach(function (ownerObj) {\n          if (ownerObj !== undefined && ownerObj.base) {\n            delete ownerObj.base[ownerObj.prop];\n            hit(source);\n          }\n        });\n      });\n    } catch (e) {\n      log(e.toString());\n    }\n\n    return root;\n  };\n\n  var nativeJSONParse = JSON.parse;\n\n  var jsonParseWrapper = function jsonParseWrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // dealing with stringified json in args, which should be parsed.\n    // so we call nativeJSONParse as JSON.parse which is bound to JSON object\n    var root = nativeJSONParse.apply(JSON, args);\n    return jsonPruner(root);\n  }; // JSON.parse mocking\n\n\n  jsonParseWrapper.toString = nativeJSONParse.toString.bind(nativeJSONParse);\n  JSON.parse = jsonParseWrapper; // eslint-disable-next-line compat/compat\n\n  var nativeResponseJson = Response.prototype.json; // eslint-disable-next-line func-names\n\n  var responseJsonWrapper = function responseJsonWrapper() {\n    var promise = nativeResponseJson.apply(this);\n    return promise.then(function (obj) {\n      return jsonPruner(obj);\n    });\n  }; // do nothing if browser does not support Response (e.g. Internet Explorer)\n  // https://developer.mozilla.org/en-US/docs/Web/API/Response\n\n\n  if (typeof Response === 'undefined') {\n    return;\n  } // eslint-disable-next-line compat/compat\n\n\n  Response.prototype.json = responseJsonWrapper;\n}\njsonPrune.names = ['json-prune', // aliases are needed for matching the related scriptlet converted into our syntax\n'json-prune.js', 'ubo-json-prune.js', 'ubo-json-prune', 'abp-json-prune'];\njsonPrune.injections = [hit, matchStackTrace, getWildcardPropertyInChain, toRegExp, getWildcardSymbol];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-requestAnimationFrame\n *\n * @description\n * Prevents a `requestAnimationFrame` call\n * if the text of the callback is matching the specified search string which does not start with `!`;\n * otherwise mismatched calls should be defused.\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-requestanimationframe-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-requestAnimationFrame'[, search])\n * ```\n *\n * - `search` - optional, string or regular expression.\n * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.\n * If do not start with `!`, the stringified callback will be matched.\n *\n * Call with no argument will log all requestAnimationFrame calls while debugging.\n * So do not use the scriptlet without any parameter in production filter lists.\n *\n * **Examples**\n * 1. Prevents `requestAnimationFrame` calls if the callback matches `/\\.test/`.\n *     ```bash\n *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '/\\.test/')\n *     ```\n *\n *     For instance, the following call will be prevented:\n *     ```javascript\n *     var times = 0;\n *     requestAnimationFrame(function change() {\n *         window.test = 'new value';\n *         if (times < 2) {\n *             times += 1;\n *             requestAnimationFrame(change);\n *         }\n *     });\n *     ```\n * 2. Prevents `requestAnimationFrame` calls if **does not match** 'check'.\n *     ```bash\n *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '!check')\n *     ```\n *\n *     For instance, only the first call will be prevented:\n *\n *     ```javascript\n *     var timesFirst = 0;\n *     requestAnimationFrame(function changeFirst() {\n *         window.check = 'should not be prevented';\n *         if (timesFirst < 2) {\n *             timesFirst += 1;\n *             requestAnimationFrame(changeFirst);\n *         }\n *     });\n *\n *     var timesSecond = 0;\n *     requestAnimationFrame(function changeSecond() {\n *         window.second = 'should be prevented';\n *         if (timesSecond < 2) {\n *             timesSecond += 1;\n *             requestAnimationFrame(changeSecond);\n *         }\n *     });\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventRequestAnimationFrame(source, match) {\n  var nativeRequestAnimationFrame = window.requestAnimationFrame; // logs requestAnimationFrame to console if no arguments have been specified\n\n  var shouldLog = typeof match === 'undefined';\n\n  var _parseMatchArg = parseMatchArg(match),\n      isInvertedMatch = _parseMatchArg.isInvertedMatch,\n      matchRegexp = _parseMatchArg.matchRegexp;\n\n  var rafWrapper = function rafWrapper(callback) {\n    var shouldPrevent = false;\n\n    if (shouldLog) {\n      var logMessage = \"log: requestAnimationFrame(\\\"\".concat(callback.toString(), \"\\\")\");\n      hit(source, logMessage);\n    } else {\n      shouldPrevent = matchRegexp.test(callback.toString()) !== isInvertedMatch;\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return nativeRequestAnimationFrame(noopFunc);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return nativeRequestAnimationFrame.apply(window, [callback].concat(args));\n  };\n\n  window.requestAnimationFrame = rafWrapper;\n}\npreventRequestAnimationFrame.names = ['prevent-requestAnimationFrame', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-requestAnimationFrame-if.js', 'ubo-no-requestAnimationFrame-if.js', 'norafif.js', 'ubo-norafif.js', 'ubo-no-requestAnimationFrame-if', 'ubo-norafif'];\npreventRequestAnimationFrame.injections = [hit, noopFunc, parseMatchArg, toRegExp, startsWith];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet set-cookie\n *\n * @description\n * Sets a cookie with the specified name and value. Cookie path defaults to root.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('set-cookie', name, value)\n * ```\n *\n * - `name` - required, cookie name to be set\n * - `value` - required, cookie value; possible values:\n *     - number `>= 0 && <= 15`\n *     - one of the predefined constants:\n *         - `true` / `True`\n *         - `false` / `False`\n *         - `yes` / `Yes` / `Y`\n *         - `no`\n *         - `ok` / `OK`\n *\n * **Examples**\n * ```\n * example.org#%#//scriptlet('set-cookie', 'ReadlyCookieConsent', '1'\n *\n * example.org#%#//scriptlet('set-cookie', 'gdpr-settings-cookie', 'true')\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction setCookie(source, name, value) {\n  var cookieData = prepareCookie(name, value);\n\n  if (cookieData) {\n    hit(source);\n    document.cookie = cookieData;\n  }\n}\nsetCookie.names = ['set-cookie'];\nsetCookie.injections = [hit, nativeIsNaN, prepareCookie];\n\n/**\n * @scriptlet set-cookie-reload\n *\n * @description\n * Sets a cookie with the specified name and value, and then reloads the current page.\n * If reloading option is not needed, use [set-cookie](#set-cookie) scriptlet.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('set-cookie-reload', name, value)\n * ```\n *\n * - `name` - required, cookie name to be set\n * - `value` - required, cookie value; possible values:\n *     - number `>= 0 && <= 15`\n *     - one of the predefined constants:\n *         - `true` / `True`\n *         - `false` / `False`\n *         - `yes` / `Yes` / `Y`\n *         - `no`\n *         - `ok` / `OK`\n *\n * **Examples**\n * ```\n * example.org#%#//scriptlet('set-cookie-reload', 'checking', 'ok')\n *\n * example.org#%#//scriptlet('set-cookie-reload', 'gdpr-settings-cookie', '1')\n * ```\n */\n\nfunction setCookieReload(source, name, value) {\n  var isCookieAlreadySet = document.cookie.split(';').some(function (cookieStr) {\n    var pos = cookieStr.indexOf('=');\n\n    if (pos === -1) {\n      return false;\n    }\n\n    var cookieName = cookieStr.slice(0, pos).trim();\n    var cookieValue = cookieStr.slice(pos + 1).trim();\n    return name === cookieName && value === cookieValue;\n  });\n  var shouldReload = !isCookieAlreadySet;\n  var cookieData = prepareCookie(name, value);\n\n  if (cookieData) {\n    hit(source);\n    document.cookie = cookieData;\n\n    if (shouldReload) {\n      window.location.reload();\n    }\n  }\n}\nsetCookieReload.names = ['set-cookie-reload'];\nsetCookieReload.injections = [hit, nativeIsNaN, prepareCookie];\n\n/**\n * @scriptlet hide-in-shadow-dom\n *\n * @description\n * Hides elements inside open shadow DOM elements.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('hide-in-shadow-dom', selector[, baseSelector])\n * ```\n *\n * - `selector`  required, CSS selector of element in shadow-dom to hide\n * - `baseSelector`  optional, selector of specific page DOM element,\n * narrows down the part of the page DOM where shadow-dom host supposed to be,\n * defaults to document.documentElement\n *\n * > `baseSelector` should match element of the page DOM, but not of shadow DOM\n *\n * **Examples**\n * ```\n * ! hides menu bar\n * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')\n *\n * ! hides floating element\n * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'vt-ui-contact-fab')\n * ```\n */\n\nfunction hideInShadowDom(source, selector, baseSelector) {\n  // do nothing if browser does not support ShadowRoot\n  // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot\n  if (!Element.prototype.attachShadow) {\n    return;\n  }\n\n  var hideElement = function hideElement(targetElement) {\n    var DISPLAY_NONE_CSS = 'display:none!important;';\n    targetElement.style.cssText = DISPLAY_NONE_CSS;\n  };\n  /**\n   * Handles shadow-dom piercing and hiding of found elements\n   */\n\n\n  var hideHandler = function hideHandler() {\n    // start value of shadow-dom hosts for the page dom\n    var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector); // if there is shadow-dom host, they should be explored\n\n    while (hostElements.length !== 0) {\n      var isHidden = false;\n\n      var _pierceShadowDom = pierceShadowDom(selector, hostElements),\n          targets = _pierceShadowDom.targets,\n          innerHosts = _pierceShadowDom.innerHosts;\n\n      targets.forEach(function (targetEl) {\n        hideElement(targetEl);\n        isHidden = true;\n      });\n\n      if (isHidden) {\n        hit(source);\n      } // continue to pierce for inner shadow-dom hosts\n      // and search inside them while the next iteration\n\n\n      hostElements = innerHosts;\n    }\n  };\n\n  hideHandler();\n  observeDOMChanges(hideHandler, true);\n}\nhideInShadowDom.names = ['hide-in-shadow-dom'];\nhideInShadowDom.injections = [hit, observeDOMChanges, flatten, findHostElements, pierceShadowDom];\n\n/**\n * @scriptlet remove-in-shadow-dom\n *\n * @description\n * Removes elements inside open shadow DOM elements.\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('remove-in-shadow-dom', selector[, baseSelector])\n * ```\n *\n * - `selector`  required, CSS selector of element in shadow-dom to remove\n * - `baseSelector`  optional, selector of specific page DOM element,\n * narrows down the part of the page DOM where shadow-dom host supposed to be,\n * defaults to document.documentElement\n *\n * > `baseSelector` should match element of the page DOM, but not of shadow DOM\n *\n * **Examples**\n * ```\n * ! removes menu bar\n * virustotal.com#%#//scriptlet('remove-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')\n *\n * ! removes floating element\n * virustotal.com#%#//scriptlet('remove-in-shadow-dom', 'vt-ui-contact-fab')\n * ```\n */\n\nfunction removeInShadowDom(source, selector, baseSelector) {\n  // do nothing if browser does not support ShadowRoot\n  // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot\n  if (!Element.prototype.attachShadow) {\n    return;\n  }\n\n  var removeElement = function removeElement(targetElement) {\n    targetElement.remove();\n  };\n  /**\n   * Handles shadow-dom piercing and removing of found elements\n   */\n\n\n  var removeHandler = function removeHandler() {\n    // start value of shadow-dom hosts for the page dom\n    var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector); // if there is shadow-dom host, they should be explored\n\n    while (hostElements.length !== 0) {\n      var isRemoved = false;\n\n      var _pierceShadowDom = pierceShadowDom(selector, hostElements),\n          targets = _pierceShadowDom.targets,\n          innerHosts = _pierceShadowDom.innerHosts;\n\n      targets.forEach(function (targetEl) {\n        removeElement(targetEl);\n        isRemoved = true;\n      });\n\n      if (isRemoved) {\n        hit(source);\n      } // continue to pierce for inner shadow-dom hosts\n      // and search inside them while the next iteration\n\n\n      hostElements = innerHosts;\n    }\n  };\n\n  removeHandler();\n  observeDOMChanges(removeHandler, true);\n}\nremoveInShadowDom.names = ['remove-in-shadow-dom'];\nremoveInShadowDom.injections = [hit, observeDOMChanges, flatten, findHostElements, pierceShadowDom];\n\n/**\n * @scriptlet no-floc\n *\n * @description\n * Prevents using Google Chrome tracking feature called Federated Learning of Cohorts (aka \"FLoC\")\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-flocjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('no-floc')\n * ```\n */\n\nfunction noFloc(source) {\n  var FLOC_PROPERTY_NAME = 'interestCohort';\n\n  if (Document instanceof Object === false) {\n    return;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(Document.prototype, FLOC_PROPERTY_NAME) || Document.prototype[FLOC_PROPERTY_NAME] instanceof Function === false) {\n    return;\n  } // document.interestCohort() is async function so it's better to return Promise.reject()\n  // https://github.com/WICG/floc/blob/dcd4c042fa6a81b048e04a78b184ea4203a75219/README.md\n\n\n  Document.prototype[FLOC_PROPERTY_NAME] = noopPromiseReject;\n  hit(source);\n}\nnoFloc.names = ['no-floc', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-floc.js', 'ubo-no-floc.js', 'ubo-no-floc'];\nnoFloc.injections = [hit, noopPromiseReject];\n\n/* eslint-disable max-len */\n\n/**\n * @scriptlet prevent-fetch\n *\n * @description\n * Prevents `fetch` calls if **all** given parameters match\n *\n * Related UBO scriptlet:\n * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-fetch-ifjs-\n *\n * **Syntax**\n * ```\n * example.org#%#//scriptlet('prevent-fetch'[, propsToMatch])\n * ```\n *\n * - `propsToMatch` - optional, string of space-separated properties to match; possible props:\n *   - string or regular expression for matching the URL passed to fetch call; empty string or wildcard `*` for all fetch calls match\n *   - colon-separated pairs `name:value` where\n *     - `name` is [`init` option name](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#parameters)\n *     - `value` is string or regular expression for matching the value of the option passed to fetch call\n *\n * > Usage with no arguments will log fetch calls to browser console;\n * which is usefull for debugging but permitted for production filter lists.\n *\n * **Examples**\n * 1. Prevent all fetch calls\n *     ```\n *     example.org#%#//scriptlet('prevent-fetch', '*')\n *     ```\n *\n * 2. Prevent fetch call for specific url\n *     ```\n *     example.org#%#//scriptlet('prevent-fetch', '/url\\\\.part/')\n *     ```\n *\n * 3. Prevent fetch call for specific request method\n *     ```\n *     example.org#%#//scriptlet('prevent-fetch', 'method:HEAD')\n *     ```\n *\n * 4. Prevent fetch call for specific url and request method\n *     ```\n *     example.org#%#//scriptlet('prevent-fetch', '/specified_url_part/ method:/HEAD|GET/')\n *     ```\n */\n\n/* eslint-enable max-len */\n\nfunction preventFetch(source, propsToMatch) {\n  // do nothing if browser does not support fetch or Proxy (e.g. Internet Explorer)\n  // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n  if (typeof fetch === 'undefined' || typeof Proxy === 'undefined') {\n    return;\n  }\n\n  var handlerWrapper = function handlerWrapper(target, thisArg, args) {\n    var shouldPrevent = false;\n    var fetchData = getFetchData(args);\n\n    if (typeof propsToMatch === 'undefined') {\n      // log if no propsToMatch given\n      var logMessage = \"log: fetch( \".concat(objectToString(fetchData), \" )\");\n      hit(source, logMessage);\n    } else if (propsToMatch === '' || propsToMatch === getWildcardSymbol()) {\n      // prevent all fetch calls\n      shouldPrevent = true;\n    } else {\n      var matchData = convertMatchPropsToObj(propsToMatch); // prevent only if all props match\n\n      shouldPrevent = Object.keys(matchData).every(function (matchKey) {\n        var matchValue = matchData[matchKey];\n        return Object.prototype.hasOwnProperty.call(fetchData, matchKey) && matchValue.test(fetchData[matchKey]);\n      });\n    }\n\n    if (shouldPrevent) {\n      hit(source);\n      return noopPromiseResolve();\n    }\n\n    return Reflect.apply(target, thisArg, args);\n  };\n\n  var fetchHandler = {\n    apply: handlerWrapper\n  };\n  fetch = new Proxy(fetch, fetchHandler); // eslint-disable-line no-global-assign\n}\npreventFetch.names = ['prevent-fetch', // aliases are needed for matching the related scriptlet converted into our syntax\n'no-fetch-if.js', 'ubo-no-fetch-if.js', 'ubo-no-fetch-if'];\npreventFetch.injections = [hit, getFetchData, objectToString, convertMatchPropsToObj, noopPromiseResolve, getWildcardSymbol, toRegExp, isEmptyObject, getRequestData, getObjectEntries, getObjectFromEntries];\n\n/**\n * This file must export all scriptlets which should be accessible\n */\n\nvar scriptletList = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    abortOnPropertyRead: abortOnPropertyRead,\n    abortOnPropertyWrite: abortOnPropertyWrite,\n    preventSetTimeout: preventSetTimeout,\n    preventSetInterval: preventSetInterval,\n    preventWindowOpen: preventWindowOpen,\n    abortCurrentInlineScript: abortCurrentInlineScript,\n    setConstant: setConstant,\n    removeCookie: removeCookie,\n    preventAddEventListener: preventAddEventListener,\n    preventBab: preventBab,\n    nowebrtc: nowebrtc,\n    logAddEventListener: logAddEventListener,\n    logEval: logEval,\n    log: log,\n    noeval: noeval,\n    preventEvalIf: preventEvalIf,\n    preventFab: preventFab,\n    setPopadsDummy: setPopadsDummy,\n    preventPopadsNet: preventPopadsNet,\n    preventAdfly: preventAdfly,\n    debugOnPropertyRead: debugOnPropertyRead,\n    debugOnPropertyWrite: debugOnPropertyWrite,\n    debugCurrentInlineScript: debugCurrentInlineScript,\n    removeAttr: removeAttr,\n    removeClass: removeClass,\n    disableNewtabLinks: disableNewtabLinks,\n    adjustSetInterval: adjustSetInterval,\n    adjustSetTimeout: adjustSetTimeout,\n    dirString: dirString,\n    jsonPrune: jsonPrune,\n    preventRequestAnimationFrame: preventRequestAnimationFrame,\n    setCookie: setCookie,\n    setCookieReload: setCookieReload,\n    hideInShadowDom: hideInShadowDom,\n    removeInShadowDom: removeInShadowDom,\n    noFloc: noFloc,\n    preventFetch: preventFetch\n});\n\n/**\n * Store of ADG redirects names and thier analogs.\n * As it is not a compatibility table, no need to keep in redirects array third-party redirects.\n *\n * Needed only for converion purposes.\n * e.g. googletagmanager-gtm is removed and should be removed from compatibility table as well\n * but now it works as alias for google-analytics so it should stay valid for compiler\n */\nvar redirects = [{\n  adg: '1x1-transparent.gif',\n  ubo: '1x1.gif',\n  abp: '1x1-transparent-gif'\n}, {\n  adg: '2x2-transparent.png',\n  ubo: '2x2.png',\n  abp: '2x2-transparent-png'\n}, {\n  adg: '3x2-transparent.png',\n  ubo: '3x2.png',\n  abp: '3x2-transparent-png'\n}, {\n  adg: '32x32-transparent.png',\n  ubo: '32x32.png',\n  abp: '32x32-transparent-png'\n}, {\n  adg: 'amazon-apstag',\n  ubo: 'amazon_apstag.js'\n}, {\n  adg: 'google-analytics',\n  ubo: 'google-analytics_analytics.js'\n}, {\n  adg: 'google-analytics-ga',\n  ubo: 'google-analytics_ga.js'\n}, {\n  adg: 'googlesyndication-adsbygoogle',\n  ubo: 'googlesyndication_adsbygoogle.js'\n}, {\n  // https://github.com/AdguardTeam/Scriptlets/issues/127\n  adg: 'googletagmanager-gtm',\n  ubo: 'google-analytics_ga.js'\n}, {\n  adg: 'googletagservices-gpt',\n  ubo: 'googletagservices_gpt.js'\n}, {\n  adg: 'metrika-yandex-watch'\n}, {\n  adg: 'metrika-yandex-tag'\n}, {\n  adg: 'noeval',\n  ubo: 'noeval-silent.js'\n}, {\n  adg: 'noopcss',\n  abp: 'blank-css'\n}, {\n  adg: 'noopframe',\n  ubo: 'noop.html',\n  abp: 'blank-html'\n}, {\n  adg: 'noopjs',\n  ubo: 'noop.js',\n  abp: 'blank-js'\n}, {\n  adg: 'nooptext',\n  ubo: 'noop.txt',\n  abp: 'blank-text'\n}, {\n  adg: 'noopmp3-0.1s',\n  ubo: 'noop-0.1s.mp3',\n  abp: 'blank-mp3'\n}, {\n  adg: 'noopmp4-1s',\n  ubo: 'noop-1s.mp4',\n  abp: 'blank-mp4'\n}, {\n  adg: 'noopvmap-1.0',\n  ubo: 'noop-vmap1.0.xml'\n}, {\n  adg: 'noopvast-2.0'\n}, {\n  adg: 'noopvast-3.0'\n}, {\n  adg: 'prevent-bab',\n  ubo: 'nobab.js'\n}, {\n  adg: 'prevent-fab-3.2.0',\n  ubo: 'nofab.js'\n}, {\n  adg: 'prevent-popads-net',\n  ubo: 'popads.js'\n}, {\n  adg: 'scorecardresearch-beacon',\n  ubo: 'scorecardresearch_beacon.js'\n}, {\n  adg: 'set-popads-dummy',\n  ubo: 'popads-dummy.js'\n}, {\n  adg: 'empty',\n  ubo: 'empty'\n}];\n\nvar JS_RULE_MARKER = '#%#';\nvar COMMENT_MARKER = '!';\n/**\n * Checks if rule text is comment e.g. !!example.org##+js(set-constant.js, test, false)\n * @param {string} rule\n * @return {boolean}\n */\n\nvar isComment = function isComment(rule) {\n  return startsWith(rule, COMMENT_MARKER);\n};\n/* ************************************************************************\n *\n * Scriptlets\n *\n ************************************************************************** */\n\n/**\n * uBlock scriptlet rule mask\n */\n\n\nvar UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\\s*\\+js/;\nvar UBO_SCRIPTLET_MASK_1 = '##+js';\nvar UBO_SCRIPTLET_MASK_2 = '##script:inject';\nvar UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';\nvar UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';\n/**\n * AdBlock Plus snippet rule mask\n */\n\nvar ABP_SCRIPTLET_MASK = '#$#';\nvar ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';\n/**\n * AdGuard CSS rule mask\n */\n\nvar ADG_CSS_MASK_REG = /#@?\\$#.+?\\s*\\{.*\\}\\s*$/g;\n/**\n * Checks if the `rule` is AdGuard scriptlet rule\n * @param {string} rule - rule text\n */\n\nvar isAdgScriptletRule = function isAdgScriptletRule(rule) {\n  return !isComment(rule) && rule.indexOf(ADG_SCRIPTLET_MASK) > -1;\n};\n/**\n * Checks if the `rule` is uBO scriptlet rule\n * @param {string} rule rule text\n */\n\n\nvar isUboScriptletRule = function isUboScriptletRule(rule) {\n  return (rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);\n};\n/**\n * Checks if the `rule` is AdBlock Plus snippet\n * @param {string} rule rule text\n */\n\n\nvar isAbpSnippetRule = function isAbpSnippetRule(rule) {\n  return (rule.indexOf(ABP_SCRIPTLET_MASK) > -1 || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);\n};\n/**\n * Finds scriptlet by it's name\n * @param {string} name - scriptlet name\n */\n\n\nvar getScriptletByName = function getScriptletByName(name) {\n  var scriptlets = Object.keys(scriptletList).map(function (key) {\n    return scriptletList[key];\n  });\n  return scriptlets.find(function (s) {\n    return s.names // full match name checking\n    && (s.names.indexOf(name) > -1 // or check ubo alias name without '.js' at the end\n    || !endsWith(name, '.js') && s.names.indexOf(\"\".concat(name, \".js\")) > -1);\n  });\n};\n/**\n * Checks if the scriptlet name is valid\n * @param {string} name - Scriptlet name\n */\n\n\nvar isValidScriptletName = function isValidScriptletName(name) {\n  if (!name) {\n    return false;\n  }\n\n  var scriptlet = getScriptletByName(name);\n\n  if (!scriptlet) {\n    return false;\n  }\n\n  return true;\n};\n/* ************************************************************************\n *\n * Redirects\n *\n ************************************************************************** */\n\n/**\n * Redirect resources markers\n */\n\n\nvar ADG_UBO_REDIRECT_MARKER = 'redirect=';\nvar ABP_REDIRECT_MARKER = 'rewrite=abp-resource:';\nvar EMPTY_REDIRECT_MARKER = 'empty';\nvar VALID_SOURCE_TYPES = ['image', 'media', 'subdocument', 'stylesheet', 'script', 'xmlhttprequest', 'other'];\n/**\n * Source types for redirect rules if there is no one of them.\n * Used for ADG -> UBO conversion.\n */\n\nvar ABSENT_SOURCE_TYPE_REPLACEMENT = [{\n  NAME: 'nooptext',\n  TYPES: VALID_SOURCE_TYPES\n}, {\n  NAME: 'noopjs',\n  TYPES: ['script']\n}, {\n  NAME: 'noopframe',\n  TYPES: ['subdocument']\n}, {\n  NAME: '1x1-transparent.gif',\n  TYPES: ['image']\n}, {\n  NAME: 'noopmp3-0.1s',\n  TYPES: ['media']\n}, {\n  NAME: 'noopmp4-1s',\n  TYPES: ['media']\n}, {\n  NAME: 'googlesyndication-adsbygoogle',\n  TYPES: ['xmlhttprequest', 'script']\n}, {\n  NAME: 'google-analytics',\n  TYPES: ['script']\n}, {\n  NAME: 'googletagservices-gpt',\n  TYPES: ['script']\n}];\nvar validAdgRedirects = redirects.filter(function (el) {\n  return el.adg;\n});\n/**\n * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names\n * It's used for UBO -> ADG converting\n */\n\nvar uboToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {\n  return el.ubo;\n}).map(function (el) {\n  return [el.ubo, el.adg];\n}));\n/**\n * Compatibility object where KEYS = ABP redirect names and VALUES = ADG redirect names\n * It's used for ABP -> ADG converting\n */\n\nvar abpToAdgCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {\n  return el.abp;\n}).map(function (el) {\n  return [el.abp, el.adg];\n}));\n/**\n * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names\n * It's used for ADG -> UBO converting\n */\n\nvar adgToUboCompatibility = getObjectFromEntries(validAdgRedirects.filter(function (el) {\n  return el.ubo;\n}).map(function (el) {\n  return [el.adg, el.ubo];\n}));\n/**\n * Needed for AdGuard redirect names validation where KEYS = **valid** AdGuard redirect names\n * 'adgToUboCompatibility' is still needed for ADG -> UBO converting\n */\n\nvar validAdgCompatibility = getObjectFromEntries(validAdgRedirects.map(function (el) {\n  return [el.adg, 'valid adg redirect'];\n}));\nvar REDIRECT_RULE_TYPES = {\n  VALID_ADG: {\n    marker: ADG_UBO_REDIRECT_MARKER,\n    compatibility: validAdgCompatibility\n  },\n  ADG: {\n    marker: ADG_UBO_REDIRECT_MARKER,\n    compatibility: adgToUboCompatibility\n  },\n  UBO: {\n    marker: ADG_UBO_REDIRECT_MARKER,\n    compatibility: uboToAdgCompatibility\n  },\n  ABP: {\n    marker: ABP_REDIRECT_MARKER,\n    compatibility: abpToAdgCompatibility\n  }\n};\n/**\n * Parses redirect rule modifiers\n * @param {string} rule\n * @returns {Array}\n */\n\nvar parseModifiers = function parseModifiers(rule) {\n  return substringAfter(rule, '$').split(',');\n};\n/**\n * Gets redirect resource name\n * @param {string} rule\n * @param {string} marker - specific Adg/Ubo or Abp redirect resources marker\n * @returns {string} - redirect resource name\n */\n\n\nvar getRedirectName = function getRedirectName(rule, marker) {\n  var ruleModifiers = parseModifiers(rule);\n  var redirectNamePart = ruleModifiers.find(function (el) {\n    return el.indexOf(marker) > -1;\n  });\n  return substringAfter(redirectNamePart, marker);\n};\n/**\n * Checks if the `rule` is AdGuard redirect rule.\n * Discards comments and JS rules and checks if the `rule` has 'redirect' modifier.\n * @param {string} rule - rule text\n */\n\n\nvar isAdgRedirectRule = function isAdgRedirectRule(rule) {\n  var MARKER_IN_BASE_PART_MASK = '/((?!\\\\$|\\\\,).{1})redirect=(.{0,}?)\\\\$(popup)?/';\n  return !isComment(rule) && rule.indexOf(REDIRECT_RULE_TYPES.ADG.marker) > -1 // some js rules may have 'redirect=' in it, so we should get rid of them\n  && rule.indexOf(JS_RULE_MARKER) === -1 // get rid of rules like '_redirect=*://look.$popup'\n  && !toRegExp(MARKER_IN_BASE_PART_MASK).test(rule);\n};\n/**\n * Checks if the `rule` satisfies the `type`\n * @param {string} rule - rule text\n * @param {'VALID_ADG'|'ADG'|'UBO'|'ABP'} type - type of a redirect rule\n */\n\n\nvar isRedirectRuleByType = function isRedirectRuleByType(rule, type) {\n  var _REDIRECT_RULE_TYPES$ = REDIRECT_RULE_TYPES[type],\n      marker = _REDIRECT_RULE_TYPES$.marker,\n      compatibility = _REDIRECT_RULE_TYPES$.compatibility;\n\n  if (rule && !isComment(rule) && rule.indexOf(marker) > -1) {\n    var redirectName = getRedirectName(rule, marker);\n\n    if (!redirectName) {\n      return false;\n    }\n\n    return redirectName === Object.keys(compatibility).find(function (el) {\n      return el === redirectName;\n    });\n  }\n\n  return false;\n};\n/**\n* Checks if the `rule` is **valid** AdGuard redirect resource rule\n* @param {string} rule - rule text\n* @returns {boolean}\n*/\n\n\nvar isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {\n  return isRedirectRuleByType(rule, 'VALID_ADG');\n};\n/**\n* Checks if the AdGuard redirect `rule` has Ubo analog. Needed for Adg->Ubo conversion\n* @param {string} rule - AdGuard rule text\n* @returns {boolean} - true if the rule can be converted to Ubo\n*/\n\n\nvar isAdgRedirectCompatibleWithUbo = function isAdgRedirectCompatibleWithUbo(rule) {\n  return isAdgRedirectRule(rule) && isRedirectRuleByType(rule, 'ADG');\n};\n/**\n* Checks if the Ubo redirect `rule` has AdGuard analog. Needed for Ubo->Adg conversion\n* @param {string} rule - Ubo rule text\n* @returns {boolean} - true if the rule can be converted to AdGuard\n*/\n\n\nvar isUboRedirectCompatibleWithAdg = function isUboRedirectCompatibleWithAdg(rule) {\n  return isRedirectRuleByType(rule, 'UBO');\n};\n/**\n* Checks if the Abp redirect `rule` has AdGuard analog. Needed for Abp->Adg conversion\n* @param {string} rule - Abp rule text\n* @returns {boolean} - true if the rule can be converted to AdGuard\n*/\n\n\nvar isAbpRedirectCompatibleWithAdg = function isAbpRedirectCompatibleWithAdg(rule) {\n  return isRedirectRuleByType(rule, 'ABP');\n};\n/**\n * Checks if the rule has specified content type before Adg -> Ubo conversion.\n *\n * Used ONLY for Adg -> Ubo conversion\n * because Ubo redirect rules must contain content type, but Adg and Abp must not.\n *\n * Also source type can not be added automatically because of such valid rules:\n * ! Abp:\n * $rewrite=abp-resource:blank-js,xmlhttprequest\n * ! Adg:\n * $script,redirect=noopvast-2.0\n * $xmlhttprequest,redirect=noopvast-2.0\n *\n * @param {string} rule\n * @returns {boolean}\n */\n\n\nvar hasValidContentType = function hasValidContentType(rule) {\n  var ruleModifiers = parseModifiers(rule); // rule can have more than one source type modifier\n\n  var sourceTypes = ruleModifiers.filter(function (el) {\n    return VALID_SOURCE_TYPES.indexOf(el) > -1;\n  });\n  var isSourceTypeSpecified = sourceTypes.length > 0;\n  var isEmptyRedirect = ruleModifiers.indexOf(\"\".concat(ADG_UBO_REDIRECT_MARKER).concat(EMPTY_REDIRECT_MARKER)) > -1;\n\n  if (isEmptyRedirect) {\n    // no source type for 'empty' is allowed\n    return true;\n  }\n\n  return isSourceTypeSpecified;\n};\n\nvar validator = {\n  UBO_SCRIPTLET_MASK_REG: UBO_SCRIPTLET_MASK_REG,\n  ABP_SCRIPTLET_MASK: ABP_SCRIPTLET_MASK,\n  ABP_SCRIPTLET_EXCEPTION_MASK: ABP_SCRIPTLET_EXCEPTION_MASK,\n  isComment: isComment,\n  isAdgScriptletRule: isAdgScriptletRule,\n  isUboScriptletRule: isUboScriptletRule,\n  isAbpSnippetRule: isAbpSnippetRule,\n  getScriptletByName: getScriptletByName,\n  isValidScriptletName: isValidScriptletName,\n  REDIRECT_RULE_TYPES: REDIRECT_RULE_TYPES,\n  ABSENT_SOURCE_TYPE_REPLACEMENT: ABSENT_SOURCE_TYPE_REPLACEMENT,\n  isAdgRedirectRule: isAdgRedirectRule,\n  isValidAdgRedirectRule: isValidAdgRedirectRule,\n  isAdgRedirectCompatibleWithUbo: isAdgRedirectCompatibleWithUbo,\n  isUboRedirectCompatibleWithAdg: isUboRedirectCompatibleWithAdg,\n  isAbpRedirectCompatibleWithAdg: isAbpRedirectCompatibleWithAdg,\n  parseModifiers: parseModifiers,\n  getRedirectName: getRedirectName,\n  hasValidContentType: hasValidContentType\n};\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar arrayLikeToArray = _arrayLikeToArray;\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nvar arrayWithoutHoles = _arrayWithoutHoles;\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nvar iterableToArray = _iterableToArray;\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nvar unsupportedIterableToArray = _unsupportedIterableToArray;\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar nonIterableSpread = _nonIterableSpread;\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nvar toConsumableArray = _toConsumableArray;\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar arrayWithHoles = _arrayWithHoles;\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar nonIterableRest = _nonIterableRest;\n\nfunction _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}\n\nvar toArray = _toArray;\n\n/**\n * AdGuard scriptlet rule\n */\n\nvar ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\\/\\/scriptlet\\(.+\\)/; // eslint-disable-next-line no-template-curly-in-string\n\nvar ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})'; // eslint-disable-next-line no-template-curly-in-string\n\nvar ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';\n/**\n * uBlock scriptlet rule mask\n */\n// eslint-disable-next-line no-template-curly-in-string\n\nvar UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})'; // eslint-disable-next-line no-template-curly-in-string\n\nvar UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';\nvar UBO_ALIAS_NAME_MARKER = 'ubo-';\nvar UBO_SCRIPTLET_JS_ENDING = '.js'; // https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#xhr\n\nvar UBO_XHR_TYPE = 'xhr';\nvar ADG_XHR_TYPE = 'xmlhttprequest';\nvar ADG_SET_CONSTANT_NAME = 'set-constant';\nvar ADG_SET_CONSTANT_EMPTY_STRING = '';\nvar UBO_SET_CONSTANT_EMPTY_STRING = '\\'\\'';\nvar ADG_PREVENT_FETCH_NAME = 'prevent-fetch';\nvar ADG_PREVENT_FETCH_EMPTY_STRING = '';\nvar ADG_PREVENT_FETCH_WILDCARD = getWildcardSymbol();\nvar UBO_NO_FETCH_IF_WILDCARD = '/^/';\nvar ESCAPED_COMMA_SEPARATOR = '\\\\,';\nvar COMMA_SEPARATOR = ',';\nvar MAX_REMOVE_ATTR_CLASS_ARGS_COUNT = 3;\nvar REMOVE_ATTR_METHOD = 'removeAttr';\nvar REMOVE_CLASS_METHOD = 'removeClass';\nvar REMOVE_ATTR_ALIASES = scriptletList[REMOVE_ATTR_METHOD].names;\nvar REMOVE_CLASS_ALIASES = scriptletList[REMOVE_CLASS_METHOD].names;\nvar ADG_REMOVE_ATTR_NAME = REMOVE_ATTR_ALIASES[0];\nvar ADG_REMOVE_CLASS_NAME = REMOVE_CLASS_ALIASES[0];\n/**\n * Returns array of strings separated by space which not in quotes\n * @param {string} str\n */\n\nvar getSentences = function getSentences(str) {\n  var reg = /'.*?'|\".*?\"|\\S+/g;\n  return str.match(reg);\n};\n/**\n * Replaces string with data by placeholders\n * @param {string} str\n * @param {Object} data - where keys are placeholders names\n */\n\n\nvar replacePlaceholders = function replacePlaceholders(str, data) {\n  return Object.keys(data).reduce(function (acc, key) {\n    var reg = new RegExp(\"\\\\$\\\\{\".concat(key, \"\\\\}\"), 'g');\n    acc = acc.replace(reg, data[key]);\n    return acc;\n  }, str);\n};\n/**\n * Converts string of UBO scriptlet rule to AdGuard scritlet rule\n * @param {string} rule - UBO scriptlet rule\n * @returns {Array} - array with one AdGuard scriptlet rule\n */\n\n\nvar convertUboScriptletToAdg = function convertUboScriptletToAdg(rule) {\n  var domains = getBeforeRegExp(rule, validator.UBO_SCRIPTLET_MASK_REG);\n  var mask = rule.match(validator.UBO_SCRIPTLET_MASK_REG)[0];\n  var template;\n\n  if (mask.indexOf('@') > -1) {\n    template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;\n  } else {\n    template = ADGUARD_SCRIPTLET_TEMPLATE;\n  }\n\n  var parsedArgs = getStringInBraces(rule).split(/,\\s/g);\n\n  if (parsedArgs.length === 1) {\n    // Most probably this is not correct separator, in this case we use ','\n    parsedArgs = getStringInBraces(rule).split(/,/g);\n  }\n\n  var scriptletName = parsedArgs[0].indexOf(UBO_SCRIPTLET_JS_ENDING) > -1 ? \"ubo-\".concat(parsedArgs[0]) : \"ubo-\".concat(parsedArgs[0]).concat(UBO_SCRIPTLET_JS_ENDING);\n\n  if ((REMOVE_ATTR_ALIASES.indexOf(scriptletName) > -1 || REMOVE_CLASS_ALIASES.indexOf(scriptletName) > -1) && parsedArgs.length > MAX_REMOVE_ATTR_CLASS_ARGS_COUNT) {\n    parsedArgs = [parsedArgs[0], parsedArgs[1], // if there are more than 3 args for remove-attr/class scriptlet,\n    // ubo rule has maltiple selector separated by comma. so we should:\n    // 1. join them into a single string\n    // 2. replace escaped commas by regular ones\n    // https://github.com/AdguardTeam/Scriptlets/issues/133\n    replaceAll(parsedArgs.slice(2).join(\"\".concat(COMMA_SEPARATOR, \" \")), ESCAPED_COMMA_SEPARATOR, COMMA_SEPARATOR)];\n  }\n\n  var args = parsedArgs.map(function (arg, index) {\n    var outputArg = arg;\n\n    if (index === 0) {\n      outputArg = scriptletName;\n    } // for example: dramaserial.xyz##+js(abort-current-inline-script, $, popup)\n\n\n    if (arg === '$') {\n      outputArg = '$$';\n    }\n\n    return outputArg;\n  }).map(function (arg) {\n    return wrapInSingleQuotes(arg);\n  }).join(\"\".concat(COMMA_SEPARATOR, \" \"));\n  var adgRule = replacePlaceholders(template, {\n    domains: domains,\n    args: args\n  });\n  return [adgRule];\n};\n/**\n * Convert string of ABP snippet rule to AdGuard scritlet rule\n * @param {string} rule - ABP snippet rule\n * @returns {Array} - array of AdGuard scriptlet rules -\n * one or few items depends on Abp-rule\n */\n\nvar convertAbpSnippetToAdg = function convertAbpSnippetToAdg(rule) {\n  var SEMICOLON_DIVIDER = /;(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/g;\n  var mask = rule.indexOf(validator.ABP_SCRIPTLET_MASK) > -1 ? validator.ABP_SCRIPTLET_MASK : validator.ABP_SCRIPTLET_EXCEPTION_MASK;\n  var template = mask === validator.ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;\n  var domains = substringBefore(rule, mask);\n  var args = substringAfter(rule, mask);\n  return args.split(SEMICOLON_DIVIDER).map(function (args) {\n    return getSentences(args).filter(function (arg) {\n      return arg;\n    }).map(function (arg, index) {\n      return index === 0 ? \"abp-\".concat(arg) : arg;\n    }).map(function (arg) {\n      return wrapInSingleQuotes(arg);\n    }).join(\"\".concat(COMMA_SEPARATOR, \" \"));\n  }).map(function (args) {\n    return replacePlaceholders(template, {\n      domains: domains,\n      args: args\n    });\n  });\n};\n/**\n * Converts scriptlet rule to AdGuard one\n * @param {string} rule\n * @returns {Array} - array of AdGuard scriptlet rules -\n * one item for Adg and Ubo or few items for Abp\n */\n\nvar convertScriptletToAdg = function convertScriptletToAdg(rule) {\n  var result;\n\n  if (validator.isUboScriptletRule(rule)) {\n    result = convertUboScriptletToAdg(rule);\n  } else if (validator.isAbpSnippetRule(rule)) {\n    result = convertAbpSnippetToAdg(rule);\n  } else if (validator.isAdgScriptletRule(rule) || validator.isComment(rule)) {\n    result = [rule];\n  }\n\n  return result;\n};\n/**\n * Converts UBO scriptlet rule to AdGuard one\n * @param {string} rule - AdGuard scriptlet rule\n * @returns {string} - UBO scriptlet rule\n */\n\nvar convertAdgScriptletToUbo = function convertAdgScriptletToUbo(rule) {\n  var res;\n\n  if (validator.isAdgScriptletRule(rule)) {\n    var _parseRule = parseRule(rule),\n        parsedName = _parseRule.name,\n        parsedParams = _parseRule.args;\n\n    var preparedParams; // https://github.com/AdguardTeam/FiltersCompiler/issues/102\n\n    if (parsedName === ADG_SET_CONSTANT_NAME && parsedParams[1] === ADG_SET_CONSTANT_EMPTY_STRING) {\n      preparedParams = [parsedParams[0], UBO_SET_CONSTANT_EMPTY_STRING];\n    } else if (parsedName === ADG_PREVENT_FETCH_NAME // https://github.com/AdguardTeam/Scriptlets/issues/109\n    && (parsedParams[0] === ADG_PREVENT_FETCH_WILDCARD || parsedParams[0] === ADG_PREVENT_FETCH_EMPTY_STRING)) {\n      preparedParams = [UBO_NO_FETCH_IF_WILDCARD];\n    } else if ((parsedName === ADG_REMOVE_ATTR_NAME || parsedName === ADG_REMOVE_CLASS_NAME) && parsedParams[1] && parsedParams[1].indexOf(COMMA_SEPARATOR) > -1) {\n      preparedParams = [parsedParams[0], replaceAll(parsedParams[1], COMMA_SEPARATOR, ESCAPED_COMMA_SEPARATOR)];\n    } else {\n      preparedParams = parsedParams;\n    } // object of name and aliases for the Adg-scriptlet\n\n\n    var adgScriptletObject = Object.keys(scriptletList).map(function (el) {\n      return scriptletList[el];\n    }).map(function (s) {\n      var _s$names = toArray(s.names),\n          name = _s$names[0],\n          aliases = _s$names.slice(1);\n\n      return {\n        name: name,\n        aliases: aliases\n      };\n    }).find(function (el) {\n      return el.name === parsedName || el.aliases.indexOf(parsedName) >= 0;\n    });\n    var aliases = adgScriptletObject.aliases;\n\n    if (aliases.length > 0) {\n      var uboAlias = adgScriptletObject.aliases // eslint-disable-next-line no-restricted-properties\n      .find(function (alias) {\n        return alias.includes(UBO_ALIAS_NAME_MARKER);\n      });\n\n      if (uboAlias) {\n        var mask = rule.match(ADGUARD_SCRIPTLET_MASK_REG)[0];\n        var template;\n\n        if (mask.indexOf('@') > -1) {\n          template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;\n        } else {\n          template = UBO_SCRIPTLET_TEMPLATE;\n        }\n\n        var domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);\n        var uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '') // '.js' in the Ubo scriptlet name can be omitted\n        // https://github.com/gorhill/uBlock/wiki/Resources-Library#general-purpose-scriptlets\n        .replace(UBO_SCRIPTLET_JS_ENDING, '');\n        var args = preparedParams.length > 0 ? \"\".concat(uboName, \", \").concat(preparedParams.join(\"\".concat(COMMA_SEPARATOR, \" \"))) : uboName;\n        var uboRule = replacePlaceholders(template, {\n          domains: domains,\n          args: args\n        });\n        res = uboRule;\n      }\n    }\n  }\n\n  return res;\n};\n/**\n * Checks whether the ADG scriptlet exists or UBO/ABP scriptlet is compatible to ADG\n * @param {string} input - can be ADG or UBO or ABP scriptlet rule\n * @returns {boolean}\n */\n\nvar isValidScriptletRule = function isValidScriptletRule(input) {\n  if (!input) {\n    return false;\n  } // ABP 'input' rule may contain more than one snippet\n\n\n  var rulesArray = convertScriptletToAdg(input); // checking if each of parsed scriptlets is valid\n  // if at least one of them is not valid - whole 'input' rule is not valid too\n\n  var isValid = rulesArray.every(function (rule) {\n    var parsedRule = parseRule(rule);\n    return validator.isValidScriptletName(parsedRule.name);\n  });\n  return isValid;\n};\n/**\n * Converts Ubo redirect rule to Adg one\n * @param {string} rule\n * @returns {string}\n */\n\nvar convertUboRedirectToAdg = function convertUboRedirectToAdg(rule) {\n  var firstPartOfRule = substringBefore(rule, '$');\n  var uboModifiers = validator.parseModifiers(rule);\n  var adgModifiers = uboModifiers.map(function (el) {\n    if (el.indexOf(validator.REDIRECT_RULE_TYPES.UBO.marker) > -1) {\n      var uboName = substringAfter(el, validator.REDIRECT_RULE_TYPES.UBO.marker);\n      var adgName = validator.REDIRECT_RULE_TYPES.UBO.compatibility[uboName];\n      return \"\".concat(validator.REDIRECT_RULE_TYPES.ADG.marker).concat(adgName);\n    }\n\n    if (el === UBO_XHR_TYPE) {\n      return ADG_XHR_TYPE;\n    }\n\n    return el;\n  }).join(COMMA_SEPARATOR);\n  return \"\".concat(firstPartOfRule, \"$\").concat(adgModifiers);\n};\n/**\n * Converts Abp redirect rule to Adg one\n * @param {string} rule\n * @returns {string}\n */\n\nvar convertAbpRedirectToAdg = function convertAbpRedirectToAdg(rule) {\n  var firstPartOfRule = substringBefore(rule, '$');\n  var abpModifiers = validator.parseModifiers(rule);\n  var adgModifiers = abpModifiers.map(function (el) {\n    if (el.indexOf(validator.REDIRECT_RULE_TYPES.ABP.marker) > -1) {\n      var abpName = substringAfter(el, validator.REDIRECT_RULE_TYPES.ABP.marker);\n      var adgName = validator.REDIRECT_RULE_TYPES.ABP.compatibility[abpName];\n      return \"\".concat(validator.REDIRECT_RULE_TYPES.ADG.marker).concat(adgName);\n    }\n\n    return el;\n  }).join(COMMA_SEPARATOR);\n  return \"\".concat(firstPartOfRule, \"$\").concat(adgModifiers);\n};\n/**\n * Converts redirect rule to AdGuard one\n * @param {string} rule\n * @returns {string}\n */\n\nvar convertRedirectToAdg = function convertRedirectToAdg(rule) {\n  var result;\n\n  if (validator.isUboRedirectCompatibleWithAdg(rule)) {\n    result = convertUboRedirectToAdg(rule);\n  } else if (validator.isAbpRedirectCompatibleWithAdg(rule)) {\n    result = convertAbpRedirectToAdg(rule);\n  } else if (validator.isValidAdgRedirectRule(rule)) {\n    result = rule;\n  }\n\n  return result;\n};\n/**\n * Converts Adg redirect rule to Ubo one\n * 1. Checks if there is Ubo analog for Adg rule\n * 2. Parses the rule and chechs if there are any source type modifiers which are required by Ubo\n *    and if there are no one we add it manually to the end.\n *    Source types are chosen according to redirect name\n *    e.g. ||ad.com^$redirect=<name>,important  ->>  ||ad.com^$redirect=<name>,important,script\n * 3. Replaces Adg redirect name by Ubo analog\n * @param {string} rule\n * @returns {string}\n */\n\nvar convertAdgRedirectToUbo = function convertAdgRedirectToUbo(rule) {\n  if (!validator.isAdgRedirectCompatibleWithUbo(rule)) {\n    throw new Error(\"Unable to convert for uBO - unsupported redirect in rule: \".concat(rule));\n  }\n\n  var basePart = substringBefore(rule, '$');\n  var adgModifiers = validator.parseModifiers(rule);\n  var adgRedirectModifier = adgModifiers.find(function (el) {\n    return el.indexOf(validator.REDIRECT_RULE_TYPES.ADG.marker) > -1;\n  });\n  var adgRedirectName = adgRedirectModifier.slice(validator.REDIRECT_RULE_TYPES.ADG.marker.length);\n  var uboRedirectName = validator.REDIRECT_RULE_TYPES.ADG.compatibility[adgRedirectName];\n  var uboRedirectModifier = \"\".concat(validator.REDIRECT_RULE_TYPES.UBO.marker).concat(uboRedirectName);\n\n  if (!validator.hasValidContentType(rule)) {\n    // add missed source types as content type modifiers\n    var sourceTypesData = validator.ABSENT_SOURCE_TYPE_REPLACEMENT.find(function (el) {\n      return el.NAME === adgRedirectName;\n    });\n\n    if (typeof sourceTypesData === 'undefined') {\n      throw new Error(\"Unable to convert for uBO - no types to add for specific redirect in rule: \".concat(rule));\n    }\n\n    var additionModifiers = sourceTypesData.TYPES;\n    adgModifiers.push.apply(adgModifiers, toConsumableArray(additionModifiers));\n  }\n\n  var uboModifiers = adgModifiers.map(function (el) {\n    if (el === adgRedirectModifier) {\n      return uboRedirectModifier;\n    }\n\n    return el;\n  }).join(COMMA_SEPARATOR);\n  return \"\".concat(basePart, \"$\").concat(uboModifiers);\n};\n\n/**\n * @redirect google-analytics\n *\n * @description\n * Mocks Google's Analytics and Tag Manager APIs.\n * [Covers obsolete googletagmanager-gtm redirect functionality](https://github.com/AdguardTeam/Scriptlets/issues/127).\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/8cd2a1d263a96421487b39040c1d23eb01169484/src/web_accessible_resources/google-analytics_analytics.js\n *\n * **Example**\n * ```\n * ||google-analytics.com/analytics.js$script,redirect=google-analytics\n * ||googletagmanager.com/gtm.js$script,redirect=googletagmanager-gtm\n * ```\n */\n\nfunction GoogleAnalytics(source) {\n  // eslint-disable-next-line func-names\n  var Tracker = function Tracker() {}; // constructor\n\n\n  var proto = Tracker.prototype;\n  proto.get = noopFunc;\n  proto.set = noopFunc;\n  proto.send = noopFunc;\n  var googleAnalyticsName = window.GoogleAnalyticsObject || 'ga'; // a -- fake arg for 'ga.length < 1' antiadblock checking\n  // eslint-disable-next-line no-unused-vars\n\n  function ga(a) {\n    var len = arguments.length;\n\n    if (len === 0) {\n      return;\n    } // eslint-disable-next-line prefer-rest-params\n\n\n    var lastArg = arguments[len - 1];\n    var replacer;\n\n    if (lastArg instanceof Object && lastArg !== null && typeof lastArg.hitCallback === 'function') {\n      replacer = lastArg.hitCallback;\n    } else if (typeof lastArg === 'function') {\n      // https://github.com/AdguardTeam/Scriptlets/issues/98\n      replacer = function replacer() {\n        lastArg(ga.create());\n      };\n    }\n\n    try {\n      setTimeout(replacer, 1); // eslint-disable-next-line no-empty\n    } catch (ex) {}\n  }\n\n  ga.create = function () {\n    return new Tracker();\n  };\n\n  ga.getByName = noopNull;\n  ga.getAll = noopArray;\n  ga.remove = noopFunc;\n  ga.loaded = true;\n  window[googleAnalyticsName] = ga;\n  var _window = window,\n      dataLayer = _window.dataLayer,\n      google_optimize = _window.google_optimize; // eslint-disable-line camelcase\n\n  if (dataLayer instanceof Object === false) {\n    return;\n  }\n\n  if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {\n    dataLayer.hide.end();\n  }\n\n  if (typeof dataLayer.push === 'function') {\n    dataLayer.push = function (data) {\n      if (data instanceof Object && typeof data.eventCallback === 'function') {\n        setTimeout(data.eventCallback, 1);\n      }\n    };\n  } // https://github.com/AdguardTeam/Scriptlets/issues/81\n\n\n  if (google_optimize instanceof Object && typeof google_optimize.get === 'function') {\n    // eslint-disable-line camelcase\n    var googleOptimizeWrapper = {};\n    googleOptimizeWrapper.get = noopFunc;\n    window.google_optimize = googleOptimizeWrapper;\n  }\n\n  hit(source);\n}\nGoogleAnalytics.names = ['google-analytics', 'ubo-google-analytics_analytics.js', 'google-analytics_analytics.js', // https://github.com/AdguardTeam/Scriptlets/issues/127\n'googletagmanager-gtm', 'ubo-googletagmanager_gtm.js', 'googletagmanager_gtm.js'];\nGoogleAnalytics.injections = [hit, noopFunc, noopNull, noopArray];\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @redirect google-analytics-ga\n *\n * @description\n * Mocks old Google Analytics API.\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/google-analytics_ga.js\n *\n * **Example**\n * ```\n * ||google-analytics.com/ga.js$script,redirect=google-analytics-ga\n * ```\n */\n\nfunction GoogleAnalyticsGa(source) {\n  // Gaq constructor\n  function Gaq() {}\n\n  Gaq.prototype.Na = noopFunc;\n  Gaq.prototype.O = noopFunc;\n  Gaq.prototype.Sa = noopFunc;\n  Gaq.prototype.Ta = noopFunc;\n  Gaq.prototype.Va = noopFunc;\n  Gaq.prototype._createAsyncTracker = noopFunc;\n  Gaq.prototype._getAsyncTracker = noopFunc;\n  Gaq.prototype._getPlugin = noopFunc;\n\n  Gaq.prototype.push = function (data) {\n    if (typeof data === 'function') {\n      data();\n      return;\n    }\n\n    if (Array.isArray(data) === false) {\n      return;\n    } // https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiDomainDirectory#_gat.GA_Tracker_._link\n\n\n    if (data[0] === '_link' && typeof data[1] === 'string') {\n      window.location.assign(data[1]);\n    } // https://github.com/gorhill/uBlock/issues/2162\n\n\n    if (data[0] === '_set' && data[1] === 'hitCallback' && typeof data[2] === 'function') {\n      data[2]();\n    }\n  };\n\n  var gaq = new Gaq();\n  var asyncTrackers = window._gaq || [];\n\n  if (Array.isArray(asyncTrackers)) {\n    while (asyncTrackers[0]) {\n      gaq.push(asyncTrackers.shift());\n    }\n  } // eslint-disable-next-line no-multi-assign\n\n\n  window._gaq = gaq.qf = gaq; // Gat constructor\n\n  function Gat() {} // Mock tracker api\n\n\n  var api = ['_addIgnoredOrganic', '_addIgnoredRef', '_addItem', '_addOrganic', '_addTrans', '_clearIgnoredOrganic', '_clearIgnoredRef', '_clearOrganic', '_cookiePathCopy', '_deleteCustomVar', '_getName', '_setAccount', '_getAccount', '_getClientInfo', '_getDetectFlash', '_getDetectTitle', '_getLinkerUrl', '_getLocalGifPath', '_getServiceMode', '_getVersion', '_getVisitorCustomVar', '_initData', '_link', '_linkByPost', '_setAllowAnchor', '_setAllowHash', '_setAllowLinker', '_setCampContentKey', '_setCampMediumKey', '_setCampNameKey', '_setCampNOKey', '_setCampSourceKey', '_setCampTermKey', '_setCampaignCookieTimeout', '_setCampaignTrack', '_setClientInfo', '_setCookiePath', '_setCookiePersistence', '_setCookieTimeout', '_setCustomVar', '_setDetectFlash', '_setDetectTitle', '_setDomainName', '_setLocalGifPath', '_setLocalRemoteServerMode', '_setLocalServerMode', '_setReferrerOverride', '_setRemoteServerMode', '_setSampleRate', '_setSessionTimeout', '_setSiteSpeedSampleRate', '_setSessionCookieTimeout', '_setVar', '_setVisitorCookieTimeout', '_trackEvent', '_trackPageLoadTime', '_trackPageview', '_trackSocial', '_trackTiming', '_trackTrans', '_visitCode'];\n  var tracker = api.reduce(function (res, funcName) {\n    res[funcName] = noopFunc;\n    return res;\n  }, {});\n\n  tracker._getLinkerUrl = function (a) {\n    return a;\n  };\n\n  Gat.prototype._anonymizeIP = noopFunc;\n  Gat.prototype._createTracker = noopFunc;\n  Gat.prototype._forceSSL = noopFunc;\n  Gat.prototype._getPlugin = noopFunc;\n\n  Gat.prototype._getTracker = function () {\n    return tracker;\n  };\n\n  Gat.prototype._getTrackerByName = function () {\n    return tracker;\n  };\n\n  Gat.prototype._getTrackers = noopFunc;\n  Gat.prototype.aa = noopFunc;\n  Gat.prototype.ab = noopFunc;\n  Gat.prototype.hb = noopFunc;\n  Gat.prototype.la = noopFunc;\n  Gat.prototype.oa = noopFunc;\n  Gat.prototype.pa = noopFunc;\n  Gat.prototype.u = noopFunc;\n  var gat = new Gat();\n  window._gat = gat;\n  hit(source);\n}\nGoogleAnalyticsGa.names = ['google-analytics-ga', 'ubo-google-analytics_ga.js', 'google-analytics_ga.js'];\nGoogleAnalyticsGa.injections = [hit, noopFunc];\n\n/* eslint-disable max-len */\n\n/**\n * @redirect googlesyndication-adsbygoogle\n *\n * @description\n * Mocks Google AdSense API.\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googlesyndication_adsbygoogle.js\n *\n * **Example**\n * ```\n * ||pagead2.googlesyndication.com/pagead/js/adsbygoogle.js$script,redirect=googlesyndication-adsbygoogle\n * ```\n */\n\n/* eslint-enable max-len */\n\nfunction GoogleSyndicationAdsByGoogle(source) {\n  window.adsbygoogle = {\n    // https://github.com/AdguardTeam/Scriptlets/issues/113\n    // length: 0,\n    loaded: true,\n    push: function push() {\n      if (typeof this.length === 'undefined') {\n        this.length = 0;\n        this.length += 1;\n      }\n    }\n  };\n  var adElems = document.querySelectorAll('.adsbygoogle');\n  var css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';\n  var statusAttrName = 'data-adsbygoogle-status';\n  var ASWIFT_IFRAME_MARKER = 'aswift_';\n  var GOOGLE_ADS_IFRAME_MARKER = 'google_ads_iframe_';\n  var executed = false;\n\n  for (var i = 0; i < adElems.length; i += 1) {\n    var adElemChildNodes = adElems[i].childNodes;\n    var childNodesQuantity = adElemChildNodes.length; // childNodes of .adsbygoogle can be defined if scriptlet was executed before\n    // so we should check are that childNodes exactly defined by us\n    // TODO: remake after scriptlets context developing in 1.3\n\n    var areIframesDefined = false;\n\n    if (childNodesQuantity > 0) {\n      // it should be only 2 child iframes if scriptlet was executed\n      areIframesDefined = childNodesQuantity === 2 // the first of child nodes should be aswift iframe\n      && adElemChildNodes[0].tagName.toLowerCase() === 'iframe' && adElemChildNodes[0].id.indexOf(ASWIFT_IFRAME_MARKER) > -1 // the second of child nodes should be google_ads iframe\n      && adElemChildNodes[1].tagName.toLowerCase() === 'iframe' && adElemChildNodes[1].id.indexOf(GOOGLE_ADS_IFRAME_MARKER) > -1;\n    }\n\n    if (!areIframesDefined) {\n      // here we do the job if scriptlet has not been executed earlier\n      adElems[i].setAttribute(statusAttrName, 'done');\n      var aswiftIframe = document.createElement('iframe');\n      aswiftIframe.id = \"\".concat(ASWIFT_IFRAME_MARKER).concat(i);\n      aswiftIframe.style = css;\n      adElems[i].appendChild(aswiftIframe);\n      var innerAswiftIframe = document.createElement('iframe');\n      aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);\n      var googleadsIframe = document.createElement('iframe');\n      googleadsIframe.id = \"\".concat(GOOGLE_ADS_IFRAME_MARKER).concat(i);\n      googleadsIframe.style = css;\n      adElems[i].appendChild(googleadsIframe);\n      var innerGoogleadsIframe = document.createElement('iframe');\n      googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);\n      executed = true;\n    }\n  }\n\n  if (executed) {\n    hit(source);\n  }\n}\nGoogleSyndicationAdsByGoogle.names = ['googlesyndication-adsbygoogle', 'ubo-googlesyndication_adsbygoogle.js', 'googlesyndication_adsbygoogle.js'];\nGoogleSyndicationAdsByGoogle.injections = [hit];\n\n/**\n * @redirect googletagservices-gpt\n *\n * @description\n * Mocks Google Publisher Tag API.\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googletagservices_gpt.js\n *\n * **Example**\n * ```\n * ||googletagservices.com/tag/js/gpt.js$script,redirect=googletagservices-gpt\n * ```\n */\n\nfunction GoogleTagServicesGpt(source) {\n  var companionAdsService = {\n    addEventListener: noopThis,\n    enableSyncLoading: noopFunc,\n    setRefreshUnfilledSlots: noopFunc\n  };\n  var contentService = {\n    addEventListener: noopThis,\n    setContent: noopFunc\n  };\n\n  function PassbackSlot() {} // constructor\n\n\n  PassbackSlot.prototype.display = noopFunc;\n  PassbackSlot.prototype.get = noopNull;\n  PassbackSlot.prototype.set = noopThis;\n  PassbackSlot.prototype.setClickUrl = noopThis;\n  PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;\n  PassbackSlot.prototype.setTargeting = noopThis;\n  PassbackSlot.prototype.updateTargetingFromMap = noopThis;\n\n  function SizeMappingBuilder() {} // constructor\n\n\n  SizeMappingBuilder.prototype.addSize = noopThis;\n  SizeMappingBuilder.prototype.build = noopNull;\n\n  function Slot() {} // constructor\n\n\n  Slot.prototype.addService = noopThis;\n  Slot.prototype.clearCategoryExclusions = noopThis;\n  Slot.prototype.clearTargeting = noopThis;\n  Slot.prototype.defineSizeMapping = noopThis;\n  Slot.prototype.get = noopNull;\n  Slot.prototype.getAdUnitPath = noopArray;\n  Slot.prototype.getAttributeKeys = noopArray;\n  Slot.prototype.getCategoryExclusions = noopArray;\n  Slot.prototype.getDomId = noopStr;\n  Slot.prototype.getSlotElementId = noopStr;\n  Slot.prototype.getSlotId = noopThis;\n  Slot.prototype.getTargeting = noopArray;\n  Slot.prototype.getTargetingKeys = noopArray;\n  Slot.prototype.set = noopThis;\n  Slot.prototype.setCategoryExclusion = noopThis;\n  Slot.prototype.setClickUrl = noopThis;\n  Slot.prototype.setCollapseEmptyDiv = noopThis;\n  Slot.prototype.setTargeting = noopThis;\n  var pubAdsService = {\n    addEventListener: noopThis,\n    clear: noopFunc,\n    clearCategoryExclusions: noopThis,\n    clearTagForChildDirectedTreatment: noopThis,\n    clearTargeting: noopThis,\n    collapseEmptyDivs: noopFunc,\n    defineOutOfPagePassback: function defineOutOfPagePassback() {\n      return new PassbackSlot();\n    },\n    definePassback: function definePassback() {\n      return new PassbackSlot();\n    },\n    disableInitialLoad: noopFunc,\n    display: noopFunc,\n    enableAsyncRendering: noopFunc,\n    enableSingleRequest: noopFunc,\n    enableSyncRendering: noopFunc,\n    enableVideoAds: noopFunc,\n    get: noopNull,\n    getAttributeKeys: noopArray,\n    getTargeting: noopFunc,\n    getTargetingKeys: noopArray,\n    getSlots: noopArray,\n    refresh: noopFunc,\n    set: noopThis,\n    setCategoryExclusion: noopThis,\n    setCentering: noopFunc,\n    setCookieOptions: noopThis,\n    setForceSafeFrame: noopThis,\n    setLocation: noopThis,\n    setPublisherProvidedId: noopThis,\n    setRequestNonPersonalizedAds: noopThis,\n    setSafeFrameConfig: noopThis,\n    setTagForChildDirectedTreatment: noopThis,\n    setTargeting: noopThis,\n    setVideoContent: noopThis,\n    updateCorrelator: noopFunc\n  };\n  var _window = window,\n      _window$googletag = _window.googletag,\n      googletag = _window$googletag === void 0 ? {} : _window$googletag;\n  var _googletag$cmd = googletag.cmd,\n      cmd = _googletag$cmd === void 0 ? [] : _googletag$cmd;\n  googletag.apiReady = true;\n  googletag.cmd = [];\n\n  googletag.cmd.push = function (a) {\n    try {\n      a(); // eslint-disable-next-line no-empty\n    } catch (ex) {}\n\n    return 1;\n  };\n\n  googletag.companionAds = function () {\n    return companionAdsService;\n  };\n\n  googletag.content = function () {\n    return contentService;\n  };\n\n  googletag.defineOutOfPageSlot = function () {\n    return new Slot();\n  };\n\n  googletag.defineSlot = function () {\n    return new Slot();\n  };\n\n  googletag.destroySlots = noopFunc;\n  googletag.disablePublisherConsole = noopFunc;\n  googletag.display = noopFunc;\n  googletag.enableServices = noopFunc;\n  googletag.getVersion = noopStr;\n\n  googletag.pubads = function () {\n    return pubAdsService;\n  };\n\n  googletag.pubadsReady = true;\n  googletag.setAdIframeTitle = noopFunc;\n\n  googletag.sizeMapping = function () {\n    return new SizeMappingBuilder();\n  };\n\n  window.googletag = googletag;\n\n  while (cmd.length !== 0) {\n    googletag.cmd.push(cmd.shift());\n  }\n\n  hit(source);\n}\nGoogleTagServicesGpt.names = ['googletagservices-gpt', 'ubo-googletagservices_gpt.js', 'googletagservices_gpt.js'];\nGoogleTagServicesGpt.injections = [hit, noopFunc, noopThis, noopNull, noopArray, noopStr];\n\n/**\n * @redirect scorecardresearch-beacon\n *\n * @description\n * Mocks Scorecard Research API.\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/scorecardresearch_beacon.js\n *\n * **Example**\n * ```\n * ||sb.scorecardresearch.com/beacon.js$script,redirect=scorecardresearch-beacon\n * ```\n */\n\nfunction ScoreCardResearchBeacon(source) {\n  window.COMSCORE = {\n    purge: function purge() {\n      // eslint-disable-next-line no-underscore-dangle\n      window._comscore = [];\n    },\n    beacon: function beacon() {}\n  };\n  hit(source);\n}\nScoreCardResearchBeacon.names = ['scorecardresearch-beacon', 'ubo-scorecardresearch_beacon.js', 'scorecardresearch_beacon.js'];\nScoreCardResearchBeacon.injections = [hit];\n\n/**\n * @redirect metrika-yandex-tag\n *\n * @description\n * Mocks Yandex Metrika API.\n * https://yandex.ru/support/metrica/objects/method-reference.html\n *\n * **Example**\n * ```\n * ||mc.yandex.ru/metrika/tag.js$script,redirect=metrika-yandex-tag\n * ```\n */\n\nfunction metrikaYandexTag(source) {\n  var asyncCallbackFromOptions = function asyncCallbackFromOptions(param) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var callback = options.callback;\n    var ctx = options.ctx;\n\n    if (typeof callback === 'function') {\n      callback = ctx !== undefined ? callback.bind(ctx) : callback;\n      setTimeout(function () {\n        return callback();\n      });\n    }\n  };\n\n  var init = noopFunc;\n  /**\n   * https://yandex.ru/support/metrica/objects/addfileextension.html\n   */\n\n  var addFileExtension = noopFunc;\n  /**\n   * https://yandex.ru/support/metrica/objects/extlink.html\n   */\n\n  var extLink = asyncCallbackFromOptions;\n  /**\n   * https://yandex.ru/support/metrica/objects/file.html\n   */\n\n  var file = asyncCallbackFromOptions;\n  /**\n   * https://yandex.ru/support/metrica/objects/get-client-id.html\n   * @param {Function} cb\n   */\n\n  var getClientID = function getClientID(cb) {\n    setTimeout(cb(null));\n  };\n  /**\n   * https://yandex.ru/support/metrica/objects/hit.html\n   */\n\n\n  var hitFunc = asyncCallbackFromOptions;\n  /**\n   * https://yandex.ru/support/metrica/objects/notbounce.html\n   */\n\n  var notBounce = asyncCallbackFromOptions;\n  /**\n   * https://yandex.ru/support/metrica/objects/params-method.html\n   */\n\n  var params = noopFunc;\n  /**\n   * https://yandex.ru/support/metrica/objects/reachgoal.html\n   * @param {string} target\n   * @param {Object} params\n   * @param {Function} callback\n   * @param {any} ctx\n   */\n\n  var reachGoal = function reachGoal(target, params, callback, ctx) {\n    asyncCallbackFromOptions(null, {\n      callback: callback,\n      ctx: ctx\n    });\n  };\n  /**\n   * https://yandex.ru/support/metrica/objects/set-user-id.html\n   */\n\n\n  var setUserID = noopFunc;\n  /**\n   * https://yandex.ru/support/metrica/objects/user-params.html\n   */\n\n  var userParams = noopFunc;\n  var api = {\n    init: init,\n    addFileExtension: addFileExtension,\n    extLink: extLink,\n    file: file,\n    getClientID: getClientID,\n    hit: hitFunc,\n    notBounce: notBounce,\n    params: params,\n    reachGoal: reachGoal,\n    setUserID: setUserID,\n    userParams: userParams\n  };\n\n  function ym(id, funcName) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return api[funcName] && api[funcName].apply(api, args);\n  }\n\n  window.ym = ym;\n  hit(source);\n}\nmetrikaYandexTag.names = ['metrika-yandex-tag'];\nmetrikaYandexTag.injections = [hit, noopFunc];\n\n/**\n * @redirect metrika-yandex-watch\n *\n * @description\n * Mocks the old Yandex Metrika API.\n * https://yandex.ru/support/metrica/objects/_method-reference.html\n *\n * **Example**\n * ```\n * ||mc.yandex.ru/metrika/watch.js$script,redirect=metrika-yandex-watch\n * ```\n */\n\nfunction metrikaYandexWatch(source) {\n  var cbName = 'yandex_metrika_callbacks';\n  /**\n   * Gets callback and its context from options and call it in async way\n   * @param {Object} options Yandex Metrika API options\n   */\n\n  var asyncCallbackFromOptions = function asyncCallbackFromOptions() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = options.callback;\n    var ctx = options.ctx;\n\n    if (typeof callback === 'function') {\n      callback = ctx !== undefined ? callback.bind(ctx) : callback;\n      setTimeout(function () {\n        return callback();\n      });\n    }\n  };\n\n  function Metrika() {} // constructor\n  // Methods without options\n\n\n  Metrika.prototype.addFileExtension = noopFunc;\n  Metrika.prototype.getClientID = noopFunc;\n  Metrika.prototype.setUserID = noopFunc;\n  Metrika.prototype.userParams = noopFunc; // Methods with options\n  // The order of arguments should be kept in according to API\n\n  Metrika.prototype.extLink = function (url, options) {\n    asyncCallbackFromOptions(options);\n  };\n\n  Metrika.prototype.file = function (url, options) {\n    asyncCallbackFromOptions(options);\n  };\n\n  Metrika.prototype.hit = function (url, options) {\n    asyncCallbackFromOptions(options);\n  };\n\n  Metrika.prototype.reachGoal = function (target, params, cb, ctx) {\n    asyncCallbackFromOptions({\n      callback: cb,\n      ctx: ctx\n    });\n  };\n\n  Metrika.prototype.notBounce = asyncCallbackFromOptions;\n\n  if (window.Ya) {\n    window.Ya.Metrika = Metrika;\n  } else {\n    window.Ya = {\n      Metrika: Metrika\n    };\n  }\n\n  if (window[cbName] && Array.isArray(window[cbName])) {\n    window[cbName].forEach(function (func) {\n      if (typeof func === 'function') {\n        func();\n      }\n    });\n  }\n\n  hit(source);\n}\nmetrikaYandexWatch.names = ['metrika-yandex-watch'];\nmetrikaYandexWatch.injections = [hit, noopFunc];\n\n/**\n * @redirect amazon-apstag\n *\n * @description\n * Mocks Amazon's apstag.js\n *\n * Related UBO redirect resource:\n * https://github.com/gorhill/uBlock/blob/f842ab6d3c1cf0394f95d27092bf59627262da40/src/web_accessible_resources/amazon_apstag.js\n *\n * **Example**\n * ```\n * ||amazon-adsystem.com/aax2/apstag.js$script,redirect=amazon-apstag\n * ```\n */\n\nfunction AmazonApstag(source) {\n  var apstagWrapper = {\n    fetchBids: function fetchBids(a, b) {\n      if (typeof b === 'function') {\n        b([]);\n      }\n    },\n    init: noopFunc,\n    setDisplayBids: noopFunc,\n    targetingKeys: noopFunc\n  };\n  window.apstag = apstagWrapper;\n  hit(source);\n}\nAmazonApstag.names = ['amazon-apstag', 'ubo-amazon_apstag.js', 'amazon_apstag.js'];\nAmazonApstag.injections = [hit, noopFunc];\n\nvar redirectsList = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    noeval: noeval,\n    GoogleAnalytics: GoogleAnalytics,\n    GoogleAnalyticsGa: GoogleAnalyticsGa,\n    GoogleSyndicationAdsByGoogle: GoogleSyndicationAdsByGoogle,\n    GoogleTagServicesGpt: GoogleTagServicesGpt,\n    ScoreCardResearchBeacon: ScoreCardResearchBeacon,\n    metrikaYandexTag: metrikaYandexTag,\n    metrikaYandexWatch: metrikaYandexWatch,\n    preventFab: preventFab,\n    preventBab: preventBab,\n    setPopadsDummy: setPopadsDummy,\n    preventPopadsNet: preventPopadsNet,\n    AmazonApstag: AmazonApstag\n});\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar classCallCheck = _classCallCheck;\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar createClass = _createClass;\n\nfunction isNothing(subject) {\n  return typeof subject === 'undefined' || subject === null;\n}\n\nfunction isObject(subject) {\n  return typeof subject === 'object' && subject !== null;\n}\n\nfunction toArray$1(sequence) {\n  if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];\n  return [sequence];\n}\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction repeat(string, count) {\n  var result = '',\n      cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\nfunction isNegativeZero(number) {\n  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n}\n\nvar isNothing_1 = isNothing;\nvar isObject_1 = isObject;\nvar toArray_1 = toArray$1;\nvar repeat_1 = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1 = extend;\nvar common = {\n  isNothing: isNothing_1,\n  isObject: isObject_1,\n  toArray: toArray_1,\n  repeat: repeat_1,\n  isNegativeZero: isNegativeZero_1,\n  extend: extend_1\n};\n\n// YAML error class. http://stackoverflow.com/questions/8458984\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : ''); // Include stack trace in error object\n\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = new Error().stack || '';\n  }\n} // Inherit from Error\n\n\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result = this.name + ': ';\n  result += this.reason || '(unknown reason)';\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\nvar exception = YAMLException;\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name = name;\n  this.buffer = buffer;\n  this.position = position;\n  this.line = line;\n  this.column = column;\n}\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n  if (!this.buffer) return null;\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n  head = '';\n  start = this.position;\n\n  while (start > 0 && \"\\0\\r\\n\\x85\\u2028\\u2029\".indexOf(this.buffer.charAt(start - 1)) === -1) {\n    start -= 1;\n\n    if (this.position - start > maxLength / 2 - 1) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && \"\\0\\r\\n\\x85\\u2028\\u2029\".indexOf(this.buffer.charAt(end)) === -1) {\n    end += 1;\n\n    if (end - this.position > maxLength / 2 - 1) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\nMark.prototype.toString = function toString(compact) {\n  var snippet,\n      where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\nvar mark = Mark;\n\nvar TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];\nvar YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  }); // TODO: Add tag format check.\n\n  this.tag = tag;\n  this.kind = options['kind'] || null;\n\n  this.resolve = options['resolve'] || function () {\n    return true;\n  };\n\n  this.construct = options['construct'] || function (data) {\n    return data;\n  };\n\n  this.instanceOf = options['instanceOf'] || null;\n  this.predicate = options['predicate'] || null;\n  this.represent = options['represent'] || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type;\n\n/*eslint-disable max-len*/\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n    result.push(currentType);\n  });\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\nfunction compileMap()\n/* lists... */\n{\n  var result = {\n    scalar: {},\n    sequence: {},\n    mapping: {},\n    fallback: {}\n  },\n      index,\n      length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n\n  return result;\n}\n\nfunction Schema(definition) {\n  this.include = definition.include || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\nSchema.DEFAULT = null;\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new exception('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) {\n    return schema instanceof Schema;\n  })) {\n    throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type$1) {\n    return type$1 instanceof type;\n  })) {\n    throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\nvar schema = Schema;\n\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function construct(data) {\n    return data !== null ? data : '';\n  }\n});\n\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function construct(data) {\n    return data !== null ? data : [];\n  }\n});\n\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function construct(data) {\n    return data !== null ? data : {};\n  }\n});\n\nvar failsafe = new schema({\n  explicit: [str, seq, map]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n  var max = data.length;\n  return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function canonical() {\n      return '~';\n    },\n    lowercase: function lowercase() {\n      return 'null';\n    },\n    uppercase: function uppercase() {\n      return 'NULL';\n    },\n    camelcase: function camelcase() {\n      return 'Null';\n    }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n  var max = data.length;\n  return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' || data === 'True' || data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function lowercase(object) {\n      return object ? 'true' : 'false';\n    },\n    uppercase: function uppercase(object) {\n      return object ? 'TRUE' : 'FALSE';\n    },\n    camelcase: function camelcase(object) {\n      return object ? 'True' : 'False';\n    }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  || 0x41\n  /* A */\n  <= c && c <= 0x46\n  /* F */\n  || 0x61\n  /* a */\n  <= c && c <= 0x66\n  /* f */\n  ;\n}\n\nfunction isOctCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x37\n  /* 7 */\n  ;\n}\n\nfunction isDecCode(c) {\n  return 0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ;\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n  if (!max) return false;\n  ch = data[index]; // sign\n\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index]; // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n\n      return hasDigits && ch !== '_';\n    }\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n\n      return hasDigits && ch !== '_';\n    } // base 8\n\n\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isOctCode(data.charCodeAt(index))) return false;\n      hasDigits = true;\n    }\n\n    return hasDigits && ch !== '_';\n  } // base 10 (except 0) or base 60\n  // value should not start with `_`;\n\n\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (ch === ':') break;\n\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n\n    hasDigits = true;\n  } // Should have digits and should not end with `_`\n\n\n  if (!hasDigits || ch === '_') return false; // if !base60 - done;\n\n  if (ch !== ':') return true; // base60 almost not used, no needs to optimize\n\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data,\n      sign = 1,\n      ch,\n      base,\n      digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value, 16);\n    return sign * parseInt(value, 8);\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n    value = 0;\n    base = 1;\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n    return sign * value;\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary: function binary(obj) {\n      return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\n    },\n    octal: function octal(obj) {\n      return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);\n    },\n    decimal: function decimal(obj) {\n      return obj.toString(10);\n    },\n\n    /* eslint-disable max-len */\n    hexadecimal: function hexadecimal(obj) {\n      return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\n    }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary: [2, 'bin'],\n    octal: [8, 'oct'],\n    decimal: [10, 'dec'],\n    hexadecimal: [16, 'hex']\n  }\n});\n\nvar YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers\n'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2\n// special case, seems not from spec\n'|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // 20:59\n'|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' + // .inf\n'|[-+]?\\\\.(?:inf|Inf|INF)' + // .nan\n'|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n  // Probably should update regexp & check speed\n  data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n  value = data.replace(/_/g, '').toLowerCase();\n  sign = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n  } else if (value === '.nan') {\n    return NaN;\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n    value = 0.0;\n    base = 1;\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n    return sign * value;\n  }\n\n  return sign * parseFloat(value, 10);\n}\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase':\n        return '.nan';\n\n      case 'uppercase':\n        return '.NAN';\n\n      case 'camelcase':\n        return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase':\n        return '.inf';\n\n      case 'uppercase':\n        return '.INF';\n\n      case 'camelcase':\n        return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase':\n        return '-.inf';\n\n      case 'uppercase':\n        return '-.INF';\n\n      case 'camelcase':\n        return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\nvar json = new schema({\n  include: [failsafe],\n  implicit: [_null, bool, int, float]\n});\n\nvar core = new schema({\n  include: [json]\n});\n\nvar YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n'-([0-9][0-9])' + // [2] month\n'-([0-9][0-9])$'); // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n'-([0-9][0-9]?)' + // [2] month\n'-([0-9][0-9]?)' + // [3] day\n'(?:[Tt]|[ \\\\t]+)' + // ...\n'([0-9][0-9]?)' + // [4] hour\n':([0-9][0-9])' + // [5] minute\n':([0-9][0-9])' + // [6] second\n'(?:\\\\.([0-9]*))?' + // [7] fraction\n'(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n'(?::([0-9][0-9]))?))?$'); // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match,\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      fraction = 0,\n      delta = null,\n      tz_hour,\n      tz_minute,\n      date;\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n  if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day\n\n  year = +match[1];\n  month = +match[2] - 1; // JS month starts with 0\n\n  day = +match[3];\n\n  if (!match[4]) {\n    // no hour\n    return new Date(Date.UTC(year, month, day));\n  } // match: [4] hour [5] minute [6] second [7] fraction\n\n\n  hour = +match[4];\n  minute = +match[5];\n  second = +match[6];\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n\n    while (fraction.length < 3) {\n      // milli-seconds\n      fraction += '0';\n    }\n\n    fraction = +fraction;\n  } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n\n  if (match[9]) {\n    tz_hour = +match[10];\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n  if (delta) date.setTime(date.getTime() - delta);\n  return date;\n}\n\nfunction representYamlTimestamp(object\n/*, style*/\n) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\nfunction commonjsRequire (target) {\n\tthrow new Error('Could not dynamically require \"' + target + '\". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');\n}\n\n/*eslint-disable no-bitwise*/\n\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = commonjsRequire;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {} // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n  var code,\n      idx,\n      bitlen = 0,\n      max = data.length,\n      map = BASE64_MAP; // Convert one by one.\n\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx)); // Skip CR/LF\n\n    if (code > 64) continue; // Fail on illegal characters\n\n    if (code < 0) return false;\n    bitlen += 6;\n  } // If there are any bits left, source was corrupted\n\n\n  return bitlen % 8 === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx,\n      tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''),\n      // remove CR/LF & padding to simplify scan\n  max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = []; // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = bits << 6 | map.indexOf(input.charAt(idx));\n  } // Dump tail\n\n\n  tailbits = max % 4 * 6;\n\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 0xFF);\n    result.push(bits >> 8 & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 0xFF);\n    result.push(bits >> 2 & 0xFF);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 0xFF);\n  } // Wrap into Buffer for NodeJS and leave Array for browser\n\n\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object\n/*, style*/\n) {\n  var result = '',\n      bits = 0,\n      idx,\n      tail,\n      max = object.length,\n      map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  } // Dump tail\n\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[bits >> 18 & 0x3F];\n    result += map[bits >> 12 & 0x3F];\n    result += map[bits >> 6 & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[bits >> 10 & 0x3F];\n    result += map[bits >> 4 & 0x3F];\n    result += map[bits << 2 & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[bits >> 2 & 0x3F];\n    result += map[bits << 4 & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n  var objectKeys = [],\n      index,\n      length,\n      pair,\n      pairKey,\n      pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n  var index,\n      length,\n      pair,\n      keys,\n      result,\n      object = data;\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n    keys = Object.keys(pair);\n    if (keys.length !== 1) return false;\n    result[index] = [keys[0], pair[keys[0]]];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n  var index,\n      length,\n      pair,\n      keys,\n      result,\n      object = data;\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    keys = Object.keys(pair);\n    result[index] = [keys[0], pair[keys[0]]];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n  var key,\n      object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$1.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar default_safe = new schema({\n  include: [core],\n  implicit: [timestamp, merge],\n  explicit: [binary, omap, pairs, set]\n});\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return typeof object === 'undefined';\n}\n\nvar _undefined = new type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n\nfunction resolveJavascriptRegExp(data) {\n  if (data === null) return false;\n  if (data.length === 0) return false;\n  var regexp = data,\n      tail = /\\/([gim]*)$/.exec(data),\n      modifiers = ''; // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    if (modifiers.length > 3) return false; // if expression starts with /, is should be properly terminated\n\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n  }\n\n  return true;\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail = /\\/([gim]*)$/.exec(data),\n      modifiers = ''; // `/foo/gim` - tail can be maximum 4 chars\n\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object\n/*, style*/\n) {\n  var result = '/' + object.source + '/';\n  if (object.global) result += 'g';\n  if (object.multiline) result += 'm';\n  if (object.ignoreCase) result += 'i';\n  return result;\n}\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nvar regexp = new type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n\nvar esprima; // Browserified version does not have esprima\n//\n// 1. For node.js just require module as deps\n// 2. For browser try to require mudule via external AMD system.\n//    If not found - try to fallback to window.esprima. If not\n//    found too - then fail to parse.\n//\n\ntry {\n  // workaround to exclude package from browserify list.\n  var _require$1 = commonjsRequire;\n  esprima = _require$1('esprima');\n} catch (_) {\n  /* eslint-disable no-redeclare */\n\n  /* global window */\n  if (typeof window !== 'undefined') esprima = window.esprima;\n}\n\nfunction resolveJavascriptFunction(data) {\n  if (data === null) return false;\n\n  try {\n    var source = '(' + data + ')',\n        ast = esprima.parse(source, {\n      range: true\n    });\n\n    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction constructJavascriptFunction(data) {\n  /*jslint evil:true*/\n  var source = '(' + data + ')',\n      ast = esprima.parse(source, {\n    range: true\n  }),\n      params = [],\n      body;\n\n  if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n    throw new Error('Failed to resolve function');\n  }\n\n  ast.body[0].expression.params.forEach(function (param) {\n    params.push(param.name);\n  });\n  body = ast.body[0].expression.body.range; // Esprima's ranges include the first '{' and the last '}' characters on\n  // function expressions. So cut them out.\n\n  if (ast.body[0].expression.body.type === 'BlockStatement') {\n    /*eslint-disable no-new-func*/\n    return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n  } // ES6 arrow functions can omit the BlockStatement. In that case, just return\n  // the body.\n\n  /*eslint-disable no-new-func*/\n\n\n  return new Function(params, 'return ' + source.slice(body[0], body[1]));\n}\n\nfunction representJavascriptFunction(object\n/*, style*/\n) {\n  return object.toString();\n}\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nvar _function = new type('tag:yaml.org,2002:js/function', {\n  kind: 'scalar',\n  resolve: resolveJavascriptFunction,\n  construct: constructJavascriptFunction,\n  predicate: isFunction,\n  represent: representJavascriptFunction\n});\n\nvar default_full = schema.DEFAULT = new schema({\n  include: [default_safe],\n  explicit: [_undefined, regexp, _function]\n});\n\n/*eslint-disable max-len,no-use-before-define*/\n\n\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\nvar CONTEXT_FLOW_IN = 1;\nvar CONTEXT_FLOW_OUT = 2;\nvar CONTEXT_BLOCK_IN = 3;\nvar CONTEXT_BLOCK_OUT = 4;\nvar CHOMPING_CLIP = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP = 3;\nvar PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\nfunction _class(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction is_EOL(c) {\n  return c === 0x0A\n  /* LF */\n  || c === 0x0D\n  /* CR */\n  ;\n}\n\nfunction is_WHITE_SPACE(c) {\n  return c === 0x09\n  /* Tab */\n  || c === 0x20\n  /* Space */\n  ;\n}\n\nfunction is_WS_OR_EOL(c) {\n  return c === 0x09\n  /* Tab */\n  || c === 0x20\n  /* Space */\n  || c === 0x0A\n  /* LF */\n  || c === 0x0D\n  /* CR */\n  ;\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C\n  /* , */\n  || c === 0x5B\n  /* [ */\n  || c === 0x5D\n  /* ] */\n  || c === 0x7B\n  /* { */\n  || c === 0x7D\n  /* } */\n  ;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if (0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ) {\n    return c - 0x30;\n  }\n  /*eslint-disable no-bitwise*/\n\n\n  lc = c | 0x20;\n\n  if (0x61\n  /* a */\n  <= lc && lc <= 0x66\n  /* f */\n  ) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78\n  /* x */\n  ) {\n      return 2;\n    }\n\n  if (c === 0x75\n  /* u */\n  ) {\n      return 4;\n    }\n\n  if (c === 0x55\n  /* U */\n  ) {\n      return 8;\n    }\n\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if (0x30\n  /* 0 */\n  <= c && c <= 0x39\n  /* 9 */\n  ) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return c === 0x30\n  /* 0 */\n  ? '\\x00' : c === 0x61\n  /* a */\n  ? '\\x07' : c === 0x62\n  /* b */\n  ? '\\x08' : c === 0x74\n  /* t */\n  ? '\\x09' : c === 0x09\n  /* Tab */\n  ? '\\x09' : c === 0x6E\n  /* n */\n  ? '\\x0A' : c === 0x76\n  /* v */\n  ? '\\x0B' : c === 0x66\n  /* f */\n  ? '\\x0C' : c === 0x72\n  /* r */\n  ? '\\x0D' : c === 0x65\n  /* e */\n  ? '\\x1B' : c === 0x20\n  /* Space */\n  ? ' ' : c === 0x22\n  /* \" */\n  ? '\\x22' : c === 0x2F\n  /* / */\n  ? '/' : c === 0x5C\n  /* \\ */\n  ? '\\x5C' : c === 0x4E\n  /* N */\n  ? '\\x85' : c === 0x5F\n  /* _ */\n  ? '\\xA0' : c === 0x4C\n  /* L */\n  ? \"\\u2028\" : c === 0x50\n  /* P */\n  ? \"\\u2029\" : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  } // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n\n\n  return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\n\nvar simpleEscapeMap = new Array(256);\n\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\nfunction State(input, options) {\n  this.input = input;\n  this.filename = options['filename'] || null;\n  this.schema = options['schema'] || default_full;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy = options['legacy'] || false;\n  this.json = options['json'] || false;\n  this.listener = options['listener'] || null;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap = this.schema.compiledTypeMap;\n  this.length = input.length;\n  this.position = 0;\n  this.line = 0;\n  this.lineStart = 0;\n  this.lineIndent = 0;\n  this.documents = [];\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n}\n\nfunction generateError(state, message) {\n  return new exception(message, new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\nvar directiveHandlers = {\n  YAML: function handleYamlDirective(state, name, args) {\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = minor < 2;\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n  TAG: function handleTagDirective(state, name, args) {\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$2.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n\n        if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$2.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n  var index, quantity; // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  } // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n\n\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json && !_hasOwnProperty$2.call(overridableKeys, keyNode) && _hasOwnProperty$2.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    _result[keyNode] = valueNode;\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A\n  /* LF */\n  ) {\n      state.position++;\n    } else if (ch === 0x0D\n  /* CR */\n  ) {\n      state.position++;\n\n      if (state.input.charCodeAt(state.position) === 0x0A\n      /* LF */\n      ) {\n          state.position++;\n        }\n    } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23\n    /* # */\n    ) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0x0A\n        /* LF */\n        && ch !== 0x0D\n        /* CR */\n        && ch !== 0);\n      }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20\n      /* Space */\n      ) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n  ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n\n  if ((ch === 0x2D\n  /* - */\n  || ch === 0x2E\n  /* . */\n  ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n    _position += 3;\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23\n  /* # */\n  || ch === 0x26\n  /* & */\n  || ch === 0x2A\n  /* * */\n  || ch === 0x21\n  /* ! */\n  || ch === 0x7C\n  /* | */\n  || ch === 0x3E\n  /* > */\n  || ch === 0x27\n  /* ' */\n  || ch === 0x22\n  /* \" */\n  || ch === 0x25\n  /* % */\n  || ch === 0x40\n  /* @ */\n  || ch === 0x60\n  /* ` */\n  ) {\n      return false;\n    }\n\n  if (ch === 0x3F\n  /* ? */\n  || ch === 0x2D\n  /* - */\n  ) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        return false;\n      }\n    }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A\n    /* : */\n    ) {\n        following = state.input.charCodeAt(state.position + 1);\n\n        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n          break;\n        }\n      } else if (ch === 0x23\n    /* # */\n    ) {\n        preceding = state.input.charCodeAt(state.position - 1);\n\n        if (is_WS_OR_EOL(preceding)) {\n          break;\n        }\n      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch, captureStart, captureEnd;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27\n  /* ' */\n  ) {\n      return false;\n    }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27\n    /* ' */\n    ) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n\n        if (ch === 0x27\n        /* ' */\n        ) {\n            captureStart = state.position;\n            state.position++;\n            captureEnd = state.position;\n          } else {\n          return true;\n        }\n      } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22\n  /* \" */\n  ) {\n      return false;\n    }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22\n    /* \" */\n    ) {\n        captureSegment(state, captureStart, state.position, true);\n        state.position++;\n        return true;\n      } else if (ch === 0x5C\n    /* \\ */\n    ) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n\n        if (is_EOL(ch)) {\n          skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?\n        } else if (ch < 256 && simpleEscapeCheck[ch]) {\n          state.result += simpleEscapeMap[ch];\n          state.position++;\n        } else if ((tmp = escapedHexLen(ch)) > 0) {\n          hexLength = tmp;\n          hexResult = 0;\n\n          for (; hexLength > 0; hexLength--) {\n            ch = state.input.charCodeAt(++state.position);\n\n            if ((tmp = fromHexCode(ch)) >= 0) {\n              hexResult = (hexResult << 4) + tmp;\n            } else {\n              throwError(state, 'expected hexadecimal character');\n            }\n          }\n\n          state.result += charFromCodepoint(hexResult);\n          state.position++;\n        } else {\n          throwError(state, 'unknown escape sequence');\n        }\n\n        captureStart = captureEnd = state.position;\n      } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag = state.tag,\n      _result,\n      _anchor = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = {},\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B\n  /* [ */\n  ) {\n      terminator = 0x5D;\n      /* ] */\n\n      isMapping = false;\n      _result = [];\n    } else if (ch === 0x7B\n  /* { */\n  ) {\n      terminator = 0x7D;\n      /* } */\n\n      isMapping = true;\n      _result = {};\n    } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F\n    /* ? */\n    ) {\n        following = state.input.charCodeAt(state.position + 1);\n\n        if (is_WS_OR_EOL(following)) {\n          isPair = isExplicitPair = true;\n          state.position++;\n          skipSeparationSpace(state, true, nodeIndent);\n        }\n      }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A\n    /* : */\n    ) {\n        isPair = true;\n        ch = state.input.charCodeAt(++state.position);\n        skipSeparationSpace(state, true, nodeIndent);\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        valueNode = state.result;\n      }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C\n    /* , */\n    ) {\n        readNext = true;\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent = nodeIndent,\n      emptyLines = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C\n  /* | */\n  ) {\n      folding = false;\n    } else if (ch === 0x3E\n  /* > */\n  ) {\n      folding = true;\n    } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B\n    /* + */\n    || ch === 0x2D\n    /* - */\n    ) {\n        if (CHOMPING_CLIP === chomping) {\n          chomping = ch === 0x2B\n          /* + */\n          ? CHOMPING_KEEP : CHOMPING_STRIP;\n        } else {\n          throwError(state, 'repeat of a chomping mode identifier');\n        }\n      } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do {\n      ch = state.input.charCodeAt(++state.position);\n    } while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23\n    /* # */\n    ) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (!is_EOL(ch) && ch !== 0);\n      }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20\n    /* Space */\n    ) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    } // End of the scalar.\n\n\n    if (state.lineIndent < textIndent) {\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) {\n          // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      } // Break this `while` cycle and go to the funciton's epilogue.\n\n\n      break;\n    } // Folded style: use fancy rules to handle line breaks.\n\n\n    if (folding) {\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true; // except for the first content line (cf. Example 8.1)\n\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1); // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) {\n          // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        } // Several line breaks - perceive as different lines.\n\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      } // Literal style: just add exact number of line breaks between content lines.\n\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && ch !== 0) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag = state.tag,\n      _anchor = state.anchor,\n      _result = [],\n      following,\n      detected = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (ch !== 0x2D\n    /* - */\n    ) {\n        break;\n      }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n\n    _result.push(state.result);\n\n    skipSeparationSpace(state, true, -1);\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _pos,\n      _tag = state.tag,\n      _anchor = state.anchor,\n      _result = {},\n      overridableKeys = {},\n      keyTag = null,\n      keyNode = null,\n      valueNode = null,\n      atExplicitKey = false,\n      detected = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    _pos = state.position; //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n\n    if ((ch === 0x3F\n    /* ? */\n    || ch === 0x3A\n    /* : */\n    ) && is_WS_OR_EOL(following)) {\n      if (ch === 0x3F\n      /* ? */\n      ) {\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = true;\n          allowCompact = true;\n        } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following; //\n      // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n      //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A\n        /* : */\n        ) {\n            ch = state.input.charCodeAt(++state.position);\n\n            if (!is_WS_OR_EOL(ch)) {\n              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n            }\n\n            if (atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n              keyTag = keyNode = valueNode = null;\n            }\n\n            detected = true;\n            atExplicitKey = false;\n            allowCompact = false;\n            keyTag = state.tag;\n            keyNode = state.result;\n          } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    } else {\n        break; // Reading is done. Go to the epilogue.\n      } //\n    // Common reading code for both explicit and implicit notations.\n    //\n\n\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && ch !== 0) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  } //\n  // Epilogue.\n  //\n  // Special case: last mapping's node contains only the key in explicit notation.\n\n\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n  } // Expose the resulting mapping.\n\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x21\n  /* ! */\n  ) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C\n  /* < */\n  ) {\n      isVerbatim = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else if (ch === 0x21\n  /* ! */\n  ) {\n      isNamed = true;\n      tagHandle = '!!';\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do {\n      ch = state.input.charCodeAt(++state.position);\n    } while (ch !== 0 && ch !== 0x3E\n    /* > */\n    );\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      if (ch === 0x21\n      /* ! */\n      ) {\n          if (!isNamed) {\n            tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n              throwError(state, 'named tag handle cannot contain such characters');\n            }\n\n            isNamed = true;\n            _position = state.position + 1;\n          } else {\n            throwError(state, 'tag suffix cannot contain exclamation marks');\n          }\n        }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n  } else if (_hasOwnProperty$2.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position, ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x26\n  /* & */\n  ) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias, ch;\n\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 0x2A\n  /* * */\n  ) return false;\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$2.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1,\n      // 1: this>parent, 0: this=parent, -1: this<parent\n  atNewLine = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag = null;\n  state.anchor = null;\n  state.kind = null;\n  state.result = null;\n  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag !== null && state.tag !== '!') {\n    if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) {\n          // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n\n          break;\n        }\n      }\n    } else if (_hasOwnProperty$2.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) {\n        // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n\n  return state.tag !== null || state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25\n    /* % */\n    ) {\n        break;\n      }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23\n      /* # */\n      ) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (ch !== 0 && !is_EOL(ch));\n\n          break;\n        }\n\n      if (is_EOL(ch)) break;\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$2.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D\n  /* - */\n  && state.input.charCodeAt(state.position + 1) === 0x2D\n  /* - */\n  && state.input.charCodeAt(state.position + 2) === 0x2D\n  /* - */\n  ) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n    if (state.input.charCodeAt(state.position) === 0x2E\n    /* . */\n    ) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n      }\n\n    return;\n  }\n\n  if (state.position < state.length - 1) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A\n    /* LF */\n    && input.charCodeAt(input.length - 1) !== 0x0D\n    /* CR */\n    ) {\n        input += '\\n';\n      } // Strip BOM\n\n\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  } // Use 0 as string terminator. That significantly simplifies bounds check.\n\n\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20\n  /* Space */\n  ) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < state.length - 1) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n\n  throw new exception('expected a single document in the stream, but found more');\n}\n\nfunction safeLoadAll(input, iterator, options) {\n  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  return loadAll(input, iterator, common.extend({\n    schema: default_safe\n  }, options));\n}\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({\n    schema: default_safe\n  }, options));\n}\n\nvar loadAll_1 = loadAll;\nvar load_1 = load;\nvar safeLoadAll_1 = safeLoadAll;\nvar safeLoad_1 = safeLoad;\nvar loader = {\n  loadAll: loadAll_1,\n  load: load_1,\n  safeLoadAll: safeLoadAll_1,\n  safeLoad: safeLoad_1\n};\n\n/*eslint-disable no-use-before-define*/\n\n\nvar _toString$2 = Object.prototype.toString;\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar CHAR_TAB = 0x09;\n/* Tab */\n\nvar CHAR_LINE_FEED = 0x0A;\n/* LF */\n\nvar CHAR_CARRIAGE_RETURN = 0x0D;\n/* CR */\n\nvar CHAR_SPACE = 0x20;\n/* Space */\n\nvar CHAR_EXCLAMATION = 0x21;\n/* ! */\n\nvar CHAR_DOUBLE_QUOTE = 0x22;\n/* \" */\n\nvar CHAR_SHARP = 0x23;\n/* # */\n\nvar CHAR_PERCENT = 0x25;\n/* % */\n\nvar CHAR_AMPERSAND = 0x26;\n/* & */\n\nvar CHAR_SINGLE_QUOTE = 0x27;\n/* ' */\n\nvar CHAR_ASTERISK = 0x2A;\n/* * */\n\nvar CHAR_COMMA = 0x2C;\n/* , */\n\nvar CHAR_MINUS = 0x2D;\n/* - */\n\nvar CHAR_COLON = 0x3A;\n/* : */\n\nvar CHAR_EQUALS = 0x3D;\n/* = */\n\nvar CHAR_GREATER_THAN = 0x3E;\n/* > */\n\nvar CHAR_QUESTION = 0x3F;\n/* ? */\n\nvar CHAR_COMMERCIAL_AT = 0x40;\n/* @ */\n\nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n/* [ */\n\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n/* ] */\n\nvar CHAR_GRAVE_ACCENT = 0x60;\n/* ` */\n\nvar CHAR_LEFT_CURLY_BRACKET = 0x7B;\n/* { */\n\nvar CHAR_VERTICAL_LINE = 0x7C;\n/* | */\n\nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n/* } */\n\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = '\\\\0';\nESCAPE_SEQUENCES[0x07] = '\\\\a';\nESCAPE_SEQUENCES[0x08] = '\\\\b';\nESCAPE_SEQUENCES[0x09] = '\\\\t';\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85] = '\\\\N';\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\nvar DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n  if (map === null) return {};\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty$3.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State$1(options) {\n  this.schema = options['schema'] || default_full;\n  this.indent = Math.max(1, options['indent'] || 2);\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys = options['sortKeys'] || false;\n  this.lineWidth = options['lineWidth'] || 80;\n  this.noRefs = options['noRefs'] || false;\n  this.noCompatMode = options['noCompatMode'] || false;\n  this.condenseFlow = options['condenseFlow'] || false;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n  this.tag = null;\n  this.result = '';\n  this.duplicates = [];\n  this.usedDuplicates = null;\n} // Indents every line in a string. Empty lines (\\n only) are not indented.\n\n\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n} // [33] s-white ::= s-space | s-tab\n\n\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n} // Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnt mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n\n\nfunction isPrintable(c) {\n  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF\n  /* BOM */\n  || 0x10000 <= c && c <= 0x10FFFF;\n} // [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\n\n\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c) // byte-order-mark\n  && c !== 0xFEFF // b-char\n  && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n} // Simplified test for values allowed after the first character in plain style.\n\n\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF // - c-flow-indicator\n  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // - \":\" - \"#\"\n  // /* An ns-char preceding */ \"#\"\n  && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));\n} // Simplified test for values allowed as the first character in plain style.\n\n\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white\n  // - (c-indicator ::=\n  // - | ? | : | , | [ | ] | { | }\n  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | # | & | * | ! | | | = | > | ' | \"\n  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | % | @ | `)\n  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n} // Determines whether block indentation indicator is required.\n\n\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN = 1,\n    STYLE_SINGLE = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED = 4,\n    STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n\n  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true; // Check if any line can be folded.\n\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    } // in case the end is missing a \\n\n\n\n    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n  } // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n\n\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;\n  } // Edge case: block indentation indicator can only have one digit.\n\n\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  } // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n\n\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n} // Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//     No ending newline => unaffected; already using strip \"-\" chomping.\n//     Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n\n\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n\n    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n\n    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.\n\n    var singleLineOnly = iskey // No block styles in flow mode.\n    || state.flowLevel > -1 && level >= state.flowLevel;\n\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }();\n} // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n\n\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n\n  var clip = string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : clip ? '' : '-';\n  return indentIndicator + chomp + '\\n';\n} // (See the note for writeScalar.)\n\n\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n} // Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n\n\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g; // first line (possibly an empty line)\n\n  var result = function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }(); // If we haven't reached the first content line yet, don't add an extra \\n.\n\n\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented; // rest of the lines\n\n  var match;\n\n  while (match = lineRe.exec(string)) {\n    var prefix = match[1],\n        line = match[2];\n    moreIndented = line[0] === ' ';\n    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n} // Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n\n\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n\n  var match; // start is an inclusive index. end, curr, and next are exclusive.\n\n  var start = 0,\n      end,\n      curr = 0,\n      next = 0;\n  var result = ''; // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n\n  while (match = breakRe.exec(line)) {\n    next = match.index; // maintain invariant: curr - start <= width\n\n    if (next - start > width) {\n      end = curr > start ? curr : next; // derive end <= length-2\n\n      result += '\\n' + line.slice(start, end); // skip the space that was output as \\n\n\n      start = end + 1; // derive start <= length-1\n    }\n\n    curr = next;\n  } // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n\n\n  result += '\\n'; // Insert a break if the remainder is too long and there is a break available.\n\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n} // Escapes a double-quoted string.\n\n\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n\n    if (char >= 0xD800 && char <= 0xDBFF\n    /* high surrogate */\n    ) {\n        nextChar = string.charCodeAt(i + 1);\n\n        if (nextChar >= 0xDC00 && nextChar <= 0xDFFF\n        /* low surrogate */\n        ) {\n            // Combine the surrogate pair and store it escaped.\n            result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.\n\n            i++;\n            continue;\n          }\n      }\n\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n    if (state.condenseFlow) pairBuffer += '\"';\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer; // Allow sorting keys so that the output file is deterministic\n\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString$2.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty$3.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\n\n\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString$2.call(state.dump);\n\n  if (block) {\n    block = state.flowLevel < 0 || state.flowLevel > level;\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n\n    if (type === '[object Object]') {\n      if (block && Object.keys(state.dump).length !== 0) {\n        writeBlockMapping(state, level, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n\n      if (block && state.dump.length !== 0) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList, index, length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n  var state = new State$1(options);\n  if (!state.noRefs) getDuplicateReferences(input, state);\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({\n    schema: default_safe\n  }, options));\n}\n\nvar dump_1 = dump;\nvar safeDump_1 = safeDump;\nvar dumper = {\n  dump: dump_1,\n  safeDump: safeDump_1\n};\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\nvar Type$1 = type;\nvar Schema$1 = schema;\nvar FAILSAFE_SCHEMA = failsafe;\nvar JSON_SCHEMA = json;\nvar CORE_SCHEMA = core;\nvar DEFAULT_SAFE_SCHEMA = default_safe;\nvar DEFAULT_FULL_SCHEMA = default_full;\nvar load$1 = loader.load;\nvar loadAll$1 = loader.loadAll;\nvar safeLoad$1 = loader.safeLoad;\nvar safeLoadAll$1 = loader.safeLoadAll;\nvar dump$1 = dumper.dump;\nvar safeDump$1 = dumper.safeDump;\nvar YAMLException$1 = exception; // Deprecated schema names from JS-YAML 2.0.x\n\nvar MINIMAL_SCHEMA = failsafe;\nvar SAFE_SCHEMA = default_safe;\nvar DEFAULT_SCHEMA = default_full; // Deprecated functions from JS-YAML 1.x.x\n\nvar scan = deprecated('scan');\nvar parse = deprecated('parse');\nvar compose = deprecated('compose');\nvar addConstructor = deprecated('addConstructor');\nvar jsYaml = {\n  Type: Type$1,\n  Schema: Schema$1,\n  FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n  JSON_SCHEMA: JSON_SCHEMA,\n  CORE_SCHEMA: CORE_SCHEMA,\n  DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,\n  DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,\n  load: load$1,\n  loadAll: loadAll$1,\n  safeLoad: safeLoad$1,\n  safeLoadAll: safeLoadAll$1,\n  dump: dump$1,\n  safeDump: safeDump$1,\n  YAMLException: YAMLException$1,\n  MINIMAL_SCHEMA: MINIMAL_SCHEMA,\n  SAFE_SCHEMA: SAFE_SCHEMA,\n  DEFAULT_SCHEMA: DEFAULT_SCHEMA,\n  scan: scan,\n  parse: parse,\n  compose: compose,\n  addConstructor: addConstructor\n};\n\nvar jsYaml$1 = jsYaml;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\n * Redirect - object used to redirect some requests\n * e.g.\n * {\n *      title: 1x1-transparent.gif\n *      comment: http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever\n *      contentType: image/gif;base64\n *      content: R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\n * }\n * @typedef {Object} Redirect\n * @property {string} title\n * @property {string} comment\n * @property {string} content\n * @property {string} contentType\n */\n\nvar Redirects = /*#__PURE__*/function () {\n  /**\n   * Converts rawYaml into JS object with sources titles used as keys\n   * @param rawYaml\n   * @returns {Object<Redirect>} - return object with titles in the keys and RedirectSources\n   * in the values\n   */\n  function Redirects(rawYaml) {\n    classCallCheck(this, Redirects);\n\n    try {\n      var arrOfRedirects = jsYaml$1.safeLoad(rawYaml);\n      this.redirects = arrOfRedirects.reduce(function (acc, redirect) {\n        return _objectSpread(_objectSpread({}, acc), {}, defineProperty({}, redirect.title, redirect));\n      }, {});\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log(\"Was unable to load YAML into JS due to: \".concat(e.message));\n      throw e;\n    }\n  }\n  /**\n   * Returns redirect source object\n   * @param {string} title\n   * @return {Redirect}\n   */\n\n\n  createClass(Redirects, [{\n    key: \"getRedirect\",\n    value: function getRedirect(title) {\n      var _this = this;\n\n      if (Object.prototype.hasOwnProperty.call(this.redirects, title)) {\n        return this.redirects[title];\n      } // look title among aliases\n\n\n      var values = Object.keys(this.redirects).map(function (key) {\n        return _this.redirects[key];\n      });\n      return values.find(function (redirect) {\n        var aliases = redirect.aliases;\n\n        if (!aliases) {\n          return false;\n        }\n\n        return aliases.indexOf(title) > -1;\n      });\n    }\n  }]);\n\n  return Redirects;\n}();\n\n/**\n * Finds redirect resource by it's name\n * @param {string} name - redirect name\n */\n\nvar getRedirectByName = function getRedirectByName(name) {\n  var redirects = Object.keys(redirectsList).map(function (key) {\n    return redirectsList[key];\n  });\n  return redirects.find(function (r) {\n    return r.names && r.names.indexOf(name) > -1;\n  });\n};\n/**\n * @typedef {Object} Source - redirect properties\n * @property {string} name redirect name\n * @property {Array<string>} args Arguments for redirect function\n * @property {'extension'|'test'} [engine] -\n * Defines the final form of redirect string presentation\n * @property {boolean} [verbose] flag to enable printing to console debug information\n */\n\n/**\n * Returns redirect code by param\n * @param {Source} source\n * @returns {string} redirect code\n */\n\n\nvar getRedirectCode = function getRedirectCode(source) {\n  var redirect = getRedirectByName(source.name);\n  var result = attachDependencies(redirect);\n  result = addCall(redirect, result); // redirect code for different sources is checked in tests\n  // so it should be just a code without any source and props passed\n\n  result = source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);\n  return result;\n};\n\nvar redirectsCjs = {\n  Redirects: Redirects,\n  getCode: getRedirectCode,\n  isAdgRedirectRule: validator.isAdgRedirectRule,\n  isValidAdgRedirectRule: validator.isValidAdgRedirectRule,\n  isAdgRedirectCompatibleWithUbo: validator.isAdgRedirectCompatibleWithUbo,\n  isUboRedirectCompatibleWithAdg: validator.isUboRedirectCompatibleWithAdg,\n  isAbpRedirectCompatibleWithAdg: validator.isAbpRedirectCompatibleWithAdg,\n  convertUboRedirectToAdg: convertUboRedirectToAdg,\n  convertAbpRedirectToAdg: convertAbpRedirectToAdg,\n  convertRedirectToAdg: convertRedirectToAdg,\n  convertAdgRedirectToUbo: convertAdgRedirectToUbo\n};\n\n/**\n * @typedef {Object} Source - scriptlet properties\n * @property {string} name Scriptlet name\n * @property {Array<string>} args Arguments for scriptlet function\n * @property {'extension'|'corelibs'|'test'} engine -\n * Defines the final form of scriptlet string presentation\n * @property {string} [version]\n * @property {boolean} [verbose] flag to enable printing to console debug information\n * @property {string} [ruleText] Source rule text is used for debugging purposes\n * @property {string} [domainName] domain name where scriptlet is applied; for debugging purposes\n */\n\n/**\n * Returns scriptlet code by param\n * @param {Source} source\n * @returns {string} scriptlet code\n */\n\nfunction getScriptletCode(source) {\n  if (!validator.isValidScriptletName(source.name)) {\n    return null;\n  }\n\n  var scriptlet = validator.getScriptletByName(source.name);\n  var result = attachDependencies(scriptlet);\n  result = addCall(scriptlet, result);\n  result = source.engine === 'corelibs' || source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);\n  return result;\n}\n/**\n * Scriptlets variable\n *\n * @returns {Object} object with methods:\n * `invoke` method receives one argument with `Source` type\n * `validate` method receives one argument with `String` type\n */\n\n\nvar scriptletsObject = function () {\n  return {\n    invoke: getScriptletCode,\n    isValidScriptletName: validator.isValidScriptletName,\n    isValidScriptletRule: isValidScriptletRule,\n    isAdgScriptletRule: validator.isAdgScriptletRule,\n    isUboScriptletRule: validator.isUboScriptletRule,\n    isAbpSnippetRule: validator.isAbpSnippetRule,\n    convertUboToAdg: convertUboScriptletToAdg,\n    convertAbpToAdg: convertAbpSnippetToAdg,\n    convertScriptletToAdg: convertScriptletToAdg,\n    convertAdgToUbo: convertAdgScriptletToUbo,\n    redirects: redirectsCjs\n  };\n}();\n\n/**\n * Add module exports to be used as node package\n */\n\nmodule.exports = scriptletsObject;\n\n/**\n * -------------------------------------------\n * |                                         |\n * |  If you want to add your own scriptlet  |\n * |  please put your code below             |\n * |                                         |\n * -------------------------------------------\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy9zY3JpcHRsZXRzL2Rpc3QvY2pzL3NjcmlwdGxldHMuY2pzLmpzP2QwMDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBLDJCQUEyQiwrRUFBK0UsK0RBQStEO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxFQUFFLDBCQUEwQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0EsTUFBTSx3Q0FBd0M7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQix1QkFBdUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOztBQUVBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsSUFBSTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsZ0xBQWdMO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FB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QUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRGQUE0RixhQUFhO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQzs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCOztBQUVB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWU7O0FBRXhCOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpRUFBaUU7O0FBRWpFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw0SEFBNEg7O0FBRTVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw0SEFBNEg7O0FBRTVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7O0FBR2xDO0FBQ0E7O0FBRUEsb0JBQW9COzs7QUFHcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVixLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxJQUFJO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7O0FBRXJHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTCxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUEsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSCw2Q0FBNkM7O0FBRTdDLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVB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QkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQ0FBMkMseUNBQXlDLGlCQUFpQjtBQUNyRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0Esc0NBQXNDLEVBQUUsZUFBZSxFQUFFLFlBQVk7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2Qzs7QUFFQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxxQkFBcUI7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTs7QUFFQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxnQkFBZ0IsZUFBZTtBQUMvQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw0RUFBNEU7QUFDNUUsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QiwwRkFBMEY7QUFDMUYsT0FBTztBQUNQO0FBQ0EsNERBQTREO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULE9BQU87QUFDUDtBQUNBLE9BQU87O0FBRVAsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0REFBNEQsc0JBQXNCO0FBQ2xGOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUVBQW1FO0FBQ25FLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQLDhEQUE4RDtBQUM5RCxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTCxjQUFjO0FBQ2QsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQSxvRUFBb0UsMEJBQTBCO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwrRUFBK0U7QUFDL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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dGxldHMuY2pzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEFkR3VhcmQgU2NyaXB0bGV0c1xuICogVmVyc2lvbiAxLjMuMjBcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgd2lsZGNhcmQgc3ltYm9sXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAnKidcbiAqL1xudmFyIGdldFdpbGRjYXJkU3ltYm9sID0gZnVuY3Rpb24gZ2V0V2lsZGNhcmRTeW1ib2woKSB7XG4gIHJldHVybiAnKic7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHJhbmRvbSBzaXggc3ltYm9scyBpZFxuICovXG5mdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KTtcbn1cblxuLyoqXG4gKiBTZXQgZ2V0dGVyIGFuZCBzZXR0ZXIgdG8gcHJvcGVydHkgaWYgaXQncyBjb25maWd1cmFibGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdGFyZ2V0IG9iamVjdCB3aXRoIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3IgY29udGFpbnMgZ2V0dGVyIGFuZCBzZXR0ZXIgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgb3BlcmF0aW9uIHN1Y2Nlc3NmdWxcbiAqL1xuZnVuY3Rpb24gc2V0UHJvcGVydHlBY2Nlc3Mob2JqZWN0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xuICB2YXIgY3VycmVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChjdXJyZW50RGVzY3JpcHRvciAmJiAhY3VycmVudERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBDaGFpblxuICogQHByb3BlcnR5IHtPYmplY3R9IGJhc2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm9wXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NoYWluXVxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHByb3BlcnR5IGV4aXN0cyBpbiB0aGUgYmFzZSBvYmplY3QgKHJlY3Vyc2l2ZWx5KVxuICpcbiAqIElmIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgaW4gYmFzZSBvYmplY3QsXG4gKiBkZWZpbmVzIHRoaXMgcHJvcGVydHkgYXMgJ3VuZGVmaW5lZCdcbiAqIGFuZCByZXR1cm5zIGJhc2UsIHByb3BlcnR5IG5hbWUgYW5kIHJlbWFpbmluZyBwYXJ0IG9mIHByb3BlcnR5IGNoYWluXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGJhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpblxuICogQHJldHVybnMge0NoYWlufVxuICovXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluQ2hhaW4oYmFzZSwgY2hhaW4pIHtcbiAgdmFyIHBvcyA9IGNoYWluLmluZGV4T2YoJy4nKTtcblxuICBpZiAocG9zID09PSAtMSkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBiYXNlLFxuICAgICAgcHJvcDogY2hhaW5cbiAgICB9O1xuICB9XG5cbiAgdmFyIHByb3AgPSBjaGFpbi5zbGljZSgwLCBwb3MpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTI4XG5cbiAgaWYgKGJhc2UgPT09IG51bGwpIHtcbiAgICAvLyBpZiBiYXNlIGlzIG51bGwsIHJldHVybiAnbnVsbCcgYXMgYmFzZS5cbiAgICAvLyBpdCdzIG5lZWRlZCBmb3IgdHJpZ2dlcmluZyB0aGUgcmVhc29uIGxvZ2dpbmcgd2hpbGUgZGVidWdnaW5nXG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGJhc2UsXG4gICAgICBwcm9wOiBwcm9wLFxuICAgICAgY2hhaW46IGNoYWluXG4gICAgfTtcbiAgfVxuXG4gIHZhciBuZXh0QmFzZSA9IGJhc2VbcHJvcF07XG4gIGNoYWluID0gY2hhaW4uc2xpY2UocG9zICsgMSk7XG5cbiAgaWYgKG5leHRCYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0UHJvcGVydHlJbkNoYWluKG5leHRCYXNlLCBjaGFpbik7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYmFzZSwgcHJvcCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBiYXNlOiBuZXh0QmFzZSxcbiAgICBwcm9wOiBwcm9wLFxuICAgIGNoYWluOiBjaGFpblxuICB9O1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIENoYWluXG4gKiBAcHJvcGVydHkge09iamVjdH0gYmFzZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3BcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2hhaW5dXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGluIHRoZSBiYXNlIG9iamVjdCAocmVjdXJzaXZlbHkpLlxuICogU2ltaWxhciB0byBnZXRQcm9wZXJ0eUluQ2hhaW4gYnV0IHVwZ3JhZGVkIGZvciBqc29uLXBydW5lOlxuICogaGFuZGxlIHdpbGRjYXJkIHByb3BlcnRpZXMgYW5kIGRvZXMgbm90IGRlZmluZSBub25leGlzdGVudCBiYXNlIHByb3BlcnR5IGFzICd1bmRlZmluZWQnXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGJhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpblxuICogQHBhcmFtIHtib29sZWFufSBbbG9va1Rocm91Z2g9ZmFsc2VdXG4gKiBzaG91bGQgdGhlIG1ldGhvZCBsb29rIHRocm91Z2ggaXQncyBwcm9wcyBpbiBvcmRlciB0byB3aWxkY2FyZFxuICogQHBhcmFtIHtBcnJheX0gW291dHB1dD1bXV0gcmVzdWx0IGFjY1xuICogQHJldHVybnMge0NoYWluW119IGFycmF5IG9mIG9iamVjdHNcbiAqL1xuXG5mdW5jdGlvbiBnZXRXaWxkY2FyZFByb3BlcnR5SW5DaGFpbihiYXNlLCBjaGFpbikge1xuICB2YXIgbG9va1Rocm91Z2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICB2YXIgb3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXTtcbiAgdmFyIHBvcyA9IGNoYWluLmluZGV4T2YoJy4nKTtcblxuICBpZiAocG9zID09PSAtMSkge1xuICAgIC8vIGZvciBwYXRocyBsaWtlICdhLmIuKicgZXZlcnkgZmluYWwgbmVzdGVkIHByb3Agc2hvdWxkIGJlIHByb2Nlc3NlZFxuICAgIGlmIChjaGFpbiA9PT0gZ2V0V2lsZGNhcmRTeW1ib2woKSB8fCBjaGFpbiA9PT0gJ1tdJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYmFzZSkge1xuICAgICAgICAvLyB0byBwcm9jZXNzIGVhY2gga2V5IGluIGJhc2UgZXhjZXB0IGluaGVyaXRlZCBvbmVzXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYmFzZSwga2V5KSkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHtcbiAgICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgICBwcm9wOiBrZXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHByb3A6IGNoYWluXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgdmFyIHByb3AgPSBjaGFpbi5zbGljZSgwLCBwb3MpO1xuICB2YXIgc2hvdWxkTG9va1Rocm91Z2ggPSBwcm9wID09PSAnW10nICYmIEFycmF5LmlzQXJyYXkoYmFzZSkgfHwgcHJvcCA9PT0gZ2V0V2lsZGNhcmRTeW1ib2woKSAmJiBiYXNlIGluc3RhbmNlb2YgT2JqZWN0O1xuXG4gIGlmIChzaG91bGRMb29rVGhyb3VnaCkge1xuICAgIHZhciBuZXh0UHJvcCA9IGNoYWluLnNsaWNlKHBvcyArIDEpO1xuICAgIHZhciBiYXNlS2V5cyA9IE9iamVjdC5rZXlzKGJhc2UpOyAvLyBpZiB0aGVyZSBpcyBhIHdpbGRjYXJkIHByb3AgaW4gaW5wdXQgY2hhaW4gKGUuZy4gJ2FkLiouc3JjJyBmb3IgJ2FkLjAuc3JjIGFkLjEuc3JjJyksXG4gICAgLy8gZWFjaCBvbmUgb2YgYmFzZSBrZXlzIHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIGEgcG90ZW50aWFsIGNoYWluIHByb3AgaW4gZmluYWwgcGF0aFxuXG4gICAgYmFzZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgaXRlbSA9IGJhc2Vba2V5XTtcbiAgICAgIGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluKGl0ZW0sIG5leHRQcm9wLCBsb29rVGhyb3VnaCwgb3V0cHV0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBuZXh0QmFzZSA9IGJhc2VbcHJvcF07XG4gIGNoYWluID0gY2hhaW4uc2xpY2UocG9zICsgMSk7XG5cbiAgaWYgKG5leHRCYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBnZXRXaWxkY2FyZFByb3BlcnR5SW5DaGFpbihuZXh0QmFzZSwgY2hhaW4sIGxvb2tUaHJvdWdoLCBvdXRwdXQpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhc3NlZCB2YWx1ZSBpcyBOYU5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc05hTlxuICogQHBhcmFtIHsqfSBudW1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgbmF0aXZlSXNOYU4gPSBmdW5jdGlvbiBuYXRpdmVJc05hTihudW0pIHtcbiAgdmFyIG5hdGl2ZSA9IE51bWJlci5pc05hTiB8fCB3aW5kb3cuaXNOYU47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29tcGF0L2NvbXBhdFxuXG4gIHJldHVybiBuYXRpdmUobnVtKTtcbn07XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgZmluaXRlIG51bWJlclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzRmluaXRlXG4gKiBAcGFyYW0geyp9IG51bVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxudmFyIG5hdGl2ZUlzRmluaXRlID0gZnVuY3Rpb24gbmF0aXZlSXNGaW5pdGUobnVtKSB7XG4gIHZhciBuYXRpdmUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgd2luZG93LmlzRmluaXRlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcblxuICByZXR1cm4gbmF0aXZlKG51bSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIG9iamVjdCB0byBhcnJheSBvZiBwYWlycy5cbiAqIE9iamVjdC5lbnRyaWVzKCkgcG9seWZpbGwgYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFXG4gKiBodHRwczovL2Nhbml1c2UuY29tLz9zZWFyY2g9T2JqZWN0LmVudHJpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2YgcGFpcnNcbiAqL1xudmFyIGdldE9iamVjdEVudHJpZXMgPSBmdW5jdGlvbiBnZXRPYmplY3RFbnRyaWVzKG9iamVjdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIHZhciBlbnRyaWVzID0gW107XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGVudHJpZXMucHVzaChba2V5LCBvYmplY3Rba2V5XV0pO1xuICB9KTtcbiAgcmV0dXJuIGVudHJpZXM7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhcnJheSBvZiBwYWlycyB0byBvYmplY3QuXG4gKiBPYmplY3QuZnJvbUVudHJpZXMoKSBwb2x5ZmlsbCBiZWNhdXNlIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUVcbiAqIGh0dHBzOi8vY2FuaXVzZS5jb20vP3NlYXJjaD1PYmplY3QuZnJvbUVudHJpZXNcbiAqIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgLSBhcnJheSBvZiBwYWlyc1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuXG52YXIgZ2V0T2JqZWN0RnJvbUVudHJpZXMgPSBmdW5jdGlvbiBnZXRPYmplY3RGcm9tRW50cmllcyhlbnRyaWVzKSB7XG4gIHZhciBvdXRwdXQgPSBlbnRyaWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBlbCkge1xuICAgIHZhciBrZXkgPSBlbFswXTtcbiAgICB2YXIgdmFsdWUgPSBlbFsxXTtcbiAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBvYmogaXMgYW4gZW1wdHkgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn07XG5cbi8qKlxuICogU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQWxsIHBvbGlmaWxsXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgaW5wdXQgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc3Vic3RyIHRvIGxvb2sgZm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3U3Vic3RyIHJlcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciByZXBsYWNlQWxsID0gZnVuY3Rpb24gcmVwbGFjZUFsbChpbnB1dCwgc3Vic3RyLCBuZXdTdWJzdHIpIHtcbiAgcmV0dXJuIGlucHV0LnNwbGl0KHN1YnN0cikuam9pbihuZXdTdWJzdHIpO1xufTtcbi8qKlxuICogRXNjYXBlcyBzcGVjaWFsIGNoYXJzIGluIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG52YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBzZWFyY2ggc3RyaW5nIHRvIHRoZSByZWdleHBcbiAqIFRPRE8gdGhpbmsgYWJvdXQgbmVzdGVkIGRlcGVuZGVuY2llcywgYnV0IGJlIGNhcmVmdWwgd2l0aCBkZXBlbmRlbmN5IGxvb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHNlYXJjaCBzdHJpbmdcbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKi9cblxudmFyIHRvUmVnRXhwID0gZnVuY3Rpb24gdG9SZWdFeHAoc3RyKSB7XG4gIGlmICghc3RyIHx8IHN0ciA9PT0gJycpIHtcbiAgICB2YXIgREVGQVVMVF9WQUxVRSA9ICcuPyc7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoREVGQVVMVF9WQUxVRSk7XG4gIH1cblxuICBpZiAoc3RyWzBdID09PSAnLycgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc3RyLnNsaWNlKDEsIC0xKSk7XG4gIH1cblxuICB2YXIgZXNjYXBlZCA9IHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChlc2NhcGVkKTtcbn07XG4vKipcbiAqIEdldCBzdHJpbmcgYmVmb3JlIHJlZ2V4cCBmaXJzdCBtYXRjaFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtSZWdFeHB9IHJ4XG4gKi9cblxudmFyIGdldEJlZm9yZVJlZ0V4cCA9IGZ1bmN0aW9uIGdldEJlZm9yZVJlZ0V4cChzdHIsIHJ4KSB7XG4gIHZhciBpbmRleCA9IHN0ci5zZWFyY2gocngpO1xuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBpbmRleCk7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIHRoZSBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgZnVsbCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggc3Vic3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpIHtcbiAgLy8gaWYgc3RyID09PSAnJywgKHN0ciAmJiBmYWxzZSkgd2lsbCByZXR1cm4gJydcbiAgLy8gdGhhdCdzIHdoeSBpdCBoYXMgdG8gYmUgISFzdHJcbiAgcmV0dXJuICEhc3RyICYmIHN0ci5pbmRleE9mKHByZWZpeCkgPT09IDA7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgc3RyaW5nIGVuZHMgd2l0aCB0aGUgc3Vic3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIGZ1bGwgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kaW5nIHN1YnN0cmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxudmFyIGVuZHNXaXRoID0gZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBlbmRpbmcpIHtcbiAgLy8gaWYgc3RyID09PSAnJywgKHN0ciAmJiBmYWxzZSkgd2lsbCByZXR1cm4gJydcbiAgLy8gdGhhdCdzIHdoeSBpdCBoYXMgdG8gYmUgISFzdHJcbiAgcmV0dXJuICEhc3RyICYmIHN0ci5pbmRleE9mKGVuZGluZykgPT09IHN0ci5sZW5ndGggLSBlbmRpbmcubGVuZ3RoO1xufTtcbnZhciBzdWJzdHJpbmdBZnRlciA9IGZ1bmN0aW9uIHN1YnN0cmluZ0FmdGVyKHN0ciwgc2VwYXJhdG9yKSB7XG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKHNlcGFyYXRvcik7XG4gIHJldHVybiBpbmRleCA8IDAgPyAnJyA6IHN0ci5zdWJzdHJpbmcoaW5kZXggKyBzZXBhcmF0b3IubGVuZ3RoKTtcbn07XG52YXIgc3Vic3RyaW5nQmVmb3JlID0gZnVuY3Rpb24gc3Vic3RyaW5nQmVmb3JlKHN0ciwgc2VwYXJhdG9yKSB7XG4gIGlmICghc3RyIHx8ICFzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IHN0ciA6IHN0ci5zdWJzdHJpbmcoMCwgaW5kZXgpO1xufTtcbi8qKlxuICogV3JhcCBzdHIgaW4gc2luZ2xlIHFvdXRlcyBhbmQgcmVwbGFjZXMgc2luZ2xlIHF1b3RlcyB0byBkb3VkbGUgb25lXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cblxudmFyIHdyYXBJblNpbmdsZVF1b3RlcyA9IGZ1bmN0aW9uIHdyYXBJblNpbmdsZVF1b3RlcyhzdHIpIHtcbiAgaWYgKHN0clswXSA9PT0gJ1xcJycgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJ1xcJycgfHwgc3RyWzBdID09PSAnXCInICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEsIHN0ci5sZW5ndGggLSAxKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuXG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9cXCcvZywgJ1wiJyk7XG4gIHJldHVybiBcIidcIi5jb25jYXQoc3RyLCBcIidcIik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHN1YnN0cmluZyBlbmNsb3NlZCBpbiB0aGUgd2lkZXN0IGJyYWNlc1xuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICovXG5cbnZhciBnZXRTdHJpbmdJbkJyYWNlcyA9IGZ1bmN0aW9uIGdldFN0cmluZ0luQnJhY2VzKHN0cikge1xuICB2YXIgZmlyc3RJbmRleCA9IHN0ci5pbmRleE9mKCcoJyk7XG4gIHZhciBsYXN0SW5kZXggPSBzdHIubGFzdEluZGV4T2YoJyknKTtcbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoZmlyc3RJbmRleCArIDEsIGxhc3RJbmRleCk7XG59O1xuLyoqXG4gKiBQcmVwYXJlcyBSVENQZWVyQ29ubmVjdGlvbiBjb25maWcgYXMgc3RyaW5nIGZvciBwcm9wZXIgbG9nZ2luZ1xuICogQHBhcmFtIHsqfSBjb25maWdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHN0cmluZ2lmaWVkIGNvbmZpZ1xuKi9cblxudmFyIGNvbnZlcnRSdGNDb25maWdUb1N0cmluZyA9IGZ1bmN0aW9uIGNvbnZlcnRSdGNDb25maWdUb1N0cmluZyhjb25maWcpIHtcbiAgdmFyIFVOREVGX1NUUiA9ICd1bmRlZmluZWQnO1xuICB2YXIgc3RyID0gVU5ERUZfU1RSO1xuXG4gIGlmIChjb25maWcgPT09IG51bGwpIHtcbiAgICBzdHIgPSAnbnVsbCc7XG4gIH0gZWxzZSBpZiAoY29uZmlnIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgdmFyIFNFUlZFUlNfUFJPUF9OQU1FID0gJ2ljZVNlcnZlcnMnO1xuICAgIHZhciBVUkxTX1BST1BfTkFNRSA9ICd1cmxzJztcbiAgICAvKlxuICAgICAgICBjb25zdCBleGFtcGxlQ29uZmlnID0ge1xuICAgICAgICAgICAgJ2ljZVNlcnZlcnMnOiBbXG4gICAgICAgICAgICAgICAgJ3VybHMnOiBbJ3N0dW46MzUuNjYuMjA2LjE4ODo0NDMnXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgKi9cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBTRVJWRVJTX1BST1BfTkFNRSkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ1tTRVJWRVJTX1BST1BfTkFNRV1bMF0sIFVSTFNfUFJPUF9OQU1FKSAmJiAhIWNvbmZpZ1tTRVJWRVJTX1BST1BfTkFNRV1bMF1bVVJMU19QUk9QX05BTUVdKSB7XG4gICAgICBzdHIgPSBjb25maWdbU0VSVkVSU19QUk9QX05BTUVdWzBdW1VSTFNfUFJPUF9OQU1FXS50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXRjaERhdGFcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNJbnZlcnRlZE1hdGNoXG4gKiBAcHJvcGVydHkge1JlZ0V4cH0gbWF0Y2hSZWdleHBcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyBtYXRjaCBhcmcgd2l0aCBwb3NzaWJsZSBuZWdhdGlvbiBmb3Igbm8gbWF0Y2hpbmcuXG4gKiBOZWVkZWQgZm9yIHByZXZlbnQtc2V0VGltZW91dCwgcHJldmVudC1zZXRJbnRlcnZhbCxcbiAqIHByZXZlbnQtcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFuZCBwcmV2ZW50LXdpbmRvdy1vcGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hcbiAqIEByZXR1cm5zIHtNYXRjaERhdGF9XG4gKi9cblxudmFyIHBhcnNlTWF0Y2hBcmcgPSBmdW5jdGlvbiBwYXJzZU1hdGNoQXJnKG1hdGNoKSB7XG4gIHZhciBJTlZFUlRfTUFSS0VSID0gJyEnO1xuICB2YXIgaXNJbnZlcnRlZE1hdGNoID0gc3RhcnRzV2l0aChtYXRjaCwgSU5WRVJUX01BUktFUik7XG4gIHZhciBtYXRjaFZhbHVlID0gaXNJbnZlcnRlZE1hdGNoID8gbWF0Y2guc2xpY2UoMSkgOiBtYXRjaDtcbiAgdmFyIG1hdGNoUmVnZXhwID0gdG9SZWdFeHAobWF0Y2hWYWx1ZSk7XG4gIHJldHVybiB7XG4gICAgaXNJbnZlcnRlZE1hdGNoOiBpc0ludmVydGVkTWF0Y2gsXG4gICAgbWF0Y2hSZWdleHA6IG1hdGNoUmVnZXhwXG4gIH07XG59O1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWxheURhdGFcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNJbnZlcnRlZERlbGF5TWF0Y2hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IGRlbGF5TWF0Y2hcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyBkZWxheSBhcmcgd2l0aCBwb3NzaWJsZSBuZWdhdGlvbiBmb3Igbm8gbWF0Y2hpbmcuXG4gKiBOZWVkZWQgZm9yIHByZXZlbnQtc2V0VGltZW91dCBhbmQgcHJldmVudC1zZXRJbnRlcnZhbFxuICogQHBhcmFtIHtzdHJpbmd9IGRlbGF5XG4gKiBAcmV0dXJucyB7RGVsYXlEYXRhfVxuICovXG5cbnZhciBwYXJzZURlbGF5QXJnID0gZnVuY3Rpb24gcGFyc2VEZWxheUFyZyhkZWxheSkge1xuICB2YXIgSU5WRVJUX01BUktFUiA9ICchJztcbiAgdmFyIGlzSW52ZXJ0ZWREZWxheU1hdGNoID0gc3RhcnRzV2l0aChkZWxheSwgSU5WRVJUX01BUktFUik7XG4gIHZhciBkZWxheVZhbHVlID0gaXNJbnZlcnRlZERlbGF5TWF0Y2ggPyBkZWxheS5zbGljZSgxKSA6IGRlbGF5O1xuICBkZWxheVZhbHVlID0gcGFyc2VJbnQoZGVsYXlWYWx1ZSwgMTApO1xuICB2YXIgZGVsYXlNYXRjaCA9IG5hdGl2ZUlzTmFOKGRlbGF5VmFsdWUpID8gbnVsbCA6IGRlbGF5VmFsdWU7XG4gIHJldHVybiB7XG4gICAgaXNJbnZlcnRlZERlbGF5TWF0Y2g6IGlzSW52ZXJ0ZWREZWxheU1hdGNoLFxuICAgIGRlbGF5TWF0Y2g6IGRlbGF5TWF0Y2hcbiAgfTtcbn07XG4vKipcbiAqIENvbnZlcnRzIG9iamVjdCB0byBzdHJpbmcgZm9yIGxvZ2dpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogZGF0YSBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIG9iamVjdFRvU3RyaW5nID0gZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcob2JqKSB7XG4gIHJldHVybiBpc0VtcHR5T2JqZWN0KG9iaikgPyAne30nIDogZ2V0T2JqZWN0RW50cmllcyhvYmopLm1hcChmdW5jdGlvbiAocGFpcikge1xuICAgIHZhciBrZXkgPSBwYWlyWzBdO1xuICAgIHZhciB2YWx1ZSA9IHBhaXJbMV07XG4gICAgdmFyIHJlY29yZFZhbHVlU3RyID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHJlY29yZFZhbHVlU3RyID0gXCJ7IFwiLmNvbmNhdChvYmplY3RUb1N0cmluZyh2YWx1ZSksIFwiIH1cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCI6XFxcIlwiKS5jb25jYXQocmVjb3JkVmFsdWVTdHIsIFwiXFxcIlwiKTtcbiAgfSkuam9pbignICcpO1xufTtcbi8qKlxuICogQ29udmVydHMgdHlwZXMgaW50byBhIHN0cmluZ1xuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG52YXIgY29udmVydFR5cGVUb1N0cmluZyA9IGZ1bmN0aW9uIGNvbnZlcnRUeXBlVG9TdHJpbmcodmFsdWUpIHtcbiAgdmFyIG91dHB1dDtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIG91dHB1dCA9ICd1bmRlZmluZWQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIG91dHB1dCA9ICdudWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGZ1bmN0aW9uIHdoaWNoIHNpbGVudHMgZ2xvYmFsIGVycm9ycyBvbiBwYWdlIGdlbmVyYXRlZCBieSBzY3JpcHRsZXRcbiAqIElmIGVycm9yIGRvZXNuJ3QgYmVsb25nIHRvIG91ciBlcnJvciB3ZSB0cmFuc2ZlciBpdCB0byB0aGUgbmF0aXZlIG9uRXJyb3IgaGFuZGxlclxuICogQHBhcmFtIHtzdHJpbmd9IHJpZCAtIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHNjcmlwdGxldFxuICogQHJldHVybiB7b25FcnJvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlT25FcnJvckhhbmRsZXIocmlkKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICB2YXIgbmF0aXZlT25FcnJvciA9IHdpbmRvdy5vbmVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnICYmIGVycm9yLmluZGV4T2YocmlkKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuYXRpdmVPbkVycm9yIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVPbkVycm9yLmFwcGx5KHRoaXMsIFtlcnJvcl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogTm9vcCBmdW5jdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xudmFyIG5vb3BGdW5jID0gZnVuY3Rpb24gbm9vcEZ1bmMoKSB7fTtcbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyBudWxsXG4gKiBAcmV0dXJuIHtudWxsfSBudWxsXG4gKi9cblxudmFyIG5vb3BOdWxsID0gZnVuY3Rpb24gbm9vcE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyB0cnVlXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlXG4gKi9cblxudmFyIHRydWVGdW5jID0gZnVuY3Rpb24gdHJ1ZUZ1bmMoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuICogQHJldHVybiB7Ym9vbGVhbn0gZmFsc2VcbiAqL1xuXG52YXIgZmFsc2VGdW5jID0gZnVuY3Rpb24gZmFsc2VGdW5jKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIHRoaXNcbiAqL1xuXG5mdW5jdGlvbiBub29wVGhpcygpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybnMgZW1wdHkgc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGVtcHR5IHN0cmluZ1xuICovXG5cbnZhciBub29wU3RyID0gZnVuY3Rpb24gbm9vcFN0cigpIHtcbiAgcmV0dXJuICcnO1xufTtcbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyBlbXB0eSBhcnJheVxuICogQHJldHVybiB7QXJyYXl9IGVtcHR5IGFycmF5XG4gKi9cblxudmFyIG5vb3BBcnJheSA9IGZ1bmN0aW9uIG5vb3BBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufTtcbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyBlbXB0eSBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gZW1wdHkgb2JqZWN0XG4gKi9cblxudmFyIG5vb3BPYmplY3QgPSBmdW5jdGlvbiBub29wT2JqZWN0KCkge1xuICByZXR1cm4ge307XG59O1xuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5zIFByb21pc2UucmVqZWN0KClcbiAqL1xuXG52YXIgbm9vcFByb21pc2VSZWplY3QgPSBmdW5jdGlvbiBub29wUHJvbWlzZVJlamVjdCgpIHtcbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcblxuLyoqXG4gKiBSZXR1cm5zIFByb21pc2Ugb2JqZWN0IHRoYXQgaXMgcmVzb2x2ZWQgd2l0aCBhbiBlbXB0eSByZXNwb25zZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXG52YXIgbm9vcFByb21pc2VSZXNvbHZlID0gZnVuY3Rpb24gbm9vcFByb21pc2VSZXNvbHZlKCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBSZXNwb25zZSgpKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUsIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG5cbi8qKlxuICogSGl0IHVzZWQgb25seSBmb3IgZGVidWcgcHVycG9zZXMgbm93XG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIC0gb3B0aW9uYWwgbWVzc2FnZTtcbiAqIHVzZSBMT0dfTUFSS0VSID0gJ2xvZzogJyBhdCB0aGUgc3RhcnQgb2YgYSBtZXNzYWdlXG4gKiBmb3IgbG9nZ2luZyBzY3JpcHRsZXRzXG4gKi9cbnZhciBoaXQgPSBmdW5jdGlvbiBoaXQoc291cmNlLCBtZXNzYWdlKSB7XG4gIGlmIChzb3VyY2UudmVyYm9zZSAhPT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgdmFyIHRyYWNlID0gY29uc29sZS50cmFjZS5iaW5kKGNvbnNvbGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcblxuICAgIHZhciBwcmVmaXggPSBzb3VyY2UucnVsZVRleHQgfHwgJyc7XG5cbiAgICBpZiAoc291cmNlLmRvbWFpbk5hbWUpIHtcbiAgICAgIHZhciBBR19TQ1JJUFRMRVRfTUFSS0VSID0gJyMlIy8vJztcbiAgICAgIHZhciBVQk9fU0NSSVBUTEVUX01BUktFUiA9ICcjIytqcyc7XG4gICAgICB2YXIgcnVsZVN0YXJ0SW5kZXg7XG5cbiAgICAgIGlmIChzb3VyY2UucnVsZVRleHQuaW5kZXhPZihBR19TQ1JJUFRMRVRfTUFSS0VSKSA+IC0xKSB7XG4gICAgICAgIHJ1bGVTdGFydEluZGV4ID0gc291cmNlLnJ1bGVUZXh0LmluZGV4T2YoQUdfU0NSSVBUTEVUX01BUktFUik7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZS5ydWxlVGV4dC5pbmRleE9mKFVCT19TQ1JJUFRMRVRfTUFSS0VSKSA+IC0xKSB7XG4gICAgICAgIHJ1bGVTdGFydEluZGV4ID0gc291cmNlLnJ1bGVUZXh0LmluZGV4T2YoVUJPX1NDUklQVExFVF9NQVJLRVIpO1xuICAgICAgfSAvLyBkZWxldGUgYWxsIGRvbWFpbnMgZnJvbSBydWxlVGV4dCBhbmQgbGVhdmUganVzdCBydWxlIHBhcnRcblxuXG4gICAgICB2YXIgcnVsZVBhcnQgPSBzb3VyY2UucnVsZVRleHQuc2xpY2UocnVsZVN0YXJ0SW5kZXgpOyAvLyBwcmVwYXJlIGFwcGxpZWQgc2NyaXB0bGV0IHJ1bGUgZm9yIHNwZWNpZmljIGRvbWFpblxuXG4gICAgICBwcmVmaXggPSBcIlwiLmNvbmNhdChzb3VyY2UuZG9tYWluTmFtZSkuY29uY2F0KHJ1bGVQYXJ0KTtcbiAgICB9IC8vIFVzZWQgdG8gY2hlY2sgaWYgc2NyaXB0bGV0IHVzZXMgJ2hpdCcgZnVuY3Rpb24gZm9yIGxvZ2dpbmdcblxuXG4gICAgdmFyIExPR19NQVJLRVIgPSAnbG9nOiAnO1xuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIGlmIChtZXNzYWdlLmluZGV4T2YoTE9HX01BUktFUikgPT09IC0xKSB7XG4gICAgICAgIGxvZyhcIlwiLmNvbmNhdChwcmVmaXgsIFwiIG1lc3NhZ2U6XFxuXCIpLmNvbmNhdChtZXNzYWdlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2cobWVzc2FnZS5zbGljZShMT0dfTUFSS0VSLmxlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxvZyhcIlwiLmNvbmNhdChwcmVmaXgsIFwiIHRyYWNlIHN0YXJ0XCIpKTtcblxuICAgIGlmICh0cmFjZSkge1xuICAgICAgdHJhY2UoKTtcbiAgICB9XG5cbiAgICBsb2coXCJcIi5jb25jYXQocHJlZml4LCBcIiB0cmFjZSBlbmRcIikpO1xuICB9IGNhdGNoIChlKSB7Ly8gdHJ5IGNhdGNoIGZvciBFZGdlIDE1XG4gICAgLy8gSW4gYWNjb3JkaW5nIHRvIHRoaXMgaXNzdWUgaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTQ0OTUyMjAvXG4gICAgLy8gY29uc29sZS5sb2cgdGhyb3dzIGFuIGVycm9yXG4gIH0gLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIHVuaXQtdGVzdHMgb25seSFcblxuXG4gIGlmICh0eXBlb2Ygd2luZG93Ll9fZGVidWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3aW5kb3cuX19kZWJ1Zyhzb3VyY2UpO1xuICB9XG59O1xuXG4vKipcbiAqIERPTSB0cmVlIGNoYW5nZXMgb2JzZXJ2ZXIuIFVzZWQgZm9yICdyZW1vdmUtYXR0cicgYW5kICdyZW1vdmUtY2xhc3MnIHNjcmlwdGxldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9ic2VydmVBdHRycyAtIG9wdGlvbmFsIHBhcmFtZXRlciAtIHNob3VsZCBvYnNlcnZlciBjaGVjayBhdHRpYnV0ZXMgY2hhbmdlc1xuICovXG52YXIgb2JzZXJ2ZURPTUNoYW5nZXMgPSBmdW5jdGlvbiBvYnNlcnZlRE9NQ2hhbmdlcyhjYWxsYmFjaykge1xuICB2YXIgb2JzZXJ2ZUF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGF0dHJzVG9PYnNlcnYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgd3JhcHBlciwgcGFzc2luZyB0aGUgY2FsbCB0byAnbWV0aG9kJyBhdCBtYXhpbXVtIG9uY2UgcGVyICdkZWxheScgbWlsbGlzZWNvbmRzLlxuICAgKiBUaG9zZSBjYWxscyB0aGF0IGZhbGwgaW50byB0aGUgXCJjb29sZG93blwiIHBlcmlvZCwgYXJlIGlnbm9yZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgdmFyIHRocm90dGxlID0gZnVuY3Rpb24gdGhyb3R0bGUobWV0aG9kLCBkZWxheSkge1xuICAgIHZhciB3YWl0ID0gZmFsc2U7XG4gICAgdmFyIHNhdmVkQXJncztcblxuICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAod2FpdCkge1xuICAgICAgICBzYXZlZEFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG1ldGhvZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgd2FpdCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FpdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzYXZlZEFyZ3MpIHtcbiAgICAgICAgICB3cmFwcGVyKHNhdmVkQXJncyk7XG4gICAgICAgICAgc2F2ZWRBcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSwgZGVsYXkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfTtcbiAgLyoqXG4gICAqICdkZWxheScgaW4gbWlsbGlzZWNvbmRzIGZvciAndGhyb3R0bGUnIG1ldGhvZFxuICAgKi9cblxuXG4gIHZhciBUSFJPVFRMRV9ERUxBWV9NUyA9IDIwO1xuICAvKipcbiAgICogVXNlZCBmb3IgcmVtb3ZlLWNsYXNzXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmUsIGNvbXBhdC9jb21wYXRcblxuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIsIFRIUk9UVExFX0RFTEFZX01TKSk7XG5cbiAgdmFyIGNvbm5lY3QgPSBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgIGlmIChhdHRyc1RvT2JzZXJ2Lmxlbmd0aCA+IDApIHtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogb2JzZXJ2ZUF0dHJzLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IGF0dHJzVG9PYnNlcnZcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9ic2VydmVBdHRyc1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkaXNjb25uZWN0ID0gZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2tXcmFwcGVyKCkge1xuICAgIGRpc2Nvbm5lY3QoKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIGNvbm5lY3QoKTtcbiAgfVxuXG4gIGNvbm5lY3QoKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdGFja1RyYWNlIGNvbnRhaW5zIHN0YWNrUmVnZXhwXG4gKiAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvODJcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gc3RhY2tNYXRjaCAtIGlucHV0IHN0YWNrIHZhbHVlIHRvIG1hdGNoXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhY2tUcmFjZSAtIHNjcmlwdCBlcnJvciBzdGFjayB0cmFjZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxudmFyIG1hdGNoU3RhY2tUcmFjZSA9IGZ1bmN0aW9uIG1hdGNoU3RhY2tUcmFjZShzdGFja01hdGNoLCBzdGFja1RyYWNlKSB7XG4gIGlmICghc3RhY2tNYXRjaCB8fCBzdGFja01hdGNoID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHN0YWNrUmVnZXhwID0gdG9SZWdFeHAoc3RhY2tNYXRjaCk7XG4gIHZhciByZWZpbmVkU3RhY2tUcmFjZSA9IHN0YWNrVHJhY2Uuc3BsaXQoJ1xcbicpLnNsaWNlKDIpIC8vIGdldCByaWQgb2Ygb3VyIG93biBmdW5jdGlvbnMgaW4gdGhlIHN0YWNrIHRyYWNlXG4gIC5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS50cmltKCk7XG4gIH0pIC8vIHRyaW0gdGhlIGxpbmVzXG4gIC5qb2luKCdcXG4nKTtcbiAgcmV0dXJuIHN0YWNrUmVnZXhwLnRlc3QocmVmaW5lZFN0YWNrVHJhY2UpO1xufTtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IEFycmF5LnByb3RvdHlwZS5mbGF0KClcbiAqIGZvciBleGFtcGxlLCBPcGVyYSA0MiB3aGljaCBpcyB1c2VkIGZvciBicm93c2Vyc3RhY2sgdGVzdHNcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZsYXRcbiAqIEBwYXJhbSB7QXJyYXl9IGlucHV0XG4gKi9cbnZhciBmbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbihpbnB1dCkge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gc3RhY2sucHVzaChlbCk7XG4gIH0pO1xuICB2YXIgcmVzID0gW107XG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIC8vIHBvcCB2YWx1ZSBmcm9tIHN0YWNrXG4gICAgdmFyIG5leHQgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICAvLyBwdXNoIGJhY2sgYXJyYXkgaXRlbXMsIHdvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWwgaW5wdXRcbiAgICAgIG5leHQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrLnB1c2goZWwpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy5wdXNoKG5leHQpO1xuICAgIH1cbiAgfSAvLyByZXZlcnNlIHRvIHJlc3RvcmUgaW5wdXQgb3JkZXJcblxuXG4gIHJldHVybiByZXMucmV2ZXJzZSgpO1xufTtcblxuLyoqXG4gKiBGaW5kcyBzaGFkb3ctZG9tIGhvc3QgKGVsZW1lbnRzIHdpdGggc2hhZG93Um9vdCBwcm9wZXJ0eSkgaW4gRE9NIG9mIHJvb3RFbGVtZW50LlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnRcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFtdfSBzaGFkb3ctZG9tIGhvc3RzXG4gKi9cblxudmFyIGZpbmRIb3N0RWxlbWVudHMgPSBmdW5jdGlvbiBmaW5kSG9zdEVsZW1lbnRzKHJvb3RFbGVtZW50KSB7XG4gIHZhciBob3N0cyA9IFtdOyAvLyBFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKSByZXR1cm5zIGxpc3Qgb2YgZWxlbWVudHNcbiAgLy8gd2hpY2ggYXJlIGRlZmluZWQgaW4gRE9NIG9mIEVsZW1lbnQuXG4gIC8vIE1lYW53aGlsZSwgaW5uZXIgRE9NIG9mIHRoZSBlbGVtZW50IHdpdGggc2hhZG93Um9vdCBwcm9wZXJ0eVxuICAvLyBpcyBhYnNvbHV0ZWx5IGFub3RoZXIgRE9NIGFuZCB3aGljaCBjYW4gbm90IGJlIHJlYWNoZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgnKicpXG5cbiAgdmFyIGRvbUVsZW1zID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuICBkb21FbGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5zaGFkb3dSb290KSB7XG4gICAgICBob3N0cy5wdXNoKGVsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaG9zdHM7XG59O1xuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygbm9kZXMuXG4gKlxuICogQGV4dGVybmFsIE5vZGVMaXN0XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZUxpc3QgTm9kZUxpc3R9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQaWVyY2VEYXRhXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50W119IHRhcmdldHMgZm91bmQgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50W119IGlubmVySG9zdHMgaW5uZXIgc2hhZG93LWRvbSBob3N0c1xuICovXG5cbi8qKlxuICogUGllcmNlcyBvcGVuIHNoYWRvdy1kb20gaW4gb3JkZXIgdG8gZmluZDpcbiAqIC0gZWxlbWVudHMgYnkgJ3NlbGVjdG9yJyBtYXRjaGluZ1xuICogLSBpbm5lciBzaGFkb3ctZG9tIGhvc3RzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxleHRlcm5hbDpOb2RlTGlzdH0gaG9zdEVsZW1lbnRzXG4gKiBAcmV0dXJucyB7UGllcmNlRGF0YX1cbiAqL1xuXG52YXIgcGllcmNlU2hhZG93RG9tID0gZnVuY3Rpb24gcGllcmNlU2hhZG93RG9tKHNlbGVjdG9yLCBob3N0RWxlbWVudHMpIHtcbiAgdmFyIHRhcmdldHMgPSBbXTtcbiAgdmFyIGlubmVySG9zdHNBY2MgPSBbXTsgLy8gaXQncyBwb3NzaWJsZSB0byBnZXQgYSBmZXcgaG9zdEVsZW1lbnRzIGZvdW5kIGJ5IGJhc2VTZWxlY3RvciBvbiB0aGUgcGFnZVxuXG4gIGhvc3RFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0KSB7XG4gICAgLy8gY2hlY2sgcHJlc2VuY2Ugb2Ygc2VsZWN0b3IgZWxlbWVudCBpbnNpZGUgYmFzZSBlbGVtZW50IGlmIGl0J3Mgbm90IGluIHNoYWRvdy1kb21cbiAgICB2YXIgc2ltcGxlRWxlbXMgPSBob3N0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChbXS5zbGljZS5jYWxsKHNpbXBsZUVsZW1zKSk7XG4gICAgdmFyIHNoYWRvd1Jvb3RFbGVtID0gaG9zdC5zaGFkb3dSb290O1xuICAgIHZhciBzaGFkb3dDaGlsZHJlbiA9IHNoYWRvd1Jvb3RFbGVtLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgIHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChbXS5zbGljZS5jYWxsKHNoYWRvd0NoaWxkcmVuKSk7IC8vIGZpbmQgaW5uZXIgc2hhZG93LWRvbSBob3N0cyBpbnNpZGUgcHJvY2Vzc2luZyBzaGFkb3ctZG9tXG5cbiAgICBpbm5lckhvc3RzQWNjLnB1c2goZmluZEhvc3RFbGVtZW50cyhzaGFkb3dSb290RWxlbSkpO1xuICB9KTsgLy8gaWYgdGhlcmUgd2VyZSBtb3JlIHRoYW4gb25lIGhvc3QgZWxlbWVudCxcbiAgLy8gaW5uZXJIb3N0c0FjYyBpcyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIHNob3VsZCBiZSBmbGF0dGVuXG5cbiAgdmFyIGlubmVySG9zdHMgPSBmbGF0dGVuKGlubmVySG9zdHNBY2MpO1xuICByZXR1cm4ge1xuICAgIHRhcmdldHM6IHRhcmdldHMsXG4gICAgaW5uZXJIb3N0czogaW5uZXJIb3N0c1xuICB9O1xufTtcblxuLyoqXG4gKiBQcmVwYXJlcyBjb29raWUgc3RyaW5nIGlmIGdpdmVuIHBhcmFtZXRlcnMgYXJlIG9rXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb29raWUgbmFtZSB0byBzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBjb29raWUgdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGNvb2tpZSBzdHJpbmcgaWYgb2sgT1IgbnVsbCBpZiBub3RcbiAqL1xuXG52YXIgcHJlcGFyZUNvb2tpZSA9IGZ1bmN0aW9uIHByZXBhcmVDb29raWUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFuYW1lIHx8ICF2YWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHZhbHVlVG9TZXQ7XG5cbiAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ3RydWUnO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnVHJ1ZScpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ1RydWUnO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgdmFsdWVUb1NldCA9ICdmYWxzZSc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdGYWxzZScpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ0ZhbHNlJztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3llcycpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ3llcyc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdZZXMnKSB7XG4gICAgdmFsdWVUb1NldCA9ICdZZXMnO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnWScpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ1knO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnbm8nKSB7XG4gICAgdmFsdWVUb1NldCA9ICdubyc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdvaycpIHtcbiAgICB2YWx1ZVRvU2V0ID0gJ29rJztcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ09LJykge1xuICAgIHZhbHVlVG9TZXQgPSAnT0snO1xuICB9IGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgdmFsdWVUb1NldCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgaWYgKG5hdGl2ZUlzTmFOKHZhbHVlVG9TZXQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnModmFsdWVUb1NldCkgPCAwIHx8IE1hdGguYWJzKHZhbHVlVG9TZXQpID4gMTUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwYXRoVG9TZXQgPSAncGF0aD0vOyc7XG4gIHZhciBjb29raWVEYXRhID0gXCJcIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVRvU2V0KSwgXCI7IFwiKS5jb25jYXQocGF0aFRvU2V0KTtcbiAgcmV0dXJuIGNvb2tpZURhdGE7XG59O1xuXG52YXIgc2hvdWxkTWF0Y2hBbnlEZWxheSA9IGZ1bmN0aW9uIHNob3VsZE1hdGNoQW55RGVsYXkoZGVsYXkpIHtcbiAgcmV0dXJuIGRlbGF5ID09PSBnZXRXaWxkY2FyZFN5bWJvbCgpO1xufTtcbi8qKlxuICogSGFuZGxlcyBpbnB1dCBkZWxheSB2YWx1ZVxuICogQHBhcmFtIHsqfSBkZWxheVxuICogQHJldHVybnMge251bWJlcn0gcHJvcGVyIG51bWJlciBkZWxheSB2YWx1ZVxuICovXG5cbnZhciBnZXRNYXRjaERlbGF5ID0gZnVuY3Rpb24gZ2V0TWF0Y2hEZWxheShkZWxheSkge1xuICB2YXIgREVGQVVMVF9ERUxBWSA9IDEwMDA7XG4gIHZhciBwYXJzZWREZWxheSA9IHBhcnNlSW50KGRlbGF5LCAxMCk7XG4gIHZhciBkZWxheU1hdGNoID0gbmF0aXZlSXNOYU4ocGFyc2VkRGVsYXkpID8gREVGQVVMVF9ERUxBWSAvLyBkZWZhdWx0IHNjcmlwdGxldCB2YWx1ZVxuICA6IHBhcnNlZERlbGF5O1xuICByZXR1cm4gZGVsYXlNYXRjaDtcbn07XG4vKipcbiAqIENoZWNrcyBkZWxheSBtYXRjaCBjb25kaXRpb25cbiAqIEBwYXJhbSB7Kn0gaW5wdXREZWxheVxuICogQHBhcmFtIHtudW1iZXJ9IHJlYWxEZWxheVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxudmFyIGlzRGVsYXlNYXRjaGVkID0gZnVuY3Rpb24gaXNEZWxheU1hdGNoZWQoaW5wdXREZWxheSwgcmVhbERlbGF5KSB7XG4gIHJldHVybiBzaG91bGRNYXRjaEFueURlbGF5KGlucHV0RGVsYXkpIHx8IHJlYWxEZWxheSA9PT0gZ2V0TWF0Y2hEZWxheShpbnB1dERlbGF5KTtcbn07XG4vKipcbiAqIEhhbmRsZXMgaW5wdXQgYm9vc3QgdmFsdWVcbiAqIEBwYXJhbSB7Kn0gYm9vc3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHByb3BlciBudW1iZXIgYm9vc3QgbXVsdGlwbGllciB2YWx1ZVxuICovXG5cbnZhciBnZXRCb29zdE11bHRpcGxpZXIgPSBmdW5jdGlvbiBnZXRCb29zdE11bHRpcGxpZXIoYm9vc3QpIHtcbiAgdmFyIERFRkFVTFRfTVVMVElQTElFUiA9IDAuMDU7XG4gIHZhciBNSU5fTVVMVElQTElFUiA9IDAuMDI7XG4gIHZhciBNQVhfTVVMVElQTElFUiA9IDUwO1xuICB2YXIgcGFyc2VkQm9vc3QgPSBwYXJzZUZsb2F0KGJvb3N0KTtcbiAgdmFyIGJvb3N0TXVsdGlwbGllciA9IG5hdGl2ZUlzTmFOKHBhcnNlZEJvb3N0KSB8fCAhbmF0aXZlSXNGaW5pdGUocGFyc2VkQm9vc3QpID8gREVGQVVMVF9NVUxUSVBMSUVSIC8vIGRlZmF1bHQgc2NyaXB0bGV0IHZhbHVlXG4gIDogcGFyc2VkQm9vc3Q7XG5cbiAgaWYgKGJvb3N0TXVsdGlwbGllciA8IE1JTl9NVUxUSVBMSUVSKSB7XG4gICAgYm9vc3RNdWx0aXBsaWVyID0gTUlOX01VTFRJUExJRVI7XG4gIH1cblxuICBpZiAoYm9vc3RNdWx0aXBsaWVyID4gTUFYX01VTFRJUExJRVIpIHtcbiAgICBib29zdE11bHRpcGxpZXIgPSBNQVhfTVVMVElQTElFUjtcbiAgfVxuXG4gIHJldHVybiBib29zdE11bHRpcGxpZXI7XG59O1xuXG4vKipcbiAqIENvbGxlY3RzIFJlcXVlc3Qgb3B0aW9ucyB0byBvYmplY3RcbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICogQHJldHVybnMge09iamVjdH0gZGF0YSBvYmplY3RcbiAqL1xuXG52YXIgZ2V0UmVxdWVzdERhdGEgPSBmdW5jdGlvbiBnZXRSZXF1ZXN0RGF0YShyZXF1ZXN0KSB7XG4gIHZhciBSRVFVRVNUX0lOSVRfT1BUSU9OUyA9IFsndXJsJywgJ21ldGhvZCcsICdoZWFkZXJzJywgJ2JvZHknLCAnbW9kZScsICdjcmVkZW50aWFscycsICdjYWNoZScsICdyZWRpcmVjdCcsICdyZWZlcnJlcicsICdpbnRlZ3JpdHknXTtcbiAgdmFyIGVudHJpZXMgPSBSRVFVRVNUX0lOSVRfT1BUSU9OUy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIC8vIGlmIHJlcXVlc3QgaGFzIG5vIHN1Y2ggb3B0aW9uLCB2YWx1ZSB3aWxsIGJlIHVuZGVmaW5lZFxuICAgIHZhciB2YWx1ZSA9IHJlcXVlc3Rba2V5XTtcbiAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIGdldE9iamVjdEZyb21FbnRyaWVzKGVudHJpZXMpO1xufTtcbi8qKlxuICogQ29sbGVjdHMgZmV0Y2ggYXJncyB0byBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gYXJncyBmZXRjaCBhcmdzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkYXRhIG9iamVjdFxuICovXG5cbnZhciBnZXRGZXRjaERhdGEgPSBmdW5jdGlvbiBnZXRGZXRjaERhdGEoYXJncykge1xuICB2YXIgZmV0Y2hQcm9wc09iaiA9IHt9O1xuICB2YXIgZmV0Y2hVcmw7XG4gIHZhciBmZXRjaEluaXQ7XG5cbiAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgLy8gaWYgUmVxdWVzdCBwYXNzZWQgdG8gZmV0Y2gsIGl0IHdpbGwgYmUgaW4gYXJyYXlcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBnZXRSZXF1ZXN0RGF0YShhcmdzWzBdKTtcbiAgICBmZXRjaFVybCA9IHJlcXVlc3REYXRhLnVybDtcbiAgICBmZXRjaEluaXQgPSByZXF1ZXN0RGF0YTtcbiAgfSBlbHNlIHtcbiAgICBmZXRjaFVybCA9IGFyZ3NbMF07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICAgIGZldGNoSW5pdCA9IGFyZ3NbMV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgfVxuXG4gIGZldGNoUHJvcHNPYmoudXJsID0gZmV0Y2hVcmw7XG5cbiAgaWYgKGZldGNoSW5pdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIE9iamVjdC5rZXlzKGZldGNoSW5pdCkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgZmV0Y2hQcm9wc09ialtwcm9wXSA9IGZldGNoSW5pdFtwcm9wXTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmZXRjaFByb3BzT2JqO1xufTtcbi8qKlxuICogQ29udmVydHMgcHJldmVudC1mZXRjaCBwcm9wc1RvTWF0Y2ggaW5wdXQgc3RyaW5nIHRvIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzVG9NYXRjaFN0clxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdoZXJlICdrZXknIGlzIHByb3AgbmFtZSBhbmQgJ3ZhbHVlJyBpcyBwcm9wIHZhbHVlXG4gKi9cblxudmFyIGNvbnZlcnRNYXRjaFByb3BzVG9PYmogPSBmdW5jdGlvbiBjb252ZXJ0TWF0Y2hQcm9wc1RvT2JqKHByb3BzVG9NYXRjaFN0cikge1xuICB2YXIgUFJPUFNfRElWSURFUiA9ICcgJztcbiAgdmFyIFBBSVJTX01BUktFUiA9ICc6JztcbiAgdmFyIHByb3BzT2JqID0ge307XG4gIHZhciBwcm9wcyA9IHByb3BzVG9NYXRjaFN0ci5zcGxpdChQUk9QU19ESVZJREVSKTtcbiAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciBkaXZpZGVySW5kID0gcHJvcC5pbmRleE9mKFBBSVJTX01BUktFUik7XG5cbiAgICBpZiAoZGl2aWRlckluZCA9PT0gLTEpIHtcbiAgICAgIHByb3BzT2JqLnVybCA9IHRvUmVnRXhwKHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5ID0gcHJvcC5zbGljZSgwLCBkaXZpZGVySW5kKTtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3Auc2xpY2UoZGl2aWRlckluZCArIDEpO1xuICAgICAgcHJvcHNPYmpba2V5XSA9IHRvUmVnRXhwKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJvcHNPYmo7XG59O1xuXG52YXIgaGFuZGxlT2xkUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBoYW5kbGVPbGRSZXBsYWNlbWVudChyZXBsYWNlbWVudCkge1xuICB2YXIgcmVzdWx0OyAvLyBkZWZhdWx0cyB0byByZXR1cm4gbm9vcEZ1bmMgaW5zdGVhZCBvZiB3aW5kb3cub3BlblxuXG4gIGlmICghcmVwbGFjZW1lbnQpIHtcbiAgICByZXN1bHQgPSBub29wRnVuYztcbiAgfSBlbHNlIGlmIChyZXBsYWNlbWVudCA9PT0gJ3RydWVGdW5jJykge1xuICAgIHJlc3VsdCA9IHRydWVGdW5jO1xuICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50LmluZGV4T2YoJz0nKSA+IC0xKSB7XG4gICAgLy8gV2Ugc2hvdWxkIHJldHVybiBub29wRnVuYyBpbnN0ZWFkIG9mIHdpbmRvdy5vcGVuXG4gICAgLy8gYnV0IHdpdGggc29tZSBwcm9wZXJ0eSBpZiB3ZWJzaXRlIGNoZWNrcyBpdCAoZXhhbXBsZXMgNSwgNilcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvNzFcbiAgICB2YXIgaXNQcm9wID0gc3RhcnRzV2l0aChyZXBsYWNlbWVudCwgJ3snKSAmJiBlbmRzV2l0aChyZXBsYWNlbWVudCwgJ30nKTtcblxuICAgIGlmIChpc1Byb3ApIHtcbiAgICAgIHZhciBwcm9wZXJ0eVBhcnQgPSByZXBsYWNlbWVudC5zbGljZSgxLCAtMSk7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gc3Vic3RyaW5nQmVmb3JlKHByb3BlcnR5UGFydCwgJz0nKTtcbiAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gc3Vic3RyaW5nQWZ0ZXIocHJvcGVydHlQYXJ0LCAnPScpO1xuXG4gICAgICBpZiAocHJvcGVydHlWYWx1ZSA9PT0gJ25vb3BGdW5jJykge1xuICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSBub29wRnVuYztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBjcmVhdGVEZWNveSA9IGZ1bmN0aW9uIGNyZWF0ZURlY295KGFyZ3MpIHtcbiAgdmFyIE9CSkVDVF9UQUdfTkFNRSA9ICdvYmplY3QnO1xuICB2YXIgT0JKRUNUX1VSTF9QUk9QX05BTUUgPSAnZGF0YSc7XG4gIHZhciBJRlJBTUVfVEFHX05BTUUgPSAnaWZyYW1lJztcbiAgdmFyIElGUkFNRV9VUkxfUFJPUF9OQU1FID0gJ3NyYyc7XG4gIHZhciByZXBsYWNlbWVudCA9IGFyZ3MucmVwbGFjZW1lbnQsXG4gICAgICB1cmwgPSBhcmdzLnVybCxcbiAgICAgIGRlbGF5ID0gYXJncy5kZWxheTtcbiAgdmFyIHRhZztcbiAgdmFyIHVybFByb3A7XG5cbiAgaWYgKHJlcGxhY2VtZW50ID09PSAnb2JqJykge1xuICAgIHRhZyA9IE9CSkVDVF9UQUdfTkFNRTtcbiAgICB1cmxQcm9wID0gT0JKRUNUX1VSTF9QUk9QX05BTUU7XG4gIH0gZWxzZSB7XG4gICAgdGFnID0gSUZSQU1FX1RBR19OQU1FO1xuICAgIHVybFByb3AgPSBJRlJBTUVfVVJMX1BST1BfTkFNRTtcbiAgfVxuXG4gIHZhciBkZWNveSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgZGVjb3lbdXJsUHJvcF0gPSB1cmw7XG4gIGRlY295LnN0eWxlLnNldFByb3BlcnR5KCdoZWlnaHQnLCAnMXB4JywgJ2ltcG9ydGFudCcpO1xuICBkZWNveS5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCAnZml4ZWQnLCAnaW1wb3J0YW50Jyk7XG4gIGRlY295LnN0eWxlLnNldFByb3BlcnR5KCd0b3AnLCAnLTFweCcsICdpbXBvcnRhbnQnKTtcbiAgZGVjb3kuc3R5bGUuc2V0UHJvcGVydHkoJ3dpZHRoJywgJzFweCcsICdpbXBvcnRhbnQnKTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkZWNveSk7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWNveS5yZW1vdmUoKTtcbiAgfSwgZGVsYXkgKiAxMDAwKTtcbiAgcmV0dXJuIGRlY295O1xufTtcbnZhciBnZXRQcmV2ZW50R2V0dGVyID0gZnVuY3Rpb24gZ2V0UHJldmVudEdldHRlcihuYXRpdmVHZXR0ZXIpIHtcbiAgdmFyIHByZXZlbnRHZXR0ZXIgPSBmdW5jdGlvbiBwcmV2ZW50R2V0dGVyKHRhcmdldCwgcHJvcCkge1xuICAgIGlmIChwcm9wICYmIHByb3AgPT09ICdjbG9zZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVHZXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBub29wRnVuYztcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcCAmJiB0YXJnZXRbcHJvcF07XG4gIH07XG5cbiAgcmV0dXJuIHByZXZlbnRHZXR0ZXI7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBldmVudCB0eXBlXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgdmFsaWRhdGVUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVUeXBlKHR5cGUpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzEyNVxuICByZXR1cm4gdHlwZW9mIHR5cGUgIT09ICd1bmRlZmluZWQnO1xufTtcbi8qKlxuICogVmFsaWRhdGVzIGV2ZW50IGxpc3RlbmVyXG4gKiBAcGFyYW0geyp9IGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG52YXIgdmFsaWRhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjcGFyYW1ldGVyc1xuICByZXR1cm4gdHlwZW9mIGxpc3RlbmVyICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzc2XG4gICYmIGxpc3RlbmVyICE9PSBudWxsICYmIHR5cGVvZiBsaXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuLyoqXG4gKiBTZXJpYWxpemUgdmFsaWQgZXZlbnQgbGlzdGVuZXJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudExpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGxpc3RlbmVyIHZhbGlkIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBsaXN0ZW5lclRvU3RyaW5nID0gZnVuY3Rpb24gbGlzdGVuZXJUb1N0cmluZyhsaXN0ZW5lcikge1xuICByZXR1cm4gdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nID8gbGlzdGVuZXIudG9TdHJpbmcoKSA6IGxpc3RlbmVyLmhhbmRsZUV2ZW50LnRvU3RyaW5nKCk7XG59O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBtdXN0IGV4cG9ydCBhbGwgdXNlZCBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZGVwZW5kZW5jaWVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXRXaWxkY2FyZFN5bWJvbDogZ2V0V2lsZGNhcmRTeW1ib2wsXG4gICAgcmFuZG9tSWQ6IHJhbmRvbUlkLFxuICAgIHNldFByb3BlcnR5QWNjZXNzOiBzZXRQcm9wZXJ0eUFjY2VzcyxcbiAgICBnZXRQcm9wZXJ0eUluQ2hhaW46IGdldFByb3BlcnR5SW5DaGFpbixcbiAgICBnZXRXaWxkY2FyZFByb3BlcnR5SW5DaGFpbjogZ2V0V2lsZGNhcmRQcm9wZXJ0eUluQ2hhaW4sXG4gICAgcmVwbGFjZUFsbDogcmVwbGFjZUFsbCxcbiAgICBlc2NhcGVSZWdFeHA6IGVzY2FwZVJlZ0V4cCxcbiAgICB0b1JlZ0V4cDogdG9SZWdFeHAsXG4gICAgZ2V0QmVmb3JlUmVnRXhwOiBnZXRCZWZvcmVSZWdFeHAsXG4gICAgc3RhcnRzV2l0aDogc3RhcnRzV2l0aCxcbiAgICBlbmRzV2l0aDogZW5kc1dpdGgsXG4gICAgc3Vic3RyaW5nQWZ0ZXI6IHN1YnN0cmluZ0FmdGVyLFxuICAgIHN1YnN0cmluZ0JlZm9yZTogc3Vic3RyaW5nQmVmb3JlLFxuICAgIHdyYXBJblNpbmdsZVF1b3Rlczogd3JhcEluU2luZ2xlUXVvdGVzLFxuICAgIGdldFN0cmluZ0luQnJhY2VzOiBnZXRTdHJpbmdJbkJyYWNlcyxcbiAgICBjb252ZXJ0UnRjQ29uZmlnVG9TdHJpbmc6IGNvbnZlcnRSdGNDb25maWdUb1N0cmluZyxcbiAgICBwYXJzZU1hdGNoQXJnOiBwYXJzZU1hdGNoQXJnLFxuICAgIHBhcnNlRGVsYXlBcmc6IHBhcnNlRGVsYXlBcmcsXG4gICAgb2JqZWN0VG9TdHJpbmc6IG9iamVjdFRvU3RyaW5nLFxuICAgIGNvbnZlcnRUeXBlVG9TdHJpbmc6IGNvbnZlcnRUeXBlVG9TdHJpbmcsXG4gICAgY3JlYXRlT25FcnJvckhhbmRsZXI6IGNyZWF0ZU9uRXJyb3JIYW5kbGVyLFxuICAgIG5vb3BGdW5jOiBub29wRnVuYyxcbiAgICBub29wTnVsbDogbm9vcE51bGwsXG4gICAgdHJ1ZUZ1bmM6IHRydWVGdW5jLFxuICAgIGZhbHNlRnVuYzogZmFsc2VGdW5jLFxuICAgIG5vb3BUaGlzOiBub29wVGhpcyxcbiAgICBub29wU3RyOiBub29wU3RyLFxuICAgIG5vb3BBcnJheTogbm9vcEFycmF5LFxuICAgIG5vb3BPYmplY3Q6IG5vb3BPYmplY3QsXG4gICAgbm9vcFByb21pc2VSZWplY3Q6IG5vb3BQcm9taXNlUmVqZWN0LFxuICAgIG5vb3BQcm9taXNlUmVzb2x2ZTogbm9vcFByb21pc2VSZXNvbHZlLFxuICAgIGhpdDogaGl0LFxuICAgIG9ic2VydmVET01DaGFuZ2VzOiBvYnNlcnZlRE9NQ2hhbmdlcyxcbiAgICBtYXRjaFN0YWNrVHJhY2U6IG1hdGNoU3RhY2tUcmFjZSxcbiAgICBmaW5kSG9zdEVsZW1lbnRzOiBmaW5kSG9zdEVsZW1lbnRzLFxuICAgIHBpZXJjZVNoYWRvd0RvbTogcGllcmNlU2hhZG93RG9tLFxuICAgIGZsYXR0ZW46IGZsYXR0ZW4sXG4gICAgcHJlcGFyZUNvb2tpZTogcHJlcGFyZUNvb2tpZSxcbiAgICBuYXRpdmVJc05hTjogbmF0aXZlSXNOYU4sXG4gICAgbmF0aXZlSXNGaW5pdGU6IG5hdGl2ZUlzRmluaXRlLFxuICAgIHNob3VsZE1hdGNoQW55RGVsYXk6IHNob3VsZE1hdGNoQW55RGVsYXksXG4gICAgZ2V0TWF0Y2hEZWxheTogZ2V0TWF0Y2hEZWxheSxcbiAgICBpc0RlbGF5TWF0Y2hlZDogaXNEZWxheU1hdGNoZWQsXG4gICAgZ2V0Qm9vc3RNdWx0aXBsaWVyOiBnZXRCb29zdE11bHRpcGxpZXIsXG4gICAgZ2V0UmVxdWVzdERhdGE6IGdldFJlcXVlc3REYXRhLFxuICAgIGdldEZldGNoRGF0YTogZ2V0RmV0Y2hEYXRhLFxuICAgIGNvbnZlcnRNYXRjaFByb3BzVG9PYmo6IGNvbnZlcnRNYXRjaFByb3BzVG9PYmosXG4gICAgZ2V0T2JqZWN0RW50cmllczogZ2V0T2JqZWN0RW50cmllcyxcbiAgICBnZXRPYmplY3RGcm9tRW50cmllczogZ2V0T2JqZWN0RnJvbUVudHJpZXMsXG4gICAgaXNFbXB0eU9iamVjdDogaXNFbXB0eU9iamVjdCxcbiAgICBoYW5kbGVPbGRSZXBsYWNlbWVudDogaGFuZGxlT2xkUmVwbGFjZW1lbnQsXG4gICAgY3JlYXRlRGVjb3k6IGNyZWF0ZURlY295LFxuICAgIGdldFByZXZlbnRHZXR0ZXI6IGdldFByZXZlbnRHZXR0ZXIsXG4gICAgdmFsaWRhdGVUeXBlOiB2YWxpZGF0ZVR5cGUsXG4gICAgdmFsaWRhdGVMaXN0ZW5lcjogdmFsaWRhdGVMaXN0ZW5lcixcbiAgICBsaXN0ZW5lclRvU3RyaW5nOiBsaXN0ZW5lclRvU3RyaW5nXG59KTtcblxuLyoqXG4gKiBDb25jYXQgZGVwZW5kZW5jaWVzIHRvIHNjcmlwdGxldCBjb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0bGV0IHN0cmluZyB2aWV3IG9mIHNjcmlwdGxldFxuICovXG5cbmZ1bmN0aW9uIGF0dGFjaERlcGVuZGVuY2llcyhzY3JpcHRsZXQpIHtcbiAgdmFyIF9zY3JpcHRsZXQkaW5qZWN0aW9ucyA9IHNjcmlwdGxldC5pbmplY3Rpb25zLFxuICAgICAgaW5qZWN0aW9ucyA9IF9zY3JpcHRsZXQkaW5qZWN0aW9ucyA9PT0gdm9pZCAwID8gW10gOiBfc2NyaXB0bGV0JGluamVjdGlvbnM7XG4gIHJldHVybiBpbmplY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGRlcCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChhY2N1bSwgXCJcXG5cIikuY29uY2F0KGRlcGVuZGVuY2llc1tkZXAubmFtZV0pO1xuICB9LCBzY3JpcHRsZXQudG9TdHJpbmcoKSk7XG59XG4vKipcbiAqIEFkZCBzY3JpcHRsZXQgY2FsbCB0byBleGlzdGluZyBjb2RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzY3JpcHRsZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKi9cblxuZnVuY3Rpb24gYWRkQ2FsbChzY3JpcHRsZXQsIGNvZGUpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGNvZGUsIFwiO1xcbiAgICAgICAgY29uc3QgdXBkYXRlZEFyZ3MgPSBhcmdzID8gW10uY29uY2F0KHNvdXJjZSkuY29uY2F0KGFyZ3MpIDogW3NvdXJjZV07XFxuICAgICAgICBcIikuY29uY2F0KHNjcmlwdGxldC5uYW1lLCBcIi5hcHBseSh0aGlzLCB1cGRhdGVkQXJncyk7XFxuICAgIFwiKTtcbn1cbi8qKlxuICogV3JhcCBmdW5jdGlvbiBpbnRvIElJRkUgKEltbWVkaWF0ZWx5IGludm9rZWQgZnVuY3Rpb24gZXhwcmVzc2lvbilcbiAqXG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlIC0gb2JqZWN0IHdpdGggc2NyaXB0bGV0IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIC0gc2NyaXB0bGV0IHNvdXJjZSBjb2RlIHdpdGggZGVwZW5kZW5jaWVzXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gZnVsbCBzY3JpcHRsZXQgY29kZVxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzb3VyY2UgPSB7XG4gKiAgICAgIGFyZ3M6IFtcImFhYVwiLCBcImJiYlwiXSxcbiAqICAgICAgbmFtZTogJ25vZXZhbCcsXG4gKiB9O1xuICogY29uc3QgY29kZSA9IFwiZnVuY3Rpb24gbm9ldmFsKHNvdXJjZSwgYXJncykgeyBhbGVydChzb3VyY2UpOyB9IG5vZXZhbC5hcHBseSh0aGlzLCBhcmdzKTtcIlxuICogY29uc3QgcmVzdWx0ID0gd3JhcEluSUlGRShzb3VyY2UsIGNvZGUpO1xuICpcbiAqIC8vIHJlc3VsdFxuICogYChmdW5jdGlvbihzb3VyY2UsIGFyZ3MpIHtcbiAqICAgICAgZnVuY3Rpb24gbm9ldmFsKHNvdXJjZSkgeyBhbGVydChzb3VyY2UpOyB9XG4gKiAgICAgIG5vZXZhbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAqICkoe1wiYXJnc1wiOiBbXCJhYWFcIiwgXCJiYmJcIl0sIFwibmFtZVwiOlwibm9ldmFsXCJ9LCBbXCJhYWFcIiwgXCJiYmJcIl0pYFxuICovXG5cbmZ1bmN0aW9uIHBhc3NTb3VyY2VBbmRQcm9wcyhzb3VyY2UsIGNvZGUpIHtcbiAgaWYgKHNvdXJjZS5oaXQpIHtcbiAgICBzb3VyY2UuaGl0ID0gc291cmNlLmhpdC50b1N0cmluZygpO1xuICB9XG5cbiAgdmFyIHNvdXJjZVN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHNvdXJjZSk7XG4gIHZhciBhcmdzU3RyaW5nID0gc291cmNlLmFyZ3MgPyBcIltcIi5jb25jYXQoc291cmNlLmFyZ3MubWFwKEpTT04uc3RyaW5naWZ5KSwgXCJdXCIpIDogdW5kZWZpbmVkO1xuICB2YXIgcGFyYW1zID0gYXJnc1N0cmluZyA/IFwiXCIuY29uY2F0KHNvdXJjZVN0cmluZywgXCIsIFwiKS5jb25jYXQoYXJnc1N0cmluZykgOiBzb3VyY2VTdHJpbmc7XG4gIHJldHVybiBcIihmdW5jdGlvbihzb3VyY2UsIGFyZ3Mpe1xcblwiLmNvbmNhdChjb2RlLCBcIlxcbn0pKFwiKS5jb25jYXQocGFyYW1zLCBcIik7XCIpO1xufVxuLyoqXG4gKiBXcmFwIGNvZGUgaW4gbm8gbmFtZSBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgd2hpY2ggbXVzdCBiZSB3cmFwcGVkXG4gKi9cblxuZnVuY3Rpb24gd3JhcEluTm9uYW1lRnVuYyhjb2RlKSB7XG4gIHJldHVybiBcImZ1bmN0aW9uKHNvdXJjZSwgYXJncyl7XFxuXCIuY29uY2F0KGNvZGUsIFwiXFxufVwiKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9kZWZpbmVQcm9wZXJ0eTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgaXRlcmFibGUgYXJndW1lbnQgYW5kIGV2YWx1YXRlIGN1cnJlbnQgc3RhdGUgd2l0aCB0cmFuc2l0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IGluaXQgZmlyc3QgdHJhbnNpdGlvbiBuYW1lXG4gKiBAcGFyYW0ge0FycmF5fENvbGxlY3Rpb258c3RyaW5nfSBpdGVyYWJsZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb25zIHRyYW5zdGlvbiBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzIGFyZ3VtZW50cyB3aGljaCBzaG91bGQgYmUgcGFzc2VkIHRvIHRyYW5zaXRpb24gZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGl0ZXJhdGVXaXRoVHJhbnNpdGlvbnMoaXRlcmFibGUsIHRyYW5zaXRpb25zLCBpbml0LCBhcmdzKSB7XG4gIHZhciBzdGF0ZSA9IGluaXQgfHwgT2JqZWN0LmtleXModHJhbnNpdGlvbnMpWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzdGF0ZSA9IHRyYW5zaXRpb25zW3N0YXRlXShpdGVyYWJsZSwgaSwgYXJncyk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG4vKipcbiAqIEFkR3VhcmQgc2NyaXB0bGV0IHJ1bGUgbWFza1xuICovXG5cblxudmFyIEFER19TQ1JJUFRMRVRfTUFTSyA9ICcjLy9zY3JpcHRsZXQnO1xuLyoqXG4gKiBIZWxwZXIgdG8gYWNjdW11bGF0ZSBhbiBhcnJheSBvZiBzdHJpbmdzIGNoYXIgYnkgY2hhclxuICovXG5cbnZhciB3b3JkU2F2ZXIgPSBmdW5jdGlvbiB3b3JkU2F2ZXIoKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIHN0cnMgPSBbXTtcblxuICB2YXIgc2F2ZVN5bWIgPSBmdW5jdGlvbiBzYXZlU3ltYihzKSB7XG4gICAgc3RyICs9IHM7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICB2YXIgc2F2ZVN0ciA9IGZ1bmN0aW9uIHNhdmVTdHIoKSB7XG4gICAgc3Rycy5wdXNoKHN0cik7XG4gICAgc3RyID0gJyc7XG4gIH07XG5cbiAgdmFyIGdldEFsbCA9IGZ1bmN0aW9uIGdldEFsbCgpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KHN0cnMpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2F2ZVN5bWI6IHNhdmVTeW1iLFxuICAgIHNhdmVTdHI6IHNhdmVTdHIsXG4gICAgZ2V0QWxsOiBnZXRBbGxcbiAgfTtcbn07XG5cbnZhciBzdWJzdHJpbmdBZnRlciQxID0gZnVuY3Rpb24gc3Vic3RyaW5nQWZ0ZXIoc3RyLCBzZXBhcmF0b3IpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/ICcnIDogc3RyLnN1YnN0cmluZyhpbmRleCArIHNlcGFyYXRvci5sZW5ndGgpO1xufTtcbi8qKlxuICogUGFyc2UgYW5kIHZhbGlkYXRlIHNjcmlwdGxldCBydWxlXG4gKiBAcGFyYW0geyp9IHJ1bGVUZXh0XG4gKiBAcmV0dXJucyB7e25hbWU6IHN0cmluZywgYXJnczogQXJyYXk8c3RyaW5nPn19XG4gKi9cblxuXG52YXIgcGFyc2VSdWxlID0gZnVuY3Rpb24gcGFyc2VSdWxlKHJ1bGVUZXh0KSB7XG4gIHZhciBfdHJhbnNpdGlvbnM7XG5cbiAgcnVsZVRleHQgPSBzdWJzdHJpbmdBZnRlciQxKHJ1bGVUZXh0LCBBREdfU0NSSVBUTEVUX01BU0spO1xuICAvKipcbiAgICogVHJhbnNpdGlvbiBuYW1lc1xuICAgKi9cblxuICB2YXIgVFJBTlNJVElPTiA9IHtcbiAgICBPUEVORUQ6ICdvcGVuZWQnLFxuICAgIFBBUkFNOiAncGFyYW0nLFxuICAgIENMT1NFRDogJ2Nsb3NlZCdcbiAgfTtcbiAgLyoqXG4gICAqIFRyYW5zaXRpb24gZnVuY3Rpb246IHRoZSBjdXJyZW50IGluZGV4IHBvc2l0aW9uIGluIHN0YXJ0LCBlbmQgb3IgYmV0d2VlbiBwYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3RcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IE9iamVjdC5zZXAgY29udGFpbnMgcHJvcCBzeW1iIHdpdGggY3VycmVudCBzZXBhcmF0b3IgY2hhclxuICAgKi9cblxuICB2YXIgb3BlbmVkID0gZnVuY3Rpb24gb3BlbmVkKHJ1bGUsIGluZGV4LCBfcmVmKSB7XG4gICAgdmFyIHNlcCA9IF9yZWYuc2VwO1xuICAgIHZhciBjaGFyID0gcnVsZVtpbmRleF07XG4gICAgdmFyIHRyYW5zaXRpb247XG5cbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgJyAnOlxuICAgICAgY2FzZSAnKCc6XG4gICAgICBjYXNlICcsJzpcbiAgICAgICAge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBUUkFOU0lUSU9OLk9QRU5FRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdcXCcnOlxuICAgICAgY2FzZSAnXCInOlxuICAgICAgICB7XG4gICAgICAgICAgc2VwLnN5bWIgPSBjaGFyO1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBUUkFOU0lUSU9OLlBBUkFNO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IGluZGV4ID09PSBydWxlLmxlbmd0aCAtIDEgPyBUUkFOU0lUSU9OLkNMT1NFRCA6IFRSQU5TSVRJT04uT1BFTkVEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBydWxlIGlzIG5vdCBhIHNjcmlwdGxldCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zaXRpb247XG4gIH07XG4gIC8qKlxuICAgKiBUcmFuc2l0aW9uIGZ1bmN0aW9uOiB0aGUgY3VycmVudCBpbmRleCBwb3NpdGlvbiBpbnNpZGUgcGFyYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3RcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IE9iamVjdC5zZXAgY29udGFpbnMgcHJvcCBgc3ltYmAgd2l0aCBjdXJyZW50IHNlcGFyYXRvciBjaGFyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBPYmplY3Quc2F2ZXIgaGVscGVyIHdoaWNoIGFsbG93IHRvIHNhdmUgc3RyaW5ncyBieSBjYXIgYnkgY2hhclxuICAgKi9cblxuXG4gIHZhciBwYXJhbSA9IGZ1bmN0aW9uIHBhcmFtKHJ1bGUsIGluZGV4LCBfcmVmMikge1xuICAgIHZhciBzYXZlciA9IF9yZWYyLnNhdmVyLFxuICAgICAgICBzZXAgPSBfcmVmMi5zZXA7XG4gICAgdmFyIGNoYXIgPSBydWxlW2luZGV4XTtcblxuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSAnXFwnJzpcbiAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmVJbmRleCA9IGluZGV4IC0gMTtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gcnVsZVtwcmVJbmRleF07XG5cbiAgICAgICAgICBpZiAoY2hhciA9PT0gc2VwLnN5bWIgJiYgYmVmb3JlICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHNlcC5zeW1iID0gbnVsbDtcbiAgICAgICAgICAgIHNhdmVyLnNhdmVTdHIoKTtcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OLk9QRU5FRDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgc2F2ZXIuc2F2ZVN5bWIoY2hhcik7XG4gICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT04uUEFSQU07XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25zID0gKF90cmFuc2l0aW9ucyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfdHJhbnNpdGlvbnMsIFRSQU5TSVRJT04uT1BFTkVELCBvcGVuZWQpLCBkZWZpbmVQcm9wZXJ0eShfdHJhbnNpdGlvbnMsIFRSQU5TSVRJT04uUEFSQU0sIHBhcmFtKSwgZGVmaW5lUHJvcGVydHkoX3RyYW5zaXRpb25zLCBUUkFOU0lUSU9OLkNMT1NFRCwgZnVuY3Rpb24gKCkge30pLCBfdHJhbnNpdGlvbnMpO1xuICB2YXIgc2VwID0ge1xuICAgIHN5bWI6IG51bGxcbiAgfTtcbiAgdmFyIHNhdmVyID0gd29yZFNhdmVyKCk7XG4gIHZhciBzdGF0ZSA9IGl0ZXJhdGVXaXRoVHJhbnNpdGlvbnMocnVsZVRleHQsIHRyYW5zaXRpb25zLCBUUkFOU0lUSU9OLk9QRU5FRCwge1xuICAgIHNlcDogc2VwLFxuICAgIHNhdmVyOiBzYXZlclxuICB9KTtcblxuICBpZiAoc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzY3JpcHRsZXQgcnVsZSBcIi5jb25jYXQocnVsZVRleHQpKTtcbiAgfVxuXG4gIHZhciBhcmdzID0gc2F2ZXIuZ2V0QWxsKCk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogYXJnc1swXSxcbiAgICBhcmdzOiBhcmdzLnNsaWNlKDEpXG4gIH07XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBYm9ydHMgYSBzY3JpcHQgd2hlbiBpdCBhdHRlbXB0cyB0byAqKnJlYWQqKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2Fib3J0LW9uLXByb3BlcnR5LXJlYWRqcy1cbiAqXG4gKiBSZWxhdGVkIEFCUCBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWRibG9ja3BsdXMvYWRibG9ja3BsdXNjb3JlL2Jsb2IvNmIyYTMwOTA1NGNjMjM0MzIxMDJiODVkMTNmMTI1NTk2MzllZjQ5NS9saWIvY29udGVudC9zbmlwcGV0cy5qcyNMODY0XG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkJywgcHJvcGVydHlbLCBzdGFja10pXG4gKiBgYGBcbiAqXG4gKiAtIGBwcm9wZXJ0eWAgLSByZXF1aXJlZCwgcGF0aCB0byBhIHByb3BlcnR5IChqb2luZWQgd2l0aCBgLmAgaWYgbmVlZGVkKS4gVGhlIHByb3BlcnR5IG11c3QgYmUgYXR0YWNoZWQgdG8gYHdpbmRvd2BcbiAqIC0gYHN0YWNrYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbXVzdCBtYXRjaCB0aGUgY3VycmVudCBmdW5jdGlvbiBjYWxsIHN0YWNrIHRyYWNlXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiBgYGBcbiAqICEgQWJvcnRzIHNjcmlwdCB3aGVuIGl0IHRyaWVzIHRvIGFjY2VzcyBgd2luZG93LmFsZXJ0YFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWJvcnQtb24tcHJvcGVydHktcmVhZCcsICdhbGVydCcpXG4gKlxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gYWNjZXNzIGBuYXZpZ2F0b3IubGFuZ3VhZ2VgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkJywgJ25hdmlnYXRvci5sYW5ndWFnZScpXG4gKlxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gYWNjZXNzIGB3aW5kb3cuYWRibG9ja2AgYW5kIGl0J3MgZXJyb3Igc3RhY2sgdHJhY2UgY29udGFpbnMgYHRlc3QuanNgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkJywgJ2FkYmxvY2snLCAndGVzdC5qcycpXG4gKiBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gYWJvcnRPblByb3BlcnR5UmVhZChzb3VyY2UsIHByb3BlcnR5LCBzdGFjaykge1xuICBpZiAoIXByb3BlcnR5IHx8ICFtYXRjaFN0YWNrVHJhY2Uoc3RhY2ssIG5ldyBFcnJvcigpLnN0YWNrKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByaWQgPSByYW5kb21JZCgpO1xuXG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGhpdChzb3VyY2UpO1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihyaWQpO1xuICB9O1xuXG4gIHZhciBzZXRDaGFpblByb3BBY2Nlc3MgPSBmdW5jdGlvbiBzZXRDaGFpblByb3BBY2Nlc3Mob3duZXIsIHByb3BlcnR5KSB7XG4gICAgdmFyIGNoYWluSW5mbyA9IGdldFByb3BlcnR5SW5DaGFpbihvd25lciwgcHJvcGVydHkpO1xuICAgIHZhciBiYXNlID0gY2hhaW5JbmZvLmJhc2U7XG4gICAgdmFyIHByb3AgPSBjaGFpbkluZm8ucHJvcCxcbiAgICAgICAgY2hhaW4gPSBjaGFpbkluZm8uY2hhaW47XG5cbiAgICBpZiAoY2hhaW4pIHtcbiAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIoYSkge1xuICAgICAgICBiYXNlID0gYTtcblxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHNldENoYWluUHJvcEFjY2VzcyhhLCBjaGFpbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgcHJvcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFByb3BlcnR5QWNjZXNzKGJhc2UsIHByb3AsIHtcbiAgICAgIGdldDogYWJvcnQsXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHt9XG4gICAgfSk7XG4gIH07XG5cbiAgc2V0Q2hhaW5Qcm9wQWNjZXNzKHdpbmRvdywgcHJvcGVydHkpO1xuICB3aW5kb3cub25lcnJvciA9IGNyZWF0ZU9uRXJyb3JIYW5kbGVyKHJpZCkuYmluZCgpO1xufVxuYWJvcnRPblByb3BlcnR5UmVhZC5uYW1lcyA9IFsnYWJvcnQtb24tcHJvcGVydHktcmVhZCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidhYm9ydC1vbi1wcm9wZXJ0eS1yZWFkLmpzJywgJ3Viby1hYm9ydC1vbi1wcm9wZXJ0eS1yZWFkLmpzJywgJ2FvcHIuanMnLCAndWJvLWFvcHIuanMnLCAndWJvLWFib3J0LW9uLXByb3BlcnR5LXJlYWQnLCAndWJvLWFvcHInLCAnYWJwLWFib3J0LW9uLXByb3BlcnR5LXJlYWQnXTtcbmFib3J0T25Qcm9wZXJ0eVJlYWQuaW5qZWN0aW9ucyA9IFtyYW5kb21JZCwgdG9SZWdFeHAsIHNldFByb3BlcnR5QWNjZXNzLCBnZXRQcm9wZXJ0eUluQ2hhaW4sIGNyZWF0ZU9uRXJyb3JIYW5kbGVyLCBoaXQsIG1hdGNoU3RhY2tUcmFjZV07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGFib3J0LW9uLXByb3BlcnR5LXdyaXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBYm9ydHMgYSBzY3JpcHQgd2hlbiBpdCBhdHRlbXB0cyB0byAqKndyaXRlKiogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNhYm9ydC1vbi1wcm9wZXJ0eS13cml0ZWpzLVxuICpcbiAqIFJlbGF0ZWQgQUJQIHNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hZGJsb2NrcGx1cy9hZGJsb2NrcGx1c2NvcmUvYmxvYi82YjJhMzA5MDU0Y2MyMzQzMjEwMmI4NWQxM2YxMjU1OTYzOWVmNDk1L2xpYi9jb250ZW50L3NuaXBwZXRzLmpzI0w4OTZcbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LW9uLXByb3BlcnR5LXdyaXRlJywgcHJvcGVydHlbLCBzdGFja10pXG4gKiBgYGBcbiAqXG4gKiAtIGBwcm9wZXJ0eWAgLSByZXF1aXJlZCwgcGF0aCB0byBhIHByb3BlcnR5IChqb2luZWQgd2l0aCBgLmAgaWYgbmVlZGVkKS4gVGhlIHByb3BlcnR5IG11c3QgYmUgYXR0YWNoZWQgdG8gYHdpbmRvd2BcbiAqIC0gYHN0YWNrYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbXVzdCBtYXRjaCB0aGUgY3VycmVudCBmdW5jdGlvbiBjYWxsIHN0YWNrIHRyYWNlXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiBgYGBcbiAqICEgQWJvcnRzIHNjcmlwdCB3aGVuIGl0IHRyaWVzIHRvIHNldCBgd2luZG93LmFkYmxvY2tgIHZhbHVlXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1vbi1wcm9wZXJ0eS13cml0ZScsICdhZGJsb2NrJylcbiAqXG4gKiAhIEFib3J0cyBzY3JpcHQgd2hlbiBpdCB0cmllcyB0byBzZXQgYHdpbmRvdy5hZGJsb2NrYCB2YWx1ZSBhbmQgaXQncyBlcnJvciBzdGFjayB0cmFjZSBjb250YWlucyBgY2hlY2tpbmcuanNgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1vbi1wcm9wZXJ0eS13cml0ZScsICdhZGJsb2NrJywgJ2NoZWNraW5nLmpzJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBhYm9ydE9uUHJvcGVydHlXcml0ZShzb3VyY2UsIHByb3BlcnR5LCBzdGFjaykge1xuICBpZiAoIXByb3BlcnR5IHx8ICFtYXRjaFN0YWNrVHJhY2Uoc3RhY2ssIG5ldyBFcnJvcigpLnN0YWNrKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByaWQgPSByYW5kb21JZCgpO1xuXG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGhpdChzb3VyY2UpO1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihyaWQpO1xuICB9O1xuXG4gIHZhciBzZXRDaGFpblByb3BBY2Nlc3MgPSBmdW5jdGlvbiBzZXRDaGFpblByb3BBY2Nlc3Mob3duZXIsIHByb3BlcnR5KSB7XG4gICAgdmFyIGNoYWluSW5mbyA9IGdldFByb3BlcnR5SW5DaGFpbihvd25lciwgcHJvcGVydHkpO1xuICAgIHZhciBiYXNlID0gY2hhaW5JbmZvLmJhc2U7XG4gICAgdmFyIHByb3AgPSBjaGFpbkluZm8ucHJvcCxcbiAgICAgICAgY2hhaW4gPSBjaGFpbkluZm8uY2hhaW47XG5cbiAgICBpZiAoY2hhaW4pIHtcbiAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIoYSkge1xuICAgICAgICBiYXNlID0gYTtcblxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHNldENoYWluUHJvcEFjY2VzcyhhLCBjaGFpbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgcHJvcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFByb3BlcnR5QWNjZXNzKGJhc2UsIHByb3AsIHtcbiAgICAgIHNldDogYWJvcnRcbiAgICB9KTtcbiAgfTtcblxuICBzZXRDaGFpblByb3BBY2Nlc3Mod2luZG93LCBwcm9wZXJ0eSk7XG4gIHdpbmRvdy5vbmVycm9yID0gY3JlYXRlT25FcnJvckhhbmRsZXIocmlkKS5iaW5kKCk7XG59XG5hYm9ydE9uUHJvcGVydHlXcml0ZS5uYW1lcyA9IFsnYWJvcnQtb24tcHJvcGVydHktd3JpdGUnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nYWJvcnQtb24tcHJvcGVydHktd3JpdGUuanMnLCAndWJvLWFib3J0LW9uLXByb3BlcnR5LXdyaXRlLmpzJywgJ2FvcHcuanMnLCAndWJvLWFvcHcuanMnLCAndWJvLWFib3J0LW9uLXByb3BlcnR5LXdyaXRlJywgJ3Viby1hb3B3JywgJ2FicC1hYm9ydC1vbi1wcm9wZXJ0eS13cml0ZSddO1xuYWJvcnRPblByb3BlcnR5V3JpdGUuaW5qZWN0aW9ucyA9IFtyYW5kb21JZCwgc2V0UHJvcGVydHlBY2Nlc3MsIGdldFByb3BlcnR5SW5DaGFpbiwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdCwgdG9SZWdFeHAsIG1hdGNoU3RhY2tUcmFjZV07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IHByZXZlbnQtc2V0VGltZW91dFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgYSBgc2V0VGltZW91dGAgY2FsbCBpZjpcbiAqIDEpIHRoZSB0ZXh0IG9mIHRoZSBjYWxsYmFjayBpcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHNlYXJjaCBzdHJpbmcvcmVnZXhwIHdoaWNoIGRvZXMgbm90IHN0YXJ0IHdpdGggYCFgO1xuICogb3RoZXJ3aXNlIG1pc21hdGNoZWQgY2FsbHMgc2hvdWxkIGJlIGRlZnVzZWQ7XG4gKiAyKSB0aGUgdGltZW91dCBpcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIGRlbGF5OyBvdGhlcndpc2UgbWlzbWF0Y2hlZCBjYWxscyBzaG91bGQgYmUgZGVmdXNlZC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNuby1zZXR0aW1lb3V0LWlmanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldFRpbWVvdXQnWywgc2VhcmNoWywgZGVsYXldXSlcbiAqIGBgYFxuICpcbiAqIENhbGwgd2l0aCBubyBhcmd1bWVudHMgd2lsbCBsb2cgY2FsbHMgdG8gc2V0VGltZW91dCB3aGlsZSBkZWJ1Z2dpbmcgKGBsb2ctc2V0VGltZW91dGAgc3VwZXJzZWRpbmcpLFxuICogc28gcHJvZHVjdGlvbiBmaWx0ZXIgbGlzdHMnIHJ1bGVzIGRlZmluaXRlbHkgcmVxdWlyZSBhdCBsZWFzdCBvbmUgb2YgdGhlIHBhcmFtZXRlcnM6XG4gKiAtIGBzZWFyY2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBJZiBzdGFydHMgd2l0aCBgIWAsIHNjcmlwdGxldCB3aWxsIG5vdCBtYXRjaCB0aGUgc3RyaW5naWZpZWQgY2FsbGJhY2sgYnV0IGFsbCBvdGhlciB3aWxsIGJlIGRlZnVzZWQuXG4gKiBJZiBkbyBub3Qgc3RhcnQgd2l0aCBgIWAsIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayB3aWxsIGJlIG1hdGNoZWQuXG4gKiBJZiBub3Qgc2V0LCBwcmV2ZW50cyBhbGwgYHNldFRpbWVvdXRgIGNhbGxzIGR1ZSB0byBzcGVjaWZpZWQgYGRlbGF5YC5cbiAqIC0gYGRlbGF5YCAtIG9wdGlvbmFsLCBtdXN0IGJlIGFuIGludGVnZXIuXG4gKiBJZiBzdGFydHMgd2l0aCBgIWAsIHNjcmlwdGxldCB3aWxsIG5vdCBtYXRjaCB0aGUgZGVsYXkgYnV0IGFsbCBvdGhlciB3aWxsIGJlIGRlZnVzZWQuXG4gKiBJZiBkbyBub3Qgc3RhcnQgd2l0aCBgIWAsIHRoZSBkZWxheSBwYXNzZWQgdG8gdGhlIGBzZXRUaW1lb3V0YCBjYWxsIHdpbGwgYmUgbWF0Y2hlZC5cbiAqXG4gKiA+IElmIGBwcmV2ZW50LXNldFRpbWVvdXRgIHdpdGhvdXQgcGFyYW1ldGVycyBsb2dzIHNtdGggbGlrZSBgc2V0VGltZW91dCh1bmRlZmluZWQsIDEwMDApYCxcbiAqIGl0IG1lYW5zIHRoYXQgbm8gY2FsbGJhY2sgd2FzIHBhc3NlZCB0byBzZXRUaW1lb3V0KCkgYW5kIHRoYXQncyBub3Qgc2NyaXB0bGV0IGlzc3VlXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBQcmV2ZW50cyBgc2V0VGltZW91dGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIG1hdGNoZXMgYC9cXC50ZXN0L2AgcmVnYXJkbGVzcyBvZiB0aGUgZGVsYXkuXG4gKiAgICAgYGBgYmFzaFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0VGltZW91dCcsICcvXFwudGVzdC8nKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgY2FsbCB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZVwiO1xuICogICAgIH0sIDEwMCk7XG4gKiAgICAgYGBgXG4gKlxuICogMi4gUHJldmVudHMgYHNldFRpbWVvdXRgIGNhbGxzIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCBjb250YWluIGB2YWx1ZWAuXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRUaW1lb3V0JywgJyF2YWx1ZScpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgb25seSB0aGUgZmlyc3Qgb2YgdGhlIGZvbGxvd2luZyBjYWxscyB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ0ZXN0IC0tIHByZXZlbnRlZFwiO1xuICogICAgIH0sIDMwMCk7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZSAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDQwMCk7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy52YWx1ZSA9IFwidGVzdCAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDUwMCk7XG4gKiAgICAgYGBgXG4gKlxuICogMy4gUHJldmVudHMgYHNldFRpbWVvdXRgIGNhbGxzIGlmIHRoZSBjYWxsYmFjayBjb250YWlucyBgdmFsdWVgIGFuZCB0aGUgZGVsYXkgaXMgbm90IHNldCB0byBgMzAwYC5cbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldFRpbWVvdXQnLCAndmFsdWUnLCAnITMwMCcpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgb25seSB0aGUgZmlyc3Qgb2YgdGhlIGZvbGxvd2luZyBjYWxscyB3aWxsIG5vdCBiZSBwcmV2ZW50ZWQ6XG4gKiAgICAgYGBgamF2YXNjcmlwdFxuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidmFsdWUgMSAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDMwMCk7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZSAyIC0tIHByZXZlbnRlZFwiO1xuICogICAgIH0sIDQwMCk7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZSAzIC0tIHByZXZlbnRlZFwiO1xuICogICAgIH0sIDUwMCk7XG4gKiAgICAgYGBgXG4gKlxuICogNC4gUHJldmVudHMgYHNldFRpbWVvdXRgIGNhbGxzIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCBjb250YWluIGB2YWx1ZWAgYW5kIHRoZSBkZWxheSBpcyBub3Qgc2V0IHRvIGAzMDBgLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0VGltZW91dCcsICchdmFsdWUnLCAnITMwMCcpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgb25seSB0aGUgc2Vjb25kIG9mIHRoZSBmb2xsb3dpbmcgY2FsbHMgd2lsbCBiZSBwcmV2ZW50ZWQ6XG4gKiAgICAgYGBgamF2YXNjcmlwdFxuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidGVzdCAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDMwMCk7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ0ZXN0IC0tIHByZXZlbnRlZFwiO1xuICogICAgIH0sIDQwMCk7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZSAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDQwMCk7XG4gKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy52YWx1ZSA9IFwidGVzdCAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDUwMCk7XG4gKiAgICAgYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRTZXRUaW1lb3V0KHNvdXJjZSwgbWF0Y2gsIGRlbGF5KSB7XG4gIHZhciBuYXRpdmVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG4gIHZhciBsb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgLy8gbG9ncyBzZXRUaW1lb3V0cyB0byBjb25zb2xlIGlmIG5vIGFyZ3VtZW50cyBoYXZlIGJlZW4gc3BlY2lmaWVkXG5cbiAgdmFyIHNob3VsZExvZyA9IHR5cGVvZiBtYXRjaCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRlbGF5ID09PSAndW5kZWZpbmVkJztcblxuICB2YXIgX3BhcnNlTWF0Y2hBcmcgPSBwYXJzZU1hdGNoQXJnKG1hdGNoKSxcbiAgICAgIGlzSW52ZXJ0ZWRNYXRjaCA9IF9wYXJzZU1hdGNoQXJnLmlzSW52ZXJ0ZWRNYXRjaCxcbiAgICAgIG1hdGNoUmVnZXhwID0gX3BhcnNlTWF0Y2hBcmcubWF0Y2hSZWdleHA7XG5cbiAgdmFyIF9wYXJzZURlbGF5QXJnID0gcGFyc2VEZWxheUFyZyhkZWxheSksXG4gICAgICBpc0ludmVydGVkRGVsYXlNYXRjaCA9IF9wYXJzZURlbGF5QXJnLmlzSW52ZXJ0ZWREZWxheU1hdGNoLFxuICAgICAgZGVsYXlNYXRjaCA9IF9wYXJzZURlbGF5QXJnLmRlbGF5TWF0Y2g7XG5cbiAgdmFyIHRpbWVvdXRXcmFwcGVyID0gZnVuY3Rpb24gdGltZW91dFdyYXBwZXIoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlOyAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTA1XG5cbiAgICB2YXIgY2JTdHJpbmcgPSBTdHJpbmcoY2FsbGJhY2spO1xuXG4gICAgaWYgKHNob3VsZExvZykge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICBsb2coXCJzZXRUaW1lb3V0KFwiLmNvbmNhdChjYlN0cmluZywgXCIsIFwiKS5jb25jYXQodGltZW91dCwgXCIpXCIpKTtcbiAgICB9IGVsc2UgaWYgKCFkZWxheU1hdGNoKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gbWF0Y2hSZWdleHAudGVzdChjYlN0cmluZykgIT09IGlzSW52ZXJ0ZWRNYXRjaDtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgc2hvdWxkUHJldmVudCA9IHRpbWVvdXQgPT09IGRlbGF5TWF0Y2ggIT09IGlzSW52ZXJ0ZWREZWxheU1hdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gbWF0Y2hSZWdleHAudGVzdChjYlN0cmluZykgIT09IGlzSW52ZXJ0ZWRNYXRjaCAmJiB0aW1lb3V0ID09PSBkZWxheU1hdGNoICE9PSBpc0ludmVydGVkRGVsYXlNYXRjaDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICByZXR1cm4gbmF0aXZlVGltZW91dChub29wRnVuYywgdGltZW91dCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVRpbWVvdXQuYXBwbHkod2luZG93LCBbY2FsbGJhY2ssIHRpbWVvdXRdLmNvbmNhdChhcmdzKSk7XG4gIH07XG5cbiAgd2luZG93LnNldFRpbWVvdXQgPSB0aW1lb3V0V3JhcHBlcjtcbn1cbnByZXZlbnRTZXRUaW1lb3V0Lm5hbWVzID0gWydwcmV2ZW50LXNldFRpbWVvdXQnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm8tc2V0VGltZW91dC1pZi5qcycsIC8vIG5ldyBpbXBsZW1lbnRhdGlvbiBvZiBzZXRUaW1lb3V0LWRlZnVzZXIuanNcbid1Ym8tbm8tc2V0VGltZW91dC1pZi5qcycsICdub3N0aWYuanMnLCAvLyBuZXcgc2hvcnQgbmFtZSBvZiBuby1zZXRUaW1lb3V0LWlmXG4ndWJvLW5vc3RpZi5qcycsICd1Ym8tbm8tc2V0VGltZW91dC1pZicsICd1Ym8tbm9zdGlmJywgLy8gb2xkIHNjcmlwdGxldCBuYW1lcyB3aGljaCBzaG91bGQgYmUgc3VwcG9ydGVkIGFzIHdlbGwuXG4vLyBzaG91bGQgYmUgcmVtb3ZlZCBldmVudHVhbGx5LlxuLy8gZG8gbm90IHJlbW92ZSB1bnRpbCBvdGhlciBmaWx0ZXIgbGlzdHMgbWFpbnRhaW5lcnMgdXNlIHRoZW1cbidzZXRUaW1lb3V0LWRlZnVzZXIuanMnLCAndWJvLXNldFRpbWVvdXQtZGVmdXNlci5qcycsICd1Ym8tc2V0VGltZW91dC1kZWZ1c2VyJywgJ3N0ZC5qcycsICd1Ym8tc3RkLmpzJywgJ3Viby1zdGQnXTtcbnByZXZlbnRTZXRUaW1lb3V0LmluamVjdGlvbnMgPSBbaGl0LCBub29wRnVuYywgcGFyc2VNYXRjaEFyZywgcGFyc2VEZWxheUFyZywgdG9SZWdFeHAsIHN0YXJ0c1dpdGgsIG5hdGl2ZUlzTmFOXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1zZXRJbnRlcnZhbFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgYSBgc2V0SW50ZXJ2YWxgIGNhbGwgaWY6XG4gKiAxKSB0aGUgdGV4dCBvZiB0aGUgY2FsbGJhY2sgaXMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBgc2VhcmNoYCBzdHJpbmcvcmVnZXhwIHdoaWNoIGRvZXMgbm90IHN0YXJ0IHdpdGggYCFgO1xuICogb3RoZXJ3aXNlIG1pc21hdGNoZWQgY2FsbHMgc2hvdWxkIGJlIGRlZnVzZWQ7XG4gKiAyKSB0aGUgaW50ZXJ2YWwgaXMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBgZGVsYXlgOyBvdGhlcndpc2UgbWlzbWF0Y2hlZCBjYWxscyBzaG91bGQgYmUgZGVmdXNlZC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNuby1zZXRpbnRlcnZhbC1pZmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRJbnRlcnZhbCdbLCBzZWFyY2hbLCBkZWxheV1dKVxuICogYGBgXG4gKlxuICogQ2FsbCB3aXRoIG5vIGFyZ3VtZW50cyB3aWxsIGxvZyBjYWxscyB0byBzZXRJbnRlcnZhbCB3aGlsZSBkZWJ1Z2dpbmcgKGBsb2ctc2V0SW50ZXJ2YWxgIHN1cGVyc2VkaW5nKSxcbiAqIHNvIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzJyBydWxlcyBkZWZpbml0ZWx5IHJlcXVpcmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBwYXJhbWV0ZXJzOlxuICogLSBgc2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uLlxuICogSWYgc3RhcnRzIHdpdGggYCFgLCBzY3JpcHRsZXQgd2lsbCBub3QgbWF0Y2ggdGhlIHN0cmluZ2lmaWVkIGNhbGxiYWNrIGJ1dCBhbGwgb3RoZXIgd2lsbCBiZSBkZWZ1c2VkLlxuICogSWYgZG8gbm90IHN0YXJ0IHdpdGggYCFgLCB0aGUgc3RyaW5naWZpZWQgY2FsbGJhY2sgd2lsbCBiZSBtYXRjaGVkLlxuICogSWYgbm90IHNldCwgcHJldmVudHMgYWxsIGBzZXRJbnRlcnZhbGAgY2FsbHMgZHVlIHRvIHNwZWNpZmllZCBgZGVsYXlgLlxuICogLSBgZGVsYXlgIC0gb3B0aW9uYWwsIG11c3QgYmUgYW4gaW50ZWdlci5cbiAqIElmIHN0YXJ0cyB3aXRoIGAhYCwgc2NyaXB0bGV0IHdpbGwgbm90IG1hdGNoIHRoZSBkZWxheSBidXQgYWxsIG90aGVyIHdpbGwgYmUgZGVmdXNlZC5cbiAqIElmIGRvIG5vdCBzdGFydCB3aXRoIGAhYCwgdGhlIGRlbGF5IHBhc3NlZCB0byB0aGUgYHNldEludGVydmFsYCBjYWxsIHdpbGwgYmUgbWF0Y2hlZC5cbiAqXG4gKiA+IElmIGBwcmV2ZW50LXNldEludGVydmFsYCB3aXRob3V0IHBhcmFtZXRlcnMgbG9ncyBzbXRoIGxpa2UgYHNldEludGVydmFsKHVuZGVmaW5lZCwgMTAwMClgLFxuICogaXQgbWVhbnMgdGhhdCBubyBjYWxsYmFjayB3YXMgcGFzc2VkIHRvIHNldEludGVydmFsKCkgYW5kIHRoYXQncyBub3Qgc2NyaXB0bGV0IGlzc3VlXG5cbiAqICAqKkV4YW1wbGVzKipcbiAqIDEuIFByZXZlbnRzIGBzZXRJbnRlcnZhbGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIG1hdGNoZXMgYC9cXC50ZXN0L2AgcmVnYXJkbGVzcyBvZiB0aGUgZGVsYXkuXG4gKiAgICAgYGBgYmFzaFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0SW50ZXJ2YWwnLCAnL1xcLnRlc3QvJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCB0aGUgZm9sbG93aW5nIGNhbGwgd2lsbCBiZSBwcmV2ZW50ZWQ6XG4gKiAgICAgYGBgamF2YXNjcmlwdFxuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlXCI7XG4gKiAgICAgfSwgMTAwKTtcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBQcmV2ZW50cyBgc2V0SW50ZXJ2YWxgIGNhbGxzIGlmIHRoZSBjYWxsYmFjayBkb2VzIG5vdCBjb250YWluIGB2YWx1ZWAuXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1zZXRJbnRlcnZhbCcsICchdmFsdWUnKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIG9ubHkgdGhlIGZpcnN0IG9mIHRoZSBmb2xsb3dpbmcgY2FsbHMgd2lsbCBiZSBwcmV2ZW50ZWQ6XG4gKiAgICAgYGBgamF2YXNjcmlwdFxuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInRlc3QgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgMzAwKTtcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZSAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDQwMCk7XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudmFsdWUgPSBcInRlc3QgLS0gZXhlY3V0ZWRcIjtcbiAqICAgICB9LCA1MDApO1xuICogICAgIGBgYFxuICpcbiAqIDMuIFByZXZlbnRzIGBzZXRJbnRlcnZhbGAgY2FsbHMgaWYgdGhlIGNhbGxiYWNrIGNvbnRhaW5zIGB2YWx1ZWAgYW5kIHRoZSBkZWxheSBpcyBub3Qgc2V0IHRvIGAzMDBgLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtc2V0SW50ZXJ2YWwnLCAndmFsdWUnLCAnITMwMCcpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgb25seSB0aGUgZmlyc3Qgb2YgdGhlIGZvbGxvd2luZyBjYWxscyB3aWxsIG5vdCBiZSBwcmV2ZW50ZWQ6XG4gKiAgICAgYGBgamF2YXNjcmlwdFxuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIDEgLS0gZXhlY3V0ZWRcIjtcbiAqICAgICB9LCAzMDApO1xuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIDIgLS0gcHJldmVudGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy50ZXN0ID0gXCJ2YWx1ZSAzIC0tIHByZXZlbnRlZFwiO1xuICogICAgIH0sIDUwMCk7XG4gKiAgICAgYGBgXG4gKlxuICogNC4gUHJldmVudHMgYHNldEludGVydmFsYCBjYWxscyBpZiB0aGUgY2FsbGJhY2sgZG9lcyBub3QgY29udGFpbiBgdmFsdWVgIGFuZCB0aGUgZGVsYXkgaXMgbm90IHNldCB0byBgMzAwYC5cbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXNldEludGVydmFsJywgJyF2YWx1ZScsICchMzAwJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCBvbmx5IHRoZSBzZWNvbmQgb2YgdGhlIGZvbGxvd2luZyBjYWxscyB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidGVzdCAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDMwMCk7XG4gKiAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9IFwidGVzdCAtLSBwcmV2ZW50ZWRcIjtcbiAqICAgICB9LCA0MDApO1xuICogICAgIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSBcInZhbHVlIC0tIGV4ZWN1dGVkXCI7XG4gKiAgICAgfSwgNDAwKTtcbiAqICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHdpbmRvdy52YWx1ZSA9IFwidGVzdCAtLSBleGVjdXRlZFwiO1xuICogICAgIH0sIDUwMCk7XG4gKiAgICAgYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRTZXRJbnRlcnZhbChzb3VyY2UsIG1hdGNoLCBkZWxheSkge1xuICB2YXIgbmF0aXZlSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWw7XG4gIHZhciBsb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgLy8gbG9ncyBzZXRJbnRlcnZhbHMgdG8gY29uc29sZSBpZiBubyBhcmd1bWVudHMgaGF2ZSBiZWVuIHNwZWNpZmllZFxuXG4gIHZhciBzaG91bGRMb2cgPSB0eXBlb2YgbWF0Y2ggPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkZWxheSA9PT0gJ3VuZGVmaW5lZCc7XG5cbiAgdmFyIF9wYXJzZU1hdGNoQXJnID0gcGFyc2VNYXRjaEFyZyhtYXRjaCksXG4gICAgICBpc0ludmVydGVkTWF0Y2ggPSBfcGFyc2VNYXRjaEFyZy5pc0ludmVydGVkTWF0Y2gsXG4gICAgICBtYXRjaFJlZ2V4cCA9IF9wYXJzZU1hdGNoQXJnLm1hdGNoUmVnZXhwO1xuXG4gIHZhciBfcGFyc2VEZWxheUFyZyA9IHBhcnNlRGVsYXlBcmcoZGVsYXkpLFxuICAgICAgaXNJbnZlcnRlZERlbGF5TWF0Y2ggPSBfcGFyc2VEZWxheUFyZy5pc0ludmVydGVkRGVsYXlNYXRjaCxcbiAgICAgIGRlbGF5TWF0Y2ggPSBfcGFyc2VEZWxheUFyZy5kZWxheU1hdGNoO1xuXG4gIHZhciBpbnRlcnZhbFdyYXBwZXIgPSBmdW5jdGlvbiBpbnRlcnZhbFdyYXBwZXIoY2FsbGJhY2ssIGludGVydmFsKSB7XG4gICAgdmFyIHNob3VsZFByZXZlbnQgPSBmYWxzZTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzEwNVxuXG4gICAgdmFyIGNiU3RyaW5nID0gU3RyaW5nKGNhbGxiYWNrKTtcblxuICAgIGlmIChzaG91bGRMb2cpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgbG9nKFwic2V0SW50ZXJ2YWwoXCIuY29uY2F0KGNiU3RyaW5nLCBcIiwgXCIpLmNvbmNhdChpbnRlcnZhbCwgXCIpXCIpKTtcbiAgICB9IGVsc2UgaWYgKCFkZWxheU1hdGNoKSB7XG4gICAgICBzaG91bGRQcmV2ZW50ID0gbWF0Y2hSZWdleHAudGVzdChjYlN0cmluZykgIT09IGlzSW52ZXJ0ZWRNYXRjaDtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgc2hvdWxkUHJldmVudCA9IGludGVydmFsID09PSBkZWxheU1hdGNoICE9PSBpc0ludmVydGVkRGVsYXlNYXRjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkUHJldmVudCA9IG1hdGNoUmVnZXhwLnRlc3QoY2JTdHJpbmcpICE9PSBpc0ludmVydGVkTWF0Y2ggJiYgaW50ZXJ2YWwgPT09IGRlbGF5TWF0Y2ggIT09IGlzSW52ZXJ0ZWREZWxheU1hdGNoO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHJldHVybiBuYXRpdmVJbnRlcnZhbChub29wRnVuYywgaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVJbnRlcnZhbC5hcHBseSh3aW5kb3csIFtjYWxsYmFjaywgaW50ZXJ2YWxdLmNvbmNhdChhcmdzKSk7XG4gIH07XG5cbiAgd2luZG93LnNldEludGVydmFsID0gaW50ZXJ2YWxXcmFwcGVyO1xufVxucHJldmVudFNldEludGVydmFsLm5hbWVzID0gWydwcmV2ZW50LXNldEludGVydmFsJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25vLXNldEludGVydmFsLWlmLmpzJywgLy8gbmV3IGltcGxlbWVudGF0aW9uIG9mIHNldEludGVydmFsLWRlZnVzZXIuanNcbid1Ym8tbm8tc2V0SW50ZXJ2YWwtaWYuanMnLCAnc2V0SW50ZXJ2YWwtZGVmdXNlci5qcycsIC8vIG9sZCBuYW1lIHNob3VsZCBiZSBzdXBwb3J0ZWQgYXMgd2VsbFxuJ3Viby1zZXRJbnRlcnZhbC1kZWZ1c2VyLmpzJywgJ25vc2lpZi5qcycsIC8vIG5ldyBzaG9ydCBuYW1lIG9mIG5vLXNldEludGVydmFsLWlmXG4ndWJvLW5vc2lpZi5qcycsICdzaWQuanMnLCAvLyBvbGQgc2hvcnQgc2NyaXB0bGV0IG5hbWVcbid1Ym8tc2lkLmpzJywgJ3Viby1uby1zZXRJbnRlcnZhbC1pZicsICd1Ym8tc2V0SW50ZXJ2YWwtZGVmdXNlcicsICd1Ym8tbm9zaWlmJywgJ3Viby1zaWQnXTtcbnByZXZlbnRTZXRJbnRlcnZhbC5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmMsIHBhcnNlTWF0Y2hBcmcsIHBhcnNlRGVsYXlBcmcsIHRvUmVnRXhwLCBzdGFydHNXaXRoLCBuYXRpdmVJc05hTl07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IHByZXZlbnQtd2luZG93LW9wZW5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGB3aW5kb3cub3BlbmAgY2FsbHMgd2hlbiBVUkwgZWl0aGVyIG1hdGNoZXMgb3Igbm90IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBzdHJpbmcvcmVnZXhwLiBVc2luZyBpdCB3aXRob3V0IHBhcmFtZXRlcnMgcHJldmVudHMgYWxsIGB3aW5kb3cub3BlbmAgY2FsbHMuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjd2luZG93b3Blbi1kZWZ1c2VyanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXdpbmRvdy1vcGVuJ1ssIG1hdGNoWywgZGVsYXlbLCByZXBsYWNlbWVudF1dXSlcbiAqIGBgYFxuICpcbiAqIC0gYG1hdGNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uLiBJZiBub3Qgc2V0LCBhbGwgd2luZG93Lm9wZW4gY2FsbHMgd2lsbCBiZSBtYXRjaGVkLlxuICogSWYgc3RhcnRzIHdpdGggYCFgLCBzY3JpcHRsZXQgd2lsbCBub3QgbWF0Y2ggdGhlIHN0cmluZ2lmaWVkIGNhbGxiYWNrIGJ1dCBhbGwgb3RoZXIgd2lsbCBiZSBkZWZ1c2VkLlxuICogSWYgZG8gbm90IHN0YXJ0IHdpdGggYCFgLCB0aGUgc3RyaW5naWZpZWQgY2FsbGJhY2sgd2lsbCBiZSBtYXRjaGVkLlxuICogLSBgZGVsYXlgIC0gb3B0aW9uYWwsIG51bWJlciBvZiBzZWNvbmRzLiBJZiBub3Qgc2V0LCBzY3JpcHRsZXQgd2lsbCByZXR1cm4gYG51bGxgLFxuICogb3RoZXJ3aXNlIHZhbGlkIHNoYW0gd2luZG93IG9iamVjdCBhcyBpbmplY3RlZCBgaWZyYW1lYCB3aWxsIGJlIHJldHVybmVkXG4gKiBmb3IgYWNjZXNzaW5nIGl0J3MgbWV0aG9kcyAoYmx1cigpLCBmb2N1cygpIGV0Yy4pIGFuZCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgdGhlIGRlbGF5LlxuICogLSBgcmVwbGFjZW1lbnRgIC0gb3B0aW9uYWwsIHN0cmluZzsgb25lIG9mIHRoZSBwcmVkZWZpbmVkIGNvbnN0YW50czpcbiAqICAgICAtIGBvYmpgIC0gZm9yIHJldHVybmluZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkZWZhdWx0IGlmcmFtZTtcbiAqICAgICAgICBmb3IgY2FzZXMgd2hlbiB0aGUgcGFnZSByZXF1aXJlcyBhIHZhbGlkIGB3aW5kb3dgIGluc3RhbmNlIHRvIGJlIHJldHVybmVkXG4gKiAgICAgLSBgbG9nYCAtIGZvciBsb2dnaW5nIHdpbmRvdy5vcGVuIGNhbGxzOyBwZXJtaXR0ZWQgZm9yIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzLlxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gUHJldmVudCBhbGwgYHdpbmRvdy5vcGVuYCBjYWxsczpcbiAqIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtd2luZG93LW9wZW4nKVxuICogYGBgXG4gKlxuICogMi4gUHJldmVudCBgd2luZG93Lm9wZW5gIGZvciBhbGwgVVJMcyBjb250YWluaW5nIGBleGFtcGxlYDpcbiAqIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtd2luZG93LW9wZW4nLCAnZXhhbXBsZScpXG4gKiBgYGBcbiAqXG4gKiAzLiBQcmV2ZW50IGB3aW5kb3cub3BlbmAgZm9yIGFsbCBVUkxzIG1hdGNoaW5nIFJlZ0V4cCBgL2V4YW1wbGVcXC4vYDpcbiAqIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtd2luZG93LW9wZW4nLCAnL2V4YW1wbGVcXC4vJylcbiAqIGBgYFxuICpcbiAqIDQuIFByZXZlbnQgYHdpbmRvdy5vcGVuYCBmb3IgYWxsIFVSTHMgKipOT1QqKiBjb250YWluaW5nIGBleGFtcGxlYDpcbiAqIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtd2luZG93LW9wZW4nLCAnIWV4YW1wbGUnKVxuICogYGBgXG4gKlxuICogT2xkIHN5bnRheCBvZiBwcmV2ZW50LXdpbmRvdy1vcGVuIHBhcmFtZXRlcnM6XG4gKiAtIGBtYXRjaGAgLSBvcHRpb25hbCwgZGVmYXVsdHMgdG8gXCJtYXRjaGluZ1wiLCBhbnkgcG9zaXRpdmUgbnVtYmVyIG9yIG5vdGhpbmcgZm9yIFwibWF0Y2hpbmdcIiwgMCBvciBlbXB0eSBzdHJpbmcgZm9yIFwibm90IG1hdGNoaW5nXCJcbiAqIC0gYHNlYXJjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ2V4cCBmb3IgbWF0Y2hpbmcgdGhlIFVSTCBwYXNzZWQgdG8gYHdpbmRvdy5vcGVuYCBjYWxsOyBkZWZhdWx0cyB0byBzZWFyY2ggYWxsIGB3aW5kb3cub3BlbmAgY2FsbFxuICogLSBgcmVwbGFjZW1lbnRgIC0gb3B0aW9uYWwsIHN0cmluZyB0byByZXR1cm4gcHJvcCB2YWx1ZSBvciBwcm9wZXJ0eSBpbnN0ZWFkIG9mIHdpbmRvdy5vcGVuOyBkZWZhdWx0cyB0byByZXR1cm4gbm9vcEZ1bmMuXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtd2luZG93LW9wZW4nLCAnMScsICcvZXhhbXBsZVxcLi8nXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICcwJywgJ2V4YW1wbGUnKVxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtd2luZG93LW9wZW4nLCAnJywgJycsICd0cnVlRnVuYycpXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC13aW5kb3ctb3BlbicsICcxJywgJycsICd7cHJvcE5hbWU9bm9vcEZ1bmN9JylcbiAqIGBgYFxuICpcbiAqID4gRm9yIGJldHRlciBjb21wYXRpYmlsaXR5IHdpdGggdUJPLCBvbGQgc3ludGF4IGlzIG5vdCByZWNvbW1lbmRlZCB0byB1c2UuXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRXaW5kb3dPcGVuKHNvdXJjZSkge1xuICB2YXIgbWF0Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGdldFdpbGRjYXJkU3ltYm9sKCk7XG4gIHZhciBkZWxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgcmVwbGFjZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgLy8gZGVmYXVsdCBtYXRjaCB2YWx1ZSBpcyBuZWVkZWQgZm9yIHByZXZlbnRpbmcgYWxsIHdpbmRvdy5vcGVuIGNhbGxzXG4gIC8vIGlmIHNjcmlwdGxldCBydW5zIHdpdGhvdXQgYXJnc1xuICB2YXIgbmF0aXZlT3BlbiA9IHdpbmRvdy5vcGVuO1xuICB2YXIgaXNOZXdTeW50YXggPSBtYXRjaCAhPT0gJzAnICYmIG1hdGNoICE9PSAnMSc7XG5cbiAgdmFyIG9sZE9wZW5XcmFwcGVyID0gZnVuY3Rpb24gb2xkT3BlbldyYXBwZXIoc3RyKSB7XG4gICAgbWF0Y2ggPSBOdW1iZXIobWF0Y2gpID4gMDsgLy8gJ2RlbGF5JyB3YXMgJ3NlYXJjaCcgcHJvcCBmb3IgbWF0Y2hpbmcgaW4gb2xkIHN5bnRheFxuXG4gICAgdmFyIHNlYXJjaFJlZ2V4cCA9IHRvUmVnRXhwKGRlbGF5KTtcblxuICAgIGlmIChtYXRjaCAhPT0gc2VhcmNoUmVnZXhwLnRlc3Qoc3RyKSkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZU9wZW4uYXBwbHkod2luZG93LCBbc3RyXS5jb25jYXQoYXJncykpO1xuICAgIH1cblxuICAgIGhpdChzb3VyY2UpO1xuICAgIHJldHVybiBoYW5kbGVPbGRSZXBsYWNlbWVudChyZXBsYWNlbWVudCk7XG4gIH07XG5cbiAgdmFyIG5ld09wZW5XcmFwcGVyID0gZnVuY3Rpb24gbmV3T3BlbldyYXBwZXIodXJsKSB7XG4gICAgdmFyIHNob3VsZExvZyA9IHJlcGxhY2VtZW50ICYmIHJlcGxhY2VtZW50LmluZGV4T2YoJ2xvZycpID4gLTE7XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkTG9nKSB7XG4gICAgICB2YXIgYXJnc1N0ciA9IGFyZ3MgJiYgYXJncy5sZW5ndGggPiAwID8gXCIsIFwiLmNvbmNhdChhcmdzLmpvaW4oJywgJykpIDogJyc7XG4gICAgICB2YXIgbG9nTWVzc2FnZSA9IFwibG9nOiB3aW5kb3ctb3BlbjogXCIuY29uY2F0KHVybCkuY29uY2F0KGFyZ3NTdHIpO1xuICAgICAgaGl0KHNvdXJjZSwgbG9nTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcblxuICAgIGlmIChtYXRjaCA9PT0gZ2V0V2lsZGNhcmRTeW1ib2woKSkge1xuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcGFyc2VNYXRjaEFyZyA9IHBhcnNlTWF0Y2hBcmcobWF0Y2gpLFxuICAgICAgICAgIGlzSW52ZXJ0ZWRNYXRjaCA9IF9wYXJzZU1hdGNoQXJnLmlzSW52ZXJ0ZWRNYXRjaCxcbiAgICAgICAgICBtYXRjaFJlZ2V4cCA9IF9wYXJzZU1hdGNoQXJnLm1hdGNoUmVnZXhwO1xuXG4gICAgICBzaG91bGRQcmV2ZW50ID0gbWF0Y2hSZWdleHAudGVzdCh1cmwpICE9PSBpc0ludmVydGVkTWF0Y2g7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIHZhciBwYXJzZWREZWxheSA9IHBhcnNlSW50KGRlbGF5LCAxMCk7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAobmF0aXZlSXNOYU4ocGFyc2VkRGVsYXkpKSB7XG4gICAgICAgIHJlc3VsdCA9IG5vb3BOdWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVjb3lBcmdzID0ge1xuICAgICAgICAgIHJlcGxhY2VtZW50OiByZXBsYWNlbWVudCxcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBkZWxheTogcGFyc2VkRGVsYXlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlY295ID0gY3JlYXRlRGVjb3koZGVjb3lBcmdzKTtcbiAgICAgICAgdmFyIHBvcHVwID0gZGVjb3kuY29udGVudFdpbmRvdztcblxuICAgICAgICBpZiAodHlwZW9mIHBvcHVwID09PSAnb2JqZWN0JyAmJiBwb3B1cCAhPT0gbnVsbCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwb3B1cCwgJ2Nsb3NlZCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuYXRpdmVHZXR0ZXIgPSBkZWNveS5jb250ZW50V2luZG93ICYmIGRlY295LmNvbnRlbnRXaW5kb3cuZ2V0O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNveSwgJ2NvbnRlbnRXaW5kb3cnLCB7XG4gICAgICAgICAgICBnZXQ6IGdldFByZXZlbnRHZXR0ZXIobmF0aXZlR2V0dGVyKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBvcHVwID0gZGVjb3kuY29udGVudFdpbmRvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHBvcHVwO1xuICAgICAgfVxuXG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZU9wZW4uYXBwbHkod2luZG93LCBbdXJsXS5jb25jYXQoYXJncykpO1xuICB9O1xuXG4gIHdpbmRvdy5vcGVuID0gaXNOZXdTeW50YXggPyBuZXdPcGVuV3JhcHBlciA6IG9sZE9wZW5XcmFwcGVyO1xufVxucHJldmVudFdpbmRvd09wZW4ubmFtZXMgPSBbJ3ByZXZlbnQtd2luZG93LW9wZW4nLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nd2luZG93Lm9wZW4tZGVmdXNlci5qcycsICd1Ym8td2luZG93Lm9wZW4tZGVmdXNlci5qcycsICd1Ym8td2luZG93Lm9wZW4tZGVmdXNlcicsICdub3dvaWYuanMnLCAndWJvLW5vd29pZi5qcycsICd1Ym8tbm93b2lmJ107XG5wcmV2ZW50V2luZG93T3Blbi5pbmplY3Rpb25zID0gW2hpdCwgdG9SZWdFeHAsIG5hdGl2ZUlzTmFOLCBwYXJzZU1hdGNoQXJnLCBoYW5kbGVPbGRSZXBsYWNlbWVudCwgY3JlYXRlRGVjb3ksIGdldFByZXZlbnRHZXR0ZXIsIG5vb3BOdWxsLCBnZXRXaWxkY2FyZFN5bWJvbCwgbm9vcEZ1bmMsIHRydWVGdW5jLCBzdGFydHNXaXRoLCBlbmRzV2l0aCwgc3Vic3RyaW5nQmVmb3JlLCBzdWJzdHJpbmdBZnRlcl07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGFib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWJvcnRzIGFuIGlubGluZSBzY3JpcHQgd2hlbiBpdCBhdHRlbXB0cyB0byAqKnJlYWQqKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gKiBBTkQgd2hlbiB0aGUgY29udGVudHMgb2YgdGhlIGA8c2NyaXB0PmAgZWxlbWVudCBjb250YWlucyB0aGUgc3BlY2lmaWVkXG4gKiB0ZXh0IG9yIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHRqcy1cbiAqXG4gKiBSZWxhdGVkIEFCUCBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWRibG9ja3BsdXMvYWRibG9ja3BsdXNjb3JlL2Jsb2IvNmIyYTMwOTA1NGNjMjM0MzIxMDJiODVkMTNmMTI1NTk2MzllZjQ5NS9saWIvY29udGVudC9zbmlwcGV0cy5qcyNMOTI4XG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQnLCBwcm9wZXJ0eVssIHNlYXJjaF0pXG4gKiBgYGBcbiAqXG4gKiAtIGBwcm9wZXJ0eWAgLSByZXF1aXJlZCwgcGF0aCB0byBhIHByb3BlcnR5IChqb2luZWQgd2l0aCBgLmAgaWYgbmVlZGVkKS4gVGhlIHByb3BlcnR5IG11c3QgYmUgYXR0YWNoZWQgdG8gYHdpbmRvd2BcbiAqIC0gYHNlYXJjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG11c3QgbWF0Y2ggdGhlIGlubGluZSBzY3JpcHQgY29udGVudHMuIElmIG5vdCBzZXQsIGFib3J0IGFsbCBpbmxpbmUgc2NyaXB0cyB3aGljaCBhcmUgdHJ5aW5nIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gKlxuICogPiBOb3RlIHBsZWFzZSB0aGF0IGZvciBpbmxpbmUgc2NyaXB0IHdpdGggYWRkRXZlbnRMaXN0ZW5lciBpbiBpdFxuICogYHByb3BlcnR5YCBzaG91bGQgYmUgc2V0IGFzIGBFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcmAsXG4gKiBub3QganVzdCBgYWRkRXZlbnRMaXN0ZW5lcmAuXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBBYm9ydHMgYWxsIGlubGluZSBzY3JpcHRzIHRyeWluZyB0byBhY2Nlc3MgYHdpbmRvdy5hbGVydGBcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQnLCAnYWxlcnQnKVxuICogICAgIGBgYFxuICpcbiAqIDIuIEFib3J0cyBpbmxpbmUgc2NyaXB0cyB3aGljaCBhcmUgdHJ5aW5nIHRvIGFjY2VzcyBgd2luZG93LmFsZXJ0YCBhbmQgY29udGFpbiBgSGVsbG8sIHdvcmxkYC5cbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQnLCAnYWxlcnQnLCAnSGVsbG8sIHdvcmxkJylcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCB0aGUgZm9sbG93aW5nIHNjcmlwdCB3aWxsIGJlIGFib3J0ZWRcbiAqICAgICBgYGBodG1sXG4gKiAgICAgPHNjcmlwdD5hbGVydChcIkhlbGxvLCB3b3JsZFwiKTs8L3NjcmlwdD5cbiAqICAgICBgYGBcbiAqXG4gKiAzLiBBYm9ydHMgaW5saW5lIHNjcmlwdHMgd2hpY2ggYXJlIHRyeWluZyB0byBhY2Nlc3MgYHdpbmRvdy5hbGVydGAgYW5kIG1hdGNoIHRoaXMgcmVnZXhwOiBgL0hlbGxvLit3b3JsZC9gLlxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCcsICdhbGVydCcsICcvSGVsbG8uK3dvcmxkLycpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIEZvciBpbnN0YW5jZSwgdGhlIGZvbGxvd2luZyBzY3JpcHRzIHdpbGwgYmUgYWJvcnRlZDpcbiAqICAgICBgYGBodG1sXG4gKiAgICAgPHNjcmlwdD5hbGVydChcIkhlbGxvLCBiaWcgd29ybGRcIik7PC9zY3JpcHQ+XG4gKiAgICAgYGBgXG4gKiAgICAgYGBgaHRtbFxuICogICAgIDxzY3JpcHQ+YWxlcnQoXCJIZWxsbywgbGl0dGxlIHdvcmxkXCIpOzwvc2NyaXB0PlxuICogICAgIGBgYFxuICpcbiAqICAgICBUaGlzIHNjcmlwdCB3aWxsIG5vdCBiZSBhYm9ydGVkOlxuICogICAgIGBgYGh0bWxcbiAqICAgICA8c2NyaXB0PmFsZXJ0KFwiSGksIGxpdHRsZSB3b3JsZFwiKTs8L3NjcmlwdD5cbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gYWJvcnRDdXJyZW50SW5saW5lU2NyaXB0KHNvdXJjZSwgcHJvcGVydHksIHNlYXJjaCkge1xuICB2YXIgc2VhcmNoUmVnZXhwID0gdG9SZWdFeHAoc2VhcmNoKTtcbiAgdmFyIHJpZCA9IHJhbmRvbUlkKCk7XG5cbiAgdmFyIGdldEN1cnJlbnRTY3JpcHQgPSBmdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0KCkge1xuICAgIGlmICgnY3VycmVudFNjcmlwdCcgaW4gZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcbiAgICB9XG5cbiAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICByZXR1cm4gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIHZhciBvdXJTY3JpcHQgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgdmFyIHNjcmlwdEVsID0gZ2V0Q3VycmVudFNjcmlwdCgpO1xuXG4gICAgaWYgKCFzY3JpcHRFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gc2NyaXB0RWwudGV4dENvbnRlbnQ7IC8vIFdlIGFyZSB1c2luZyBOb2RlLnByb3RvdHlwZS50ZXh0Q29udGVudCBwcm9wZXJ0eSBkZXNjcmlwdG9yXG4gICAgLy8gdG8gZ2V0IHRoZSByZWFsIHNjcmlwdCBjb250ZW50XG4gICAgLy8gZXZlbiB3aGVuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQudGV4dENvbnRlbnQgaXMgcmVwbGFjZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzU3I2lzc3VlY29tbWVudC01OTM2Mzg5OTFcblxuICAgIHRyeSB7XG4gICAgICB2YXIgdGV4dENvbnRlbnRHZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKS5nZXQ7XG4gICAgICBjb250ZW50ID0gdGV4dENvbnRlbnRHZXR0ZXIuY2FsbChzY3JpcHRFbCk7XG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXG5cbiAgICBpZiAoc2NyaXB0RWwgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCAmJiBjb250ZW50Lmxlbmd0aCA+IDAgJiYgc2NyaXB0RWwgIT09IG91clNjcmlwdCAmJiBzZWFyY2hSZWdleHAudGVzdChjb250ZW50KSkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IocmlkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjsgLy8gVGhlIHNjcmlwdGxldCBtaWdodCBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIGNoYWluIHByb3BlcnR5IGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAvLyAoZm9yIGluc3RhbmNlLCBkb2N1bWVudC5ib2R5IGJlZm9yZSB0aGUgSFRNTCBib2R5IHdhcyBsb2FkZWQpLlxuICAgIC8vIEluIHRoaXMgY2FzZSB3ZSdyZSBjaGVja2luZyB3aGV0aGVyIHRoZSBiYXNlIGVsZW1lbnQgZXhpc3RzIG9yIG5vdFxuICAgIC8vIGFuZCBpZiBub3QsIHdlIHNpbXBseSBleGl0IHdpdGhvdXQgb3ZlcnJpZGluZyBhbnl0aGluZy5cbiAgICAvLyBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy81NyNpc3N1ZWNvbW1lbnQtNTc1ODQxMDkyXG5cbiAgICBpZiAoYmFzZSBpbnN0YW5jZW9mIE9iamVjdCA9PT0gZmFsc2UgJiYgYmFzZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIHByb3BzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBwcm9wSW5kZXggPSBwcm9wcy5pbmRleE9mKHByb3ApO1xuICAgICAgdmFyIGJhc2VOYW1lID0gcHJvcHNbcHJvcEluZGV4IC0gMV07XG4gICAgICBjb25zb2xlLmxvZyhcIlRoZSBzY3JpcHRsZXQgaGFkIGJlZW4gZXhlY3V0ZWQgYmVmb3JlIHRoZSBcIi5jb25jYXQoYmFzZU5hbWUsIFwiIHdhcyBsb2FkZWQuXCIpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2hhaW4pIHtcbiAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIoYSkge1xuICAgICAgICBiYXNlID0gYTtcblxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHNldENoYWluUHJvcEFjY2VzcyhhLCBjaGFpbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgcHJvcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VmFsdWUgPSBiYXNlW3Byb3BdO1xuICAgIHNldFByb3BlcnR5QWNjZXNzKGJhc2UsIHByb3AsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHNldENoYWluUHJvcEFjY2Vzcyh3aW5kb3csIHByb3BlcnR5KTtcbiAgd2luZG93Lm9uZXJyb3IgPSBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpLmJpbmQoKTtcbn1cbmFib3J0Q3VycmVudElubGluZVNjcmlwdC5uYW1lcyA9IFsnYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0JywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2Fib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdC5qcycsICd1Ym8tYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0LmpzJywgJ2FjaXMuanMnLCAndWJvLWFjaXMuanMnLCAndWJvLWFib3J0LWN1cnJlbnQtaW5saW5lLXNjcmlwdCcsICd1Ym8tYWNpcycsICdhYnAtYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0J107XG5hYm9ydEN1cnJlbnRJbmxpbmVTY3JpcHQuaW5qZWN0aW9ucyA9IFtyYW5kb21JZCwgc2V0UHJvcGVydHlBY2Nlc3MsIGdldFByb3BlcnR5SW5DaGFpbiwgdG9SZWdFeHAsIGNyZWF0ZU9uRXJyb3JIYW5kbGVyLCBoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBzZXQtY29uc3RhbnRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSBjb25zdGFudCBwcm9wZXJ0eSBhbmQgYXNzaWducyBpdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBwcmVkZWZpbmVkIGxpc3QuXG4gKlxuICogPiBBY3R1YWxseSwgaXQncyBub3QgYSBjb25zdGFudC4gUGxlYXNlIG5vdGUsIHRoYXQgaXQgY2FuIGJlIHJld3JpdHRlbiB3aXRoIGEgdmFsdWUgb2YgYSBkaWZmZXJlbnQgdHlwZS5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNzZXQtY29uc3RhbnRqcy1cbiAqXG4gKiBSZWxhdGVkIEFCUCBzbmlwcGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FkYmxvY2twbHVzL2FkYmxvY2twbHVzY29yZS9ibG9iL2FkYmxvY2twbHVzY2hyb21lLTMuOS40L2xpYi9jb250ZW50L3NuaXBwZXRzLmpzI0wxMzYxXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtY29uc3RhbnQnLCBwcm9wZXJ0eSwgdmFsdWVbLCBzdGFja10pXG4gKiBgYGBcbiAqXG4gKiAtIGBwcm9wZXJ0eWAgLSByZXF1aXJlZCwgcGF0aCB0byBhIHByb3BlcnR5IChqb2luZWQgd2l0aCBgLmAgaWYgbmVlZGVkKS4gVGhlIHByb3BlcnR5IG11c3QgYmUgYXR0YWNoZWQgdG8gYHdpbmRvd2AuXG4gKiAtIGB2YWx1ZWAgLSByZXF1aXJlZC4gUG9zc2libGUgdmFsdWVzOlxuICogICAgIC0gcG9zaXRpdmUgZGVjaW1hbCBpbnRlZ2VyIGA8PSAzMjc2N2BcbiAqICAgICAtIG9uZSBvZiB0aGUgcHJlZGVmaW5lZCBjb25zdGFudHM6XG4gKiAgICAgICAgIC0gYHVuZGVmaW5lZGBcbiAqICAgICAgICAgLSBgZmFsc2VgXG4gKiAgICAgICAgIC0gYHRydWVgXG4gKiAgICAgICAgIC0gYG51bGxgXG4gKiAgICAgICAgIC0gYGVtcHR5T2JqYCAtIGVtcHR5IG9iamVjdFxuICogICAgICAgICAtIGBlbXB0eUFycmAgLSBlbXB0eSBhcnJheVxuICogICAgICAgICAtIGBub29wRnVuY2AgLSBmdW5jdGlvbiB3aXRoIGVtcHR5IGJvZHlcbiAqICAgICAgICAgLSBgdHJ1ZUZ1bmNgIC0gZnVuY3Rpb24gcmV0dXJuaW5nIHRydWVcbiAqICAgICAgICAgLSBgZmFsc2VGdW5jYCAtIGZ1bmN0aW9uIHJldHVybmluZyBmYWxzZVxuICogICAgICAgICAtIGAnJ2AgLSBlbXB0eSBzdHJpbmdcbiAqICAgICAgICAgLSBgLTFgIC0gbnVtYmVyIHZhbHVlIGAtMWBcbiAqIC0gYHN0YWNrYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIHRoYXQgbXVzdCBtYXRjaCB0aGUgY3VycmVudCBmdW5jdGlvbiBjYWxsIHN0YWNrIHRyYWNlXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiBgYGBcbiAqICEgd2luZG93LmZpcnN0Q29uc3QgPT09IGZhbHNlIC8vIHRoaXMgY29tcGFyaXNpb24gd2lsbCByZXR1cm4gZmFsc2VcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb25zdGFudCcsICdmaXJzdENvbnN0JywgJ2ZhbHNlJylcbiAqXG4gKiAhIHdpbmRvdy5zZWNvbmQoKSA9PT0gdHJ1ZUZ1bmMgLy8gJ3NlY29uZCcgY2FsbCB3aWxsIHJldHVybiB0cnVlXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtY29uc3RhbnQnLCAnc2Vjb25kQ29uc3QnLCAndHJ1ZUZ1bmMnKVxuICpcbiAqICEgZG9jdW1lbnQudGhpcmQoKSA9PT0gZmFsc2VGdW5jICAvLyAndGhpcmQnIGNhbGwgd2lsbCByZXR1cm4gZmFsc2UgaWYgdGhlIG1ldGhvZCBpcyByZWxhdGVkIHRvIGNoZWNraW5nLmpzXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtY29uc3RhbnQnLCAnc2Vjb25kQ29uc3QnLCAndHJ1ZUZ1bmMnLCAnY2hlY2tpbmcuanMnKVxuICogYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIHNldENvbnN0YW50KHNvdXJjZSwgcHJvcGVydHksIHZhbHVlLCBzdGFjaykge1xuICBpZiAoIXByb3BlcnR5IHx8ICFtYXRjaFN0YWNrVHJhY2Uoc3RhY2ssIG5ldyBFcnJvcigpLnN0YWNrKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbXB0eUFyciA9IG5vb3BBcnJheSgpO1xuICB2YXIgZW1wdHlPYmogPSBub29wT2JqZWN0KCk7XG4gIHZhciBjb25zdGFudFZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdGFudFZhbHVlID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgY29uc3RhbnRWYWx1ZSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICBjb25zdGFudFZhbHVlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgY29uc3RhbnRWYWx1ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdlbXB0eUFycicpIHtcbiAgICBjb25zdGFudFZhbHVlID0gZW1wdHlBcnI7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdlbXB0eU9iaicpIHtcbiAgICBjb25zdGFudFZhbHVlID0gZW1wdHlPYmo7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdub29wRnVuYycpIHtcbiAgICBjb25zdGFudFZhbHVlID0gbm9vcEZ1bmM7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICd0cnVlRnVuYycpIHtcbiAgICBjb25zdGFudFZhbHVlID0gdHJ1ZUZ1bmM7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09ICdmYWxzZUZ1bmMnKSB7XG4gICAgY29uc3RhbnRWYWx1ZSA9IGZhbHNlRnVuYztcbiAgfSBlbHNlIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgIGNvbnN0YW50VmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgIGlmIChuYXRpdmVJc05hTihjb25zdGFudFZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyhjb25zdGFudFZhbHVlKSA+IDB4N0ZGRikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy0xJykge1xuICAgIGNvbnN0YW50VmFsdWUgPSAtMTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICBjb25zdGFudFZhbHVlID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG5cbiAgdmFyIG11c3RDYW5jZWwgPSBmdW5jdGlvbiBtdXN0Q2FuY2VsKHZhbHVlKSB7XG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm4gY2FuY2VsZWQ7XG4gICAgfVxuXG4gICAgY2FuY2VsZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50VmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09IHR5cGVvZiBjb25zdGFudFZhbHVlO1xuICAgIHJldHVybiBjYW5jZWxlZDtcbiAgfTtcblxuICB2YXIgc2V0Q2hhaW5Qcm9wQWNjZXNzID0gZnVuY3Rpb24gc2V0Q2hhaW5Qcm9wQWNjZXNzKG93bmVyLCBwcm9wZXJ0eSkge1xuICAgIHZhciBjaGFpbkluZm8gPSBnZXRQcm9wZXJ0eUluQ2hhaW4ob3duZXIsIHByb3BlcnR5KTtcbiAgICB2YXIgYmFzZSA9IGNoYWluSW5mby5iYXNlO1xuICAgIHZhciBwcm9wID0gY2hhaW5JbmZvLnByb3AsXG4gICAgICAgIGNoYWluID0gY2hhaW5JbmZvLmNoYWluOyAvLyBUaGUgc2NyaXB0bGV0IG1pZ2h0IGJlIGV4ZWN1dGVkIGJlZm9yZSB0aGUgY2hhaW4gcHJvcGVydHkgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAvLyBJbiB0aGlzIGNhc2Ugd2UncmUgY2hlY2tpbmcgd2hldGhlciB0aGUgYmFzZSBlbGVtZW50IGV4aXN0cyBvciBub3RcbiAgICAvLyBhbmQgaWYgbm90LCB3ZSBzaW1wbHkgZXhpdCB3aXRob3V0IG92ZXJyaWRpbmcgYW55dGhpbmdcblxuICAgIGlmIChiYXNlIGluc3RhbmNlb2YgT2JqZWN0ID09PSBmYWxzZSAmJiBiYXNlID09PSBudWxsKSB7XG4gICAgICAvLyBsb2cgdGhlIHJlYXNvbiBvbmx5IHdoaWxlIGRlYnVnZ2luZ1xuICAgICAgaWYgKHNvdXJjZS52ZXJib3NlKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBwcm9wSW5kZXggPSBwcm9wcy5pbmRleE9mKHByb3ApO1xuICAgICAgICB2YXIgYmFzZU5hbWUgPSBwcm9wc1twcm9wSW5kZXggLSAxXTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZXQtY29uc3RhbnQgZmFpbGVkIGJlY2F1c2UgdGhlIHByb3BlcnR5ICdcIi5jb25jYXQoYmFzZU5hbWUsIFwiJyBkb2VzIG5vdCBleGlzdFwiKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoYWluKSB7XG4gICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gc2V0dGVyKGEpIHtcbiAgICAgICAgYmFzZSA9IGE7XG5cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBzZXRDaGFpblByb3BBY2Nlc3MoYSwgY2hhaW4pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3duZXIsIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogc2V0dGVyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobXVzdENhbmNlbChiYXNlW3Byb3BdKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhpdChzb3VyY2UpO1xuICAgIHNldFByb3BlcnR5QWNjZXNzKGJhc2UsIHByb3AsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnRWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XG4gICAgICAgIGlmIChtdXN0Q2FuY2VsKGEpKSB7XG4gICAgICAgICAgY29uc3RhbnRWYWx1ZSA9IGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBzZXRDaGFpblByb3BBY2Nlc3Mod2luZG93LCBwcm9wZXJ0eSk7XG59XG5zZXRDb25zdGFudC5uYW1lcyA9IFsnc2V0LWNvbnN0YW50JywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ3NldC1jb25zdGFudC5qcycsICd1Ym8tc2V0LWNvbnN0YW50LmpzJywgJ3NldC5qcycsICd1Ym8tc2V0LmpzJywgJ3Viby1zZXQtY29uc3RhbnQnLCAndWJvLXNldCcsICdhYnAtb3ZlcnJpZGUtcHJvcGVydHktcmVhZCddO1xuc2V0Q29uc3RhbnQuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BBcnJheSwgbm9vcE9iamVjdCwgbm9vcEZ1bmMsIHRydWVGdW5jLCBmYWxzZUZ1bmMsIGdldFByb3BlcnR5SW5DaGFpbiwgc2V0UHJvcGVydHlBY2Nlc3MsIHRvUmVnRXhwLCBtYXRjaFN0YWNrVHJhY2UsIG5hdGl2ZUlzTmFOXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcmVtb3ZlLWNvb2tpZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmVtb3ZlcyBjdXJyZW50IHBhZ2UgY29va2llcyBieSBwYXNzZWQgc3RyaW5nIG1hdGNoaW5nIHdpdGggbmFtZS4gRm9yIGN1cnJlbnQgZG9tYWluIGFuZCBzdWJkb21haW5zLiBSdW5zIG9uIGxvYWQgYW5kIGJlZm9yZSB1bmxvYWQuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjY29va2llLXJlbW92ZXJqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3JlbW92ZS1jb29raWUnWywgbWF0Y2hdKVxuICogYGBgXG4gKlxuICogLSBgbWF0Y2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWdleCBtYXRjaGluZyB0aGUgY29va2llIG5hbWUuIElmIG5vdCBzcGVjaWZpZWQgYWxsIGFjY2Vzc2libGUgY29va2llcyB3aWxsIGJlIHJlbW92ZWQuXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiBSZW1vdmVzIGFsbCBjb29raWVzOlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWNvb2tpZScpXG4gKiBgYGBcbiAqXG4gKiAyLiBSZW1vdmVzIGNvb2tpZXMgd2hpY2ggbmFtZSBjb250YWlucyBgZXhhbXBsZWAgc3RyaW5nLlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWNvb2tpZScsICdleGFtcGxlJylcbiAqIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UgdGhpcyBjb29raWUgd2lsbCBiZSByZW1vdmVkXG4gKiAgICAgYGBgamF2YXNjcmlwdFxuICogICAgIGRvY3VtZW50LmNvb2tpZSA9ICdfX2V4YW1wbGU9cmFuZG9tVmFsdWUnO1xuICogICAgIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVDb29raWUoc291cmNlLCBtYXRjaCkge1xuICB2YXIgbWF0Y2hSZWdleHAgPSB0b1JlZ0V4cChtYXRjaCk7XG5cbiAgdmFyIHJlbW92ZUNvb2tpZUZyb21Ib3N0ID0gZnVuY3Rpb24gcmVtb3ZlQ29va2llRnJvbUhvc3QoY29va2llTmFtZSwgaG9zdE5hbWUpIHtcbiAgICB2YXIgY29va2llU3BlYyA9IFwiXCIuY29uY2F0KGNvb2tpZU5hbWUsIFwiPVwiKTtcbiAgICB2YXIgZG9tYWluMSA9IFwiOyBkb21haW49XCIuY29uY2F0KGhvc3ROYW1lKTtcbiAgICB2YXIgZG9tYWluMiA9IFwiOyBkb21haW49LlwiLmNvbmNhdChob3N0TmFtZSk7XG4gICAgdmFyIHBhdGggPSAnOyBwYXRoPS8nO1xuICAgIHZhciBleHBpcmF0aW9uID0gJzsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIEdNVCc7XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llU3BlYyArIGV4cGlyYXRpb247XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llU3BlYyArIGRvbWFpbjEgKyBleHBpcmF0aW9uO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZVNwZWMgKyBkb21haW4yICsgZXhwaXJhdGlvbjtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVTcGVjICsgcGF0aCArIGV4cGlyYXRpb247XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llU3BlYyArIGRvbWFpbjEgKyBwYXRoICsgZXhwaXJhdGlvbjtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWVTcGVjICsgZG9tYWluMiArIHBhdGggKyBleHBpcmF0aW9uO1xuICAgIGhpdChzb3VyY2UpO1xuICB9O1xuXG4gIHZhciBybUNvb2tpZSA9IGZ1bmN0aW9uIHJtQ29va2llKCkge1xuICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKGNvb2tpZVN0cikge1xuICAgICAgdmFyIHBvcyA9IGNvb2tpZVN0ci5pbmRleE9mKCc9Jyk7XG5cbiAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvb2tpZU5hbWUgPSBjb29raWVTdHIuc2xpY2UoMCwgcG9zKS50cmltKCk7XG5cbiAgICAgIGlmICghbWF0Y2hSZWdleHAudGVzdChjb29raWVOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBob3N0UGFydHMgPSBkb2N1bWVudC5sb2NhdGlvbi5ob3N0bmFtZS5zcGxpdCgnLicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBob3N0UGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBob3N0TmFtZSA9IGhvc3RQYXJ0cy5zbGljZShpKS5qb2luKCcuJyk7XG5cbiAgICAgICAgaWYgKGhvc3ROYW1lKSB7XG4gICAgICAgICAgcmVtb3ZlQ29va2llRnJvbUhvc3QoY29va2llTmFtZSwgaG9zdE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcm1Db29raWUoKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHJtQ29va2llKTtcbn1cbnJlbW92ZUNvb2tpZS5uYW1lcyA9IFsncmVtb3ZlLWNvb2tpZScsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidjb29raWUtcmVtb3Zlci5qcycsICd1Ym8tY29va2llLXJlbW92ZXIuanMnLCAndWJvLWNvb2tpZS1yZW1vdmVyJ107XG5yZW1vdmVDb29raWUuaW5qZWN0aW9ucyA9IFt0b1JlZ0V4cCwgaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1hZGRFdmVudExpc3RlbmVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBhZGRpbmcgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50cyBhbmQgY2FsbGJhY2tzLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2FkZGV2ZW50bGlzdGVuZXItZGVmdXNlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1hZGRFdmVudExpc3RlbmVyJ1ssIGV2ZW50U2VhcmNoWywgZnVuY3Rpb25TZWFyY2hdXSlcbiAqIGBgYFxuICpcbiAqIC0gYGV2ZW50U2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVnZXggbWF0Y2hpbmcgdGhlIGV2ZW50IG5hbWUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBzY3JpcHRsZXRzIHByZXZlbnRzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAqIC0gYGZ1bmN0aW9uU2VhcmNoYCAtIG9wdGlvbmFsLCBzdHJpbmcgb3IgcmVnZXggbWF0Y2hpbmcgdGhlIGV2ZW50IGxpc3RlbmVyIGZ1bmN0aW9uIGJvZHkuIElmIG5vdCBzZXQsIHRoZSBzY3JpcHRsZXQgcHJldmVudHMgYWxsIGV2ZW50IGxpc3RlbmVycyB3aXRoIGV2ZW50IG5hbWUgbWF0Y2hpbmcgYGV2ZW50U2VhcmNoYFxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gUHJldmVudCBhbGwgYGNsaWNrYCBsaXN0ZW5lcnM6XG4gKiBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWFkZEV2ZW50TGlzdGVuZXInLCAnY2xpY2snKVxuICogYGBgXG5cbjIuIFByZXZlbnQgJ2NsaWNrJyBsaXN0ZW5lcnMgd2l0aCB0aGUgY2FsbGJhY2sgYm9keSBjb250YWluaW5nIGBzZWFyY2hTdHJpbmdgLlxuICogYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1hZGRFdmVudExpc3RlbmVyJywgJ2NsaWNrJywgJ3NlYXJjaFN0cmluZycpXG4gKiBgYGBcbiAqXG4gKiAgICAgRm9yIGluc3RhbmNlLCB0aGlzIGxpc3RlbmVyIHdpbGwgbm90IGJlIGNhbGxlZDpcbiAqIGBgYGphdmFzY3JpcHRcbiAqICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAqICAgICAgICAgd2luZG93LnRlc3QgPSAnc2VhcmNoU3RyaW5nJztcbiAqICAgICB9KTtcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50QWRkRXZlbnRMaXN0ZW5lcihzb3VyY2UsIGV2ZW50U2VhcmNoLCBmdW5jU2VhcmNoKSB7XG4gIHZhciBldmVudFNlYXJjaFJlZ2V4cCA9IHRvUmVnRXhwKGV2ZW50U2VhcmNoKTtcbiAgdmFyIGZ1bmNTZWFyY2hSZWdleHAgPSB0b1JlZ0V4cChmdW5jU2VhcmNoKTtcbiAgdmFyIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcldyYXBwZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgc2hvdWxkUHJldmVudCA9IGZhbHNlO1xuXG4gICAgaWYgKHZhbGlkYXRlVHlwZSh0eXBlKSAmJiB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSkge1xuICAgICAgc2hvdWxkUHJldmVudCA9IGV2ZW50U2VhcmNoUmVnZXhwLnRlc3QodHlwZS50b1N0cmluZygpKSAmJiBmdW5jU2VhcmNoUmVnZXhwLnRlc3QobGlzdGVuZXJUb1N0cmluZyhsaXN0ZW5lcikpO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRQcmV2ZW50KSB7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW3R5cGUsIGxpc3RlbmVyXS5jb25jYXQoYXJncykpO1xuICB9XG5cbiAgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcldyYXBwZXI7XG59XG5wcmV2ZW50QWRkRXZlbnRMaXN0ZW5lci5uYW1lcyA9IFsncHJldmVudC1hZGRFdmVudExpc3RlbmVyJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2FkZEV2ZW50TGlzdGVuZXItZGVmdXNlci5qcycsICd1Ym8tYWRkRXZlbnRMaXN0ZW5lci1kZWZ1c2VyLmpzJywgJ2FlbGQuanMnLCAndWJvLWFlbGQuanMnLCAndWJvLWFkZEV2ZW50TGlzdGVuZXItZGVmdXNlcicsICd1Ym8tYWVsZCddO1xucHJldmVudEFkZEV2ZW50TGlzdGVuZXIuaW5qZWN0aW9ucyA9IFtoaXQsIHRvUmVnRXhwLCB2YWxpZGF0ZVR5cGUsIHZhbGlkYXRlTGlzdGVuZXIsIGxpc3RlbmVyVG9TdHJpbmddO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiwgbm8tZXZhbCAqL1xuLyoqXG4gKiBAc2NyaXB0bGV0IHByZXZlbnQtYmFiXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBCbG9ja0FkYmxvY2sgc2NyaXB0IGZyb20gZGV0ZWN0aW5nIGFuIGFkIGJsb2NrZXIuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjYmFiLWRlZnVzZXJqcy1cbiAqXG4gKiBJdCBhbHNvIGNhbiBiZSB1c2VkIGFzIGAkcmVkaXJlY3RgIHNvbWV0aW1lcy5cbiAqIFNlZSBbcmVkaXJlY3QgZGVzY3JpcHRpb25dKC4uL3dpa2kvYWJvdXQtcmVkaXJlY3RzLm1kI3ByZXZlbnQtYmFiKS5cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtYmFiJylcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIHByZXZlbnRCYWIoc291cmNlKSB7XG4gIHZhciBuYXRpdmVTZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG4gIHZhciBiYWJSZWdleCA9IC9cXC5iYWJfZWxlbWVudGlkLiQvO1xuXG4gIHZhciB0aW1lb3V0V3JhcHBlciA9IGZ1bmN0aW9uIHRpbWVvdXRXcmFwcGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ3N0cmluZycgfHwgIWJhYlJlZ2V4LnRlc3QoY2FsbGJhY2spKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlU2V0VGltZW91dC5hcHBseSh3aW5kb3csIFtjYWxsYmFja10uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG5cbiAgICBoaXQoc291cmNlKTtcbiAgfTtcblxuICB3aW5kb3cuc2V0VGltZW91dCA9IHRpbWVvdXRXcmFwcGVyO1xuICB2YXIgc2lnbmF0dXJlcyA9IFtbJ2Jsb2NrYWRibG9jayddLCBbJ2JhYmFzYm0nXSwgWy9nZXRJdGVtXFwoJ2JhYm4nXFwpL10sIFsnZ2V0RWxlbWVudEJ5SWQnLCAnU3RyaW5nLmZyb21DaGFyQ29kZScsICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OScsICdjaGFyQXQnLCAnRE9NQ29udGVudExvYWRlZCcsICdBZEJsb2NrJywgJ2FkZEV2ZW50TGlzdGVuZXInLCAnZG9TY3JvbGwnLCAnZnJvbUNoYXJDb2RlJywgJzw8MnxyPj40JywgJ3Nlc3Npb25TdG9yYWdlJywgJ2NsaWVudFdpZHRoJywgJ2xvY2FsU3RvcmFnZScsICdNYXRoJywgJ3JhbmRvbSddXTtcblxuICB2YXIgY2hlY2sgPSBmdW5jdGlvbiBjaGVjayhzdHIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ25hdHVyZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBzaWduYXR1cmVzW2ldO1xuICAgICAgdmFyIG1hdGNoID0gMDtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2pdO1xuICAgICAgICB2YXIgZm91bmQgPSB0b2tlbiBpbnN0YW5jZW9mIFJlZ0V4cCA/IHRva2VuLnRlc3Qoc3RyKSA6IHN0ci5pbmRleE9mKHRva2VuKSA+IC0xO1xuXG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIG1hdGNoICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoIC8gdG9rZW5zLmxlbmd0aCA+PSAwLjgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBuYXRpdmVFdmFsID0gd2luZG93LmV2YWw7XG5cbiAgdmFyIGV2YWxXcmFwcGVyID0gZnVuY3Rpb24gZXZhbFdyYXBwZXIoc3RyKSB7XG4gICAgaWYgKCFjaGVjayhzdHIpKSB7XG4gICAgICByZXR1cm4gbmF0aXZlRXZhbChzdHIpO1xuICAgIH1cblxuICAgIGhpdChzb3VyY2UpO1xuICAgIHZhciBib2R5RWwgPSBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKGJvZHlFbCkge1xuICAgICAgYm9keUVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCd2aXNpYmlsaXR5Jyk7XG4gICAgfVxuXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhYmFzYm1zZ3gnKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxuICB9O1xuXG4gIHdpbmRvdy5ldmFsID0gZXZhbFdyYXBwZXIuYmluZCh3aW5kb3cpO1xufVxucHJldmVudEJhYi5uYW1lcyA9IFsncHJldmVudC1iYWInLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm9iYWIuanMnLCAndWJvLW5vYmFiLmpzJywgJ2JhYi1kZWZ1c2VyLmpzJywgJ3Viby1iYWItZGVmdXNlci5qcycsICd1Ym8tbm9iYWInLCAndWJvLWJhYi1kZWZ1c2VyJ107XG5wcmV2ZW50QmFiLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLWV4dHJhLWJpbmQsIGZ1bmMtbmFtZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IG5vd2VicnRjXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEaXNhYmxlcyBXZWJSVEMgYnkgb3ZlcnJpZGluZyBgUlRDUGVlckNvbm5lY3Rpb25gLiBUaGUgb3ZlcnJpZGVuIGZ1bmN0aW9uIHdpbGwgbG9nIGV2ZXJ5IGF0dGVtcHQgdG8gY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24uXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjbm93ZWJydGNqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ25vd2VicnRjJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBub3dlYnJ0Yyhzb3VyY2UpIHtcbiAgdmFyIHByb3BlcnR5TmFtZSA9ICcnO1xuXG4gIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICBwcm9wZXJ0eU5hbWUgPSAnUlRDUGVlckNvbm5lY3Rpb24nO1xuICB9IGVsc2UgaWYgKHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHByb3BlcnR5TmFtZSA9ICd3ZWJraXRSVENQZWVyQ29ubmVjdGlvbic7XG4gIH1cblxuICBpZiAocHJvcGVydHlOYW1lID09PSAnJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBydGNSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIHJ0Y1JlcGxhY2VtZW50KGNvbmZpZykge1xuICAgIGhpdChzb3VyY2UsIFwiRG9jdW1lbnQgdHJpZWQgdG8gY3JlYXRlIGFuIFJUQ1BlZXJDb25uZWN0aW9uOiBcIi5jb25jYXQoY29udmVydFJ0Y0NvbmZpZ1RvU3RyaW5nKGNvbmZpZykpKTtcbiAgfTtcblxuICBydGNSZXBsYWNlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgY2xvc2U6IG5vb3BGdW5jLFxuICAgIGNyZWF0ZURhdGFDaGFubmVsOiBub29wRnVuYyxcbiAgICBjcmVhdGVPZmZlcjogbm9vcEZ1bmMsXG4gICAgc2V0UmVtb3RlRGVzY3JpcHRpb246IG5vb3BGdW5jXG4gIH07XG4gIHZhciBydGMgPSB3aW5kb3dbcHJvcGVydHlOYW1lXTtcbiAgd2luZG93W3Byb3BlcnR5TmFtZV0gPSBydGNSZXBsYWNlbWVudDtcblxuICBpZiAocnRjLnByb3RvdHlwZSkge1xuICAgIHJ0Yy5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2U6IG5vb3BGdW5jLFxuICAgICAgICBzZW5kOiBub29wRnVuY1xuICAgICAgfTtcbiAgICB9LmJpbmQobnVsbCk7XG4gIH1cbn1cbm5vd2VicnRjLm5hbWVzID0gWydub3dlYnJ0YycsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidub3dlYnJ0Yy5qcycsICd1Ym8tbm93ZWJydGMuanMnLCAndWJvLW5vd2VicnRjJ107XG5ub3dlYnJ0Yy5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmMsIGNvbnZlcnRSdGNDb25maWdUb1N0cmluZ107XG5cbi8qKlxuICogQHNjcmlwdGxldCBsb2ctYWRkRXZlbnRMaXN0ZW5lclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTG9ncyBhbGwgYWRkRXZlbnRMaXN0ZW5lciBjYWxscyB0byB0aGUgY29uc29sZS5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNhZGRldmVudGxpc3RlbmVyLWxvZ2dlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnbG9nLWFkZEV2ZW50TGlzdGVuZXInKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gbG9nQWRkRXZlbnRMaXN0ZW5lcihzb3VyY2UpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gIHZhciBuYXRpdmVBZGRFdmVudExpc3RlbmVyID0gd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJXcmFwcGVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHZhbGlkYXRlVHlwZSh0eXBlKSAmJiB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSkge1xuICAgICAgdmFyIGxvZ01lc3NhZ2UgPSBcImxvZzogYWRkRXZlbnRMaXN0ZW5lcihcXFwiXCIuY29uY2F0KHR5cGUsIFwiXFxcIiwgXCIpLmNvbmNhdChsaXN0ZW5lclRvU3RyaW5nKGxpc3RlbmVyKSwgXCIpXCIpO1xuICAgICAgaGl0KHNvdXJjZSwgbG9nTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UudmVyYm9zZSkge1xuICAgICAgLy8gbG9nZ2luZyB3aGlsZSBkZWJ1Z2dpbmdcbiAgICAgIHZhciBfbG9nTWVzc2FnZSA9IFwiSW52YWxpZCBldmVudCB0eXBlIG9yIGxpc3RlbmVyIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyOlxcbnR5cGU6IFwiLmNvbmNhdChjb252ZXJ0VHlwZVRvU3RyaW5nKHR5cGUpLCBcIlxcbmxpc3RlbmVyOiBcIikuY29uY2F0KGNvbnZlcnRUeXBlVG9TdHJpbmcobGlzdGVuZXIpKTtcblxuICAgICAgbG9nKF9sb2dNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbdHlwZSwgbGlzdGVuZXJdLmNvbmNhdChhcmdzKSk7XG4gIH1cblxuICB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyV3JhcHBlcjtcbn1cbmxvZ0FkZEV2ZW50TGlzdGVuZXIubmFtZXMgPSBbJ2xvZy1hZGRFdmVudExpc3RlbmVyJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2FkZEV2ZW50TGlzdGVuZXItbG9nZ2VyLmpzJywgJ3Viby1hZGRFdmVudExpc3RlbmVyLWxvZ2dlci5qcycsICdhZWxsLmpzJywgJ3Viby1hZWxsLmpzJywgJ3Viby1hZGRFdmVudExpc3RlbmVyLWxvZ2dlcicsICd1Ym8tYWVsbCddO1xubG9nQWRkRXZlbnRMaXN0ZW5lci5pbmplY3Rpb25zID0gW2hpdCwgdmFsaWRhdGVUeXBlLCB2YWxpZGF0ZUxpc3RlbmVyLCBsaXN0ZW5lclRvU3RyaW5nLCBjb252ZXJ0VHlwZVRvU3RyaW5nLCBvYmplY3RUb1N0cmluZywgaXNFbXB0eU9iamVjdCwgZ2V0T2JqZWN0RW50cmllc107XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUsIG5vLWV2YWwgKi9cbi8qKlxuICogQHNjcmlwdGxldCBsb2ctZXZhbFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTG9ncyBhbGwgYGV2YWwoKWAgb3IgYG5ldyBGdW5jdGlvbigpYCBjYWxscyB0byB0aGUgY29uc29sZS5cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2xvZy1ldmFsJylcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIGxvZ0V2YWwoc291cmNlKSB7XG4gIHZhciBsb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpOyAvLyB3cmFwIGV2YWwgZnVuY3Rpb25cblxuICB2YXIgbmF0aXZlRXZhbCA9IHdpbmRvdy5ldmFsO1xuXG4gIGZ1bmN0aW9uIGV2YWxXcmFwcGVyKHN0cikge1xuICAgIGhpdChzb3VyY2UpO1xuICAgIGxvZyhcImV2YWwoXFxcIlwiLmNvbmNhdChzdHIsIFwiXFxcIilcIikpO1xuICAgIHJldHVybiBuYXRpdmVFdmFsKHN0cik7XG4gIH1cblxuICB3aW5kb3cuZXZhbCA9IGV2YWxXcmFwcGVyOyAvLyB3cmFwIG5ldyBGdW5jdGlvblxuXG4gIHZhciBuYXRpdmVGdW5jdGlvbiA9IHdpbmRvdy5GdW5jdGlvbjtcblxuICBmdW5jdGlvbiBGdW5jdGlvbldyYXBwZXIoKSB7XG4gICAgaGl0KHNvdXJjZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbG9nKFwibmV3IEZ1bmN0aW9uKFwiLmNvbmNhdChhcmdzLmpvaW4oJywgJyksIFwiKVwiKSk7XG4gICAgcmV0dXJuIG5hdGl2ZUZ1bmN0aW9uLmFwcGx5KHRoaXMsIFtdLmNvbmNhdChhcmdzKSk7XG4gIH1cblxuICBGdW5jdGlvbldyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYXRpdmVGdW5jdGlvbi5wcm90b3R5cGUpO1xuICBGdW5jdGlvbldyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnVuY3Rpb25XcmFwcGVyO1xuICB3aW5kb3cuRnVuY3Rpb24gPSBGdW5jdGlvbldyYXBwZXI7XG59XG5sb2dFdmFsLm5hbWVzID0gWydsb2ctZXZhbCddO1xubG9nRXZhbC5pbmplY3Rpb25zID0gW2hpdF07XG5cbi8qKlxuICogQHNjcmlwdGxldCBsb2dcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc2ltcGxlIHNjcmlwdGxldCB3aGljaCBvbmx5IHB1cnBvc2UgaXMgdG8gcHJpbnQgYXJndW1lbnRzIHRvIGNvbnNvbGUuXG4gKiBUaGlzIHNjcmlwdGxldCBjYW4gYmUgaGVscGZ1bCBmb3IgZGVidWdnaW5nIGFuZCB0cm91Ymxlc2hvb3Rpbmcgb3RoZXIgc2NyaXB0bGV0cy5cbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdsb2cnLCAnYXJnMScsICdhcmcyJylcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBsb2coKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBjb25zb2xlLmxvZyhhcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG59XG5sb2cubmFtZXMgPSBbJ2xvZyddO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1ldmFsLCBuby1leHRyYS1iaW5kICovXG4vKipcbiAqIEBzY3JpcHRsZXQgbm9ldmFsXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBwYWdlIHRvIHVzZSBldmFsLlxuICogTm90aWZpZXMgYWJvdXQgYXR0ZW1wdHMgaW4gdGhlIGNvbnNvbGVcbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNub2V2YWxqcy1cbiAqXG4gKiBJdCBhbHNvIGNhbiBiZSB1c2VkIGFzIGAkcmVkaXJlY3RgIHJ1bGVzIHNvbWV0aW1lcy5cbiAqIFNlZSBbcmVkaXJlY3QgZGVzY3JpcHRpb25dKC4uL3dpa2kvYWJvdXQtcmVkaXJlY3RzLm1kI25vZXZhbCkuXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdub2V2YWwnKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gbm9ldmFsKHNvdXJjZSkge1xuICB3aW5kb3cuZXZhbCA9IGZ1bmN0aW9uIGV2YWxXcmFwcGVyKHMpIHtcbiAgICBoaXQoc291cmNlLCBcIkFkR3VhcmQgaGFzIHByZXZlbnRlZCBldmFsOlxcblwiLmNvbmNhdChzKSk7XG4gIH0uYmluZCgpO1xufVxubm9ldmFsLm5hbWVzID0gWydub2V2YWwnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm9ldmFsLmpzJywgJ3NpbGVudC1ub2V2YWwuanMnLCAndWJvLW5vZXZhbC5qcycsICd1Ym8tc2lsZW50LW5vZXZhbC5qcycsICd1Ym8tbm9ldmFsJywgJ3Viby1zaWxlbnQtbm9ldmFsJ107XG5ub2V2YWwuaW5qZWN0aW9ucyA9IFtoaXRdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1ldmFsLCBuby1leHRyYS1iaW5kLCBmdW5jLW5hbWVzICovXG4vKipcbiAqIEBzY3JpcHRsZXQgcHJldmVudC1ldmFsLWlmXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBwYWdlIHRvIHVzZSBldmFsIG1hdGNoaW5nIHBheWxvYWQuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjbm9ldmFsLWlmanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWV2YWwtaWYnWywgc2VhcmNoXSlcbiAqIGBgYFxuICpcbiAqIC0gYHNlYXJjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ2V4cCBmb3IgbWF0Y2hpbmcgc3RyaW5naWZpZWQgZXZhbCBwYXlsb2FkLlxuICogSWYgJ3NlYXJjaCBpcyBub3Qgc3BlY2lmaWVkIOKAlCBhbGwgc3RyaW5naWZpZWQgZXZhbCBwYXlsb2FkIHdpbGwgYmUgbWF0Y2hlZFxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogYGBgXG4gKiAhIFByZXZlbnRzIGV2YWwgaWYgaXQgbWF0Y2hlcyAndGVzdCdcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZXZhbC1pZicsICd0ZXN0JylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gW3NlYXJjaF0gc3RyaW5nIG9yIHJlZ2V4cCBtYXRjaGluZyBzdHJpbmdpZmllZCBldmFsIHBheWxvYWRcbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50RXZhbElmKHNvdXJjZSwgc2VhcmNoKSB7XG4gIHZhciBzZWFyY2hSZWdleHAgPSB0b1JlZ0V4cChzZWFyY2gpO1xuICB2YXIgbmF0aXZlRXZhbCA9IHdpbmRvdy5ldmFsO1xuXG4gIHdpbmRvdy5ldmFsID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICBpZiAoIXNlYXJjaFJlZ2V4cC50ZXN0KHBheWxvYWQudG9TdHJpbmcoKSkpIHtcbiAgICAgIHJldHVybiBuYXRpdmVFdmFsLmNhbGwod2luZG93LCBwYXlsb2FkKTtcbiAgICB9XG5cbiAgICBoaXQoc291cmNlLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LmJpbmQod2luZG93KTtcbn1cbnByZXZlbnRFdmFsSWYubmFtZXMgPSBbJ3ByZXZlbnQtZXZhbC1pZicsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidub2V2YWwtaWYuanMnLCAndWJvLW5vZXZhbC1pZi5qcycsICd1Ym8tbm9ldmFsLWlmJ107XG5wcmV2ZW50RXZhbElmLmluamVjdGlvbnMgPSBbdG9SZWdFeHAsIGhpdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUsIGZ1bmMtbmFtZXMsIG5vLW11bHRpLWFzc2lnbiAqL1xuLyoqXG4gKiBAc2NyaXB0bGV0IHByZXZlbnQtZmFiLTMuMi4wXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBleGVjdXRpb24gb2YgdGhlIEZBQiBzY3JpcHQgdjMuMi4wLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2Z1Y2thZGJsb2NranMtMzIwLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1mYWItMy4yLjAnKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcHJldmVudEZhYihzb3VyY2UpIHtcbiAgaGl0KHNvdXJjZSk7IC8vIHJlZGVmaW5lcyBGYWIgZnVuY3Rpb24gZm9yIGFkYmxvY2sgZGV0ZWN0aW9uXG5cbiAgdmFyIEZhYiA9IGZ1bmN0aW9uIEZhYigpIHt9O1xuXG4gIEZhYi5wcm90b3R5cGUuY2hlY2sgPSBub29wRnVuYztcbiAgRmFiLnByb3RvdHlwZS5jbGVhckV2ZW50ID0gbm9vcEZ1bmM7XG4gIEZhYi5wcm90b3R5cGUuZW1pdEV2ZW50ID0gbm9vcEZ1bmM7XG5cbiAgRmFiLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKCFhKSB7XG4gICAgICBiKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRmFiLnByb3RvdHlwZS5vbkRldGVjdGVkID0gbm9vcFRoaXM7XG5cbiAgRmFiLnByb3RvdHlwZS5vbk5vdERldGVjdGVkID0gZnVuY3Rpb24gKGEpIHtcbiAgICBhKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRmFiLnByb3RvdHlwZS5zZXRPcHRpb24gPSBub29wRnVuYztcbiAgRmFiLnByb3RvdHlwZS5vcHRpb25zID0ge1xuICAgIHNldDogbm9vcEZ1bmMsXG4gICAgZ2V0OiBub29wRnVuY1xuICB9O1xuICB2YXIgZmFiID0gbmV3IEZhYigpO1xuICB2YXIgZ2V0U2V0RmFiID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEZhYjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KCkge31cbiAgfTtcbiAgdmFyIGdldHNldGZhYiA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHt9XG4gIH07IC8vIHJlZGVmaW5lZCBGYWIgZGF0YSBwcm9wZXJ0aWVzIHdoaWNoIGlmICdGdWNrQWRCbG9jaycgdmFyaWFibGUgZXhpc3RzXG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3aW5kb3csICdGdWNrQWRCbG9jaycpKSB7XG4gICAgd2luZG93LkZ1Y2tBZEJsb2NrID0gRmFiO1xuICB9IGVsc2Uge1xuICAgIC8vIG9yIHJlZGVmaW5lZCBGYWIgYWNjZXNzb3IgcHJvcGVydGllc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdGdWNrQWRCbG9jaycsIGdldFNldEZhYik7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdpbmRvdywgJ0Jsb2NrQWRCbG9jaycpKSB7XG4gICAgd2luZG93LkJsb2NrQWRCbG9jayA9IEZhYjtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnQmxvY2tBZEJsb2NrJywgZ2V0U2V0RmFiKTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2luZG93LCAnU25pZmZBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuU25pZmZBZEJsb2NrID0gRmFiO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdTbmlmZkFkQmxvY2snLCBnZXRTZXRGYWIpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3aW5kb3csICdmdWNrQWRCbG9jaycpKSB7XG4gICAgd2luZG93LmZ1Y2tBZEJsb2NrID0gZmFiO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdmdWNrQWRCbG9jaycsIGdldHNldGZhYik7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdpbmRvdywgJ2Jsb2NrQWRCbG9jaycpKSB7XG4gICAgd2luZG93LmJsb2NrQWRCbG9jayA9IGZhYjtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnYmxvY2tBZEJsb2NrJywgZ2V0c2V0ZmFiKTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2luZG93LCAnc25pZmZBZEJsb2NrJykpIHtcbiAgICB3aW5kb3cuc25pZmZBZEJsb2NrID0gZmFiO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdzbmlmZkFkQmxvY2snLCBnZXRzZXRmYWIpO1xuICB9XG59XG5wcmV2ZW50RmFiLm5hbWVzID0gWydwcmV2ZW50LWZhYi0zLjIuMCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidub2ZhYi5qcycsICd1Ym8tbm9mYWIuanMnLCAnZnVja2FkYmxvY2suanMtMy4yLjAnLCAndWJvLWZ1Y2thZGJsb2NrLmpzLTMuMi4wJywgJ3Viby1ub2ZhYiddO1xucHJldmVudEZhYi5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmMsIG5vb3BUaGlzXTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSwgZnVuYy1uYW1lcywgbm8tbXVsdGktYXNzaWduICovXG4vKipcbiAqIEBzY3JpcHRsZXQgc2V0LXBvcGFkcy1kdW1teVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0cyBzdGF0aWMgcHJvcGVydGllcyBQb3BBZHMgYW5kIHBvcG5zLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I3BvcGFkcy1kdW1teWpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LXBvcGFkcy1kdW1teScpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBzZXRQb3BhZHNEdW1teShzb3VyY2UpIHtcbiAgZGVsZXRlIHdpbmRvdy5Qb3BBZHM7XG4gIGRlbGV0ZSB3aW5kb3cucG9wbnM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdpbmRvdywge1xuICAgIFBvcEFkczoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICBwb3Buczoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbnNldFBvcGFkc0R1bW15Lm5hbWVzID0gWydzZXQtcG9wYWRzLWR1bW15JywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ3BvcGFkcy1kdW1teS5qcycsICd1Ym8tcG9wYWRzLWR1bW15LmpzJywgJ3Viby1wb3BhZHMtZHVtbXknXTtcbnNldFBvcGFkc0R1bW15LmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IHByZXZlbnQtcG9wYWRzLW5ldFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWJvcnRzIG9uIHByb3BlcnR5IHdyaXRlIChQb3BBZHMsIHBvcG5zKSwgdGhyb3dzIHJlZmVyZW5jZSBlcnJvciB3aXRoIHJhbmRvbSBpZC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNwb3BhZHNuZXRqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtcG9wYWRzLW5ldCcpXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBwcmV2ZW50UG9wYWRzTmV0KHNvdXJjZSkge1xuICB2YXIgcmlkID0gcmFuZG9tSWQoKTtcblxuICB2YXIgdGhyb3dFcnJvciA9IGZ1bmN0aW9uIHRocm93RXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKHJpZCk7XG4gIH07XG5cbiAgZGVsZXRlIHdpbmRvdy5Qb3BBZHM7XG4gIGRlbGV0ZSB3aW5kb3cucG9wbnM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdpbmRvdywge1xuICAgIFBvcEFkczoge1xuICAgICAgc2V0OiB0aHJvd0Vycm9yXG4gICAgfSxcbiAgICBwb3Buczoge1xuICAgICAgc2V0OiB0aHJvd0Vycm9yXG4gICAgfVxuICB9KTtcbiAgd2luZG93Lm9uZXJyb3IgPSBjcmVhdGVPbkVycm9ySGFuZGxlcihyaWQpLmJpbmQoKTtcbiAgaGl0KHNvdXJjZSk7XG59XG5wcmV2ZW50UG9wYWRzTmV0Lm5hbWVzID0gWydwcmV2ZW50LXBvcGFkcy1uZXQnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4ncG9wYWRzLm5ldC5qcycsICd1Ym8tcG9wYWRzLm5ldC5qcycsICd1Ym8tcG9wYWRzLm5ldCddO1xucHJldmVudFBvcGFkc05ldC5pbmplY3Rpb25zID0gW2NyZWF0ZU9uRXJyb3JIYW5kbGVyLCByYW5kb21JZCwgaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1uYW1lcyAqL1xuLyoqXG4gKiBAc2NyaXB0bGV0IHByZXZlbnQtYWRmbHlcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGFudGktYWRibG9jayBzY3JpcHRzIG9uIGFkZmx5IHNob3J0IGxpbmtzLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2FkZmx5LWRlZnVzZXJqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtYWRmbHknKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcHJldmVudEFkZmx5KHNvdXJjZSkge1xuICB2YXIgaXNEaWdpdCA9IGZ1bmN0aW9uIGlzRGlnaXQoZGF0YSkge1xuICAgIHJldHVybiAvXlxcZCQvLnRlc3QoZGF0YSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGVuY29kZWRVUkwpIHtcbiAgICB2YXIgZXZlbkNoYXJzID0gJyc7XG4gICAgdmFyIG9kZENoYXJzID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRVUkwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICBldmVuQ2hhcnMgKz0gZW5jb2RlZFVSTC5jaGFyQXQoaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZGRDaGFycyA9IGVuY29kZWRVUkwuY2hhckF0KGkpICsgb2RkQ2hhcnM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSAoZXZlbkNoYXJzICsgb2RkQ2hhcnMpLnNwbGl0KCcnKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkYXRhLmxlbmd0aDsgX2kgKz0gMSkge1xuICAgICAgaWYgKGlzRGlnaXQoZGF0YVtfaV0pKSB7XG4gICAgICAgIGZvciAodmFyIGlpID0gX2kgKyAxOyBpaSA8IGRhdGEubGVuZ3RoOyBpaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGlzRGlnaXQoZGF0YVtpaV0pKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgdmFyIHRlbXAgPSBwYXJzZUludChkYXRhW19pXSwgMTApIF4gcGFyc2VJbnQoZGF0YVtpaV0sIDEwKTtcblxuICAgICAgICAgICAgaWYgKHRlbXAgPCAxMCkge1xuICAgICAgICAgICAgICBkYXRhW19pXSA9IHRlbXAudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2kgPSBpaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRhdGEgPSBkYXRhLmpvaW4oJycpO1xuICAgIHZhciBkZWNvZGVkVVJMID0gd2luZG93LmF0b2IoZGF0YSkuc2xpY2UoMTYsIC0xNik7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY29tcGF0L2NvbXBhdCAqL1xuXG4gICAgaWYgKHdpbmRvdy5zdG9wKSB7XG4gICAgICB3aW5kb3cuc3RvcCgpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBhdC9jb21wYXQgKi9cblxuXG4gICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gbnVsbDtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGRlY29kZWRVUkw7XG4gIH07XG5cbiAgdmFyIHZhbDsgLy8gRG8gbm90IGFwcGx5IGhhbmRsZXIgbW9yZSB0aGFuIG9uZSB0aW1lXG5cbiAgdmFyIGFwcGx5SGFuZGxlciA9IHRydWU7XG4gIHZhciByZXN1bHQgPSBzZXRQcm9wZXJ0eUFjY2Vzcyh3aW5kb3csICd5c21tJywge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmIChhcHBseUhhbmRsZXIpIHtcbiAgICAgICAgYXBwbHlIYW5kbGVyID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxuICAgICAgfVxuXG4gICAgICB2YWwgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChyZXN1bHQpIHtcbiAgICBoaXQoc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNldCB1cCBwcmV2ZW50LWFkZmx5IHNjcmlwdGxldCcpO1xuICB9XG59XG5wcmV2ZW50QWRmbHkubmFtZXMgPSBbJ3ByZXZlbnQtYWRmbHknLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nYWRmbHktZGVmdXNlci5qcycsICd1Ym8tYWRmbHktZGVmdXNlci5qcycsICd1Ym8tYWRmbHktZGVmdXNlciddO1xucHJldmVudEFkZmx5LmluamVjdGlvbnMgPSBbc2V0UHJvcGVydHlBY2Nlc3MsIGhpdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGRlYnVnLW9uLXByb3BlcnR5LXJlYWRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc2NyaXB0bGV0IGlzIGJhc2ljYWxseSB0aGUgc2FtZSBhcyBbYWJvcnQtb24tcHJvcGVydHktcmVhZF0oI2Fib3J0LW9uLXByb3BlcnR5LXJlYWQpLCBidXQgaW5zdGVhZCBvZiBhYm9ydGluZyBpdCBzdGFydHMgdGhlIGRlYnVnZ2VyLlxuICpcbiAqICoqSXQgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gcHJvZHVjdGlvbiBmaWx0ZXIgbGlzdHMhKipcbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqICEgRGVidWcgc2NyaXB0IGlmIGl0IHRyaWVzIHRvIGFjY2VzcyBgd2luZG93LmFsZXJ0YFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnZGVidWctb24tcHJvcGVydHktcmVhZCcsICdhbGVydCcpXG4gKiAhIG9mIGB3aW5kb3cub3BlbmBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2RlYnVnLW9uLXByb3BlcnR5LXJlYWQnLCAnb3BlbicpXG4gKiBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gZGVidWdPblByb3BlcnR5UmVhZChzb3VyY2UsIHByb3BlcnR5LCBzdGFjaykge1xuICBpZiAoIXByb3BlcnR5IHx8ICFtYXRjaFN0YWNrVHJhY2Uoc3RhY2ssIG5ldyBFcnJvcigpLnN0YWNrKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByaWQgPSByYW5kb21JZCgpO1xuXG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGhpdChzb3VyY2UpO1xuICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjtcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgZ2V0OiBhYm9ydCxcbiAgICAgIHNldDogbm9vcEZ1bmNcbiAgICB9KTtcbiAgfTtcblxuICBzZXRDaGFpblByb3BBY2Nlc3Mod2luZG93LCBwcm9wZXJ0eSk7XG4gIHdpbmRvdy5vbmVycm9yID0gY3JlYXRlT25FcnJvckhhbmRsZXIocmlkKS5iaW5kKCk7XG59XG5kZWJ1Z09uUHJvcGVydHlSZWFkLm5hbWVzID0gWydkZWJ1Zy1vbi1wcm9wZXJ0eS1yZWFkJ107XG5kZWJ1Z09uUHJvcGVydHlSZWFkLmluamVjdGlvbnMgPSBbcmFuZG9tSWQsIHNldFByb3BlcnR5QWNjZXNzLCBnZXRQcm9wZXJ0eUluQ2hhaW4sIGNyZWF0ZU9uRXJyb3JIYW5kbGVyLCBoaXQsIHRvUmVnRXhwLCBtYXRjaFN0YWNrVHJhY2UsIG5vb3BGdW5jXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgZGVidWctb24tcHJvcGVydHktd3JpdGVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc2NyaXB0bGV0IGlzIGJhc2ljYWxseSB0aGUgc2FtZSBhcyBbYWJvcnQtb24tcHJvcGVydHktd3JpdGVdKCNhYm9ydC1vbi1wcm9wZXJ0eS13cml0ZSksIGJ1dCBpbnN0ZWFkIG9mIGFib3J0aW5nIGl0IHN0YXJ0cyB0aGUgZGVidWdnZXIuXG4gKlxuICogKipJdCBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgdXNlZCBpbiBwcm9kdWN0aW9uIGZpbHRlciBsaXN0cyEqKlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogISBBYm9ydHMgc2NyaXB0IHdoZW4gaXQgdHJpZXMgdG8gd3JpdGUgaW4gcHJvcGVydHkgYHdpbmRvdy50ZXN0YFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnZGVidWctb24tcHJvcGVydHktd3JpdGUnLCAndGVzdCcpXG4gKiBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gZGVidWdPblByb3BlcnR5V3JpdGUoc291cmNlLCBwcm9wZXJ0eSwgc3RhY2spIHtcbiAgaWYgKCFwcm9wZXJ0eSB8fCAhbWF0Y2hTdGFja1RyYWNlKHN0YWNrLCBuZXcgRXJyb3IoKS5zdGFjaykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmlkID0gcmFuZG9tSWQoKTtcblxuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBoaXQoc291cmNlKTtcbiAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICB9O1xuXG4gIHZhciBzZXRDaGFpblByb3BBY2Nlc3MgPSBmdW5jdGlvbiBzZXRDaGFpblByb3BBY2Nlc3Mob3duZXIsIHByb3BlcnR5KSB7XG4gICAgdmFyIGNoYWluSW5mbyA9IGdldFByb3BlcnR5SW5DaGFpbihvd25lciwgcHJvcGVydHkpO1xuICAgIHZhciBiYXNlID0gY2hhaW5JbmZvLmJhc2U7XG4gICAgdmFyIHByb3AgPSBjaGFpbkluZm8ucHJvcCxcbiAgICAgICAgY2hhaW4gPSBjaGFpbkluZm8uY2hhaW47XG5cbiAgICBpZiAoY2hhaW4pIHtcbiAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiBzZXR0ZXIoYSkge1xuICAgICAgICBiYXNlID0gYTtcblxuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHNldENoYWluUHJvcEFjY2VzcyhhLCBjaGFpbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvd25lciwgcHJvcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFByb3BlcnR5QWNjZXNzKGJhc2UsIHByb3AsIHtcbiAgICAgIHNldDogYWJvcnRcbiAgICB9KTtcbiAgfTtcblxuICBzZXRDaGFpblByb3BBY2Nlc3Mod2luZG93LCBwcm9wZXJ0eSk7XG4gIHdpbmRvdy5vbmVycm9yID0gY3JlYXRlT25FcnJvckhhbmRsZXIocmlkKS5iaW5kKCk7XG59XG5kZWJ1Z09uUHJvcGVydHlXcml0ZS5uYW1lcyA9IFsnZGVidWctb24tcHJvcGVydHktd3JpdGUnXTtcbmRlYnVnT25Qcm9wZXJ0eVdyaXRlLmluamVjdGlvbnMgPSBbcmFuZG9tSWQsIHNldFByb3BlcnR5QWNjZXNzLCBnZXRQcm9wZXJ0eUluQ2hhaW4sIGNyZWF0ZU9uRXJyb3JIYW5kbGVyLCBoaXQsIHRvUmVnRXhwLCBtYXRjaFN0YWNrVHJhY2VdO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBkZWJ1Zy1jdXJyZW50LWlubGluZS1zY3JpcHRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc2NyaXB0bGV0IGlzIGJhc2ljYWxseSB0aGUgc2FtZSBhcyBbYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0XSgjYWJvcnQtY3VycmVudC1pbmxpbmUtc2NyaXB0KSwgYnV0IGluc3RlYWQgb2YgYWJvcnRpbmcgaXQgc3RhcnRzIHRoZSBkZWJ1Z2dlci5cbiAqXG4gKiAqKkl0IGlzIG5vdCBzdXBwb3NlZCB0byBiZSB1c2VkIGluIHByb2R1Y3Rpb24gZmlsdGVyIGxpc3RzISoqXG4gKlxuICogKipTeW50YXgqKlxuICpgYGBcbiAqICEgQWJvcnRzIHNjcmlwdCB3aGVuIGl0IHRyaWVzIHRvIGFjY2VzcyBgd2luZG93LmFsZXJ0YFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnZGVidWctY3VycmVudC1pbmxpbmUtc2NyaXB0JywgJ2FsZXJ0JylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBkZWJ1Z0N1cnJlbnRJbmxpbmVTY3JpcHQoc291cmNlLCBwcm9wZXJ0eSkge1xuICB2YXIgc2VhcmNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICB2YXIgc2VhcmNoUmVnZXhwID0gdG9SZWdFeHAoc2VhcmNoKTtcbiAgdmFyIHJpZCA9IHJhbmRvbUlkKCk7XG5cbiAgdmFyIGdldEN1cnJlbnRTY3JpcHQgPSBmdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0KCkge1xuICAgIGlmICgnY3VycmVudFNjcmlwdCcgaW4gZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcbiAgICB9XG5cbiAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICByZXR1cm4gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIHZhciBvdXJTY3JpcHQgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG5cbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgdmFyIHNjcmlwdEVsID0gZ2V0Q3VycmVudFNjcmlwdCgpO1xuXG4gICAgaWYgKHNjcmlwdEVsIGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQgJiYgc2NyaXB0RWwudGV4dENvbnRlbnQubGVuZ3RoID4gMCAmJiBzY3JpcHRFbCAhPT0gb3VyU2NyaXB0ICYmICghc2VhcmNoIHx8IHNlYXJjaFJlZ2V4cC50ZXN0KHNjcmlwdEVsLnRleHRDb250ZW50KSkpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNldENoYWluUHJvcEFjY2VzcyA9IGZ1bmN0aW9uIHNldENoYWluUHJvcEFjY2Vzcyhvd25lciwgcHJvcGVydHkpIHtcbiAgICB2YXIgY2hhaW5JbmZvID0gZ2V0UHJvcGVydHlJbkNoYWluKG93bmVyLCBwcm9wZXJ0eSk7XG4gICAgdmFyIGJhc2UgPSBjaGFpbkluZm8uYmFzZTtcbiAgICB2YXIgcHJvcCA9IGNoYWluSW5mby5wcm9wLFxuICAgICAgICBjaGFpbiA9IGNoYWluSW5mby5jaGFpbjtcblxuICAgIGlmIChjaGFpbikge1xuICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uIHNldHRlcihhKSB7XG4gICAgICAgIGJhc2UgPSBhO1xuXG4gICAgICAgIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgc2V0Q2hhaW5Qcm9wQWNjZXNzKGEsIGNoYWluKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG93bmVyLCBwcm9wLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IHNldHRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IGJhc2VbcHJvcF07XG4gICAgc2V0UHJvcGVydHlBY2Nlc3MoYmFzZSwgcHJvcCwge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgc2V0Q2hhaW5Qcm9wQWNjZXNzKHdpbmRvdywgcHJvcGVydHkpO1xuICB3aW5kb3cub25lcnJvciA9IGNyZWF0ZU9uRXJyb3JIYW5kbGVyKHJpZCkuYmluZCgpO1xufVxuZGVidWdDdXJyZW50SW5saW5lU2NyaXB0Lm5hbWVzID0gWydkZWJ1Zy1jdXJyZW50LWlubGluZS1zY3JpcHQnXTtcbmRlYnVnQ3VycmVudElubGluZVNjcmlwdC5pbmplY3Rpb25zID0gW3JhbmRvbUlkLCBzZXRQcm9wZXJ0eUFjY2VzcywgZ2V0UHJvcGVydHlJbkNoYWluLCB0b1JlZ0V4cCwgY3JlYXRlT25FcnJvckhhbmRsZXIsIGhpdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IHJlbW92ZS1hdHRyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcyBmcm9tIERPTSBub2Rlcy4gVGhpcyBzY3JpcHRsZXQgcnVucyBvbmNlIHdoZW4gdGhlIHBhZ2UgbG9hZHNcbiAqIGFuZCBhZnRlciB0aGF0IHBlcmlvZGljYWxseSBpbiBvcmRlciB0byBET00gdHJlZSBjaGFuZ2VzLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I3JlbW92ZS1hdHRyanMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtYXR0cicsIGF0dHJzWywgc2VsZWN0b3JdKVxuICogYGBgXG4gKlxuICogLSBgYXR0cnNgIOKAlCByZXF1aXJlZCwgYXR0cmlidXRlIG9yIGxpc3Qgb2YgYXR0cmlidXRlcyBqb2luZWQgYnkgJ3wnXG4gKiAtIGBzZWxlY3RvcmAg4oCUIG9wdGlvbmFsLCBDU1Mgc2VsZWN0b3IsIHNwZWNpZmllcyBET00gbm9kZXMgZnJvbSB3aGljaCB0aGUgYXR0cmlidXRlcyB3aWxsIGJlIHJlbW92ZWRcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuICBSZW1vdmVzIGJ5IGF0dHJpYnV0ZVxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3JlbW92ZS1hdHRyJywgJ2V4YW1wbGV8dGVzdCcpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIGBgYGh0bWxcbiAqICAgICA8IS0tIGJlZm9yZSAgLS0+XG4gKiAgICAgPGRpdiBleGFtcGxlPVwidHJ1ZVwiIHRlc3Q9XCJ0cnVlXCI+U29tZSB0ZXh0PC9kaXY+XG4gKlxuICogICAgIDwhLS0gYWZ0ZXIgLS0+XG4gKiAgICAgPGRpdj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICBgYGBcbiAqXG4gKiAyLiBSZW1vdmVzIHdpdGggc3BlY2lmaWVkIHNlbGVjdG9yXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWF0dHInLCAnZXhhbXBsZScsICdkaXZbY2xhc3M9XCJpbm5lclwiXScpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIGBgYGh0bWxcbiAqICAgICA8IS0tIGJlZm9yZSAtLT5cbiAqICAgICA8ZGl2IGNsYXNzPVwid3JhcHBlclwiIGV4YW1wbGU9XCJ0cnVlXCI+XG4gKiAgICAgICAgIDxkaXYgY2xhc3M9XCJpbm5lclwiIGV4YW1wbGU9XCJ0cnVlXCI+U29tZSB0ZXh0PC9kaXY+XG4gKiAgICAgPC9kaXY+XG4gKlxuICogICAgIDwhLS0gYWZ0ZXIgLS0+XG4gKiAgICAgPGRpdiBjbGFzcz1cIndyYXBwZXJcIiBleGFtcGxlPVwidHJ1ZVwiPlxuICogICAgICAgICA8ZGl2IGNsYXNzPVwiaW5uZXJcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQXR0cihzb3VyY2UsIGF0dHJzLCBzZWxlY3Rvcikge1xuICBpZiAoIWF0dHJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXR0cnMgPSBhdHRycy5zcGxpdCgvXFxzKlxcfFxccyovKTtcblxuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgc2VsZWN0b3IgPSBcIltcIi5jb25jYXQoYXR0cnMuam9pbignXSxbJyksIFwiXVwiKTtcbiAgfVxuXG4gIHZhciBybWF0dHIgPSBmdW5jdGlvbiBybWF0dHIoKSB7XG4gICAgdmFyIG5vZGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgIH1cbiAgfTtcblxuICBybWF0dHIoKTsgLy8gJ3RydWUnIGZvciBvYnNlcnZpbmcgYXR0cmlidXRlc1xuXG4gIG9ic2VydmVET01DaGFuZ2VzKHJtYXR0ciwgdHJ1ZSk7XG59XG5yZW1vdmVBdHRyLm5hbWVzID0gWydyZW1vdmUtYXR0cicsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidyZW1vdmUtYXR0ci5qcycsICd1Ym8tcmVtb3ZlLWF0dHIuanMnLCAncmEuanMnLCAndWJvLXJhLmpzJywgJ3Viby1yZW1vdmUtYXR0cicsICd1Ym8tcmEnXTtcbnJlbW92ZUF0dHIuaW5qZWN0aW9ucyA9IFtoaXQsIG9ic2VydmVET01DaGFuZ2VzXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgcmVtb3ZlLWNsYXNzXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgY2xhc3NlcyBmcm9tIERPTSBub2Rlcy4gVGhpcyBzY3JpcHRsZXQgcnVucyBvbmNlIGFmdGVyIHRoZSBwYWdlIGxvYWRzXG4gKiBhbmQgYWZ0ZXIgdGhhdCBwZXJpb2RpY2FsbHkgaW4gb3JkZXIgdG8gRE9NIHRyZWUgY2hhbmdlcy5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNyZW1vdmUtY2xhc3Nqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3JlbW92ZS1jbGFzcycsIGNsYXNzZXNbLCBzZWxlY3Rvcl0pXG4gKiBgYGBcbiAqXG4gKiAtIGBjbGFzc2VzYCDigJQgcmVxdWlyZWQsIGNsYXNzIG9yIGxpc3Qgb2YgY2xhc3NlcyBzZXBhcmF0ZWQgYnkgJ3wnXG4gKiAtIGBzZWxlY3RvcmAg4oCUIG9wdGlvbmFsLCBDU1Mgc2VsZWN0b3IsIHNwZWNpZmllcyBET00gbm9kZXMgZnJvbSB3aGljaCB0aGUgY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuXG4gKiBJZiB0aGVyZSBpcyBubyBgc2VsZWN0b3JgLCBlYWNoIGNsYXNzIG9mIGBjbGFzc2VzYCBpbmRlcGVuZGVudGx5IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGFsbCBub2RlcyB3aGljaCBoYXMgb25lXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiAxLiAgUmVtb3ZlcyBieSBjbGFzc2VzXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWNsYXNzJywgJ2V4YW1wbGV8dGVzdCcpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIGBgYGh0bWxcbiAqICAgICA8IS0tIGJlZm9yZSAgLS0+XG4gKiAgICAgPGRpdiBpZD1cImZpcnN0XCIgY2xhc3M9XCJuaWNlIHRlc3RcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICA8ZGl2IGlkPVwic2Vjb25kXCIgY2xhc3M9XCJyYXJlIGV4YW1wbGUgZm9yIHRlc3RcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICA8ZGl2IGlkPVwidGhpcmRcIiBjbGFzcz1cInRlc3RpbmcgYmV0dGVyIGV4YW1wbGVcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqXG4gKiAgICAgPCEtLSBhZnRlciAtLT5cbiAqICAgICA8ZGl2IGlkPVwiZmlyc3RcIiBjbGFzcz1cIm5pY2VcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICA8ZGl2IGlkPVwic2Vjb25kXCIgY2xhc3M9XCJyYXJlIGZvclwiPlNvbWUgdGV4dDwvZGl2PlxuICogICAgIDxkaXYgaWQ9XCJ0aGlyZFwiIGNsYXNzPVwidGVzdGluZyBiZXR0ZXJcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICBgYGBcbiAqXG4gKiAyLiBSZW1vdmVzIHdpdGggc3BlY2lmaWVkIHNlbGVjdG9yXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWNsYXNzJywgJ2JyYW5kaW5nJywgJ2RpdltjbGFzc149XCJpbm5lclwiXScpXG4gKiAgICAgYGBgXG4gKlxuICogICAgIGBgYGh0bWxcbiAqICAgICA8IS0tIGJlZm9yZSAtLT5cbiAqICAgICA8ZGl2IGNsYXNzPVwid3JhcHBlciB0cnVlIGJyYW5kaW5nXCI+XG4gKiAgICAgICAgIDxkaXYgY2xhc3M9XCJpbm5lciBiYWQgYnJhbmRpbmdcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgPCEtLSBhZnRlciAtLT5cbiAqICAgICA8ZGl2IGNsYXNzPVwid3JhcHBlciB0cnVlIGJyYW5kaW5nXCI+XG4gKiAgICAgICAgIDxkaXYgY2xhc3M9XCJpbm5lciBiYWRcIj5Tb21lIHRleHQ8L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3Moc291cmNlLCBjbGFzc05hbWVzLCBzZWxlY3Rvcikge1xuICBpZiAoIWNsYXNzTmFtZXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5zcGxpdCgvXFxzKlxcfFxccyovKTtcbiAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuXG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICBzZWxlY3RvcnMgPSBjbGFzc05hbWVzLm1hcChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gXCIuXCIuY29uY2F0KGNsYXNzTmFtZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcmVtb3ZlQ2xhc3NIYW5kbGVyID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3NIYW5kbGVyKCkge1xuICAgIHZhciBub2RlcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGZvdW5kZWROb2RlcyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgZm91bmRlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzLmFkZChuKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgbm9kZXMuYWRkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGNsYXNzTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgIH1cbiAgfTtcblxuICByZW1vdmVDbGFzc0hhbmRsZXIoKTtcbiAgdmFyIENMQVNTX0FUVFJfTkFNRSA9IFsnY2xhc3MnXTsgLy8gJ3RydWUnIGZvciBvYnNlcnZpbmcgYXR0cmlidXRlc1xuICAvLyAnY2xhc3MnIGZvciBvYnNlcnZpbmcgb25seSBjbGFzc2VzXG5cbiAgb2JzZXJ2ZURPTUNoYW5nZXMocmVtb3ZlQ2xhc3NIYW5kbGVyLCB0cnVlLCBDTEFTU19BVFRSX05BTUUpO1xufVxucmVtb3ZlQ2xhc3MubmFtZXMgPSBbJ3JlbW92ZS1jbGFzcycsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidyZW1vdmUtY2xhc3MuanMnLCAndWJvLXJlbW92ZS1jbGFzcy5qcycsICdyYy5qcycsICd1Ym8tcmMuanMnLCAndWJvLXJlbW92ZS1jbGFzcycsICd1Ym8tcmMnXTtcbnJlbW92ZUNsYXNzLmluamVjdGlvbnMgPSBbaGl0LCBvYnNlcnZlRE9NQ2hhbmdlc107XG5cbi8qKlxuICogQHNjcmlwdGxldCBkaXNhYmxlLW5ld3RhYi1saW5rc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUHJldmVudHMgb3BlbmluZyBuZXcgdGFicyBhbmQgd2luZG93cyBpZiB0aGVyZSBpcyBgdGFyZ2V0YCBhdHRyaWJ1dGUgaW4gZWxlbWVudC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNkaXNhYmxlLW5ld3RhYi1saW5rc2pzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnZGlzYWJsZS1uZXd0YWItbGlua3MnKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZU5ld3RhYkxpbmtzKHNvdXJjZSkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldikge1xuICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQ7XG5cbiAgICB3aGlsZSAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICBpZiAodGFyZ2V0LmxvY2FsTmFtZSA9PT0gJ2EnICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3RhcmdldCcpKSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBoaXQoc291cmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIH1cbiAgfSk7XG59XG5kaXNhYmxlTmV3dGFiTGlua3MubmFtZXMgPSBbJ2Rpc2FibGUtbmV3dGFiLWxpbmtzJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ2Rpc2FibGUtbmV3dGFiLWxpbmtzLmpzJywgJ3Viby1kaXNhYmxlLW5ld3RhYi1saW5rcy5qcycsICd1Ym8tZGlzYWJsZS1uZXd0YWItbGlua3MnXTtcbmRpc2FibGVOZXd0YWJMaW5rcy5pbmplY3Rpb25zID0gW2hpdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGFkanVzdC1zZXRJbnRlcnZhbFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRqdXN0cyBpbnRlcnZhbCBmb3Igc3BlY2lmaWVkIHNldEludGVydmFsKCkgY2FsbGJhY2tzLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHNjcmlwdGxldDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I25hbm8tc2V0aW50ZXJ2YWwtYm9vc3RlcmpzLVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldEludGVydmFsJ1ssIG1hdGNoIFssIGludGVydmFsWywgYm9vc3RdXV0pXG4gKiBgYGBcbiAqXG4gKiAtIGBtYXRjaGAgLSBvcHRpb25hbCwgc3RyaW5nL3JlZ3VsYXIgZXhwcmVzc2lvbiwgbWF0Y2hpbmcgaW4gc3RyaW5naWZpZWQgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIC0gYGludGVydmFsYCAtIG9wdGlvbmFsLCBkZWZhdWx0cyB0byAxMDAwLCBtYXRjaGluZyBzZXRJbnRlcnZhbCBkZWxheTsgZGVjaW1hbCBpbnRlZ2VyIE9SICcqJyBmb3IgYW55IGRlbGF5XG4gKiAtIGBib29zdGAgLSBvcHRpb25hbCwgZGVmYXVsdCB0byAwLjA1LCBmbG9hdCwgY2FwcGVkIGF0IDUwIHRpbWVzIGZvciB1cCBhbmQgZG93biAoMC4wMi4uLjUwKSwgaW50ZXJ2YWwgbXVsdGlwbGllclxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gQWRqdXN0IGFsbCBzZXRJbnRlcnZhbCgpIHgyMCB0aW1lcyB3aGVyZSBpbnRlcnZhbCBlcXVhbCAxMDAwbXM6XG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldEludGVydmFsJylcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBBZGp1c3QgYWxsIHNldEludGVydmFsKCkgeDIwIHRpbWVzIHdoZXJlIGNhbGxiYWNrIG1hdGhlZCB3aXRoIGBleGFtcGxlYCBhbmQgaW50ZXJ2YWwgZXF1YWwgMTAwMG1zXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldEludGVydmFsJywgJ2V4YW1wbGUnKVxuICogICAgIGBgYFxuICpcbiAqIDMuIEFkanVzdCBhbGwgc2V0SW50ZXJ2YWwoKSB4MjAgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0aGVkIHdpdGggYGV4YW1wbGVgIGFuZCBpbnRlcnZhbCBlcXVhbCA0MDBtc1xuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRJbnRlcnZhbCcsICdleGFtcGxlJywgJzQwMCcpXG4gKiAgICAgYGBgXG4gKlxuICogNC4gU2xvdyBkb3duIHNldEludGVydmFsKCkgeDIgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0Y2hlZCB3aXRoIGBleGFtcGxlYCBhbmQgaW50ZXJ2YWwgZXF1YWwgMTAwMG1zXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldEludGVydmFsJywgJ2V4YW1wbGUnLCAnJywgJzInKVxuICogICAgIGBgYFxuICogNS4gQWRqdXN0IGFsbCBzZXRJbnRlcnZhbCgpIHg1MCB0aW1lcyB3aGVyZSBpbnRlcnZhbCBlcXVhbCAyMDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnLCAnJywgJzIwMDAnLCAnMC4wMicpXG4gKiAgICAgYGBgXG4gKiA2LiBBZGp1c3QgYWxsIHNldEludGVydmFsKCkgeDUwIHRpbWVzIHdoZXJlIGludGVydmFsIGlzIHJhbmRvbWl6ZWRcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0SW50ZXJ2YWwnLCAnJywgJyonLCAnMC4wMicpXG4gKiAgICAgYGBgXG4gKi9cblxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbmZ1bmN0aW9uIGFkanVzdFNldEludGVydmFsKHNvdXJjZSwgbWF0Y2gsIGludGVydmFsLCBib29zdCkge1xuICB2YXIgbmF0aXZlU2V0SW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWw7XG4gIHZhciBtYXRjaFJlZ2V4cCA9IHRvUmVnRXhwKG1hdGNoKTtcblxuICB2YXIgaW50ZXJ2YWxXcmFwcGVyID0gZnVuY3Rpb24gaW50ZXJ2YWxXcmFwcGVyKGNiLCBkKSB7XG4gICAgaWYgKG1hdGNoUmVnZXhwLnRlc3QoY2IudG9TdHJpbmcoKSkgJiYgaXNEZWxheU1hdGNoZWQoaW50ZXJ2YWwsIGQpKSB7XG4gICAgICBkICo9IGdldEJvb3N0TXVsdGlwbGllcihib29zdCk7XG4gICAgICBoaXQoc291cmNlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlU2V0SW50ZXJ2YWwuYXBwbHkod2luZG93LCBbY2IsIGRdLmNvbmNhdChhcmdzKSk7XG4gIH07XG5cbiAgd2luZG93LnNldEludGVydmFsID0gaW50ZXJ2YWxXcmFwcGVyO1xufVxuYWRqdXN0U2V0SW50ZXJ2YWwubmFtZXMgPSBbJ2FkanVzdC1zZXRJbnRlcnZhbCcsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbiduYW5vLXNldEludGVydmFsLWJvb3N0ZXIuanMnLCAndWJvLW5hbm8tc2V0SW50ZXJ2YWwtYm9vc3Rlci5qcycsICduYW5vLXNpYi5qcycsICd1Ym8tbmFuby1zaWIuanMnLCAndWJvLW5hbm8tc2V0SW50ZXJ2YWwtYm9vc3RlcicsICd1Ym8tbmFuby1zaWInXTtcbmFkanVzdFNldEludGVydmFsLmluamVjdGlvbnMgPSBbaGl0LCB0b1JlZ0V4cCwgZ2V0Qm9vc3RNdWx0aXBsaWVyLCBpc0RlbGF5TWF0Y2hlZCwgbmF0aXZlSXNOYU4sIG5hdGl2ZUlzRmluaXRlLCBnZXRNYXRjaERlbGF5LCBnZXRXaWxkY2FyZFN5bWJvbCwgc2hvdWxkTWF0Y2hBbnlEZWxheV07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IGFkanVzdC1zZXRUaW1lb3V0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGp1c3RzIHRpbWVvdXQgZm9yIHNwZWNpZmllZCBzZXRUaW1vdXQoKSBjYWxsYmFja3MuXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjbmFuby1zZXR0aW1lb3V0LWJvb3N0ZXJqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRUaW1lb3V0J1ssIG1hdGNoIFssIHRpbWVvdXRbLCBib29zdF1dXSlcbiAqIGBgYFxuICpcbiAqIC0gYG1hdGNoYCAtIG9wdGlvbmFsLCBzdHJpbmcvcmVndWxhciBleHByZXNzaW9uLCBtYXRjaGluZyBpbiBzdHJpbmdpZmllZCBjYWxsYmFjayBmdW5jdGlvblxuICogLSBgdGltZW91dGAgLSBvcHRpb25hbCwgZGVmYXVsdHMgdG8gMTAwMCwgbWF0Y2hpbmcgc2V0VGltb3V0IGRlbGF5OyBkZWNpbWFsIGludGVnZXIgT1IgJyonIGZvciBhbnkgZGVsYXlcbiAqIC0gYGJvb3N0YCAtIG9wdGlvbmFsLCBkZWZhdWx0IHRvIDAuMDUsIGZsb2F0LCBjYXBwZWQgYXQgNTAgdGltZXMgZm9yIHVwIGFuZCBkb3duICgwLjAyLi4uNTApLCB0aW1lb3V0IG11bHRpcGxpZXJcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIEFkanVzdCBhbGwgc2V0VGltZW91dCgpIHgyMCB0aW1lcyB3aGVyZSB0aW1lb3V0IGVxdWFsIDEwMDBtczpcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0VGltZW91dCcpXG4gKiAgICAgYGBgXG4gKlxuICogMi4gQWRqdXN0IGFsbCBzZXRUaW1lb3V0KCkgeDIwIHRpbWVzIHdoZXJlIGNhbGxiYWNrIG1hdGhlZCB3aXRoIGBleGFtcGxlYCBhbmQgdGltZW91dCBlcXVhbCAxMDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0VGltZW91dCcsICdleGFtcGxlJylcbiAqICAgICBgYGBcbiAqXG4gKiAzLiBBZGp1c3QgYWxsIHNldFRpbWVvdXQoKSB4MjAgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0aGVkIHdpdGggYGV4YW1wbGVgIGFuZCB0aW1lb3V0IGVxdWFsIDQwMG1zXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldFRpbWVvdXQnLCAnZXhhbXBsZScsICc0MDAnKVxuICogICAgIGBgYFxuICpcbiAqIDQuIFNsb3cgZG93biBzZXRUaW1lb3V0KCkgeDIgdGltZXMgd2hlcmUgY2FsbGJhY2sgbWF0Y2hlZCB3aXRoIGBleGFtcGxlYCBhbmQgdGltZW91dCBlcXVhbCAxMDAwbXNcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdhZGp1c3Qtc2V0VGltZW91dCcsICdleGFtcGxlJywgJycsICcyJylcbiAqICAgICBgYGBcbiAqIDUuIEFkanVzdCBhbGwgc2V0VGltZW91dCgpIHg1MCB0aW1lcyB3aGVyZSB0aW1lb3V0IGVxdWFsIDIwMDBtc1xuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2FkanVzdC1zZXRUaW1lb3V0JywgJycsICcyMDAwJywgJzAuMDInKVxuICogICAgIGBgYFxuICogNi4gQWRqdXN0IGFsbCBzZXRUaW1lb3V0KCkgeDIwIHRpbWVzIHdoZXJlIGNhbGxiYWNrIG1hdGhlZCB3aXRoIGB0ZXN0YCBhbmQgdGltZW91dCBpcyByYW5kb21pemVkXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnYWRqdXN0LXNldFRpbWVvdXQnLCAndGVzdCcsICcqJylcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gYWRqdXN0U2V0VGltZW91dChzb3VyY2UsIG1hdGNoLCB0aW1lb3V0LCBib29zdCkge1xuICB2YXIgbmF0aXZlU2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuICB2YXIgbWF0Y2hSZWdleHAgPSB0b1JlZ0V4cChtYXRjaCk7XG5cbiAgdmFyIHRpbWVvdXRXcmFwcGVyID0gZnVuY3Rpb24gdGltZW91dFdyYXBwZXIoY2IsIGQpIHtcbiAgICBpZiAobWF0Y2hSZWdleHAudGVzdChjYi50b1N0cmluZygpKSAmJiBpc0RlbGF5TWF0Y2hlZCh0aW1lb3V0LCBkKSkge1xuICAgICAgZCAqPSBnZXRCb29zdE11bHRpcGxpZXIoYm9vc3QpO1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVNldFRpbWVvdXQuYXBwbHkod2luZG93LCBbY2IsIGRdLmNvbmNhdChhcmdzKSk7XG4gIH07XG5cbiAgd2luZG93LnNldFRpbWVvdXQgPSB0aW1lb3V0V3JhcHBlcjtcbn1cbmFkanVzdFNldFRpbWVvdXQubmFtZXMgPSBbJ2FkanVzdC1zZXRUaW1lb3V0JywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25hbm8tc2V0VGltZW91dC1ib29zdGVyLmpzJywgJ3Viby1uYW5vLXNldFRpbWVvdXQtYm9vc3Rlci5qcycsICduYW5vLXN0Yi5qcycsICd1Ym8tbmFuby1zdGIuanMnLCAndWJvLW5hbm8tc2V0VGltZW91dC1ib29zdGVyJywgJ3Viby1uYW5vLXN0YiddO1xuYWRqdXN0U2V0VGltZW91dC5pbmplY3Rpb25zID0gW2hpdCwgdG9SZWdFeHAsIGdldEJvb3N0TXVsdGlwbGllciwgaXNEZWxheU1hdGNoZWQsIG5hdGl2ZUlzTmFOLCBuYXRpdmVJc0Zpbml0ZSwgZ2V0TWF0Y2hEZWxheSwgZ2V0V2lsZGNhcmRTeW1ib2wsIHNob3VsZE1hdGNoQW55RGVsYXldO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogQHNjcmlwdGxldCBkaXItc3RyaW5nXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBXcmFwcyB0aGUgYGNvbnNvbGUuZGlyYCBBUEkgdG8gY2FsbCB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgdGhlIGFyZ3VtZW50LlxuICogVGhlcmUgYXJlIHNldmVyYWwgYWRibG9jayBjaXJjdW12ZW50aW9uIHN5c3RlbXMgdGhhdCBkZXRlY3QgYnJvd3NlciBkZXZ0b29sc1xuICogYW5kIGhpZGUgdGhlbXNlbHZlcy4gVGhlcmVmb3JlLCBpZiB3ZSBmb3JjZSB0aGVtIHRvIHRoaW5rXG4gKiB0aGF0IGRldnRvb2xzIGFyZSBvcGVuICh1c2luZyB0aGlzIHNjcmNpcHRsZXQpLFxuICogaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc2FibGUgdGhlIGFkYmxvY2sgY2lyY3VtdmVudGlvbiBzY3JpcHQuXG4gKlxuICogUmVsYXRlZCBBQlAgc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FkYmxvY2twbHVzL2FkYmxvY2twbHVzY29yZS9ibG9iLzZiMmEzMDkwNTRjYzIzNDMyMTAyYjg1ZDEzZjEyNTU5NjM5ZWY0OTUvbGliL2NvbnRlbnQvc25pcHBldHMuanMjTDc2NlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnZGlyLXN0cmluZydbLCB0aW1lc10pXG4gKiBgYGBcbiAqIC0gYHRpbWVzYCAtIG9wdGlvbmFsLCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIGNhbGwgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIHRoZSBhcmd1bWVudCB0byBgY29uc29sZS5kaXJgXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogISBSdW4gMiB0aW1lc1xuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnZGlyLXN0cmluZycsICcyJylcbiAqIGBgYFxuICovXG5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5mdW5jdGlvbiBkaXJTdHJpbmcoc291cmNlLCB0aW1lcykge1xuICB2YXIgX2NvbnNvbGUgPSBjb25zb2xlLFxuICAgICAgZGlyID0gX2NvbnNvbGUuZGlyO1xuICB0aW1lcyA9IHBhcnNlSW50KHRpbWVzLCAxMCk7XG5cbiAgZnVuY3Rpb24gZGlyV3JhcHBlcihvYmplY3QpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgdGVtcDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZXM7IGkgKz0gMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgdGVtcCA9IFwiXCIuY29uY2F0KG9iamVjdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkaXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRpci5jYWxsKHRoaXMsIG9iamVjdCk7XG4gICAgfVxuXG4gICAgaGl0KHNvdXJjZSwgdGVtcCk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuXG4gIGNvbnNvbGUuZGlyID0gZGlyV3JhcHBlcjtcbn1cbmRpclN0cmluZy5uYW1lcyA9IFsnZGlyLXN0cmluZycsICdhYnAtZGlyLXN0cmluZyddO1xuZGlyU3RyaW5nLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQganNvbi1wcnVuZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmVtb3ZlcyBzcGVjaWZpZWQgcHJvcGVydGllcyBmcm9tIHRoZSByZXN1bHQgb2YgY2FsbGluZyBKU09OLnBhcnNlIGFuZCByZXR1cm5zIHRoZSBjYWxsZXJcbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNqc29uLXBydW5lanMtXG4gKlxuICogUmVsYXRlZCBBQlAgc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FkYmxvY2twbHVzL2FkYmxvY2twbHVzY29yZS9ibG9iL21hc3Rlci9saWIvY29udGVudC9zbmlwcGV0cy5qcyNMMTI4NVxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnanNvbi1wcnVuZSdbLCBwcm9wc1RvUmVtb3ZlIFssIG9ibGlnYXRvcnlQcm9wcyBbLCBzdGFja11dXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BzVG9SZW1vdmVgIC0gb3B0aW9uYWwsIHN0cmluZyBvZiBzcGFjZS1zZXBhcmF0ZWQgcHJvcGVydGllcyB0byByZW1vdmVcbiAqIC0gYG9ibGlnYXRvcnlQcm9wc2AgLSBvcHRpb25hbCwgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCBwcm9wZXJ0aWVzIHdoaWNoIG11c3QgYmUgYWxsIHByZXNlbnQgZm9yIHRoZSBwcnVuaW5nIHRvIG9jY3VyXG4gKiAtIGBzdGFja2AgLSBvcHRpb25hbCwgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG11c3QgbWF0Y2ggdGhlIGN1cnJlbnQgZnVuY3Rpb24gY2FsbCBzdGFjayB0cmFjZVxuICpcbiAqID4gTm90ZSBwbGVhc2UgdGhhdCB5b3UgY2FuIHVzZSB3aWxkY2FyZCBgKmAgZm9yIGNoYWluIHByb3BlcnR5IG5hbWUuXG4gKiBlLmcuICdhZC4qLnNyYycgaW5zdGVhZCBvZiAnYWQuMC5zcmMgYWQuMS5zcmMgYWQuMi5zcmMgLi4uJ1xuICpcbiAqICoqRXhhbXBsZXMqKlxuICogMS4gUmVtb3ZlcyBwcm9wZXJ0eSBgZXhhbXBsZWAgZnJvbSB0aGUgcmVzdWx0cyBvZiBKU09OLnBhcnNlIGNhbGxcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJywgJ2V4YW1wbGUnKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgY2FsbCB3aWxsIHJldHVybiBgeyBvbmU6IDF9YFxuICpcbiAqICAgICBgYGBodG1sXG4gKiAgICAgSlNPTi5wYXJzZSgne1wib25lXCI6MSxcImV4YW1wbGVcIjp0cnVlfScpXG4gKiAgICAgYGBgXG4gKlxuICogMi4gSWYgdGhlcmUgYXJlIG5vIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGluIHRoZSByZXN1bHQgb2YgSlNPTi5wYXJzZSBjYWxsLCBwcnVuaW5nIHdpbGwgTk9UIG9jY3VyXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnanNvbi1wcnVuZScsICdvbmUnLCAnb2JsaWdhdG9yeVByb3AnKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgY2FsbCB3aWxsIHJldHVybiBgeyBvbmU6IDEsIHR3bzogMn1gXG4gKlxuICogICAgIGBgYGh0bWxcbiAqICAgICBKU09OLnBhcnNlKCd7XCJvbmVcIjoxLFwidHdvXCI6Mn0nKVxuICogICAgIGBgYFxuICpcbiAqIDMuIEEgcHJvcGVydHkgaW4gYSBsaXN0IG9mIHByb3BlcnRpZXMgY2FuIGJlIGEgY2hhaW4gb2YgcHJvcGVydGllc1xuICpcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJywgJ2EuYicsICdhZHBhdGgudXJsLmZpcnN0JylcbiAqICAgICBgYGBcbiAqXG4gKiA0LiBSZW1vdmVzIHByb3BlcnR5IGBjb250ZW50LmFkYCBmcm9tIHRoZSByZXN1bHRzIG9mIEpTT04ucGFyc2UgY2FsbCBpdCdzIGVycm9yIHN0YWNrIHRyYWNlIGNvbnRhaW5zIGB0ZXN0LmpzYFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ2pzb24tcHJ1bmUnLCAnY29udGVudC5hZCcsICcnLCAndGVzdC5qcycpXG4gKiAgICAgYGBgXG4gKlxuICogNS4gQSBwcm9wZXJ0eSBpbiBhIGxpc3Qgb2YgcHJvcGVydGllcyBjYW4gYmUgYSBjaGFpbiBvZiBwcm9wZXJ0aWVzIHdpdGggd2lsZGNhcmQgaW4gaXRcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnanNvbi1wcnVuZScsICdjb250ZW50LioubWVkaWEuc3JjJywgJ2NvbnRlbnQuKi5tZWRpYS5wcmVyb2xsJylcbiAqICAgICBgYGBcbiAqXG4gKiA2LiBDYWxsIHdpdGggbm8gYXJndW1lbnRzIHdpbGwgbG9nIHRoZSBjdXJyZW50IGhvc3RuYW1lIGFuZCBqc29uIHBheWxvYWQgYXQgdGhlIGNvbnNvbGVcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdqc29uLXBydW5lJylcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24ganNvblBydW5lKHNvdXJjZSwgcHJvcHNUb1JlbW92ZSwgcmVxdWlyZWRJbml0aWFsUHJvcHMsIHN0YWNrKSB7XG4gIGlmICghIXN0YWNrICYmICFtYXRjaFN0YWNrVHJhY2Uoc3RhY2ssIG5ldyBFcnJvcigpLnN0YWNrKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG5cbiAgdmFyIGxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gIHZhciBwcnVuZVBhdGhzID0gcHJvcHNUb1JlbW92ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzVG9SZW1vdmUgIT09ICcnID8gcHJvcHNUb1JlbW92ZS5zcGxpdCgvICsvKSA6IFtdO1xuICB2YXIgcmVxdWlyZWRQYXRocyA9IHJlcXVpcmVkSW5pdGlhbFByb3BzICE9PSB1bmRlZmluZWQgJiYgcmVxdWlyZWRJbml0aWFsUHJvcHMgIT09ICcnID8gcmVxdWlyZWRJbml0aWFsUHJvcHMuc3BsaXQoLyArLykgOiBbXTtcblxuICBmdW5jdGlvbiBpc1BydW5pbmdOZWVkZWQocm9vdCkge1xuICAgIGlmICghcm9vdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRQcm9jZXNzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXF1aXJlZFBhdGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgcmVxdWlyZWRQYXRoID0gcmVxdWlyZWRQYXRoc1tpXTtcbiAgICAgIHZhciBsYXN0TmVzdGVkUHJvcE5hbWUgPSByZXF1aXJlZFBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgICAgIHZhciBoYXNXaWxkY2FyZCA9IHJlcXVpcmVkUGF0aC5pbmRleE9mKCcuKi4nKSA+IC0xIHx8IHJlcXVpcmVkUGF0aC5pbmRleE9mKCcqLicpID4gLTEgfHwgcmVxdWlyZWRQYXRoLmluZGV4T2YoJy4qJykgPiAtMSB8fCByZXF1aXJlZFBhdGguaW5kZXhPZignLltdLicpID4gLTEgfHwgcmVxdWlyZWRQYXRoLmluZGV4T2YoJ1tdLicpID4gLTEgfHwgcmVxdWlyZWRQYXRoLmluZGV4T2YoJy5bXScpID4gLTE7IC8vIGlmIHRoZSBwYXRoIGhhcyB3aWxkY2FyZCwgZ2V0UHJvcGVydHlJbkNoYWluIHNob3VsZCAnbG9vayB0aHJvdWdoJyBjaGFpbiBwcm9wc1xuXG4gICAgICB2YXIgZGV0YWlscyA9IGdldFdpbGRjYXJkUHJvcGVydHlJbkNoYWluKHJvb3QsIHJlcXVpcmVkUGF0aCwgaGFzV2lsZGNhcmQpOyAvLyBzdGFydCB2YWx1ZSBvZiAnc2hvdWxkUHJvY2VzcycgZHVlIHRvIGNoZWNraW5nIGJlbG93XG5cbiAgICAgIHNob3VsZFByb2Nlc3MgPSAhaGFzV2lsZGNhcmQ7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkZXRhaWxzLmxlbmd0aDsgX2kgKz0gMSkge1xuICAgICAgICBpZiAoaGFzV2lsZGNhcmQpIHtcbiAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHdpbGRjYXJkLFxuICAgICAgICAgIC8vIGF0IGxlYXN0IG9uZSAofHwpIG9mIHByb3BzIGNoYWluIHNob3VsZCBiZSBwcmVzZW50IGluIG9iamVjdFxuICAgICAgICAgIHNob3VsZFByb2Nlc3MgPSAhKGRldGFpbHNbX2ldLmJhc2VbbGFzdE5lc3RlZFByb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB8fCBzaG91bGRQcm9jZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBlYWNoIG9uZSAoJiYpIG9mIHRoZW0gc2hvdWxkIGJlIHRoZXJlXG4gICAgICAgICAgc2hvdWxkUHJvY2VzcyA9ICEoZGV0YWlsc1tfaV0uYmFzZVtsYXN0TmVzdGVkUHJvcE5hbWVdID09PSB1bmRlZmluZWQpICYmIHNob3VsZFByb2Nlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkUHJvY2VzcztcbiAgfVxuICAvKipcbiAgICogUHJ1bmVzIHByb3BlcnRpZXMgb2YgJ3Jvb3QnIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gcm9vdFxuICAgKi9cblxuXG4gIHZhciBqc29uUHJ1bmVyID0gZnVuY3Rpb24ganNvblBydW5lcihyb290KSB7XG4gICAgaWYgKHBydW5lUGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsb2cod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLCByb290KTtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoaXNQcnVuaW5nTmVlZGVkKHJvb3QpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgIH0gLy8gaWYgcHJ1bmluZyBpcyBuZWVkZWQsIHdlIGNoZWNrIGV2ZXJ5IGlucHV0IHBhdGhUb1JlbW92ZVxuICAgICAgLy8gYW5kIGRlbGV0ZSBpdCBpZiByb290IGhhcyBpdFxuXG5cbiAgICAgIHBydW5lUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgb3duZXJPYmpBcnIgPSBnZXRXaWxkY2FyZFByb3BlcnR5SW5DaGFpbihyb290LCBwYXRoLCB0cnVlKTtcbiAgICAgICAgb3duZXJPYmpBcnIuZm9yRWFjaChmdW5jdGlvbiAob3duZXJPYmopIHtcbiAgICAgICAgICBpZiAob3duZXJPYmogIT09IHVuZGVmaW5lZCAmJiBvd25lck9iai5iYXNlKSB7XG4gICAgICAgICAgICBkZWxldGUgb3duZXJPYmouYmFzZVtvd25lck9iai5wcm9wXTtcbiAgICAgICAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2coZS50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfTtcblxuICB2YXIgbmF0aXZlSlNPTlBhcnNlID0gSlNPTi5wYXJzZTtcblxuICB2YXIganNvblBhcnNlV3JhcHBlciA9IGZ1bmN0aW9uIGpzb25QYXJzZVdyYXBwZXIoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIGRlYWxpbmcgd2l0aCBzdHJpbmdpZmllZCBqc29uIGluIGFyZ3MsIHdoaWNoIHNob3VsZCBiZSBwYXJzZWQuXG4gICAgLy8gc28gd2UgY2FsbCBuYXRpdmVKU09OUGFyc2UgYXMgSlNPTi5wYXJzZSB3aGljaCBpcyBib3VuZCB0byBKU09OIG9iamVjdFxuICAgIHZhciByb290ID0gbmF0aXZlSlNPTlBhcnNlLmFwcGx5KEpTT04sIGFyZ3MpO1xuICAgIHJldHVybiBqc29uUHJ1bmVyKHJvb3QpO1xuICB9OyAvLyBKU09OLnBhcnNlIG1vY2tpbmdcblxuXG4gIGpzb25QYXJzZVdyYXBwZXIudG9TdHJpbmcgPSBuYXRpdmVKU09OUGFyc2UudG9TdHJpbmcuYmluZChuYXRpdmVKU09OUGFyc2UpO1xuICBKU09OLnBhcnNlID0ganNvblBhcnNlV3JhcHBlcjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcblxuICB2YXIgbmF0aXZlUmVzcG9uc2VKc29uID0gUmVzcG9uc2UucHJvdG90eXBlLmpzb247IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cbiAgdmFyIHJlc3BvbnNlSnNvbldyYXBwZXIgPSBmdW5jdGlvbiByZXNwb25zZUpzb25XcmFwcGVyKCkge1xuICAgIHZhciBwcm9taXNlID0gbmF0aXZlUmVzcG9uc2VKc29uLmFwcGx5KHRoaXMpO1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIGpzb25QcnVuZXIob2JqKTtcbiAgICB9KTtcbiAgfTsgLy8gZG8gbm90aGluZyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgUmVzcG9uc2UgKGUuZy4gSW50ZXJuZXQgRXhwbG9yZXIpXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNwb25zZVxuXG5cbiAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcblxuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5qc29uID0gcmVzcG9uc2VKc29uV3JhcHBlcjtcbn1cbmpzb25QcnVuZS5uYW1lcyA9IFsnanNvbi1wcnVuZScsIC8vIGFsaWFzZXMgYXJlIG5lZWRlZCBmb3IgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgc2NyaXB0bGV0IGNvbnZlcnRlZCBpbnRvIG91ciBzeW50YXhcbidqc29uLXBydW5lLmpzJywgJ3Viby1qc29uLXBydW5lLmpzJywgJ3Viby1qc29uLXBydW5lJywgJ2FicC1qc29uLXBydW5lJ107XG5qc29uUHJ1bmUuaW5qZWN0aW9ucyA9IFtoaXQsIG1hdGNoU3RhY2tUcmFjZSwgZ2V0V2lsZGNhcmRQcm9wZXJ0eUluQ2hhaW4sIHRvUmVnRXhwLCBnZXRXaWxkY2FyZFN5bWJvbF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IHByZXZlbnQtcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcmV2ZW50cyBhIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGNhbGxcbiAqIGlmIHRoZSB0ZXh0IG9mIHRoZSBjYWxsYmFjayBpcyBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHNlYXJjaCBzdHJpbmcgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCBgIWA7XG4gKiBvdGhlcndpc2UgbWlzbWF0Y2hlZCBjYWxscyBzaG91bGQgYmUgZGVmdXNlZC5cbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNuby1yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtaWZqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtcmVxdWVzdEFuaW1hdGlvbkZyYW1lJ1ssIHNlYXJjaF0pXG4gKiBgYGBcbiAqXG4gKiAtIGBzZWFyY2hgIC0gb3B0aW9uYWwsIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBJZiBzdGFydHMgd2l0aCBgIWAsIHNjcmlwdGxldCB3aWxsIG5vdCBtYXRjaCB0aGUgc3RyaW5naWZpZWQgY2FsbGJhY2sgYnV0IGFsbCBvdGhlciB3aWxsIGJlIGRlZnVzZWQuXG4gKiBJZiBkbyBub3Qgc3RhcnQgd2l0aCBgIWAsIHRoZSBzdHJpbmdpZmllZCBjYWxsYmFjayB3aWxsIGJlIG1hdGNoZWQuXG4gKlxuICogQ2FsbCB3aXRoIG5vIGFyZ3VtZW50IHdpbGwgbG9nIGFsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbHMgd2hpbGUgZGVidWdnaW5nLlxuICogU28gZG8gbm90IHVzZSB0aGUgc2NyaXB0bGV0IHdpdGhvdXQgYW55IHBhcmFtZXRlciBpbiBwcm9kdWN0aW9uIGZpbHRlciBsaXN0cy5cbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIFByZXZlbnRzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGNhbGxzIGlmIHRoZSBjYWxsYmFjayBtYXRjaGVzIGAvXFwudGVzdC9gLlxuICogICAgIGBgYGJhc2hcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXJlcXVlc3RBbmltYXRpb25GcmFtZScsICcvXFwudGVzdC8nKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIHRoZSBmb2xsb3dpbmcgY2FsbCB3aWxsIGJlIHByZXZlbnRlZDpcbiAqICAgICBgYGBqYXZhc2NyaXB0XG4gKiAgICAgdmFyIHRpbWVzID0gMDtcbiAqICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gY2hhbmdlKCkge1xuICogICAgICAgICB3aW5kb3cudGVzdCA9ICduZXcgdmFsdWUnO1xuICogICAgICAgICBpZiAodGltZXMgPCAyKSB7XG4gKiAgICAgICAgICAgICB0aW1lcyArPSAxO1xuICogICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNoYW5nZSk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICBgYGBcbiAqIDIuIFByZXZlbnRzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGNhbGxzIGlmICoqZG9lcyBub3QgbWF0Y2gqKiAnY2hlY2snLlxuICogICAgIGBgYGJhc2hcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LXJlcXVlc3RBbmltYXRpb25GcmFtZScsICchY2hlY2snKVxuICogICAgIGBgYFxuICpcbiAqICAgICBGb3IgaW5zdGFuY2UsIG9ubHkgdGhlIGZpcnN0IGNhbGwgd2lsbCBiZSBwcmV2ZW50ZWQ6XG4gKlxuICogICAgIGBgYGphdmFzY3JpcHRcbiAqICAgICB2YXIgdGltZXNGaXJzdCA9IDA7XG4gKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGNoYW5nZUZpcnN0KCkge1xuICogICAgICAgICB3aW5kb3cuY2hlY2sgPSAnc2hvdWxkIG5vdCBiZSBwcmV2ZW50ZWQnO1xuICogICAgICAgICBpZiAodGltZXNGaXJzdCA8IDIpIHtcbiAqICAgICAgICAgICAgIHRpbWVzRmlyc3QgKz0gMTtcbiAqICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjaGFuZ2VGaXJzdCk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdmFyIHRpbWVzU2Vjb25kID0gMDtcbiAqICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gY2hhbmdlU2Vjb25kKCkge1xuICogICAgICAgICB3aW5kb3cuc2Vjb25kID0gJ3Nob3VsZCBiZSBwcmV2ZW50ZWQnO1xuICogICAgICAgICBpZiAodGltZXNTZWNvbmQgPCAyKSB7XG4gKiAgICAgICAgICAgICB0aW1lc1NlY29uZCArPSAxO1xuICogICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNoYW5nZVNlY29uZCk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcHJldmVudFJlcXVlc3RBbmltYXRpb25GcmFtZShzb3VyY2UsIG1hdGNoKSB7XG4gIHZhciBuYXRpdmVSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyAvLyBsb2dzIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0byBjb25zb2xlIGlmIG5vIGFyZ3VtZW50cyBoYXZlIGJlZW4gc3BlY2lmaWVkXG5cbiAgdmFyIHNob3VsZExvZyA9IHR5cGVvZiBtYXRjaCA9PT0gJ3VuZGVmaW5lZCc7XG5cbiAgdmFyIF9wYXJzZU1hdGNoQXJnID0gcGFyc2VNYXRjaEFyZyhtYXRjaCksXG4gICAgICBpc0ludmVydGVkTWF0Y2ggPSBfcGFyc2VNYXRjaEFyZy5pc0ludmVydGVkTWF0Y2gsXG4gICAgICBtYXRjaFJlZ2V4cCA9IF9wYXJzZU1hdGNoQXJnLm1hdGNoUmVnZXhwO1xuXG4gIHZhciByYWZXcmFwcGVyID0gZnVuY3Rpb24gcmFmV3JhcHBlcihjYWxsYmFjaykge1xuICAgIHZhciBzaG91bGRQcmV2ZW50ID0gZmFsc2U7XG5cbiAgICBpZiAoc2hvdWxkTG9nKSB7XG4gICAgICB2YXIgbG9nTWVzc2FnZSA9IFwibG9nOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXFxcIlwiLmNvbmNhdChjYWxsYmFjay50b1N0cmluZygpLCBcIlxcXCIpXCIpO1xuICAgICAgaGl0KHNvdXJjZSwgbG9nTWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFByZXZlbnQgPSBtYXRjaFJlZ2V4cC50ZXN0KGNhbGxiYWNrLnRvU3RyaW5nKCkpICE9PSBpc0ludmVydGVkTWF0Y2g7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByZXZlbnQpIHtcbiAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlcXVlc3RBbmltYXRpb25GcmFtZShub29wRnVuYyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVJlcXVlc3RBbmltYXRpb25GcmFtZS5hcHBseSh3aW5kb3csIFtjYWxsYmFja10uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmV3JhcHBlcjtcbn1cbnByZXZlbnRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUubmFtZXMgPSBbJ3ByZXZlbnQtcmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgLy8gYWxpYXNlcyBhcmUgbmVlZGVkIGZvciBtYXRjaGluZyB0aGUgcmVsYXRlZCBzY3JpcHRsZXQgY29udmVydGVkIGludG8gb3VyIHN5bnRheFxuJ25vLXJlcXVlc3RBbmltYXRpb25GcmFtZS1pZi5qcycsICd1Ym8tbm8tcmVxdWVzdEFuaW1hdGlvbkZyYW1lLWlmLmpzJywgJ25vcmFmaWYuanMnLCAndWJvLW5vcmFmaWYuanMnLCAndWJvLW5vLXJlcXVlc3RBbmltYXRpb25GcmFtZS1pZicsICd1Ym8tbm9yYWZpZiddO1xucHJldmVudFJlcXVlc3RBbmltYXRpb25GcmFtZS5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmMsIHBhcnNlTWF0Y2hBcmcsIHRvUmVnRXhwLCBzdGFydHNXaXRoXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgc2V0LWNvb2tpZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0cyBhIGNvb2tpZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBhbmQgdmFsdWUuIENvb2tpZSBwYXRoIGRlZmF1bHRzIHRvIHJvb3QuXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdzZXQtY29va2llJywgbmFtZSwgdmFsdWUpXG4gKiBgYGBcbiAqXG4gKiAtIGBuYW1lYCAtIHJlcXVpcmVkLCBjb29raWUgbmFtZSB0byBiZSBzZXRcbiAqIC0gYHZhbHVlYCAtIHJlcXVpcmVkLCBjb29raWUgdmFsdWU7IHBvc3NpYmxlIHZhbHVlczpcbiAqICAgICAtIG51bWJlciBgPj0gMCAmJiA8PSAxNWBcbiAqICAgICAtIG9uZSBvZiB0aGUgcHJlZGVmaW5lZCBjb25zdGFudHM6XG4gKiAgICAgICAgIC0gYHRydWVgIC8gYFRydWVgXG4gKiAgICAgICAgIC0gYGZhbHNlYCAvIGBGYWxzZWBcbiAqICAgICAgICAgLSBgeWVzYCAvIGBZZXNgIC8gYFlgXG4gKiAgICAgICAgIC0gYG5vYFxuICogICAgICAgICAtIGBva2AgLyBgT0tgXG4gKlxuICogKipFeGFtcGxlcyoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb29raWUnLCAnUmVhZGx5Q29va2llQ29uc2VudCcsICcxJ1xuICpcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb29raWUnLCAnZ2Rwci1zZXR0aW5ncy1jb29raWUnLCAndHJ1ZScpXG4gKiBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gc2V0Q29va2llKHNvdXJjZSwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGNvb2tpZURhdGEgPSBwcmVwYXJlQ29va2llKG5hbWUsIHZhbHVlKTtcblxuICBpZiAoY29va2llRGF0YSkge1xuICAgIGhpdChzb3VyY2UpO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZURhdGE7XG4gIH1cbn1cbnNldENvb2tpZS5uYW1lcyA9IFsnc2V0LWNvb2tpZSddO1xuc2V0Q29va2llLmluamVjdGlvbnMgPSBbaGl0LCBuYXRpdmVJc05hTiwgcHJlcGFyZUNvb2tpZV07XG5cbi8qKlxuICogQHNjcmlwdGxldCBzZXQtY29va2llLXJlbG9hZFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0cyBhIGNvb2tpZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBhbmQgdmFsdWUsIGFuZCB0aGVuIHJlbG9hZHMgdGhlIGN1cnJlbnQgcGFnZS5cbiAqIElmIHJlbG9hZGluZyBvcHRpb24gaXMgbm90IG5lZWRlZCwgdXNlIFtzZXQtY29va2llXSgjc2V0LWNvb2tpZSkgc2NyaXB0bGV0LlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvb2tpZS1yZWxvYWQnLCBuYW1lLCB2YWx1ZSlcbiAqIGBgYFxuICpcbiAqIC0gYG5hbWVgIC0gcmVxdWlyZWQsIGNvb2tpZSBuYW1lIHRvIGJlIHNldFxuICogLSBgdmFsdWVgIC0gcmVxdWlyZWQsIGNvb2tpZSB2YWx1ZTsgcG9zc2libGUgdmFsdWVzOlxuICogICAgIC0gbnVtYmVyIGA+PSAwICYmIDw9IDE1YFxuICogICAgIC0gb25lIG9mIHRoZSBwcmVkZWZpbmVkIGNvbnN0YW50czpcbiAqICAgICAgICAgLSBgdHJ1ZWAgLyBgVHJ1ZWBcbiAqICAgICAgICAgLSBgZmFsc2VgIC8gYEZhbHNlYFxuICogICAgICAgICAtIGB5ZXNgIC8gYFllc2AgLyBgWWBcbiAqICAgICAgICAgLSBgbm9gXG4gKiAgICAgICAgIC0gYG9rYCAvIGBPS2BcbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnc2V0LWNvb2tpZS1yZWxvYWQnLCAnY2hlY2tpbmcnLCAnb2snKVxuICpcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3NldC1jb29raWUtcmVsb2FkJywgJ2dkcHItc2V0dGluZ3MtY29va2llJywgJzEnKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gc2V0Q29va2llUmVsb2FkKHNvdXJjZSwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlzQ29va2llQWxyZWFkeVNldCA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpLnNvbWUoZnVuY3Rpb24gKGNvb2tpZVN0cikge1xuICAgIHZhciBwb3MgPSBjb29raWVTdHIuaW5kZXhPZignPScpO1xuXG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29va2llTmFtZSA9IGNvb2tpZVN0ci5zbGljZSgwLCBwb3MpLnRyaW0oKTtcbiAgICB2YXIgY29va2llVmFsdWUgPSBjb29raWVTdHIuc2xpY2UocG9zICsgMSkudHJpbSgpO1xuICAgIHJldHVybiBuYW1lID09PSBjb29raWVOYW1lICYmIHZhbHVlID09PSBjb29raWVWYWx1ZTtcbiAgfSk7XG4gIHZhciBzaG91bGRSZWxvYWQgPSAhaXNDb29raWVBbHJlYWR5U2V0O1xuICB2YXIgY29va2llRGF0YSA9IHByZXBhcmVDb29raWUobmFtZSwgdmFsdWUpO1xuXG4gIGlmIChjb29raWVEYXRhKSB7XG4gICAgaGl0KHNvdXJjZSk7XG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llRGF0YTtcblxuICAgIGlmIChzaG91bGRSZWxvYWQpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gIH1cbn1cbnNldENvb2tpZVJlbG9hZC5uYW1lcyA9IFsnc2V0LWNvb2tpZS1yZWxvYWQnXTtcbnNldENvb2tpZVJlbG9hZC5pbmplY3Rpb25zID0gW2hpdCwgbmF0aXZlSXNOYU4sIHByZXBhcmVDb29raWVdO1xuXG4vKipcbiAqIEBzY3JpcHRsZXQgaGlkZS1pbi1zaGFkb3ctZG9tXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBIaWRlcyBlbGVtZW50cyBpbnNpZGUgb3BlbiBzaGFkb3cgRE9NIGVsZW1lbnRzLlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgnaGlkZS1pbi1zaGFkb3ctZG9tJywgc2VsZWN0b3JbLCBiYXNlU2VsZWN0b3JdKVxuICogYGBgXG4gKlxuICogLSBgc2VsZWN0b3JgIOKAlCByZXF1aXJlZCwgQ1NTIHNlbGVjdG9yIG9mIGVsZW1lbnQgaW4gc2hhZG93LWRvbSB0byBoaWRlXG4gKiAtIGBiYXNlU2VsZWN0b3JgIOKAlCBvcHRpb25hbCwgc2VsZWN0b3Igb2Ygc3BlY2lmaWMgcGFnZSBET00gZWxlbWVudCxcbiAqIG5hcnJvd3MgZG93biB0aGUgcGFydCBvZiB0aGUgcGFnZSBET00gd2hlcmUgc2hhZG93LWRvbSBob3N0IHN1cHBvc2VkIHRvIGJlLFxuICogZGVmYXVsdHMgdG8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gKlxuICogPiBgYmFzZVNlbGVjdG9yYCBzaG91bGQgbWF0Y2ggZWxlbWVudCBvZiB0aGUgcGFnZSBET00sIGJ1dCBub3Qgb2Ygc2hhZG93IERPTVxuICpcbiAqICoqRXhhbXBsZXMqKlxuICogYGBgXG4gKiAhIGhpZGVzIG1lbnUgYmFyXG4gKiB2aXJ1c3RvdGFsLmNvbSMlIy8vc2NyaXB0bGV0KCdoaWRlLWluLXNoYWRvdy1kb20nLCAnaXJvbi1wYWdlcycsICd2dC12aXJ1c3RvdGFsLWFwcCcpXG4gKlxuICogISBoaWRlcyBmbG9hdGluZyBlbGVtZW50XG4gKiB2aXJ1c3RvdGFsLmNvbSMlIy8vc2NyaXB0bGV0KCdoaWRlLWluLXNoYWRvdy1kb20nLCAndnQtdWktY29udGFjdC1mYWInKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gaGlkZUluU2hhZG93RG9tKHNvdXJjZSwgc2VsZWN0b3IsIGJhc2VTZWxlY3Rvcikge1xuICAvLyBkbyBub3RoaW5nIGlmIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBTaGFkb3dSb290XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TaGFkb3dSb290XG4gIGlmICghRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhpZGVFbGVtZW50ID0gZnVuY3Rpb24gaGlkZUVsZW1lbnQodGFyZ2V0RWxlbWVudCkge1xuICAgIHZhciBESVNQTEFZX05PTkVfQ1NTID0gJ2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnQ7JztcbiAgICB0YXJnZXRFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBESVNQTEFZX05PTkVfQ1NTO1xuICB9O1xuICAvKipcbiAgICogSGFuZGxlcyBzaGFkb3ctZG9tIHBpZXJjaW5nIGFuZCBoaWRpbmcgb2YgZm91bmQgZWxlbWVudHNcbiAgICovXG5cblxuICB2YXIgaGlkZUhhbmRsZXIgPSBmdW5jdGlvbiBoaWRlSGFuZGxlcigpIHtcbiAgICAvLyBzdGFydCB2YWx1ZSBvZiBzaGFkb3ctZG9tIGhvc3RzIGZvciB0aGUgcGFnZSBkb21cbiAgICB2YXIgaG9zdEVsZW1lbnRzID0gIWJhc2VTZWxlY3RvciA/IGZpbmRIb3N0RWxlbWVudHMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYmFzZVNlbGVjdG9yKTsgLy8gaWYgdGhlcmUgaXMgc2hhZG93LWRvbSBob3N0LCB0aGV5IHNob3VsZCBiZSBleHBsb3JlZFxuXG4gICAgd2hpbGUgKGhvc3RFbGVtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBpc0hpZGRlbiA9IGZhbHNlO1xuXG4gICAgICB2YXIgX3BpZXJjZVNoYWRvd0RvbSA9IHBpZXJjZVNoYWRvd0RvbShzZWxlY3RvciwgaG9zdEVsZW1lbnRzKSxcbiAgICAgICAgICB0YXJnZXRzID0gX3BpZXJjZVNoYWRvd0RvbS50YXJnZXRzLFxuICAgICAgICAgIGlubmVySG9zdHMgPSBfcGllcmNlU2hhZG93RG9tLmlubmVySG9zdHM7XG5cbiAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0RWwpIHtcbiAgICAgICAgaGlkZUVsZW1lbnQodGFyZ2V0RWwpO1xuICAgICAgICBpc0hpZGRlbiA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgIGhpdChzb3VyY2UpO1xuICAgICAgfSAvLyBjb250aW51ZSB0byBwaWVyY2UgZm9yIGlubmVyIHNoYWRvdy1kb20gaG9zdHNcbiAgICAgIC8vIGFuZCBzZWFyY2ggaW5zaWRlIHRoZW0gd2hpbGUgdGhlIG5leHQgaXRlcmF0aW9uXG5cblxuICAgICAgaG9zdEVsZW1lbnRzID0gaW5uZXJIb3N0cztcbiAgICB9XG4gIH07XG5cbiAgaGlkZUhhbmRsZXIoKTtcbiAgb2JzZXJ2ZURPTUNoYW5nZXMoaGlkZUhhbmRsZXIsIHRydWUpO1xufVxuaGlkZUluU2hhZG93RG9tLm5hbWVzID0gWydoaWRlLWluLXNoYWRvdy1kb20nXTtcbmhpZGVJblNoYWRvd0RvbS5pbmplY3Rpb25zID0gW2hpdCwgb2JzZXJ2ZURPTUNoYW5nZXMsIGZsYXR0ZW4sIGZpbmRIb3N0RWxlbWVudHMsIHBpZXJjZVNoYWRvd0RvbV07XG5cbi8qKlxuICogQHNjcmlwdGxldCByZW1vdmUtaW4tc2hhZG93LWRvbVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmVtb3ZlcyBlbGVtZW50cyBpbnNpZGUgb3BlbiBzaGFkb3cgRE9NIGVsZW1lbnRzLlxuICpcbiAqICoqU3ludGF4KipcbiAqIGBgYFxuICogZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncmVtb3ZlLWluLXNoYWRvdy1kb20nLCBzZWxlY3RvclssIGJhc2VTZWxlY3Rvcl0pXG4gKiBgYGBcbiAqXG4gKiAtIGBzZWxlY3RvcmAg4oCUIHJlcXVpcmVkLCBDU1Mgc2VsZWN0b3Igb2YgZWxlbWVudCBpbiBzaGFkb3ctZG9tIHRvIHJlbW92ZVxuICogLSBgYmFzZVNlbGVjdG9yYCDigJQgb3B0aW9uYWwsIHNlbGVjdG9yIG9mIHNwZWNpZmljIHBhZ2UgRE9NIGVsZW1lbnQsXG4gKiBuYXJyb3dzIGRvd24gdGhlIHBhcnQgb2YgdGhlIHBhZ2UgRE9NIHdoZXJlIHNoYWRvdy1kb20gaG9zdCBzdXBwb3NlZCB0byBiZSxcbiAqIGRlZmF1bHRzIHRvIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICpcbiAqID4gYGJhc2VTZWxlY3RvcmAgc2hvdWxkIG1hdGNoIGVsZW1lbnQgb2YgdGhlIHBhZ2UgRE9NLCBidXQgbm90IG9mIHNoYWRvdyBET01cbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIGBgYFxuICogISByZW1vdmVzIG1lbnUgYmFyXG4gKiB2aXJ1c3RvdGFsLmNvbSMlIy8vc2NyaXB0bGV0KCdyZW1vdmUtaW4tc2hhZG93LWRvbScsICdpcm9uLXBhZ2VzJywgJ3Z0LXZpcnVzdG90YWwtYXBwJylcbiAqXG4gKiAhIHJlbW92ZXMgZmxvYXRpbmcgZWxlbWVudFxuICogdmlydXN0b3RhbC5jb20jJSMvL3NjcmlwdGxldCgncmVtb3ZlLWluLXNoYWRvdy1kb20nLCAndnQtdWktY29udGFjdC1mYWInKVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlSW5TaGFkb3dEb20oc291cmNlLCBzZWxlY3RvciwgYmFzZVNlbGVjdG9yKSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFNoYWRvd1Jvb3RcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NoYWRvd1Jvb3RcbiAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3cpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQodGFyZ2V0RWxlbWVudCkge1xuICAgIHRhcmdldEVsZW1lbnQucmVtb3ZlKCk7XG4gIH07XG4gIC8qKlxuICAgKiBIYW5kbGVzIHNoYWRvdy1kb20gcGllcmNpbmcgYW5kIHJlbW92aW5nIG9mIGZvdW5kIGVsZW1lbnRzXG4gICAqL1xuXG5cbiAgdmFyIHJlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiByZW1vdmVIYW5kbGVyKCkge1xuICAgIC8vIHN0YXJ0IHZhbHVlIG9mIHNoYWRvdy1kb20gaG9zdHMgZm9yIHRoZSBwYWdlIGRvbVxuICAgIHZhciBob3N0RWxlbWVudHMgPSAhYmFzZVNlbGVjdG9yID8gZmluZEhvc3RFbGVtZW50cyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChiYXNlU2VsZWN0b3IpOyAvLyBpZiB0aGVyZSBpcyBzaGFkb3ctZG9tIGhvc3QsIHRoZXkgc2hvdWxkIGJlIGV4cGxvcmVkXG5cbiAgICB3aGlsZSAoaG9zdEVsZW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIGlzUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgX3BpZXJjZVNoYWRvd0RvbSA9IHBpZXJjZVNoYWRvd0RvbShzZWxlY3RvciwgaG9zdEVsZW1lbnRzKSxcbiAgICAgICAgICB0YXJnZXRzID0gX3BpZXJjZVNoYWRvd0RvbS50YXJnZXRzLFxuICAgICAgICAgIGlubmVySG9zdHMgPSBfcGllcmNlU2hhZG93RG9tLmlubmVySG9zdHM7XG5cbiAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0RWwpIHtcbiAgICAgICAgcmVtb3ZlRWxlbWVudCh0YXJnZXRFbCk7XG4gICAgICAgIGlzUmVtb3ZlZCA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzUmVtb3ZlZCkge1xuICAgICAgICBoaXQoc291cmNlKTtcbiAgICAgIH0gLy8gY29udGludWUgdG8gcGllcmNlIGZvciBpbm5lciBzaGFkb3ctZG9tIGhvc3RzXG4gICAgICAvLyBhbmQgc2VhcmNoIGluc2lkZSB0aGVtIHdoaWxlIHRoZSBuZXh0IGl0ZXJhdGlvblxuXG5cbiAgICAgIGhvc3RFbGVtZW50cyA9IGlubmVySG9zdHM7XG4gICAgfVxuICB9O1xuXG4gIHJlbW92ZUhhbmRsZXIoKTtcbiAgb2JzZXJ2ZURPTUNoYW5nZXMocmVtb3ZlSGFuZGxlciwgdHJ1ZSk7XG59XG5yZW1vdmVJblNoYWRvd0RvbS5uYW1lcyA9IFsncmVtb3ZlLWluLXNoYWRvdy1kb20nXTtcbnJlbW92ZUluU2hhZG93RG9tLmluamVjdGlvbnMgPSBbaGl0LCBvYnNlcnZlRE9NQ2hhbmdlcywgZmxhdHRlbiwgZmluZEhvc3RFbGVtZW50cywgcGllcmNlU2hhZG93RG9tXTtcblxuLyoqXG4gKiBAc2NyaXB0bGV0IG5vLWZsb2NcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIHVzaW5nIEdvb2dsZSBDaHJvbWUgdHJhY2tpbmcgZmVhdHVyZSBjYWxsZWQgRmVkZXJhdGVkIExlYXJuaW5nIG9mIENvaG9ydHMgKGFrYSBcIkZMb0NcIilcbiAqXG4gKiBSZWxhdGVkIFVCTyBzY3JpcHRsZXQ6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svd2lraS9SZXNvdXJjZXMtTGlicmFyeSNuby1mbG9janMtXG4gKlxuICogKipTeW50YXgqKlxuICogYGBgXG4gKiBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCduby1mbG9jJylcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIG5vRmxvYyhzb3VyY2UpIHtcbiAgdmFyIEZMT0NfUFJPUEVSVFlfTkFNRSA9ICdpbnRlcmVzdENvaG9ydCc7XG5cbiAgaWYgKERvY3VtZW50IGluc3RhbmNlb2YgT2JqZWN0ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKERvY3VtZW50LnByb3RvdHlwZSwgRkxPQ19QUk9QRVJUWV9OQU1FKSB8fCBEb2N1bWVudC5wcm90b3R5cGVbRkxPQ19QUk9QRVJUWV9OQU1FXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBkb2N1bWVudC5pbnRlcmVzdENvaG9ydCgpIGlzIGFzeW5jIGZ1bmN0aW9uIHNvIGl0J3MgYmV0dGVyIHRvIHJldHVybiBQcm9taXNlLnJlamVjdCgpXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2Zsb2MvYmxvYi9kY2Q0YzA0MmZhNmE4MWIwNDhlMDRhNzhiMTg0ZWE0MjAzYTc1MjE5L1JFQURNRS5tZFxuXG5cbiAgRG9jdW1lbnQucHJvdG90eXBlW0ZMT0NfUFJPUEVSVFlfTkFNRV0gPSBub29wUHJvbWlzZVJlamVjdDtcbiAgaGl0KHNvdXJjZSk7XG59XG5ub0Zsb2MubmFtZXMgPSBbJ25vLWZsb2MnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm8tZmxvYy5qcycsICd1Ym8tbm8tZmxvYy5qcycsICd1Ym8tbm8tZmxvYyddO1xubm9GbG9jLmluamVjdGlvbnMgPSBbaGl0LCBub29wUHJvbWlzZVJlamVjdF07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBAc2NyaXB0bGV0IHByZXZlbnQtZmV0Y2hcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByZXZlbnRzIGBmZXRjaGAgY2FsbHMgaWYgKiphbGwqKiBnaXZlbiBwYXJhbWV0ZXJzIG1hdGNoXG4gKlxuICogUmVsYXRlZCBVQk8gc2NyaXB0bGV0OlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL3dpa2kvUmVzb3VyY2VzLUxpYnJhcnkjbm8tZmV0Y2gtaWZqcy1cbiAqXG4gKiAqKlN5bnRheCoqXG4gKiBgYGBcbiAqIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZmV0Y2gnWywgcHJvcHNUb01hdGNoXSlcbiAqIGBgYFxuICpcbiAqIC0gYHByb3BzVG9NYXRjaGAgLSBvcHRpb25hbCwgc3RyaW5nIG9mIHNwYWNlLXNlcGFyYXRlZCBwcm9wZXJ0aWVzIHRvIG1hdGNoOyBwb3NzaWJsZSBwcm9wczpcbiAqICAgLSBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyB0aGUgVVJMIHBhc3NlZCB0byBmZXRjaCBjYWxsOyBlbXB0eSBzdHJpbmcgb3Igd2lsZGNhcmQgYCpgIGZvciBhbGwgZmV0Y2ggY2FsbHMgbWF0Y2hcbiAqICAgLSBjb2xvbi1zZXBhcmF0ZWQgcGFpcnMgYG5hbWU6dmFsdWVgIHdoZXJlXG4gKiAgICAgLSBgbmFtZWAgaXMgW2Bpbml0YCBvcHRpb24gbmFtZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd09yV29ya2VyR2xvYmFsU2NvcGUvZmV0Y2gjcGFyYW1ldGVycylcbiAqICAgICAtIGB2YWx1ZWAgaXMgc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgdGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gcGFzc2VkIHRvIGZldGNoIGNhbGxcbiAqXG4gKiA+IFVzYWdlIHdpdGggbm8gYXJndW1lbnRzIHdpbGwgbG9nIGZldGNoIGNhbGxzIHRvIGJyb3dzZXIgY29uc29sZTtcbiAqIHdoaWNoIGlzIHVzZWZ1bGwgZm9yIGRlYnVnZ2luZyBidXQgcGVybWl0dGVkIGZvciBwcm9kdWN0aW9uIGZpbHRlciBsaXN0cy5cbiAqXG4gKiAqKkV4YW1wbGVzKipcbiAqIDEuIFByZXZlbnQgYWxsIGZldGNoIGNhbGxzXG4gKiAgICAgYGBgXG4gKiAgICAgZXhhbXBsZS5vcmcjJSMvL3NjcmlwdGxldCgncHJldmVudC1mZXRjaCcsICcqJylcbiAqICAgICBgYGBcbiAqXG4gKiAyLiBQcmV2ZW50IGZldGNoIGNhbGwgZm9yIHNwZWNpZmljIHVybFxuICogICAgIGBgYFxuICogICAgIGV4YW1wbGUub3JnIyUjLy9zY3JpcHRsZXQoJ3ByZXZlbnQtZmV0Y2gnLCAnL3VybFxcXFwucGFydC8nKVxuICogICAgIGBgYFxuICpcbiAqIDMuIFByZXZlbnQgZmV0Y2ggY2FsbCBmb3Igc3BlY2lmaWMgcmVxdWVzdCBtZXRob2RcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWZldGNoJywgJ21ldGhvZDpIRUFEJylcbiAqICAgICBgYGBcbiAqXG4gKiA0LiBQcmV2ZW50IGZldGNoIGNhbGwgZm9yIHNwZWNpZmljIHVybCBhbmQgcmVxdWVzdCBtZXRob2RcbiAqICAgICBgYGBcbiAqICAgICBleGFtcGxlLm9yZyMlIy8vc2NyaXB0bGV0KCdwcmV2ZW50LWZldGNoJywgJy9zcGVjaWZpZWRfdXJsX3BhcnQvIG1ldGhvZDovSEVBRHxHRVQvJylcbiAqICAgICBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gcHJldmVudEZldGNoKHNvdXJjZSwgcHJvcHNUb01hdGNoKSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGZldGNoIG9yIFByb3h5IChlLmcuIEludGVybmV0IEV4cGxvcmVyKVxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9mZXRjaFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eVxuICBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJXcmFwcGVyID0gZnVuY3Rpb24gaGFuZGxlcldyYXBwZXIodGFyZ2V0LCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgdmFyIHNob3VsZFByZXZlbnQgPSBmYWxzZTtcbiAgICB2YXIgZmV0Y2hEYXRhID0gZ2V0RmV0Y2hEYXRhKGFyZ3MpO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wc1RvTWF0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBsb2cgaWYgbm8gcHJvcHNUb01hdGNoIGdpdmVuXG4gICAgICB2YXIgbG9nTWVzc2FnZSA9IFwibG9nOiBmZXRjaCggXCIuY29uY2F0KG9iamVjdFRvU3RyaW5nKGZldGNoRGF0YSksIFwiIClcIik7XG4gICAgICBoaXQoc291cmNlLCBsb2dNZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BzVG9NYXRjaCA9PT0gJycgfHwgcHJvcHNUb01hdGNoID09PSBnZXRXaWxkY2FyZFN5bWJvbCgpKSB7XG4gICAgICAvLyBwcmV2ZW50IGFsbCBmZXRjaCBjYWxsc1xuICAgICAgc2hvdWxkUHJldmVudCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBjb252ZXJ0TWF0Y2hQcm9wc1RvT2JqKHByb3BzVG9NYXRjaCk7IC8vIHByZXZlbnQgb25seSBpZiBhbGwgcHJvcHMgbWF0Y2hcblxuICAgICAgc2hvdWxkUHJldmVudCA9IE9iamVjdC5rZXlzKG1hdGNoRGF0YSkuZXZlcnkoZnVuY3Rpb24gKG1hdGNoS2V5KSB7XG4gICAgICAgIHZhciBtYXRjaFZhbHVlID0gbWF0Y2hEYXRhW21hdGNoS2V5XTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmZXRjaERhdGEsIG1hdGNoS2V5KSAmJiBtYXRjaFZhbHVlLnRlc3QoZmV0Y2hEYXRhW21hdGNoS2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUHJldmVudCkge1xuICAgICAgaGl0KHNvdXJjZSk7XG4gICAgICByZXR1cm4gbm9vcFByb21pc2VSZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgZmV0Y2hIYW5kbGVyID0ge1xuICAgIGFwcGx5OiBoYW5kbGVyV3JhcHBlclxuICB9O1xuICBmZXRjaCA9IG5ldyBQcm94eShmZXRjaCwgZmV0Y2hIYW5kbGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1nbG9iYWwtYXNzaWduXG59XG5wcmV2ZW50RmV0Y2gubmFtZXMgPSBbJ3ByZXZlbnQtZmV0Y2gnLCAvLyBhbGlhc2VzIGFyZSBuZWVkZWQgZm9yIG1hdGNoaW5nIHRoZSByZWxhdGVkIHNjcmlwdGxldCBjb252ZXJ0ZWQgaW50byBvdXIgc3ludGF4XG4nbm8tZmV0Y2gtaWYuanMnLCAndWJvLW5vLWZldGNoLWlmLmpzJywgJ3Viby1uby1mZXRjaC1pZiddO1xucHJldmVudEZldGNoLmluamVjdGlvbnMgPSBbaGl0LCBnZXRGZXRjaERhdGEsIG9iamVjdFRvU3RyaW5nLCBjb252ZXJ0TWF0Y2hQcm9wc1RvT2JqLCBub29wUHJvbWlzZVJlc29sdmUsIGdldFdpbGRjYXJkU3ltYm9sLCB0b1JlZ0V4cCwgaXNFbXB0eU9iamVjdCwgZ2V0UmVxdWVzdERhdGEsIGdldE9iamVjdEVudHJpZXMsIGdldE9iamVjdEZyb21FbnRyaWVzXTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgbXVzdCBleHBvcnQgYWxsIHNjcmlwdGxldHMgd2hpY2ggc2hvdWxkIGJlIGFjY2Vzc2libGVcbiAqL1xuXG52YXIgc2NyaXB0bGV0TGlzdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYWJvcnRPblByb3BlcnR5UmVhZDogYWJvcnRPblByb3BlcnR5UmVhZCxcbiAgICBhYm9ydE9uUHJvcGVydHlXcml0ZTogYWJvcnRPblByb3BlcnR5V3JpdGUsXG4gICAgcHJldmVudFNldFRpbWVvdXQ6IHByZXZlbnRTZXRUaW1lb3V0LFxuICAgIHByZXZlbnRTZXRJbnRlcnZhbDogcHJldmVudFNldEludGVydmFsLFxuICAgIHByZXZlbnRXaW5kb3dPcGVuOiBwcmV2ZW50V2luZG93T3BlbixcbiAgICBhYm9ydEN1cnJlbnRJbmxpbmVTY3JpcHQ6IGFib3J0Q3VycmVudElubGluZVNjcmlwdCxcbiAgICBzZXRDb25zdGFudDogc2V0Q29uc3RhbnQsXG4gICAgcmVtb3ZlQ29va2llOiByZW1vdmVDb29raWUsXG4gICAgcHJldmVudEFkZEV2ZW50TGlzdGVuZXI6IHByZXZlbnRBZGRFdmVudExpc3RlbmVyLFxuICAgIHByZXZlbnRCYWI6IHByZXZlbnRCYWIsXG4gICAgbm93ZWJydGM6IG5vd2VicnRjLFxuICAgIGxvZ0FkZEV2ZW50TGlzdGVuZXI6IGxvZ0FkZEV2ZW50TGlzdGVuZXIsXG4gICAgbG9nRXZhbDogbG9nRXZhbCxcbiAgICBsb2c6IGxvZyxcbiAgICBub2V2YWw6IG5vZXZhbCxcbiAgICBwcmV2ZW50RXZhbElmOiBwcmV2ZW50RXZhbElmLFxuICAgIHByZXZlbnRGYWI6IHByZXZlbnRGYWIsXG4gICAgc2V0UG9wYWRzRHVtbXk6IHNldFBvcGFkc0R1bW15LFxuICAgIHByZXZlbnRQb3BhZHNOZXQ6IHByZXZlbnRQb3BhZHNOZXQsXG4gICAgcHJldmVudEFkZmx5OiBwcmV2ZW50QWRmbHksXG4gICAgZGVidWdPblByb3BlcnR5UmVhZDogZGVidWdPblByb3BlcnR5UmVhZCxcbiAgICBkZWJ1Z09uUHJvcGVydHlXcml0ZTogZGVidWdPblByb3BlcnR5V3JpdGUsXG4gICAgZGVidWdDdXJyZW50SW5saW5lU2NyaXB0OiBkZWJ1Z0N1cnJlbnRJbmxpbmVTY3JpcHQsXG4gICAgcmVtb3ZlQXR0cjogcmVtb3ZlQXR0cixcbiAgICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG4gICAgZGlzYWJsZU5ld3RhYkxpbmtzOiBkaXNhYmxlTmV3dGFiTGlua3MsXG4gICAgYWRqdXN0U2V0SW50ZXJ2YWw6IGFkanVzdFNldEludGVydmFsLFxuICAgIGFkanVzdFNldFRpbWVvdXQ6IGFkanVzdFNldFRpbWVvdXQsXG4gICAgZGlyU3RyaW5nOiBkaXJTdHJpbmcsXG4gICAganNvblBydW5lOiBqc29uUHJ1bmUsXG4gICAgcHJldmVudFJlcXVlc3RBbmltYXRpb25GcmFtZTogcHJldmVudFJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICBzZXRDb29raWU6IHNldENvb2tpZSxcbiAgICBzZXRDb29raWVSZWxvYWQ6IHNldENvb2tpZVJlbG9hZCxcbiAgICBoaWRlSW5TaGFkb3dEb206IGhpZGVJblNoYWRvd0RvbSxcbiAgICByZW1vdmVJblNoYWRvd0RvbTogcmVtb3ZlSW5TaGFkb3dEb20sXG4gICAgbm9GbG9jOiBub0Zsb2MsXG4gICAgcHJldmVudEZldGNoOiBwcmV2ZW50RmV0Y2hcbn0pO1xuXG4vKipcbiAqIFN0b3JlIG9mIEFERyByZWRpcmVjdHMgbmFtZXMgYW5kIHRoaWVyIGFuYWxvZ3MuXG4gKiBBcyBpdCBpcyBub3QgYSBjb21wYXRpYmlsaXR5IHRhYmxlLCBubyBuZWVkIHRvIGtlZXAgaW4gcmVkaXJlY3RzIGFycmF5IHRoaXJkLXBhcnR5IHJlZGlyZWN0cy5cbiAqXG4gKiBOZWVkZWQgb25seSBmb3IgY29udmVyaW9uIHB1cnBvc2VzLlxuICogZS5nLiBnb29nbGV0YWdtYW5hZ2VyLWd0bSBpcyByZW1vdmVkIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGNvbXBhdGliaWxpdHkgdGFibGUgYXMgd2VsbFxuICogYnV0IG5vdyBpdCB3b3JrcyBhcyBhbGlhcyBmb3IgZ29vZ2xlLWFuYWx5dGljcyBzbyBpdCBzaG91bGQgc3RheSB2YWxpZCBmb3IgY29tcGlsZXJcbiAqL1xudmFyIHJlZGlyZWN0cyA9IFt7XG4gIGFkZzogJzF4MS10cmFuc3BhcmVudC5naWYnLFxuICB1Ym86ICcxeDEuZ2lmJyxcbiAgYWJwOiAnMXgxLXRyYW5zcGFyZW50LWdpZidcbn0sIHtcbiAgYWRnOiAnMngyLXRyYW5zcGFyZW50LnBuZycsXG4gIHVibzogJzJ4Mi5wbmcnLFxuICBhYnA6ICcyeDItdHJhbnNwYXJlbnQtcG5nJ1xufSwge1xuICBhZGc6ICczeDItdHJhbnNwYXJlbnQucG5nJyxcbiAgdWJvOiAnM3gyLnBuZycsXG4gIGFicDogJzN4Mi10cmFuc3BhcmVudC1wbmcnXG59LCB7XG4gIGFkZzogJzMyeDMyLXRyYW5zcGFyZW50LnBuZycsXG4gIHVibzogJzMyeDMyLnBuZycsXG4gIGFicDogJzMyeDMyLXRyYW5zcGFyZW50LXBuZydcbn0sIHtcbiAgYWRnOiAnYW1hem9uLWFwc3RhZycsXG4gIHVibzogJ2FtYXpvbl9hcHN0YWcuanMnXG59LCB7XG4gIGFkZzogJ2dvb2dsZS1hbmFseXRpY3MnLFxuICB1Ym86ICdnb29nbGUtYW5hbHl0aWNzX2FuYWx5dGljcy5qcydcbn0sIHtcbiAgYWRnOiAnZ29vZ2xlLWFuYWx5dGljcy1nYScsXG4gIHVibzogJ2dvb2dsZS1hbmFseXRpY3NfZ2EuanMnXG59LCB7XG4gIGFkZzogJ2dvb2dsZXN5bmRpY2F0aW9uLWFkc2J5Z29vZ2xlJyxcbiAgdWJvOiAnZ29vZ2xlc3luZGljYXRpb25fYWRzYnlnb29nbGUuanMnXG59LCB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMjdcbiAgYWRnOiAnZ29vZ2xldGFnbWFuYWdlci1ndG0nLFxuICB1Ym86ICdnb29nbGUtYW5hbHl0aWNzX2dhLmpzJ1xufSwge1xuICBhZGc6ICdnb29nbGV0YWdzZXJ2aWNlcy1ncHQnLFxuICB1Ym86ICdnb29nbGV0YWdzZXJ2aWNlc19ncHQuanMnXG59LCB7XG4gIGFkZzogJ21ldHJpa2EteWFuZGV4LXdhdGNoJ1xufSwge1xuICBhZGc6ICdtZXRyaWthLXlhbmRleC10YWcnXG59LCB7XG4gIGFkZzogJ25vZXZhbCcsXG4gIHVibzogJ25vZXZhbC1zaWxlbnQuanMnXG59LCB7XG4gIGFkZzogJ25vb3Bjc3MnLFxuICBhYnA6ICdibGFuay1jc3MnXG59LCB7XG4gIGFkZzogJ25vb3BmcmFtZScsXG4gIHVibzogJ25vb3AuaHRtbCcsXG4gIGFicDogJ2JsYW5rLWh0bWwnXG59LCB7XG4gIGFkZzogJ25vb3BqcycsXG4gIHVibzogJ25vb3AuanMnLFxuICBhYnA6ICdibGFuay1qcydcbn0sIHtcbiAgYWRnOiAnbm9vcHRleHQnLFxuICB1Ym86ICdub29wLnR4dCcsXG4gIGFicDogJ2JsYW5rLXRleHQnXG59LCB7XG4gIGFkZzogJ25vb3BtcDMtMC4xcycsXG4gIHVibzogJ25vb3AtMC4xcy5tcDMnLFxuICBhYnA6ICdibGFuay1tcDMnXG59LCB7XG4gIGFkZzogJ25vb3BtcDQtMXMnLFxuICB1Ym86ICdub29wLTFzLm1wNCcsXG4gIGFicDogJ2JsYW5rLW1wNCdcbn0sIHtcbiAgYWRnOiAnbm9vcHZtYXAtMS4wJyxcbiAgdWJvOiAnbm9vcC12bWFwMS4wLnhtbCdcbn0sIHtcbiAgYWRnOiAnbm9vcHZhc3QtMi4wJ1xufSwge1xuICBhZGc6ICdub29wdmFzdC0zLjAnXG59LCB7XG4gIGFkZzogJ3ByZXZlbnQtYmFiJyxcbiAgdWJvOiAnbm9iYWIuanMnXG59LCB7XG4gIGFkZzogJ3ByZXZlbnQtZmFiLTMuMi4wJyxcbiAgdWJvOiAnbm9mYWIuanMnXG59LCB7XG4gIGFkZzogJ3ByZXZlbnQtcG9wYWRzLW5ldCcsXG4gIHVibzogJ3BvcGFkcy5qcydcbn0sIHtcbiAgYWRnOiAnc2NvcmVjYXJkcmVzZWFyY2gtYmVhY29uJyxcbiAgdWJvOiAnc2NvcmVjYXJkcmVzZWFyY2hfYmVhY29uLmpzJ1xufSwge1xuICBhZGc6ICdzZXQtcG9wYWRzLWR1bW15JyxcbiAgdWJvOiAncG9wYWRzLWR1bW15LmpzJ1xufSwge1xuICBhZGc6ICdlbXB0eScsXG4gIHVibzogJ2VtcHR5J1xufV07XG5cbnZhciBKU19SVUxFX01BUktFUiA9ICcjJSMnO1xudmFyIENPTU1FTlRfTUFSS0VSID0gJyEnO1xuLyoqXG4gKiBDaGVja3MgaWYgcnVsZSB0ZXh0IGlzIGNvbW1lbnQgZS5nLiAhIWV4YW1wbGUub3JnIyMranMoc2V0LWNvbnN0YW50LmpzLCB0ZXN0LCBmYWxzZSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cbnZhciBpc0NvbW1lbnQgPSBmdW5jdGlvbiBpc0NvbW1lbnQocnVsZSkge1xuICByZXR1cm4gc3RhcnRzV2l0aChydWxlLCBDT01NRU5UX01BUktFUik7XG59O1xuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlxuICogU2NyaXB0bGV0c1xuICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKipcbiAqIHVCbG9jayBzY3JpcHRsZXQgcnVsZSBtYXNrXG4gKi9cblxuXG52YXIgVUJPX1NDUklQVExFVF9NQVNLX1JFRyA9IC8jQD8jc2NyaXB0OmluamVjdHwjQD8jXFxzKlxcK2pzLztcbnZhciBVQk9fU0NSSVBUTEVUX01BU0tfMSA9ICcjIytqcyc7XG52YXIgVUJPX1NDUklQVExFVF9NQVNLXzIgPSAnIyNzY3JpcHQ6aW5qZWN0JztcbnZhciBVQk9fU0NSSVBUTEVUX0VYQ0VQVElPTl9NQVNLXzEgPSAnI0AjK2pzJztcbnZhciBVQk9fU0NSSVBUTEVUX0VYQ0VQVElPTl9NQVNLXzIgPSAnI0Ajc2NyaXB0OmluamVjdCc7XG4vKipcbiAqIEFkQmxvY2sgUGx1cyBzbmlwcGV0IHJ1bGUgbWFza1xuICovXG5cbnZhciBBQlBfU0NSSVBUTEVUX01BU0sgPSAnIyQjJztcbnZhciBBQlBfU0NSSVBUTEVUX0VYQ0VQVElPTl9NQVNLID0gJyNAJCMnO1xuLyoqXG4gKiBBZEd1YXJkIENTUyBydWxlIG1hc2tcbiAqL1xuXG52YXIgQURHX0NTU19NQVNLX1JFRyA9IC8jQD9cXCQjLis/XFxzKlxcey4qXFx9XFxzKiQvZztcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBgcnVsZWAgaXMgQWRHdWFyZCBzY3JpcHRsZXQgcnVsZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBydWxlIHRleHRcbiAqL1xuXG52YXIgaXNBZGdTY3JpcHRsZXRSdWxlID0gZnVuY3Rpb24gaXNBZGdTY3JpcHRsZXRSdWxlKHJ1bGUpIHtcbiAgcmV0dXJuICFpc0NvbW1lbnQocnVsZSkgJiYgcnVsZS5pbmRleE9mKEFER19TQ1JJUFRMRVRfTUFTSykgPiAtMTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYHJ1bGVgIGlzIHVCTyBzY3JpcHRsZXQgcnVsZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgcnVsZSB0ZXh0XG4gKi9cblxuXG52YXIgaXNVYm9TY3JpcHRsZXRSdWxlID0gZnVuY3Rpb24gaXNVYm9TY3JpcHRsZXRSdWxlKHJ1bGUpIHtcbiAgcmV0dXJuIChydWxlLmluZGV4T2YoVUJPX1NDUklQVExFVF9NQVNLXzEpID4gLTEgfHwgcnVsZS5pbmRleE9mKFVCT19TQ1JJUFRMRVRfTUFTS18yKSA+IC0xIHx8IHJ1bGUuaW5kZXhPZihVQk9fU0NSSVBUTEVUX0VYQ0VQVElPTl9NQVNLXzEpID4gLTEgfHwgcnVsZS5pbmRleE9mKFVCT19TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0tfMikgPiAtMSkgJiYgVUJPX1NDUklQVExFVF9NQVNLX1JFRy50ZXN0KHJ1bGUpICYmICFpc0NvbW1lbnQocnVsZSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBydWxlYCBpcyBBZEJsb2NrIFBsdXMgc25pcHBldFxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgcnVsZSB0ZXh0XG4gKi9cblxuXG52YXIgaXNBYnBTbmlwcGV0UnVsZSA9IGZ1bmN0aW9uIGlzQWJwU25pcHBldFJ1bGUocnVsZSkge1xuICByZXR1cm4gKHJ1bGUuaW5kZXhPZihBQlBfU0NSSVBUTEVUX01BU0spID4gLTEgfHwgcnVsZS5pbmRleE9mKEFCUF9TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0spID4gLTEpICYmIHJ1bGUuc2VhcmNoKEFER19DU1NfTUFTS19SRUcpID09PSAtMSAmJiAhaXNDb21tZW50KHJ1bGUpO1xufTtcbi8qKlxuICogRmluZHMgc2NyaXB0bGV0IGJ5IGl0J3MgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBzY3JpcHRsZXQgbmFtZVxuICovXG5cblxudmFyIGdldFNjcmlwdGxldEJ5TmFtZSA9IGZ1bmN0aW9uIGdldFNjcmlwdGxldEJ5TmFtZShuYW1lKSB7XG4gIHZhciBzY3JpcHRsZXRzID0gT2JqZWN0LmtleXMoc2NyaXB0bGV0TGlzdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc2NyaXB0bGV0TGlzdFtrZXldO1xuICB9KTtcbiAgcmV0dXJuIHNjcmlwdGxldHMuZmluZChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLm5hbWVzIC8vIGZ1bGwgbWF0Y2ggbmFtZSBjaGVja2luZ1xuICAgICYmIChzLm5hbWVzLmluZGV4T2YobmFtZSkgPiAtMSAvLyBvciBjaGVjayB1Ym8gYWxpYXMgbmFtZSB3aXRob3V0ICcuanMnIGF0IHRoZSBlbmRcbiAgICB8fCAhZW5kc1dpdGgobmFtZSwgJy5qcycpICYmIHMubmFtZXMuaW5kZXhPZihcIlwiLmNvbmNhdChuYW1lLCBcIi5qc1wiKSkgPiAtMSk7XG4gIH0pO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzY3JpcHRsZXQgbmFtZSBpcyB2YWxpZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBTY3JpcHRsZXQgbmFtZVxuICovXG5cblxudmFyIGlzVmFsaWRTY3JpcHRsZXROYW1lID0gZnVuY3Rpb24gaXNWYWxpZFNjcmlwdGxldE5hbWUobmFtZSkge1xuICBpZiAoIW5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc2NyaXB0bGV0ID0gZ2V0U2NyaXB0bGV0QnlOYW1lKG5hbWUpO1xuXG4gIGlmICghc2NyaXB0bGV0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlxuICogUmVkaXJlY3RzXG4gKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qKlxuICogUmVkaXJlY3QgcmVzb3VyY2VzIG1hcmtlcnNcbiAqL1xuXG5cbnZhciBBREdfVUJPX1JFRElSRUNUX01BUktFUiA9ICdyZWRpcmVjdD0nO1xudmFyIEFCUF9SRURJUkVDVF9NQVJLRVIgPSAncmV3cml0ZT1hYnAtcmVzb3VyY2U6JztcbnZhciBFTVBUWV9SRURJUkVDVF9NQVJLRVIgPSAnZW1wdHknO1xudmFyIFZBTElEX1NPVVJDRV9UWVBFUyA9IFsnaW1hZ2UnLCAnbWVkaWEnLCAnc3ViZG9jdW1lbnQnLCAnc3R5bGVzaGVldCcsICdzY3JpcHQnLCAneG1saHR0cHJlcXVlc3QnLCAnb3RoZXInXTtcbi8qKlxuICogU291cmNlIHR5cGVzIGZvciByZWRpcmVjdCBydWxlcyBpZiB0aGVyZSBpcyBubyBvbmUgb2YgdGhlbS5cbiAqIFVzZWQgZm9yIEFERyAtPiBVQk8gY29udmVyc2lvbi5cbiAqL1xuXG52YXIgQUJTRU5UX1NPVVJDRV9UWVBFX1JFUExBQ0VNRU5UID0gW3tcbiAgTkFNRTogJ25vb3B0ZXh0JyxcbiAgVFlQRVM6IFZBTElEX1NPVVJDRV9UWVBFU1xufSwge1xuICBOQU1FOiAnbm9vcGpzJyxcbiAgVFlQRVM6IFsnc2NyaXB0J11cbn0sIHtcbiAgTkFNRTogJ25vb3BmcmFtZScsXG4gIFRZUEVTOiBbJ3N1YmRvY3VtZW50J11cbn0sIHtcbiAgTkFNRTogJzF4MS10cmFuc3BhcmVudC5naWYnLFxuICBUWVBFUzogWydpbWFnZSddXG59LCB7XG4gIE5BTUU6ICdub29wbXAzLTAuMXMnLFxuICBUWVBFUzogWydtZWRpYSddXG59LCB7XG4gIE5BTUU6ICdub29wbXA0LTFzJyxcbiAgVFlQRVM6IFsnbWVkaWEnXVxufSwge1xuICBOQU1FOiAnZ29vZ2xlc3luZGljYXRpb24tYWRzYnlnb29nbGUnLFxuICBUWVBFUzogWyd4bWxodHRwcmVxdWVzdCcsICdzY3JpcHQnXVxufSwge1xuICBOQU1FOiAnZ29vZ2xlLWFuYWx5dGljcycsXG4gIFRZUEVTOiBbJ3NjcmlwdCddXG59LCB7XG4gIE5BTUU6ICdnb29nbGV0YWdzZXJ2aWNlcy1ncHQnLFxuICBUWVBFUzogWydzY3JpcHQnXVxufV07XG52YXIgdmFsaWRBZGdSZWRpcmVjdHMgPSByZWRpcmVjdHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZWwuYWRnO1xufSk7XG4vKipcbiAqIENvbXBhdGliaWxpdHkgb2JqZWN0IHdoZXJlIEtFWVMgPSBVQk8gcmVkaXJlY3QgbmFtZXMgYW5kIFZBTFVFUyA9IEFERyByZWRpcmVjdCBuYW1lc1xuICogSXQncyB1c2VkIGZvciBVQk8gLT4gQURHIGNvbnZlcnRpbmdcbiAqL1xuXG52YXIgdWJvVG9BZGdDb21wYXRpYmlsaXR5ID0gZ2V0T2JqZWN0RnJvbUVudHJpZXModmFsaWRBZGdSZWRpcmVjdHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gZWwudWJvO1xufSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gW2VsLnVibywgZWwuYWRnXTtcbn0pKTtcbi8qKlxuICogQ29tcGF0aWJpbGl0eSBvYmplY3Qgd2hlcmUgS0VZUyA9IEFCUCByZWRpcmVjdCBuYW1lcyBhbmQgVkFMVUVTID0gQURHIHJlZGlyZWN0IG5hbWVzXG4gKiBJdCdzIHVzZWQgZm9yIEFCUCAtPiBBREcgY29udmVydGluZ1xuICovXG5cbnZhciBhYnBUb0FkZ0NvbXBhdGliaWxpdHkgPSBnZXRPYmplY3RGcm9tRW50cmllcyh2YWxpZEFkZ1JlZGlyZWN0cy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBlbC5hYnA7XG59KS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiBbZWwuYWJwLCBlbC5hZGddO1xufSkpO1xuLyoqXG4gKiBDb21wYXRpYmlsaXR5IG9iamVjdCB3aGVyZSBLRVlTID0gVUJPIHJlZGlyZWN0IG5hbWVzIGFuZCBWQUxVRVMgPSBBREcgcmVkaXJlY3QgbmFtZXNcbiAqIEl0J3MgdXNlZCBmb3IgQURHIC0+IFVCTyBjb252ZXJ0aW5nXG4gKi9cblxudmFyIGFkZ1RvVWJvQ29tcGF0aWJpbGl0eSA9IGdldE9iamVjdEZyb21FbnRyaWVzKHZhbGlkQWRnUmVkaXJlY3RzLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLnVibztcbn0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIFtlbC5hZGcsIGVsLnVib107XG59KSk7XG4vKipcbiAqIE5lZWRlZCBmb3IgQWRHdWFyZCByZWRpcmVjdCBuYW1lcyB2YWxpZGF0aW9uIHdoZXJlIEtFWVMgPSAqKnZhbGlkKiogQWRHdWFyZCByZWRpcmVjdCBuYW1lc1xuICogJ2FkZ1RvVWJvQ29tcGF0aWJpbGl0eScgaXMgc3RpbGwgbmVlZGVkIGZvciBBREcgLT4gVUJPIGNvbnZlcnRpbmdcbiAqL1xuXG52YXIgdmFsaWRBZGdDb21wYXRpYmlsaXR5ID0gZ2V0T2JqZWN0RnJvbUVudHJpZXModmFsaWRBZGdSZWRpcmVjdHMubWFwKGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gW2VsLmFkZywgJ3ZhbGlkIGFkZyByZWRpcmVjdCddO1xufSkpO1xudmFyIFJFRElSRUNUX1JVTEVfVFlQRVMgPSB7XG4gIFZBTElEX0FERzoge1xuICAgIG1hcmtlcjogQURHX1VCT19SRURJUkVDVF9NQVJLRVIsXG4gICAgY29tcGF0aWJpbGl0eTogdmFsaWRBZGdDb21wYXRpYmlsaXR5XG4gIH0sXG4gIEFERzoge1xuICAgIG1hcmtlcjogQURHX1VCT19SRURJUkVDVF9NQVJLRVIsXG4gICAgY29tcGF0aWJpbGl0eTogYWRnVG9VYm9Db21wYXRpYmlsaXR5XG4gIH0sXG4gIFVCTzoge1xuICAgIG1hcmtlcjogQURHX1VCT19SRURJUkVDVF9NQVJLRVIsXG4gICAgY29tcGF0aWJpbGl0eTogdWJvVG9BZGdDb21wYXRpYmlsaXR5XG4gIH0sXG4gIEFCUDoge1xuICAgIG1hcmtlcjogQUJQX1JFRElSRUNUX01BUktFUixcbiAgICBjb21wYXRpYmlsaXR5OiBhYnBUb0FkZ0NvbXBhdGliaWxpdHlcbiAgfVxufTtcbi8qKlxuICogUGFyc2VzIHJlZGlyZWN0IHJ1bGUgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5cbnZhciBwYXJzZU1vZGlmaWVycyA9IGZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKHJ1bGUpIHtcbiAgcmV0dXJuIHN1YnN0cmluZ0FmdGVyKHJ1bGUsICckJykuc3BsaXQoJywnKTtcbn07XG4vKipcbiAqIEdldHMgcmVkaXJlY3QgcmVzb3VyY2UgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZXIgLSBzcGVjaWZpYyBBZGcvVWJvIG9yIEFicCByZWRpcmVjdCByZXNvdXJjZXMgbWFya2VyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHJlZGlyZWN0IHJlc291cmNlIG5hbWVcbiAqL1xuXG5cbnZhciBnZXRSZWRpcmVjdE5hbWUgPSBmdW5jdGlvbiBnZXRSZWRpcmVjdE5hbWUocnVsZSwgbWFya2VyKSB7XG4gIHZhciBydWxlTW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMocnVsZSk7XG4gIHZhciByZWRpcmVjdE5hbWVQYXJ0ID0gcnVsZU1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5pbmRleE9mKG1hcmtlcikgPiAtMTtcbiAgfSk7XG4gIHJldHVybiBzdWJzdHJpbmdBZnRlcihyZWRpcmVjdE5hbWVQYXJ0LCBtYXJrZXIpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBgcnVsZWAgaXMgQWRHdWFyZCByZWRpcmVjdCBydWxlLlxuICogRGlzY2FyZHMgY29tbWVudHMgYW5kIEpTIHJ1bGVzIGFuZCBjaGVja3MgaWYgdGhlIGBydWxlYCBoYXMgJ3JlZGlyZWN0JyBtb2RpZmllci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIC0gcnVsZSB0ZXh0XG4gKi9cblxuXG52YXIgaXNBZGdSZWRpcmVjdFJ1bGUgPSBmdW5jdGlvbiBpc0FkZ1JlZGlyZWN0UnVsZShydWxlKSB7XG4gIHZhciBNQVJLRVJfSU5fQkFTRV9QQVJUX01BU0sgPSAnLygoPyFcXFxcJHxcXFxcLCkuezF9KXJlZGlyZWN0PSguezAsfT8pXFxcXCQocG9wdXApPy8nO1xuICByZXR1cm4gIWlzQ29tbWVudChydWxlKSAmJiBydWxlLmluZGV4T2YoUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcubWFya2VyKSA+IC0xIC8vIHNvbWUganMgcnVsZXMgbWF5IGhhdmUgJ3JlZGlyZWN0PScgaW4gaXQsIHNvIHdlIHNob3VsZCBnZXQgcmlkIG9mIHRoZW1cbiAgJiYgcnVsZS5pbmRleE9mKEpTX1JVTEVfTUFSS0VSKSA9PT0gLTEgLy8gZ2V0IHJpZCBvZiBydWxlcyBsaWtlICdfcmVkaXJlY3Q9KjovL2xvb2suJHBvcHVwJ1xuICAmJiAhdG9SZWdFeHAoTUFSS0VSX0lOX0JBU0VfUEFSVF9NQVNLKS50ZXN0KHJ1bGUpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBgcnVsZWAgc2F0aXNmaWVzIHRoZSBgdHlwZWBcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIC0gcnVsZSB0ZXh0XG4gKiBAcGFyYW0geydWQUxJRF9BREcnfCdBREcnfCdVQk8nfCdBQlAnfSB0eXBlIC0gdHlwZSBvZiBhIHJlZGlyZWN0IHJ1bGVcbiAqL1xuXG5cbnZhciBpc1JlZGlyZWN0UnVsZUJ5VHlwZSA9IGZ1bmN0aW9uIGlzUmVkaXJlY3RSdWxlQnlUeXBlKHJ1bGUsIHR5cGUpIHtcbiAgdmFyIF9SRURJUkVDVF9SVUxFX1RZUEVTJCA9IFJFRElSRUNUX1JVTEVfVFlQRVNbdHlwZV0sXG4gICAgICBtYXJrZXIgPSBfUkVESVJFQ1RfUlVMRV9UWVBFUyQubWFya2VyLFxuICAgICAgY29tcGF0aWJpbGl0eSA9IF9SRURJUkVDVF9SVUxFX1RZUEVTJC5jb21wYXRpYmlsaXR5O1xuXG4gIGlmIChydWxlICYmICFpc0NvbW1lbnQocnVsZSkgJiYgcnVsZS5pbmRleE9mKG1hcmtlcikgPiAtMSkge1xuICAgIHZhciByZWRpcmVjdE5hbWUgPSBnZXRSZWRpcmVjdE5hbWUocnVsZSwgbWFya2VyKTtcblxuICAgIGlmICghcmVkaXJlY3ROYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZGlyZWN0TmFtZSA9PT0gT2JqZWN0LmtleXMoY29tcGF0aWJpbGl0eSkuZmluZChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbCA9PT0gcmVkaXJlY3ROYW1lO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuKiBDaGVja3MgaWYgdGhlIGBydWxlYCBpcyAqKnZhbGlkKiogQWRHdWFyZCByZWRpcmVjdCByZXNvdXJjZSBydWxlXG4qIEBwYXJhbSB7c3RyaW5nfSBydWxlIC0gcnVsZSB0ZXh0XG4qIEByZXR1cm5zIHtib29sZWFufVxuKi9cblxuXG52YXIgaXNWYWxpZEFkZ1JlZGlyZWN0UnVsZSA9IGZ1bmN0aW9uIGlzVmFsaWRBZGdSZWRpcmVjdFJ1bGUocnVsZSkge1xuICByZXR1cm4gaXNSZWRpcmVjdFJ1bGVCeVR5cGUocnVsZSwgJ1ZBTElEX0FERycpO1xufTtcbi8qKlxuKiBDaGVja3MgaWYgdGhlIEFkR3VhcmQgcmVkaXJlY3QgYHJ1bGVgIGhhcyBVYm8gYW5hbG9nLiBOZWVkZWQgZm9yIEFkZy0+VWJvIGNvbnZlcnNpb25cbiogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBBZEd1YXJkIHJ1bGUgdGV4dFxuKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBydWxlIGNhbiBiZSBjb252ZXJ0ZWQgdG8gVWJvXG4qL1xuXG5cbnZhciBpc0FkZ1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhVYm8gPSBmdW5jdGlvbiBpc0FkZ1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhVYm8ocnVsZSkge1xuICByZXR1cm4gaXNBZGdSZWRpcmVjdFJ1bGUocnVsZSkgJiYgaXNSZWRpcmVjdFJ1bGVCeVR5cGUocnVsZSwgJ0FERycpO1xufTtcbi8qKlxuKiBDaGVja3MgaWYgdGhlIFVibyByZWRpcmVjdCBgcnVsZWAgaGFzIEFkR3VhcmQgYW5hbG9nLiBOZWVkZWQgZm9yIFViby0+QWRnIGNvbnZlcnNpb25cbiogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBVYm8gcnVsZSB0ZXh0XG4qIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIHJ1bGUgY2FuIGJlIGNvbnZlcnRlZCB0byBBZEd1YXJkXG4qL1xuXG5cbnZhciBpc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcgPSBmdW5jdGlvbiBpc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcocnVsZSkge1xuICByZXR1cm4gaXNSZWRpcmVjdFJ1bGVCeVR5cGUocnVsZSwgJ1VCTycpO1xufTtcbi8qKlxuKiBDaGVja3MgaWYgdGhlIEFicCByZWRpcmVjdCBgcnVsZWAgaGFzIEFkR3VhcmQgYW5hbG9nLiBOZWVkZWQgZm9yIEFicC0+QWRnIGNvbnZlcnNpb25cbiogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBBYnAgcnVsZSB0ZXh0XG4qIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIHJ1bGUgY2FuIGJlIGNvbnZlcnRlZCB0byBBZEd1YXJkXG4qL1xuXG5cbnZhciBpc0FicFJlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcgPSBmdW5jdGlvbiBpc0FicFJlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcocnVsZSkge1xuICByZXR1cm4gaXNSZWRpcmVjdFJ1bGVCeVR5cGUocnVsZSwgJ0FCUCcpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBydWxlIGhhcyBzcGVjaWZpZWQgY29udGVudCB0eXBlIGJlZm9yZSBBZGcgLT4gVWJvIGNvbnZlcnNpb24uXG4gKlxuICogVXNlZCBPTkxZIGZvciBBZGcgLT4gVWJvIGNvbnZlcnNpb25cbiAqIGJlY2F1c2UgVWJvIHJlZGlyZWN0IHJ1bGVzIG11c3QgY29udGFpbiBjb250ZW50IHR5cGUsIGJ1dCBBZGcgYW5kIEFicCBtdXN0IG5vdC5cbiAqXG4gKiBBbHNvIHNvdXJjZSB0eXBlIGNhbiBub3QgYmUgYWRkZWQgYXV0b21hdGljYWxseSBiZWNhdXNlIG9mIHN1Y2ggdmFsaWQgcnVsZXM6XG4gKiAhIEFicDpcbiAqICRyZXdyaXRlPWFicC1yZXNvdXJjZTpibGFuay1qcyx4bWxodHRwcmVxdWVzdFxuICogISBBZGc6XG4gKiAkc2NyaXB0LHJlZGlyZWN0PW5vb3B2YXN0LTIuMFxuICogJHhtbGh0dHByZXF1ZXN0LHJlZGlyZWN0PW5vb3B2YXN0LTIuMFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5cbnZhciBoYXNWYWxpZENvbnRlbnRUeXBlID0gZnVuY3Rpb24gaGFzVmFsaWRDb250ZW50VHlwZShydWxlKSB7XG4gIHZhciBydWxlTW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMocnVsZSk7IC8vIHJ1bGUgY2FuIGhhdmUgbW9yZSB0aGFuIG9uZSBzb3VyY2UgdHlwZSBtb2RpZmllclxuXG4gIHZhciBzb3VyY2VUeXBlcyA9IHJ1bGVNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBWQUxJRF9TT1VSQ0VfVFlQRVMuaW5kZXhPZihlbCkgPiAtMTtcbiAgfSk7XG4gIHZhciBpc1NvdXJjZVR5cGVTcGVjaWZpZWQgPSBzb3VyY2VUeXBlcy5sZW5ndGggPiAwO1xuICB2YXIgaXNFbXB0eVJlZGlyZWN0ID0gcnVsZU1vZGlmaWVycy5pbmRleE9mKFwiXCIuY29uY2F0KEFER19VQk9fUkVESVJFQ1RfTUFSS0VSKS5jb25jYXQoRU1QVFlfUkVESVJFQ1RfTUFSS0VSKSkgPiAtMTtcblxuICBpZiAoaXNFbXB0eVJlZGlyZWN0KSB7XG4gICAgLy8gbm8gc291cmNlIHR5cGUgZm9yICdlbXB0eScgaXMgYWxsb3dlZFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGlzU291cmNlVHlwZVNwZWNpZmllZDtcbn07XG5cbnZhciB2YWxpZGF0b3IgPSB7XG4gIFVCT19TQ1JJUFRMRVRfTUFTS19SRUc6IFVCT19TQ1JJUFRMRVRfTUFTS19SRUcsXG4gIEFCUF9TQ1JJUFRMRVRfTUFTSzogQUJQX1NDUklQVExFVF9NQVNLLFxuICBBQlBfU0NSSVBUTEVUX0VYQ0VQVElPTl9NQVNLOiBBQlBfU0NSSVBUTEVUX0VYQ0VQVElPTl9NQVNLLFxuICBpc0NvbW1lbnQ6IGlzQ29tbWVudCxcbiAgaXNBZGdTY3JpcHRsZXRSdWxlOiBpc0FkZ1NjcmlwdGxldFJ1bGUsXG4gIGlzVWJvU2NyaXB0bGV0UnVsZTogaXNVYm9TY3JpcHRsZXRSdWxlLFxuICBpc0FicFNuaXBwZXRSdWxlOiBpc0FicFNuaXBwZXRSdWxlLFxuICBnZXRTY3JpcHRsZXRCeU5hbWU6IGdldFNjcmlwdGxldEJ5TmFtZSxcbiAgaXNWYWxpZFNjcmlwdGxldE5hbWU6IGlzVmFsaWRTY3JpcHRsZXROYW1lLFxuICBSRURJUkVDVF9SVUxFX1RZUEVTOiBSRURJUkVDVF9SVUxFX1RZUEVTLFxuICBBQlNFTlRfU09VUkNFX1RZUEVfUkVQTEFDRU1FTlQ6IEFCU0VOVF9TT1VSQ0VfVFlQRV9SRVBMQUNFTUVOVCxcbiAgaXNBZGdSZWRpcmVjdFJ1bGU6IGlzQWRnUmVkaXJlY3RSdWxlLFxuICBpc1ZhbGlkQWRnUmVkaXJlY3RSdWxlOiBpc1ZhbGlkQWRnUmVkaXJlY3RSdWxlLFxuICBpc0FkZ1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhVYm86IGlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibyxcbiAgaXNVYm9SZWRpcmVjdENvbXBhdGlibGVXaXRoQWRnOiBpc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcsXG4gIGlzQWJwUmVkaXJlY3RDb21wYXRpYmxlV2l0aEFkZzogaXNBYnBSZWRpcmVjdENvbXBhdGlibGVXaXRoQWRnLFxuICBwYXJzZU1vZGlmaWVyczogcGFyc2VNb2RpZmllcnMsXG4gIGdldFJlZGlyZWN0TmFtZTogZ2V0UmVkaXJlY3ROYW1lLFxuICBoYXNWYWxpZENvbnRlbnRUeXBlOiBoYXNWYWxpZENvbnRlbnRUeXBlXG59O1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbnZhciBhcnJheUxpa2VUb0FycmF5ID0gX2FycmF5TGlrZVRvQXJyYXk7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxudmFyIGFycmF5V2l0aG91dEhvbGVzID0gX2FycmF5V2l0aG91dEhvbGVzO1xuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSBfaXRlcmFibGVUb0FycmF5O1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IF9ub25JdGVyYWJsZVNwcmVhZDtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IF90b0NvbnN1bWFibGVBcnJheTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG52YXIgYXJyYXlXaXRoSG9sZXMgPSBfYXJyYXlXaXRoSG9sZXM7XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSBfbm9uSXRlcmFibGVSZXN0O1xuXG5mdW5jdGlvbiBfdG9BcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxudmFyIHRvQXJyYXkgPSBfdG9BcnJheTtcblxuLyoqXG4gKiBBZEd1YXJkIHNjcmlwdGxldCBydWxlXG4gKi9cblxudmFyIEFER1VBUkRfU0NSSVBUTEVUX01BU0tfUkVHID0gLyNAPyUjXFwvXFwvc2NyaXB0bGV0XFwoLitcXCkvOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGVtcGxhdGUtY3VybHktaW4tc3RyaW5nXG5cbnZhciBBREdVQVJEX1NDUklQVExFVF9URU1QTEFURSA9ICcke2RvbWFpbnN9IyUjLy9zY3JpcHRsZXQoJHthcmdzfSknOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGVtcGxhdGUtY3VybHktaW4tc3RyaW5nXG5cbnZhciBBREdVQVJEX1NDUklQVExFVF9FWENFUFRJT05fVEVNUExBVEUgPSAnJHtkb21haW5zfSNAJSMvL3NjcmlwdGxldCgke2FyZ3N9KSc7XG4vKipcbiAqIHVCbG9jayBzY3JpcHRsZXQgcnVsZSBtYXNrXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10ZW1wbGF0ZS1jdXJseS1pbi1zdHJpbmdcblxudmFyIFVCT19TQ1JJUFRMRVRfVEVNUExBVEUgPSAnJHtkb21haW5zfSMjK2pzKCR7YXJnc30pJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRlbXBsYXRlLWN1cmx5LWluLXN0cmluZ1xuXG52YXIgVUJPX1NDUklQVExFVF9FWENFUFRJT05fVEVNUExBVEUgPSAnJHtkb21haW5zfSNAIytqcygke2FyZ3N9KSc7XG52YXIgVUJPX0FMSUFTX05BTUVfTUFSS0VSID0gJ3Viby0nO1xudmFyIFVCT19TQ1JJUFRMRVRfSlNfRU5ESU5HID0gJy5qcyc7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1N0YXRpYy1maWx0ZXItc3ludGF4I3hoclxuXG52YXIgVUJPX1hIUl9UWVBFID0gJ3hocic7XG52YXIgQURHX1hIUl9UWVBFID0gJ3htbGh0dHByZXF1ZXN0JztcbnZhciBBREdfU0VUX0NPTlNUQU5UX05BTUUgPSAnc2V0LWNvbnN0YW50JztcbnZhciBBREdfU0VUX0NPTlNUQU5UX0VNUFRZX1NUUklORyA9ICcnO1xudmFyIFVCT19TRVRfQ09OU1RBTlRfRU1QVFlfU1RSSU5HID0gJ1xcJ1xcJyc7XG52YXIgQURHX1BSRVZFTlRfRkVUQ0hfTkFNRSA9ICdwcmV2ZW50LWZldGNoJztcbnZhciBBREdfUFJFVkVOVF9GRVRDSF9FTVBUWV9TVFJJTkcgPSAnJztcbnZhciBBREdfUFJFVkVOVF9GRVRDSF9XSUxEQ0FSRCA9IGdldFdpbGRjYXJkU3ltYm9sKCk7XG52YXIgVUJPX05PX0ZFVENIX0lGX1dJTERDQVJEID0gJy9eLyc7XG52YXIgRVNDQVBFRF9DT01NQV9TRVBBUkFUT1IgPSAnXFxcXCwnO1xudmFyIENPTU1BX1NFUEFSQVRPUiA9ICcsJztcbnZhciBNQVhfUkVNT1ZFX0FUVFJfQ0xBU1NfQVJHU19DT1VOVCA9IDM7XG52YXIgUkVNT1ZFX0FUVFJfTUVUSE9EID0gJ3JlbW92ZUF0dHInO1xudmFyIFJFTU9WRV9DTEFTU19NRVRIT0QgPSAncmVtb3ZlQ2xhc3MnO1xudmFyIFJFTU9WRV9BVFRSX0FMSUFTRVMgPSBzY3JpcHRsZXRMaXN0W1JFTU9WRV9BVFRSX01FVEhPRF0ubmFtZXM7XG52YXIgUkVNT1ZFX0NMQVNTX0FMSUFTRVMgPSBzY3JpcHRsZXRMaXN0W1JFTU9WRV9DTEFTU19NRVRIT0RdLm5hbWVzO1xudmFyIEFER19SRU1PVkVfQVRUUl9OQU1FID0gUkVNT1ZFX0FUVFJfQUxJQVNFU1swXTtcbnZhciBBREdfUkVNT1ZFX0NMQVNTX05BTUUgPSBSRU1PVkVfQ0xBU1NfQUxJQVNFU1swXTtcbi8qKlxuICogUmV0dXJucyBhcnJheSBvZiBzdHJpbmdzIHNlcGFyYXRlZCBieSBzcGFjZSB3aGljaCBub3QgaW4gcXVvdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKi9cblxudmFyIGdldFNlbnRlbmNlcyA9IGZ1bmN0aW9uIGdldFNlbnRlbmNlcyhzdHIpIHtcbiAgdmFyIHJlZyA9IC8nLio/J3xcIi4qP1wifFxcUysvZztcbiAgcmV0dXJuIHN0ci5tYXRjaChyZWcpO1xufTtcbi8qKlxuICogUmVwbGFjZXMgc3RyaW5nIHdpdGggZGF0YSBieSBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gd2hlcmUga2V5cyBhcmUgcGxhY2Vob2xkZXJzIG5hbWVzXG4gKi9cblxuXG52YXIgcmVwbGFjZVBsYWNlaG9sZGVycyA9IGZ1bmN0aW9uIHJlcGxhY2VQbGFjZWhvbGRlcnMoc3RyLCBkYXRhKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCJcXFxcJFxcXFx7XCIuY29uY2F0KGtleSwgXCJcXFxcfVwiKSwgJ2cnKTtcbiAgICBhY2MgPSBhY2MucmVwbGFjZShyZWcsIGRhdGFba2V5XSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgc3RyKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyBvZiBVQk8gc2NyaXB0bGV0IHJ1bGUgdG8gQWRHdWFyZCBzY3JpdGxldCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIFVCTyBzY3JpcHRsZXQgcnVsZVxuICogQHJldHVybnMge0FycmF5fSAtIGFycmF5IHdpdGggb25lIEFkR3VhcmQgc2NyaXB0bGV0IHJ1bGVcbiAqL1xuXG5cbnZhciBjb252ZXJ0VWJvU2NyaXB0bGV0VG9BZGcgPSBmdW5jdGlvbiBjb252ZXJ0VWJvU2NyaXB0bGV0VG9BZGcocnVsZSkge1xuICB2YXIgZG9tYWlucyA9IGdldEJlZm9yZVJlZ0V4cChydWxlLCB2YWxpZGF0b3IuVUJPX1NDUklQVExFVF9NQVNLX1JFRyk7XG4gIHZhciBtYXNrID0gcnVsZS5tYXRjaCh2YWxpZGF0b3IuVUJPX1NDUklQVExFVF9NQVNLX1JFRylbMF07XG4gIHZhciB0ZW1wbGF0ZTtcblxuICBpZiAobWFzay5pbmRleE9mKCdAJykgPiAtMSkge1xuICAgIHRlbXBsYXRlID0gQURHVUFSRF9TQ1JJUFRMRVRfRVhDRVBUSU9OX1RFTVBMQVRFO1xuICB9IGVsc2Uge1xuICAgIHRlbXBsYXRlID0gQURHVUFSRF9TQ1JJUFRMRVRfVEVNUExBVEU7XG4gIH1cblxuICB2YXIgcGFyc2VkQXJncyA9IGdldFN0cmluZ0luQnJhY2VzKHJ1bGUpLnNwbGl0KC8sXFxzL2cpO1xuXG4gIGlmIChwYXJzZWRBcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIE1vc3QgcHJvYmFibHkgdGhpcyBpcyBub3QgY29ycmVjdCBzZXBhcmF0b3IsIGluIHRoaXMgY2FzZSB3ZSB1c2UgJywnXG4gICAgcGFyc2VkQXJncyA9IGdldFN0cmluZ0luQnJhY2VzKHJ1bGUpLnNwbGl0KC8sL2cpO1xuICB9XG5cbiAgdmFyIHNjcmlwdGxldE5hbWUgPSBwYXJzZWRBcmdzWzBdLmluZGV4T2YoVUJPX1NDUklQVExFVF9KU19FTkRJTkcpID4gLTEgPyBcInViby1cIi5jb25jYXQocGFyc2VkQXJnc1swXSkgOiBcInViby1cIi5jb25jYXQocGFyc2VkQXJnc1swXSkuY29uY2F0KFVCT19TQ1JJUFRMRVRfSlNfRU5ESU5HKTtcblxuICBpZiAoKFJFTU9WRV9BVFRSX0FMSUFTRVMuaW5kZXhPZihzY3JpcHRsZXROYW1lKSA+IC0xIHx8IFJFTU9WRV9DTEFTU19BTElBU0VTLmluZGV4T2Yoc2NyaXB0bGV0TmFtZSkgPiAtMSkgJiYgcGFyc2VkQXJncy5sZW5ndGggPiBNQVhfUkVNT1ZFX0FUVFJfQ0xBU1NfQVJHU19DT1VOVCkge1xuICAgIHBhcnNlZEFyZ3MgPSBbcGFyc2VkQXJnc1swXSwgcGFyc2VkQXJnc1sxXSwgLy8gaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiAzIGFyZ3MgZm9yIHJlbW92ZS1hdHRyL2NsYXNzIHNjcmlwdGxldCxcbiAgICAvLyB1Ym8gcnVsZSBoYXMgbWFsdGlwbGUgc2VsZWN0b3Igc2VwYXJhdGVkIGJ5IGNvbW1hLiBzbyB3ZSBzaG91bGQ6XG4gICAgLy8gMS4gam9pbiB0aGVtIGludG8gYSBzaW5nbGUgc3RyaW5nXG4gICAgLy8gMi4gcmVwbGFjZSBlc2NhcGVkIGNvbW1hcyBieSByZWd1bGFyIG9uZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTMzXG4gICAgcmVwbGFjZUFsbChwYXJzZWRBcmdzLnNsaWNlKDIpLmpvaW4oXCJcIi5jb25jYXQoQ09NTUFfU0VQQVJBVE9SLCBcIiBcIikpLCBFU0NBUEVEX0NPTU1BX1NFUEFSQVRPUiwgQ09NTUFfU0VQQVJBVE9SKV07XG4gIH1cblxuICB2YXIgYXJncyA9IHBhcnNlZEFyZ3MubWFwKGZ1bmN0aW9uIChhcmcsIGluZGV4KSB7XG4gICAgdmFyIG91dHB1dEFyZyA9IGFyZztcblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb3V0cHV0QXJnID0gc2NyaXB0bGV0TmFtZTtcbiAgICB9IC8vIGZvciBleGFtcGxlOiBkcmFtYXNlcmlhbC54eXojIytqcyhhYm9ydC1jdXJyZW50LWlubGluZS1zY3JpcHQsICQsIHBvcHVwKVxuXG5cbiAgICBpZiAoYXJnID09PSAnJCcpIHtcbiAgICAgIG91dHB1dEFyZyA9ICckJCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dEFyZztcbiAgfSkubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gd3JhcEluU2luZ2xlUXVvdGVzKGFyZyk7XG4gIH0pLmpvaW4oXCJcIi5jb25jYXQoQ09NTUFfU0VQQVJBVE9SLCBcIiBcIikpO1xuICB2YXIgYWRnUnVsZSA9IHJlcGxhY2VQbGFjZWhvbGRlcnModGVtcGxhdGUsIHtcbiAgICBkb21haW5zOiBkb21haW5zLFxuICAgIGFyZ3M6IGFyZ3NcbiAgfSk7XG4gIHJldHVybiBbYWRnUnVsZV07XG59O1xuLyoqXG4gKiBDb252ZXJ0IHN0cmluZyBvZiBBQlAgc25pcHBldCBydWxlIHRvIEFkR3VhcmQgc2NyaXRsZXQgcnVsZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBBQlAgc25pcHBldCBydWxlXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gYXJyYXkgb2YgQWRHdWFyZCBzY3JpcHRsZXQgcnVsZXMgLVxuICogb25lIG9yIGZldyBpdGVtcyBkZXBlbmRzIG9uIEFicC1ydWxlXG4gKi9cblxudmFyIGNvbnZlcnRBYnBTbmlwcGV0VG9BZGcgPSBmdW5jdGlvbiBjb252ZXJ0QWJwU25pcHBldFRvQWRnKHJ1bGUpIHtcbiAgdmFyIFNFTUlDT0xPTl9ESVZJREVSID0gLzsoPz0oPzooPzpbXlwiXSpcIil7Mn0pKlteXCJdKiQpL2c7XG4gIHZhciBtYXNrID0gcnVsZS5pbmRleE9mKHZhbGlkYXRvci5BQlBfU0NSSVBUTEVUX01BU0spID4gLTEgPyB2YWxpZGF0b3IuQUJQX1NDUklQVExFVF9NQVNLIDogdmFsaWRhdG9yLkFCUF9TQ1JJUFRMRVRfRVhDRVBUSU9OX01BU0s7XG4gIHZhciB0ZW1wbGF0ZSA9IG1hc2sgPT09IHZhbGlkYXRvci5BQlBfU0NSSVBUTEVUX01BU0sgPyBBREdVQVJEX1NDUklQVExFVF9URU1QTEFURSA6IEFER1VBUkRfU0NSSVBUTEVUX0VYQ0VQVElPTl9URU1QTEFURTtcbiAgdmFyIGRvbWFpbnMgPSBzdWJzdHJpbmdCZWZvcmUocnVsZSwgbWFzayk7XG4gIHZhciBhcmdzID0gc3Vic3RyaW5nQWZ0ZXIocnVsZSwgbWFzayk7XG4gIHJldHVybiBhcmdzLnNwbGl0KFNFTUlDT0xPTl9ESVZJREVSKS5tYXAoZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gZ2V0U2VudGVuY2VzKGFyZ3MpLmZpbHRlcihmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoYXJnLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gXCJhYnAtXCIuY29uY2F0KGFyZykgOiBhcmc7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiB3cmFwSW5TaW5nbGVRdW90ZXMoYXJnKTtcbiAgICB9KS5qb2luKFwiXCIuY29uY2F0KENPTU1BX1NFUEFSQVRPUiwgXCIgXCIpKTtcbiAgfSkubWFwKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VQbGFjZWhvbGRlcnModGVtcGxhdGUsIHtcbiAgICAgIGRvbWFpbnM6IGRvbWFpbnMsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gIH0pO1xufTtcbi8qKlxuICogQ29udmVydHMgc2NyaXB0bGV0IHJ1bGUgdG8gQWRHdWFyZCBvbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gYXJyYXkgb2YgQWRHdWFyZCBzY3JpcHRsZXQgcnVsZXMgLVxuICogb25lIGl0ZW0gZm9yIEFkZyBhbmQgVWJvIG9yIGZldyBpdGVtcyBmb3IgQWJwXG4gKi9cblxudmFyIGNvbnZlcnRTY3JpcHRsZXRUb0FkZyA9IGZ1bmN0aW9uIGNvbnZlcnRTY3JpcHRsZXRUb0FkZyhydWxlKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKHZhbGlkYXRvci5pc1Vib1NjcmlwdGxldFJ1bGUocnVsZSkpIHtcbiAgICByZXN1bHQgPSBjb252ZXJ0VWJvU2NyaXB0bGV0VG9BZGcocnVsZSk7XG4gIH0gZWxzZSBpZiAodmFsaWRhdG9yLmlzQWJwU25pcHBldFJ1bGUocnVsZSkpIHtcbiAgICByZXN1bHQgPSBjb252ZXJ0QWJwU25pcHBldFRvQWRnKHJ1bGUpO1xuICB9IGVsc2UgaWYgKHZhbGlkYXRvci5pc0FkZ1NjcmlwdGxldFJ1bGUocnVsZSkgfHwgdmFsaWRhdG9yLmlzQ29tbWVudChydWxlKSkge1xuICAgIHJlc3VsdCA9IFtydWxlXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBVQk8gc2NyaXB0bGV0IHJ1bGUgdG8gQWRHdWFyZCBvbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIC0gQWRHdWFyZCBzY3JpcHRsZXQgcnVsZVxuICogQHJldHVybnMge3N0cmluZ30gLSBVQk8gc2NyaXB0bGV0IHJ1bGVcbiAqL1xuXG52YXIgY29udmVydEFkZ1NjcmlwdGxldFRvVWJvID0gZnVuY3Rpb24gY29udmVydEFkZ1NjcmlwdGxldFRvVWJvKHJ1bGUpIHtcbiAgdmFyIHJlcztcblxuICBpZiAodmFsaWRhdG9yLmlzQWRnU2NyaXB0bGV0UnVsZShydWxlKSkge1xuICAgIHZhciBfcGFyc2VSdWxlID0gcGFyc2VSdWxlKHJ1bGUpLFxuICAgICAgICBwYXJzZWROYW1lID0gX3BhcnNlUnVsZS5uYW1lLFxuICAgICAgICBwYXJzZWRQYXJhbXMgPSBfcGFyc2VSdWxlLmFyZ3M7XG5cbiAgICB2YXIgcHJlcGFyZWRQYXJhbXM7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9GaWx0ZXJzQ29tcGlsZXIvaXNzdWVzLzEwMlxuXG4gICAgaWYgKHBhcnNlZE5hbWUgPT09IEFER19TRVRfQ09OU1RBTlRfTkFNRSAmJiBwYXJzZWRQYXJhbXNbMV0gPT09IEFER19TRVRfQ09OU1RBTlRfRU1QVFlfU1RSSU5HKSB7XG4gICAgICBwcmVwYXJlZFBhcmFtcyA9IFtwYXJzZWRQYXJhbXNbMF0sIFVCT19TRVRfQ09OU1RBTlRfRU1QVFlfU1RSSU5HXTtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZE5hbWUgPT09IEFER19QUkVWRU5UX0ZFVENIX05BTUUgLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzEwOVxuICAgICYmIChwYXJzZWRQYXJhbXNbMF0gPT09IEFER19QUkVWRU5UX0ZFVENIX1dJTERDQVJEIHx8IHBhcnNlZFBhcmFtc1swXSA9PT0gQURHX1BSRVZFTlRfRkVUQ0hfRU1QVFlfU1RSSU5HKSkge1xuICAgICAgcHJlcGFyZWRQYXJhbXMgPSBbVUJPX05PX0ZFVENIX0lGX1dJTERDQVJEXTtcbiAgICB9IGVsc2UgaWYgKChwYXJzZWROYW1lID09PSBBREdfUkVNT1ZFX0FUVFJfTkFNRSB8fCBwYXJzZWROYW1lID09PSBBREdfUkVNT1ZFX0NMQVNTX05BTUUpICYmIHBhcnNlZFBhcmFtc1sxXSAmJiBwYXJzZWRQYXJhbXNbMV0uaW5kZXhPZihDT01NQV9TRVBBUkFUT1IpID4gLTEpIHtcbiAgICAgIHByZXBhcmVkUGFyYW1zID0gW3BhcnNlZFBhcmFtc1swXSwgcmVwbGFjZUFsbChwYXJzZWRQYXJhbXNbMV0sIENPTU1BX1NFUEFSQVRPUiwgRVNDQVBFRF9DT01NQV9TRVBBUkFUT1IpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlcGFyZWRQYXJhbXMgPSBwYXJzZWRQYXJhbXM7XG4gICAgfSAvLyBvYmplY3Qgb2YgbmFtZSBhbmQgYWxpYXNlcyBmb3IgdGhlIEFkZy1zY3JpcHRsZXRcblxuXG4gICAgdmFyIGFkZ1NjcmlwdGxldE9iamVjdCA9IE9iamVjdC5rZXlzKHNjcmlwdGxldExpc3QpLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBzY3JpcHRsZXRMaXN0W2VsXTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHZhciBfcyRuYW1lcyA9IHRvQXJyYXkocy5uYW1lcyksXG4gICAgICAgICAgbmFtZSA9IF9zJG5hbWVzWzBdLFxuICAgICAgICAgIGFsaWFzZXMgPSBfcyRuYW1lcy5zbGljZSgxKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgYWxpYXNlczogYWxpYXNlc1xuICAgICAgfTtcbiAgICB9KS5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsLm5hbWUgPT09IHBhcnNlZE5hbWUgfHwgZWwuYWxpYXNlcy5pbmRleE9mKHBhcnNlZE5hbWUpID49IDA7XG4gICAgfSk7XG4gICAgdmFyIGFsaWFzZXMgPSBhZGdTY3JpcHRsZXRPYmplY3QuYWxpYXNlcztcblxuICAgIGlmIChhbGlhc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB1Ym9BbGlhcyA9IGFkZ1NjcmlwdGxldE9iamVjdC5hbGlhc2VzIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcbiAgICAgIC5maW5kKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXR1cm4gYWxpYXMuaW5jbHVkZXMoVUJPX0FMSUFTX05BTUVfTUFSS0VSKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodWJvQWxpYXMpIHtcbiAgICAgICAgdmFyIG1hc2sgPSBydWxlLm1hdGNoKEFER1VBUkRfU0NSSVBUTEVUX01BU0tfUkVHKVswXTtcbiAgICAgICAgdmFyIHRlbXBsYXRlO1xuXG4gICAgICAgIGlmIChtYXNrLmluZGV4T2YoJ0AnKSA+IC0xKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBVQk9fU0NSSVBUTEVUX0VYQ0VQVElPTl9URU1QTEFURTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IFVCT19TQ1JJUFRMRVRfVEVNUExBVEU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9tYWlucyA9IGdldEJlZm9yZVJlZ0V4cChydWxlLCBBREdVQVJEX1NDUklQVExFVF9NQVNLX1JFRyk7XG4gICAgICAgIHZhciB1Ym9OYW1lID0gdWJvQWxpYXMucmVwbGFjZShVQk9fQUxJQVNfTkFNRV9NQVJLRVIsICcnKSAvLyAnLmpzJyBpbiB0aGUgVWJvIHNjcmlwdGxldCBuYW1lIGNhbiBiZSBvbWl0dGVkXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay93aWtpL1Jlc291cmNlcy1MaWJyYXJ5I2dlbmVyYWwtcHVycG9zZS1zY3JpcHRsZXRzXG4gICAgICAgIC5yZXBsYWNlKFVCT19TQ1JJUFRMRVRfSlNfRU5ESU5HLCAnJyk7XG4gICAgICAgIHZhciBhcmdzID0gcHJlcGFyZWRQYXJhbXMubGVuZ3RoID4gMCA/IFwiXCIuY29uY2F0KHVib05hbWUsIFwiLCBcIikuY29uY2F0KHByZXBhcmVkUGFyYW1zLmpvaW4oXCJcIi5jb25jYXQoQ09NTUFfU0VQQVJBVE9SLCBcIiBcIikpKSA6IHVib05hbWU7XG4gICAgICAgIHZhciB1Ym9SdWxlID0gcmVwbGFjZVBsYWNlaG9sZGVycyh0ZW1wbGF0ZSwge1xuICAgICAgICAgIGRvbWFpbnM6IGRvbWFpbnMsXG4gICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzID0gdWJvUnVsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIEFERyBzY3JpcHRsZXQgZXhpc3RzIG9yIFVCTy9BQlAgc2NyaXB0bGV0IGlzIGNvbXBhdGlibGUgdG8gQURHXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBjYW4gYmUgQURHIG9yIFVCTyBvciBBQlAgc2NyaXB0bGV0IHJ1bGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbnZhciBpc1ZhbGlkU2NyaXB0bGV0UnVsZSA9IGZ1bmN0aW9uIGlzVmFsaWRTY3JpcHRsZXRSdWxlKGlucHV0KSB7XG4gIGlmICghaW5wdXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQUJQICdpbnB1dCcgcnVsZSBtYXkgY29udGFpbiBtb3JlIHRoYW4gb25lIHNuaXBwZXRcblxuXG4gIHZhciBydWxlc0FycmF5ID0gY29udmVydFNjcmlwdGxldFRvQWRnKGlucHV0KTsgLy8gY2hlY2tpbmcgaWYgZWFjaCBvZiBwYXJzZWQgc2NyaXB0bGV0cyBpcyB2YWxpZFxuICAvLyBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlbSBpcyBub3QgdmFsaWQgLSB3aG9sZSAnaW5wdXQnIHJ1bGUgaXMgbm90IHZhbGlkIHRvb1xuXG4gIHZhciBpc1ZhbGlkID0gcnVsZXNBcnJheS5ldmVyeShmdW5jdGlvbiAocnVsZSkge1xuICAgIHZhciBwYXJzZWRSdWxlID0gcGFyc2VSdWxlKHJ1bGUpO1xuICAgIHJldHVybiB2YWxpZGF0b3IuaXNWYWxpZFNjcmlwdGxldE5hbWUocGFyc2VkUnVsZS5uYW1lKTtcbiAgfSk7XG4gIHJldHVybiBpc1ZhbGlkO1xufTtcbi8qKlxuICogQ29udmVydHMgVWJvIHJlZGlyZWN0IHJ1bGUgdG8gQWRnIG9uZVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxudmFyIGNvbnZlcnRVYm9SZWRpcmVjdFRvQWRnID0gZnVuY3Rpb24gY29udmVydFVib1JlZGlyZWN0VG9BZGcocnVsZSkge1xuICB2YXIgZmlyc3RQYXJ0T2ZSdWxlID0gc3Vic3RyaW5nQmVmb3JlKHJ1bGUsICckJyk7XG4gIHZhciB1Ym9Nb2RpZmllcnMgPSB2YWxpZGF0b3IucGFyc2VNb2RpZmllcnMocnVsZSk7XG4gIHZhciBhZGdNb2RpZmllcnMgPSB1Ym9Nb2RpZmllcnMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbC5pbmRleE9mKHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLlVCTy5tYXJrZXIpID4gLTEpIHtcbiAgICAgIHZhciB1Ym9OYW1lID0gc3Vic3RyaW5nQWZ0ZXIoZWwsIHZhbGlkYXRvci5SRURJUkVDVF9SVUxFX1RZUEVTLlVCTy5tYXJrZXIpO1xuICAgICAgdmFyIGFkZ05hbWUgPSB2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5VQk8uY29tcGF0aWJpbGl0eVt1Ym9OYW1lXTtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcubWFya2VyKS5jb25jYXQoYWRnTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGVsID09PSBVQk9fWEhSX1RZUEUpIHtcbiAgICAgIHJldHVybiBBREdfWEhSX1RZUEU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xuICB9KS5qb2luKENPTU1BX1NFUEFSQVRPUik7XG4gIHJldHVybiBcIlwiLmNvbmNhdChmaXJzdFBhcnRPZlJ1bGUsIFwiJFwiKS5jb25jYXQoYWRnTW9kaWZpZXJzKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIEFicCByZWRpcmVjdCBydWxlIHRvIEFkZyBvbmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBjb252ZXJ0QWJwUmVkaXJlY3RUb0FkZyA9IGZ1bmN0aW9uIGNvbnZlcnRBYnBSZWRpcmVjdFRvQWRnKHJ1bGUpIHtcbiAgdmFyIGZpcnN0UGFydE9mUnVsZSA9IHN1YnN0cmluZ0JlZm9yZShydWxlLCAnJCcpO1xuICB2YXIgYWJwTW9kaWZpZXJzID0gdmFsaWRhdG9yLnBhcnNlTW9kaWZpZXJzKHJ1bGUpO1xuICB2YXIgYWRnTW9kaWZpZXJzID0gYWJwTW9kaWZpZXJzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwuaW5kZXhPZih2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BQlAubWFya2VyKSA+IC0xKSB7XG4gICAgICB2YXIgYWJwTmFtZSA9IHN1YnN0cmluZ0FmdGVyKGVsLCB2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BQlAubWFya2VyKTtcbiAgICAgIHZhciBhZGdOYW1lID0gdmFsaWRhdG9yLlJFRElSRUNUX1JVTEVfVFlQRVMuQUJQLmNvbXBhdGliaWxpdHlbYWJwTmFtZV07XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsaWRhdG9yLlJFRElSRUNUX1JVTEVfVFlQRVMuQURHLm1hcmtlcikuY29uY2F0KGFkZ05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfSkuam9pbihDT01NQV9TRVBBUkFUT1IpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoZmlyc3RQYXJ0T2ZSdWxlLCBcIiRcIikuY29uY2F0KGFkZ01vZGlmaWVycyk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyByZWRpcmVjdCBydWxlIHRvIEFkR3VhcmQgb25lXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVsZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG52YXIgY29udmVydFJlZGlyZWN0VG9BZGcgPSBmdW5jdGlvbiBjb252ZXJ0UmVkaXJlY3RUb0FkZyhydWxlKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKHZhbGlkYXRvci5pc1Vib1JlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcocnVsZSkpIHtcbiAgICByZXN1bHQgPSBjb252ZXJ0VWJvUmVkaXJlY3RUb0FkZyhydWxlKTtcbiAgfSBlbHNlIGlmICh2YWxpZGF0b3IuaXNBYnBSZWRpcmVjdENvbXBhdGlibGVXaXRoQWRnKHJ1bGUpKSB7XG4gICAgcmVzdWx0ID0gY29udmVydEFicFJlZGlyZWN0VG9BZGcocnVsZSk7XG4gIH0gZWxzZSBpZiAodmFsaWRhdG9yLmlzVmFsaWRBZGdSZWRpcmVjdFJ1bGUocnVsZSkpIHtcbiAgICByZXN1bHQgPSBydWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIENvbnZlcnRzIEFkZyByZWRpcmVjdCBydWxlIHRvIFVibyBvbmVcbiAqIDEuIENoZWNrcyBpZiB0aGVyZSBpcyBVYm8gYW5hbG9nIGZvciBBZGcgcnVsZVxuICogMi4gUGFyc2VzIHRoZSBydWxlIGFuZCBjaGVjaHMgaWYgdGhlcmUgYXJlIGFueSBzb3VyY2UgdHlwZSBtb2RpZmllcnMgd2hpY2ggYXJlIHJlcXVpcmVkIGJ5IFVib1xuICogICAgYW5kIGlmIHRoZXJlIGFyZSBubyBvbmUgd2UgYWRkIGl0IG1hbnVhbGx5IHRvIHRoZSBlbmQuXG4gKiAgICBTb3VyY2UgdHlwZXMgYXJlIGNob3NlbiBhY2NvcmRpbmcgdG8gcmVkaXJlY3QgbmFtZVxuICogICAgZS5nLiB8fGFkLmNvbV4kcmVkaXJlY3Q9PG5hbWU+LGltcG9ydGFudCAgLT4+ICB8fGFkLmNvbV4kcmVkaXJlY3Q9PG5hbWU+LGltcG9ydGFudCxzY3JpcHRcbiAqIDMuIFJlcGxhY2VzIEFkZyByZWRpcmVjdCBuYW1lIGJ5IFVibyBhbmFsb2dcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbnZhciBjb252ZXJ0QWRnUmVkaXJlY3RUb1VibyA9IGZ1bmN0aW9uIGNvbnZlcnRBZGdSZWRpcmVjdFRvVWJvKHJ1bGUpIHtcbiAgaWYgKCF2YWxpZGF0b3IuaXNBZGdSZWRpcmVjdENvbXBhdGlibGVXaXRoVWJvKHJ1bGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvbnZlcnQgZm9yIHVCTyAtIHVuc3VwcG9ydGVkIHJlZGlyZWN0IGluIHJ1bGU6IFwiLmNvbmNhdChydWxlKSk7XG4gIH1cblxuICB2YXIgYmFzZVBhcnQgPSBzdWJzdHJpbmdCZWZvcmUocnVsZSwgJyQnKTtcbiAgdmFyIGFkZ01vZGlmaWVycyA9IHZhbGlkYXRvci5wYXJzZU1vZGlmaWVycyhydWxlKTtcbiAgdmFyIGFkZ1JlZGlyZWN0TW9kaWZpZXIgPSBhZGdNb2RpZmllcnMuZmluZChmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuaW5kZXhPZih2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5BREcubWFya2VyKSA+IC0xO1xuICB9KTtcbiAgdmFyIGFkZ1JlZGlyZWN0TmFtZSA9IGFkZ1JlZGlyZWN0TW9kaWZpZXIuc2xpY2UodmFsaWRhdG9yLlJFRElSRUNUX1JVTEVfVFlQRVMuQURHLm1hcmtlci5sZW5ndGgpO1xuICB2YXIgdWJvUmVkaXJlY3ROYW1lID0gdmFsaWRhdG9yLlJFRElSRUNUX1JVTEVfVFlQRVMuQURHLmNvbXBhdGliaWxpdHlbYWRnUmVkaXJlY3ROYW1lXTtcbiAgdmFyIHVib1JlZGlyZWN0TW9kaWZpZXIgPSBcIlwiLmNvbmNhdCh2YWxpZGF0b3IuUkVESVJFQ1RfUlVMRV9UWVBFUy5VQk8ubWFya2VyKS5jb25jYXQodWJvUmVkaXJlY3ROYW1lKTtcblxuICBpZiAoIXZhbGlkYXRvci5oYXNWYWxpZENvbnRlbnRUeXBlKHJ1bGUpKSB7XG4gICAgLy8gYWRkIG1pc3NlZCBzb3VyY2UgdHlwZXMgYXMgY29udGVudCB0eXBlIG1vZGlmaWVyc1xuICAgIHZhciBzb3VyY2VUeXBlc0RhdGEgPSB2YWxpZGF0b3IuQUJTRU5UX1NPVVJDRV9UWVBFX1JFUExBQ0VNRU5ULmZpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwuTkFNRSA9PT0gYWRnUmVkaXJlY3ROYW1lO1xuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2VUeXBlc0RhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29udmVydCBmb3IgdUJPIC0gbm8gdHlwZXMgdG8gYWRkIGZvciBzcGVjaWZpYyByZWRpcmVjdCBpbiBydWxlOiBcIi5jb25jYXQocnVsZSkpO1xuICAgIH1cblxuICAgIHZhciBhZGRpdGlvbk1vZGlmaWVycyA9IHNvdXJjZVR5cGVzRGF0YS5UWVBFUztcbiAgICBhZGdNb2RpZmllcnMucHVzaC5hcHBseShhZGdNb2RpZmllcnMsIHRvQ29uc3VtYWJsZUFycmF5KGFkZGl0aW9uTW9kaWZpZXJzKSk7XG4gIH1cblxuICB2YXIgdWJvTW9kaWZpZXJzID0gYWRnTW9kaWZpZXJzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwgPT09IGFkZ1JlZGlyZWN0TW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiB1Ym9SZWRpcmVjdE1vZGlmaWVyO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbiAgfSkuam9pbihDT01NQV9TRVBBUkFUT1IpO1xuICByZXR1cm4gXCJcIi5jb25jYXQoYmFzZVBhcnQsIFwiJFwiKS5jb25jYXQodWJvTW9kaWZpZXJzKTtcbn07XG5cbi8qKlxuICogQHJlZGlyZWN0IGdvb2dsZS1hbmFseXRpY3NcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1vY2tzIEdvb2dsZSdzIEFuYWx5dGljcyBhbmQgVGFnIE1hbmFnZXIgQVBJcy5cbiAqIFtDb3ZlcnMgb2Jzb2xldGUgZ29vZ2xldGFnbWFuYWdlci1ndG0gcmVkaXJlY3QgZnVuY3Rpb25hbGl0eV0oaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzEyNykuXG4gKlxuICogUmVsYXRlZCBVQk8gcmVkaXJlY3QgcmVzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svYmxvYi84Y2QyYTFkMjYzYTk2NDIxNDg3YjM5MDQwYzFkMjNlYjAxMTY5NDg0L3NyYy93ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMvZ29vZ2xlLWFuYWx5dGljc19hbmFseXRpY3MuanNcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fGdvb2dsZS1hbmFseXRpY3MuY29tL2FuYWx5dGljcy5qcyRzY3JpcHQscmVkaXJlY3Q9Z29vZ2xlLWFuYWx5dGljc1xuICogfHxnb29nbGV0YWdtYW5hZ2VyLmNvbS9ndG0uanMkc2NyaXB0LHJlZGlyZWN0PWdvb2dsZXRhZ21hbmFnZXItZ3RtXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBHb29nbGVBbmFseXRpY3Moc291cmNlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHZhciBUcmFja2VyID0gZnVuY3Rpb24gVHJhY2tlcigpIHt9OyAvLyBjb25zdHJ1Y3RvclxuXG5cbiAgdmFyIHByb3RvID0gVHJhY2tlci5wcm90b3R5cGU7XG4gIHByb3RvLmdldCA9IG5vb3BGdW5jO1xuICBwcm90by5zZXQgPSBub29wRnVuYztcbiAgcHJvdG8uc2VuZCA9IG5vb3BGdW5jO1xuICB2YXIgZ29vZ2xlQW5hbHl0aWNzTmFtZSA9IHdpbmRvdy5Hb29nbGVBbmFseXRpY3NPYmplY3QgfHwgJ2dhJzsgLy8gYSAtLSBmYWtlIGFyZyBmb3IgJ2dhLmxlbmd0aCA8IDEnIGFudGlhZGJsb2NrIGNoZWNraW5nXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIGZ1bmN0aW9uIGdhKGEpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcblxuXG4gICAgdmFyIGxhc3RBcmcgPSBhcmd1bWVudHNbbGVuIC0gMV07XG4gICAgdmFyIHJlcGxhY2VyO1xuXG4gICAgaWYgKGxhc3RBcmcgaW5zdGFuY2VvZiBPYmplY3QgJiYgbGFzdEFyZyAhPT0gbnVsbCAmJiB0eXBlb2YgbGFzdEFyZy5oaXRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVwbGFjZXIgPSBsYXN0QXJnLmhpdENhbGxiYWNrO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy85OFxuICAgICAgcmVwbGFjZXIgPSBmdW5jdGlvbiByZXBsYWNlcigpIHtcbiAgICAgICAgbGFzdEFyZyhnYS5jcmVhdGUoKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzZXRUaW1lb3V0KHJlcGxhY2VyLCAxKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZXgpIHt9XG4gIH1cblxuICBnYS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFja2VyKCk7XG4gIH07XG5cbiAgZ2EuZ2V0QnlOYW1lID0gbm9vcE51bGw7XG4gIGdhLmdldEFsbCA9IG5vb3BBcnJheTtcbiAgZ2EucmVtb3ZlID0gbm9vcEZ1bmM7XG4gIGdhLmxvYWRlZCA9IHRydWU7XG4gIHdpbmRvd1tnb29nbGVBbmFseXRpY3NOYW1lXSA9IGdhO1xuICB2YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICAgIGRhdGFMYXllciA9IF93aW5kb3cuZGF0YUxheWVyLFxuICAgICAgZ29vZ2xlX29wdGltaXplID0gX3dpbmRvdy5nb29nbGVfb3B0aW1pemU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgaWYgKGRhdGFMYXllciBpbnN0YW5jZW9mIE9iamVjdCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YUxheWVyLmhpZGUgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIGRhdGFMYXllci5oaWRlLmVuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGFMYXllci5oaWRlLmVuZCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhTGF5ZXIucHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGFMYXllci5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGVvZiBkYXRhLmV2ZW50Q2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2V0VGltZW91dChkYXRhLmV2ZW50Q2FsbGJhY2ssIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL0FkZ3VhcmRUZWFtL1NjcmlwdGxldHMvaXNzdWVzLzgxXG5cblxuICBpZiAoZ29vZ2xlX29wdGltaXplIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGVvZiBnb29nbGVfb3B0aW1pemUuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICB2YXIgZ29vZ2xlT3B0aW1pemVXcmFwcGVyID0ge307XG4gICAgZ29vZ2xlT3B0aW1pemVXcmFwcGVyLmdldCA9IG5vb3BGdW5jO1xuICAgIHdpbmRvdy5nb29nbGVfb3B0aW1pemUgPSBnb29nbGVPcHRpbWl6ZVdyYXBwZXI7XG4gIH1cblxuICBoaXQoc291cmNlKTtcbn1cbkdvb2dsZUFuYWx5dGljcy5uYW1lcyA9IFsnZ29vZ2xlLWFuYWx5dGljcycsICd1Ym8tZ29vZ2xlLWFuYWx5dGljc19hbmFseXRpY3MuanMnLCAnZ29vZ2xlLWFuYWx5dGljc19hbmFseXRpY3MuanMnLCAvLyBodHRwczovL2dpdGh1Yi5jb20vQWRndWFyZFRlYW0vU2NyaXB0bGV0cy9pc3N1ZXMvMTI3XG4nZ29vZ2xldGFnbWFuYWdlci1ndG0nLCAndWJvLWdvb2dsZXRhZ21hbmFnZXJfZ3RtLmpzJywgJ2dvb2dsZXRhZ21hbmFnZXJfZ3RtLmpzJ107XG5Hb29nbGVBbmFseXRpY3MuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BGdW5jLCBub29wTnVsbCwgbm9vcEFycmF5XTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbi8qKlxuICogQHJlZGlyZWN0IGdvb2dsZS1hbmFseXRpY3MtZ2FcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1vY2tzIG9sZCBHb29nbGUgQW5hbHl0aWNzIEFQSS5cbiAqXG4gKiBSZWxhdGVkIFVCTyByZWRpcmVjdCByZXNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9ibG9iL2E5NGRmN2YzYjI3MDgwYWUyZGNiM2I5MTRhY2UzOWMwYzI5NGQyZjYvc3JjL3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy9nb29nbGUtYW5hbHl0aWNzX2dhLmpzXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogfHxnb29nbGUtYW5hbHl0aWNzLmNvbS9nYS5qcyRzY3JpcHQscmVkaXJlY3Q9Z29vZ2xlLWFuYWx5dGljcy1nYVxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gR29vZ2xlQW5hbHl0aWNzR2Eoc291cmNlKSB7XG4gIC8vIEdhcSBjb25zdHJ1Y3RvclxuICBmdW5jdGlvbiBHYXEoKSB7fVxuXG4gIEdhcS5wcm90b3R5cGUuTmEgPSBub29wRnVuYztcbiAgR2FxLnByb3RvdHlwZS5PID0gbm9vcEZ1bmM7XG4gIEdhcS5wcm90b3R5cGUuU2EgPSBub29wRnVuYztcbiAgR2FxLnByb3RvdHlwZS5UYSA9IG5vb3BGdW5jO1xuICBHYXEucHJvdG90eXBlLlZhID0gbm9vcEZ1bmM7XG4gIEdhcS5wcm90b3R5cGUuX2NyZWF0ZUFzeW5jVHJhY2tlciA9IG5vb3BGdW5jO1xuICBHYXEucHJvdG90eXBlLl9nZXRBc3luY1RyYWNrZXIgPSBub29wRnVuYztcbiAgR2FxLnByb3RvdHlwZS5fZ2V0UGx1Z2luID0gbm9vcEZ1bmM7XG5cbiAgR2FxLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRhdGEoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2FuYWx5dGljcy9kZXZndWlkZXMvY29sbGVjdGlvbi9nYWpzL21ldGhvZHMvZ2FKU0FwaURvbWFpbkRpcmVjdG9yeSNfZ2F0LkdBX1RyYWNrZXJfLl9saW5rXG5cblxuICAgIGlmIChkYXRhWzBdID09PSAnX2xpbmsnICYmIHR5cGVvZiBkYXRhWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihkYXRhWzFdKTtcbiAgICB9IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9pc3N1ZXMvMjE2MlxuXG5cbiAgICBpZiAoZGF0YVswXSA9PT0gJ19zZXQnICYmIGRhdGFbMV0gPT09ICdoaXRDYWxsYmFjaycgJiYgdHlwZW9mIGRhdGFbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRhdGFbMl0oKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdhcSA9IG5ldyBHYXEoKTtcbiAgdmFyIGFzeW5jVHJhY2tlcnMgPSB3aW5kb3cuX2dhcSB8fCBbXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhc3luY1RyYWNrZXJzKSkge1xuICAgIHdoaWxlIChhc3luY1RyYWNrZXJzWzBdKSB7XG4gICAgICBnYXEucHVzaChhc3luY1RyYWNrZXJzLnNoaWZ0KCkpO1xuICAgIH1cbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG5cblxuICB3aW5kb3cuX2dhcSA9IGdhcS5xZiA9IGdhcTsgLy8gR2F0IGNvbnN0cnVjdG9yXG5cbiAgZnVuY3Rpb24gR2F0KCkge30gLy8gTW9jayB0cmFja2VyIGFwaVxuXG5cbiAgdmFyIGFwaSA9IFsnX2FkZElnbm9yZWRPcmdhbmljJywgJ19hZGRJZ25vcmVkUmVmJywgJ19hZGRJdGVtJywgJ19hZGRPcmdhbmljJywgJ19hZGRUcmFucycsICdfY2xlYXJJZ25vcmVkT3JnYW5pYycsICdfY2xlYXJJZ25vcmVkUmVmJywgJ19jbGVhck9yZ2FuaWMnLCAnX2Nvb2tpZVBhdGhDb3B5JywgJ19kZWxldGVDdXN0b21WYXInLCAnX2dldE5hbWUnLCAnX3NldEFjY291bnQnLCAnX2dldEFjY291bnQnLCAnX2dldENsaWVudEluZm8nLCAnX2dldERldGVjdEZsYXNoJywgJ19nZXREZXRlY3RUaXRsZScsICdfZ2V0TGlua2VyVXJsJywgJ19nZXRMb2NhbEdpZlBhdGgnLCAnX2dldFNlcnZpY2VNb2RlJywgJ19nZXRWZXJzaW9uJywgJ19nZXRWaXNpdG9yQ3VzdG9tVmFyJywgJ19pbml0RGF0YScsICdfbGluaycsICdfbGlua0J5UG9zdCcsICdfc2V0QWxsb3dBbmNob3InLCAnX3NldEFsbG93SGFzaCcsICdfc2V0QWxsb3dMaW5rZXInLCAnX3NldENhbXBDb250ZW50S2V5JywgJ19zZXRDYW1wTWVkaXVtS2V5JywgJ19zZXRDYW1wTmFtZUtleScsICdfc2V0Q2FtcE5PS2V5JywgJ19zZXRDYW1wU291cmNlS2V5JywgJ19zZXRDYW1wVGVybUtleScsICdfc2V0Q2FtcGFpZ25Db29raWVUaW1lb3V0JywgJ19zZXRDYW1wYWlnblRyYWNrJywgJ19zZXRDbGllbnRJbmZvJywgJ19zZXRDb29raWVQYXRoJywgJ19zZXRDb29raWVQZXJzaXN0ZW5jZScsICdfc2V0Q29va2llVGltZW91dCcsICdfc2V0Q3VzdG9tVmFyJywgJ19zZXREZXRlY3RGbGFzaCcsICdfc2V0RGV0ZWN0VGl0bGUnLCAnX3NldERvbWFpbk5hbWUnLCAnX3NldExvY2FsR2lmUGF0aCcsICdfc2V0TG9jYWxSZW1vdGVTZXJ2ZXJNb2RlJywgJ19zZXRMb2NhbFNlcnZlck1vZGUnLCAnX3NldFJlZmVycmVyT3ZlcnJpZGUnLCAnX3NldFJlbW90ZVNlcnZlck1vZGUnLCAnX3NldFNhbXBsZVJhdGUnLCAnX3NldFNlc3Npb25UaW1lb3V0JywgJ19zZXRTaXRlU3BlZWRTYW1wbGVSYXRlJywgJ19zZXRTZXNzaW9uQ29va2llVGltZW91dCcsICdfc2V0VmFyJywgJ19zZXRWaXNpdG9yQ29va2llVGltZW91dCcsICdfdHJhY2tFdmVudCcsICdfdHJhY2tQYWdlTG9hZFRpbWUnLCAnX3RyYWNrUGFnZXZpZXcnLCAnX3RyYWNrU29jaWFsJywgJ190cmFja1RpbWluZycsICdfdHJhY2tUcmFucycsICdfdmlzaXRDb2RlJ107XG4gIHZhciB0cmFja2VyID0gYXBpLnJlZHVjZShmdW5jdGlvbiAocmVzLCBmdW5jTmFtZSkge1xuICAgIHJlc1tmdW5jTmFtZV0gPSBub29wRnVuYztcbiAgICByZXR1cm4gcmVzO1xuICB9LCB7fSk7XG5cbiAgdHJhY2tlci5fZ2V0TGlua2VyVXJsID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBHYXQucHJvdG90eXBlLl9hbm9ueW1pemVJUCA9IG5vb3BGdW5jO1xuICBHYXQucHJvdG90eXBlLl9jcmVhdGVUcmFja2VyID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUuX2ZvcmNlU1NMID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUuX2dldFBsdWdpbiA9IG5vb3BGdW5jO1xuXG4gIEdhdC5wcm90b3R5cGUuX2dldFRyYWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRyYWNrZXI7XG4gIH07XG5cbiAgR2F0LnByb3RvdHlwZS5fZ2V0VHJhY2tlckJ5TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhY2tlcjtcbiAgfTtcblxuICBHYXQucHJvdG90eXBlLl9nZXRUcmFja2VycyA9IG5vb3BGdW5jO1xuICBHYXQucHJvdG90eXBlLmFhID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUuYWIgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5oYiA9IG5vb3BGdW5jO1xuICBHYXQucHJvdG90eXBlLmxhID0gbm9vcEZ1bmM7XG4gIEdhdC5wcm90b3R5cGUub2EgPSBub29wRnVuYztcbiAgR2F0LnByb3RvdHlwZS5wYSA9IG5vb3BGdW5jO1xuICBHYXQucHJvdG90eXBlLnUgPSBub29wRnVuYztcbiAgdmFyIGdhdCA9IG5ldyBHYXQoKTtcbiAgd2luZG93Ll9nYXQgPSBnYXQ7XG4gIGhpdChzb3VyY2UpO1xufVxuR29vZ2xlQW5hbHl0aWNzR2EubmFtZXMgPSBbJ2dvb2dsZS1hbmFseXRpY3MtZ2EnLCAndWJvLWdvb2dsZS1hbmFseXRpY3NfZ2EuanMnLCAnZ29vZ2xlLWFuYWx5dGljc19nYS5qcyddO1xuR29vZ2xlQW5hbHl0aWNzR2EuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BGdW5jXTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIEByZWRpcmVjdCBnb29nbGVzeW5kaWNhdGlvbi1hZHNieWdvb2dsZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3MgR29vZ2xlIEFkU2Vuc2UgQVBJLlxuICpcbiAqIFJlbGF0ZWQgVUJPIHJlZGlyZWN0IHJlc291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvcmhpbGwvdUJsb2NrL2Jsb2IvYTk0ZGY3ZjNiMjcwODBhZTJkY2IzYjkxNGFjZTM5YzBjMjk0ZDJmNi9zcmMvd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzL2dvb2dsZXN5bmRpY2F0aW9uX2Fkc2J5Z29vZ2xlLmpzXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogfHxwYWdlYWQyLmdvb2dsZXN5bmRpY2F0aW9uLmNvbS9wYWdlYWQvanMvYWRzYnlnb29nbGUuanMkc2NyaXB0LHJlZGlyZWN0PWdvb2dsZXN5bmRpY2F0aW9uLWFkc2J5Z29vZ2xlXG4gKiBgYGBcbiAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuZnVuY3Rpb24gR29vZ2xlU3luZGljYXRpb25BZHNCeUdvb2dsZShzb3VyY2UpIHtcbiAgd2luZG93LmFkc2J5Z29vZ2xlID0ge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BZGd1YXJkVGVhbS9TY3JpcHRsZXRzL2lzc3Vlcy8xMTNcbiAgICAvLyBsZW5ndGg6IDAsXG4gICAgbG9hZGVkOiB0cnVlLFxuICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgYWRFbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5hZHNieWdvb2dsZScpO1xuICB2YXIgY3NzID0gJ2hlaWdodDoxcHghaW1wb3J0YW50O21heC1oZWlnaHQ6MXB4IWltcG9ydGFudDttYXgtd2lkdGg6MXB4IWltcG9ydGFudDt3aWR0aDoxcHghaW1wb3J0YW50Oyc7XG4gIHZhciBzdGF0dXNBdHRyTmFtZSA9ICdkYXRhLWFkc2J5Z29vZ2xlLXN0YXR1cyc7XG4gIHZhciBBU1dJRlRfSUZSQU1FX01BUktFUiA9ICdhc3dpZnRfJztcbiAgdmFyIEdPT0dMRV9BRFNfSUZSQU1FX01BUktFUiA9ICdnb29nbGVfYWRzX2lmcmFtZV8nO1xuICB2YXIgZXhlY3V0ZWQgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFkRWxlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgYWRFbGVtQ2hpbGROb2RlcyA9IGFkRWxlbXNbaV0uY2hpbGROb2RlcztcbiAgICB2YXIgY2hpbGROb2Rlc1F1YW50aXR5ID0gYWRFbGVtQ2hpbGROb2Rlcy5sZW5ndGg7IC8vIGNoaWxkTm9kZXMgb2YgLmFkc2J5Z29vZ2xlIGNhbiBiZSBkZWZpbmVkIGlmIHNjcmlwdGxldCB3YXMgZXhlY3V0ZWQgYmVmb3JlXG4gICAgLy8gc28gd2Ugc2hvdWxkIGNoZWNrIGFyZSB0aGF0IGNoaWxkTm9kZXMgZXhhY3RseSBkZWZpbmVkIGJ5IHVzXG4gICAgLy8gVE9ETzogcmVtYWtlIGFmdGVyIHNjcmlwdGxldHMgY29udGV4dCBkZXZlbG9waW5nIGluIDEuM1xuXG4gICAgdmFyIGFyZUlmcmFtZXNEZWZpbmVkID0gZmFsc2U7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1F1YW50aXR5ID4gMCkge1xuICAgICAgLy8gaXQgc2hvdWxkIGJlIG9ubHkgMiBjaGlsZCBpZnJhbWVzIGlmIHNjcmlwdGxldCB3YXMgZXhlY3V0ZWRcbiAgICAgIGFyZUlmcmFtZXNEZWZpbmVkID0gY2hpbGROb2Rlc1F1YW50aXR5ID09PSAyIC8vIHRoZSBmaXJzdCBvZiBjaGlsZCBub2RlcyBzaG91bGQgYmUgYXN3aWZ0IGlmcmFtZVxuICAgICAgJiYgYWRFbGVtQ2hpbGROb2Rlc1swXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpZnJhbWUnICYmIGFkRWxlbUNoaWxkTm9kZXNbMF0uaWQuaW5kZXhPZihBU1dJRlRfSUZSQU1FX01BUktFUikgPiAtMSAvLyB0aGUgc2Vjb25kIG9mIGNoaWxkIG5vZGVzIHNob3VsZCBiZSBnb29nbGVfYWRzIGlmcmFtZVxuICAgICAgJiYgYWRFbGVtQ2hpbGROb2Rlc1sxXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpZnJhbWUnICYmIGFkRWxlbUNoaWxkTm9kZXNbMV0uaWQuaW5kZXhPZihHT09HTEVfQURTX0lGUkFNRV9NQVJLRVIpID4gLTE7XG4gICAgfVxuXG4gICAgaWYgKCFhcmVJZnJhbWVzRGVmaW5lZCkge1xuICAgICAgLy8gaGVyZSB3ZSBkbyB0aGUgam9iIGlmIHNjcmlwdGxldCBoYXMgbm90IGJlZW4gZXhlY3V0ZWQgZWFybGllclxuICAgICAgYWRFbGVtc1tpXS5zZXRBdHRyaWJ1dGUoc3RhdHVzQXR0ck5hbWUsICdkb25lJyk7XG4gICAgICB2YXIgYXN3aWZ0SWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBhc3dpZnRJZnJhbWUuaWQgPSBcIlwiLmNvbmNhdChBU1dJRlRfSUZSQU1FX01BUktFUikuY29uY2F0KGkpO1xuICAgICAgYXN3aWZ0SWZyYW1lLnN0eWxlID0gY3NzO1xuICAgICAgYWRFbGVtc1tpXS5hcHBlbmRDaGlsZChhc3dpZnRJZnJhbWUpO1xuICAgICAgdmFyIGlubmVyQXN3aWZ0SWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBhc3dpZnRJZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlubmVyQXN3aWZ0SWZyYW1lKTtcbiAgICAgIHZhciBnb29nbGVhZHNJZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGdvb2dsZWFkc0lmcmFtZS5pZCA9IFwiXCIuY29uY2F0KEdPT0dMRV9BRFNfSUZSQU1FX01BUktFUikuY29uY2F0KGkpO1xuICAgICAgZ29vZ2xlYWRzSWZyYW1lLnN0eWxlID0gY3NzO1xuICAgICAgYWRFbGVtc1tpXS5hcHBlbmRDaGlsZChnb29nbGVhZHNJZnJhbWUpO1xuICAgICAgdmFyIGlubmVyR29vZ2xlYWRzSWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBnb29nbGVhZHNJZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlubmVyR29vZ2xlYWRzSWZyYW1lKTtcbiAgICAgIGV4ZWN1dGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXhlY3V0ZWQpIHtcbiAgICBoaXQoc291cmNlKTtcbiAgfVxufVxuR29vZ2xlU3luZGljYXRpb25BZHNCeUdvb2dsZS5uYW1lcyA9IFsnZ29vZ2xlc3luZGljYXRpb24tYWRzYnlnb29nbGUnLCAndWJvLWdvb2dsZXN5bmRpY2F0aW9uX2Fkc2J5Z29vZ2xlLmpzJywgJ2dvb2dsZXN5bmRpY2F0aW9uX2Fkc2J5Z29vZ2xlLmpzJ107XG5Hb29nbGVTeW5kaWNhdGlvbkFkc0J5R29vZ2xlLmluamVjdGlvbnMgPSBbaGl0XTtcblxuLyoqXG4gKiBAcmVkaXJlY3QgZ29vZ2xldGFnc2VydmljZXMtZ3B0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2NrcyBHb29nbGUgUHVibGlzaGVyIFRhZyBBUEkuXG4gKlxuICogUmVsYXRlZCBVQk8gcmVkaXJlY3QgcmVzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svYmxvYi9hOTRkZjdmM2IyNzA4MGFlMmRjYjNiOTE0YWNlMzljMGMyOTRkMmY2L3NyYy93ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMvZ29vZ2xldGFnc2VydmljZXNfZ3B0LmpzXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogfHxnb29nbGV0YWdzZXJ2aWNlcy5jb20vdGFnL2pzL2dwdC5qcyRzY3JpcHQscmVkaXJlY3Q9Z29vZ2xldGFnc2VydmljZXMtZ3B0XG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBHb29nbGVUYWdTZXJ2aWNlc0dwdChzb3VyY2UpIHtcbiAgdmFyIGNvbXBhbmlvbkFkc1NlcnZpY2UgPSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogbm9vcFRoaXMsXG4gICAgZW5hYmxlU3luY0xvYWRpbmc6IG5vb3BGdW5jLFxuICAgIHNldFJlZnJlc2hVbmZpbGxlZFNsb3RzOiBub29wRnVuY1xuICB9O1xuICB2YXIgY29udGVudFNlcnZpY2UgPSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogbm9vcFRoaXMsXG4gICAgc2V0Q29udGVudDogbm9vcEZ1bmNcbiAgfTtcblxuICBmdW5jdGlvbiBQYXNzYmFja1Nsb3QoKSB7fSAvLyBjb25zdHJ1Y3RvclxuXG5cbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5kaXNwbGF5ID0gbm9vcEZ1bmM7XG4gIFBhc3NiYWNrU2xvdC5wcm90b3R5cGUuZ2V0ID0gbm9vcE51bGw7XG4gIFBhc3NiYWNrU2xvdC5wcm90b3R5cGUuc2V0ID0gbm9vcFRoaXM7XG4gIFBhc3NiYWNrU2xvdC5wcm90b3R5cGUuc2V0Q2xpY2tVcmwgPSBub29wVGhpcztcbiAgUGFzc2JhY2tTbG90LnByb3RvdHlwZS5zZXRUYWdGb3JDaGlsZERpcmVjdGVkVHJlYXRtZW50ID0gbm9vcFRoaXM7XG4gIFBhc3NiYWNrU2xvdC5wcm90b3R5cGUuc2V0VGFyZ2V0aW5nID0gbm9vcFRoaXM7XG4gIFBhc3NiYWNrU2xvdC5wcm90b3R5cGUudXBkYXRlVGFyZ2V0aW5nRnJvbU1hcCA9IG5vb3BUaGlzO1xuXG4gIGZ1bmN0aW9uIFNpemVNYXBwaW5nQnVpbGRlcigpIHt9IC8vIGNvbnN0cnVjdG9yXG5cblxuICBTaXplTWFwcGluZ0J1aWxkZXIucHJvdG90eXBlLmFkZFNpemUgPSBub29wVGhpcztcbiAgU2l6ZU1hcHBpbmdCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IG5vb3BOdWxsO1xuXG4gIGZ1bmN0aW9uIFNsb3QoKSB7fSAvLyBjb25zdHJ1Y3RvclxuXG5cbiAgU2xvdC5wcm90b3R5cGUuYWRkU2VydmljZSA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5jbGVhckNhdGVnb3J5RXhjbHVzaW9ucyA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5jbGVhclRhcmdldGluZyA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5kZWZpbmVTaXplTWFwcGluZyA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5nZXQgPSBub29wTnVsbDtcbiAgU2xvdC5wcm90b3R5cGUuZ2V0QWRVbml0UGF0aCA9IG5vb3BBcnJheTtcbiAgU2xvdC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlS2V5cyA9IG5vb3BBcnJheTtcbiAgU2xvdC5wcm90b3R5cGUuZ2V0Q2F0ZWdvcnlFeGNsdXNpb25zID0gbm9vcEFycmF5O1xuICBTbG90LnByb3RvdHlwZS5nZXREb21JZCA9IG5vb3BTdHI7XG4gIFNsb3QucHJvdG90eXBlLmdldFNsb3RFbGVtZW50SWQgPSBub29wU3RyO1xuICBTbG90LnByb3RvdHlwZS5nZXRTbG90SWQgPSBub29wVGhpcztcbiAgU2xvdC5wcm90b3R5cGUuZ2V0VGFyZ2V0aW5nID0gbm9vcEFycmF5O1xuICBTbG90LnByb3RvdHlwZS5nZXRUYXJnZXRpbmdLZXlzID0gbm9vcEFycmF5O1xuICBTbG90LnByb3RvdHlwZS5zZXQgPSBub29wVGhpcztcbiAgU2xvdC5wcm90b3R5cGUuc2V0Q2F0ZWdvcnlFeGNsdXNpb24gPSBub29wVGhpcztcbiAgU2xvdC5wcm90b3R5cGUuc2V0Q2xpY2tVcmwgPSBub29wVGhpcztcbiAgU2xvdC5wcm90b3R5cGUuc2V0Q29sbGFwc2VFbXB0eURpdiA9IG5vb3BUaGlzO1xuICBTbG90LnByb3RvdHlwZS5zZXRUYXJnZXRpbmcgPSBub29wVGhpcztcbiAgdmFyIHB1YkFkc1NlcnZpY2UgPSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogbm9vcFRoaXMsXG4gICAgY2xlYXI6IG5vb3BGdW5jLFxuICAgIGNsZWFyQ2F0ZWdvcnlFeGNsdXNpb25zOiBub29wVGhpcyxcbiAgICBjbGVhclRhZ0ZvckNoaWxkRGlyZWN0ZWRUcmVhdG1lbnQ6IG5vb3BUaGlzLFxuICAgIGNsZWFyVGFyZ2V0aW5nOiBub29wVGhpcyxcbiAgICBjb2xsYXBzZUVtcHR5RGl2czogbm9vcEZ1bmMsXG4gICAgZGVmaW5lT3V0T2ZQYWdlUGFzc2JhY2s6IGZ1bmN0aW9uIGRlZmluZU91dE9mUGFnZVBhc3NiYWNrKCkge1xuICAgICAgcmV0dXJuIG5ldyBQYXNzYmFja1Nsb3QoKTtcbiAgICB9LFxuICAgIGRlZmluZVBhc3NiYWNrOiBmdW5jdGlvbiBkZWZpbmVQYXNzYmFjaygpIHtcbiAgICAgIHJldHVybiBuZXcgUGFzc2JhY2tTbG90KCk7XG4gICAgfSxcbiAgICBkaXNhYmxlSW5pdGlhbExvYWQ6IG5vb3BGdW5jLFxuICAgIGRpc3BsYXk6IG5vb3BGdW5jLFxuICAgIGVuYWJsZUFzeW5jUmVuZGVyaW5nOiBub29wRnVuYyxcbiAgICBlbmFibGVTaW5nbGVSZXF1ZXN0OiBub29wRnVuYyxcbiAgICBlbmFibGVTeW5jUmVuZGVyaW5nOiBub29wRnVuYyxcbiAgICBlbmFibGVWaWRlb0Fkczogbm9vcEZ1bmMsXG4gICAgZ2V0OiBub29wTnVsbCxcbiAgICBnZXRBdHRyaWJ1dGVLZXlzOiBub29wQXJyYXksXG4gICAgZ2V0VGFyZ2V0aW5nOiBub29wRnVuYyxcbiAgICBnZXRUYXJnZXRpbmdLZXlzOiBub29wQXJyYXksXG4gICAgZ2V0U2xvdHM6IG5vb3BBcnJheSxcbiAgICByZWZyZXNoOiBub29wRnVuYyxcbiAgICBzZXQ6IG5vb3BUaGlzLFxuICAgIHNldENhdGVnb3J5RXhjbHVzaW9uOiBub29wVGhpcyxcbiAgICBzZXRDZW50ZXJpbmc6IG5vb3BGdW5jLFxuICAgIHNldENvb2tpZU9wdGlvbnM6IG5vb3BUaGlzLFxuICAgIHNldEZvcmNlU2FmZUZyYW1lOiBub29wVGhpcyxcbiAgICBzZXRMb2NhdGlvbjogbm9vcFRoaXMsXG4gICAgc2V0UHVibGlzaGVyUHJvdmlkZWRJZDogbm9vcFRoaXMsXG4gICAgc2V0UmVxdWVzdE5vblBlcnNvbmFsaXplZEFkczogbm9vcFRoaXMsXG4gICAgc2V0U2FmZUZyYW1lQ29uZmlnOiBub29wVGhpcyxcbiAgICBzZXRUYWdGb3JDaGlsZERpcmVjdGVkVHJlYXRtZW50OiBub29wVGhpcyxcbiAgICBzZXRUYXJnZXRpbmc6IG5vb3BUaGlzLFxuICAgIHNldFZpZGVvQ29udGVudDogbm9vcFRoaXMsXG4gICAgdXBkYXRlQ29ycmVsYXRvcjogbm9vcEZ1bmNcbiAgfTtcbiAgdmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgICBfd2luZG93JGdvb2dsZXRhZyA9IF93aW5kb3cuZ29vZ2xldGFnLFxuICAgICAgZ29vZ2xldGFnID0gX3dpbmRvdyRnb29nbGV0YWcgPT09IHZvaWQgMCA/IHt9IDogX3dpbmRvdyRnb29nbGV0YWc7XG4gIHZhciBfZ29vZ2xldGFnJGNtZCA9IGdvb2dsZXRhZy5jbWQsXG4gICAgICBjbWQgPSBfZ29vZ2xldGFnJGNtZCA9PT0gdm9pZCAwID8gW10gOiBfZ29vZ2xldGFnJGNtZDtcbiAgZ29vZ2xldGFnLmFwaVJlYWR5ID0gdHJ1ZTtcbiAgZ29vZ2xldGFnLmNtZCA9IFtdO1xuXG4gIGdvb2dsZXRhZy5jbWQucHVzaCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGEoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZXgpIHt9XG5cbiAgICByZXR1cm4gMTtcbiAgfTtcblxuICBnb29nbGV0YWcuY29tcGFuaW9uQWRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb21wYW5pb25BZHNTZXJ2aWNlO1xuICB9O1xuXG4gIGdvb2dsZXRhZy5jb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb250ZW50U2VydmljZTtcbiAgfTtcblxuICBnb29nbGV0YWcuZGVmaW5lT3V0T2ZQYWdlU2xvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNsb3QoKTtcbiAgfTtcblxuICBnb29nbGV0YWcuZGVmaW5lU2xvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNsb3QoKTtcbiAgfTtcblxuICBnb29nbGV0YWcuZGVzdHJveVNsb3RzID0gbm9vcEZ1bmM7XG4gIGdvb2dsZXRhZy5kaXNhYmxlUHVibGlzaGVyQ29uc29sZSA9IG5vb3BGdW5jO1xuICBnb29nbGV0YWcuZGlzcGxheSA9IG5vb3BGdW5jO1xuICBnb29nbGV0YWcuZW5hYmxlU2VydmljZXMgPSBub29wRnVuYztcbiAgZ29vZ2xldGFnLmdldFZlcnNpb24gPSBub29wU3RyO1xuXG4gIGdvb2dsZXRhZy5wdWJhZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHB1YkFkc1NlcnZpY2U7XG4gIH07XG5cbiAgZ29vZ2xldGFnLnB1YmFkc1JlYWR5ID0gdHJ1ZTtcbiAgZ29vZ2xldGFnLnNldEFkSWZyYW1lVGl0bGUgPSBub29wRnVuYztcblxuICBnb29nbGV0YWcuc2l6ZU1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTaXplTWFwcGluZ0J1aWxkZXIoKTtcbiAgfTtcblxuICB3aW5kb3cuZ29vZ2xldGFnID0gZ29vZ2xldGFnO1xuXG4gIHdoaWxlIChjbWQubGVuZ3RoICE9PSAwKSB7XG4gICAgZ29vZ2xldGFnLmNtZC5wdXNoKGNtZC5zaGlmdCgpKTtcbiAgfVxuXG4gIGhpdChzb3VyY2UpO1xufVxuR29vZ2xlVGFnU2VydmljZXNHcHQubmFtZXMgPSBbJ2dvb2dsZXRhZ3NlcnZpY2VzLWdwdCcsICd1Ym8tZ29vZ2xldGFnc2VydmljZXNfZ3B0LmpzJywgJ2dvb2dsZXRhZ3NlcnZpY2VzX2dwdC5qcyddO1xuR29vZ2xlVGFnU2VydmljZXNHcHQuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BGdW5jLCBub29wVGhpcywgbm9vcE51bGwsIG5vb3BBcnJheSwgbm9vcFN0cl07XG5cbi8qKlxuICogQHJlZGlyZWN0IHNjb3JlY2FyZHJlc2VhcmNoLWJlYWNvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3MgU2NvcmVjYXJkIFJlc2VhcmNoIEFQSS5cbiAqXG4gKiBSZWxhdGVkIFVCTyByZWRpcmVjdCByZXNvdXJjZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb3JoaWxsL3VCbG9jay9ibG9iL2E5NGRmN2YzYjI3MDgwYWUyZGNiM2I5MTRhY2UzOWMwYzI5NGQyZjYvc3JjL3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy9zY29yZWNhcmRyZXNlYXJjaF9iZWFjb24uanNcbiAqXG4gKiAqKkV4YW1wbGUqKlxuICogYGBgXG4gKiB8fHNiLnNjb3JlY2FyZHJlc2VhcmNoLmNvbS9iZWFjb24uanMkc2NyaXB0LHJlZGlyZWN0PXNjb3JlY2FyZHJlc2VhcmNoLWJlYWNvblxuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gU2NvcmVDYXJkUmVzZWFyY2hCZWFjb24oc291cmNlKSB7XG4gIHdpbmRvdy5DT01TQ09SRSA9IHtcbiAgICBwdXJnZTogZnVuY3Rpb24gcHVyZ2UoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICAgIHdpbmRvdy5fY29tc2NvcmUgPSBbXTtcbiAgICB9LFxuICAgIGJlYWNvbjogZnVuY3Rpb24gYmVhY29uKCkge31cbiAgfTtcbiAgaGl0KHNvdXJjZSk7XG59XG5TY29yZUNhcmRSZXNlYXJjaEJlYWNvbi5uYW1lcyA9IFsnc2NvcmVjYXJkcmVzZWFyY2gtYmVhY29uJywgJ3Viby1zY29yZWNhcmRyZXNlYXJjaF9iZWFjb24uanMnLCAnc2NvcmVjYXJkcmVzZWFyY2hfYmVhY29uLmpzJ107XG5TY29yZUNhcmRSZXNlYXJjaEJlYWNvbi5pbmplY3Rpb25zID0gW2hpdF07XG5cbi8qKlxuICogQHJlZGlyZWN0IG1ldHJpa2EteWFuZGV4LXRhZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3MgWWFuZGV4IE1ldHJpa2EgQVBJLlxuICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvbWV0aG9kLXJlZmVyZW5jZS5odG1sXG4gKlxuICogKipFeGFtcGxlKipcbiAqIGBgYFxuICogfHxtYy55YW5kZXgucnUvbWV0cmlrYS90YWcuanMkc2NyaXB0LHJlZGlyZWN0PW1ldHJpa2EteWFuZGV4LXRhZ1xuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gbWV0cmlrYVlhbmRleFRhZyhzb3VyY2UpIHtcbiAgdmFyIGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucyA9IGZ1bmN0aW9uIGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucyhwYXJhbSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgIHZhciBjdHggPSBvcHRpb25zLmN0eDtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gY3R4ICE9PSB1bmRlZmluZWQgPyBjYWxsYmFjay5iaW5kKGN0eCkgOiBjYWxsYmFjaztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW5pdCA9IG5vb3BGdW5jO1xuICAvKipcbiAgICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvYWRkZmlsZWV4dGVuc2lvbi5odG1sXG4gICAqL1xuXG4gIHZhciBhZGRGaWxlRXh0ZW5zaW9uID0gbm9vcEZ1bmM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9leHRsaW5rLmh0bWxcbiAgICovXG5cbiAgdmFyIGV4dExpbmsgPSBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9maWxlLmh0bWxcbiAgICovXG5cbiAgdmFyIGZpbGUgPSBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9nZXQtY2xpZW50LWlkLmh0bWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgdmFyIGdldENsaWVudElEID0gZnVuY3Rpb24gZ2V0Q2xpZW50SUQoY2IpIHtcbiAgICBzZXRUaW1lb3V0KGNiKG51bGwpKTtcbiAgfTtcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL2hpdC5odG1sXG4gICAqL1xuXG5cbiAgdmFyIGhpdEZ1bmMgPSBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy9ub3Rib3VuY2UuaHRtbFxuICAgKi9cblxuICB2YXIgbm90Qm91bmNlID0gYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zO1xuICAvKipcbiAgICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvcGFyYW1zLW1ldGhvZC5odG1sXG4gICAqL1xuXG4gIHZhciBwYXJhbXMgPSBub29wRnVuYztcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL3JlYWNoZ29hbC5odG1sXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2FueX0gY3R4XG4gICAqL1xuXG4gIHZhciByZWFjaEdvYWwgPSBmdW5jdGlvbiByZWFjaEdvYWwodGFyZ2V0LCBwYXJhbXMsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnMobnVsbCwge1xuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY3R4OiBjdHhcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIGh0dHBzOi8veWFuZGV4LnJ1L3N1cHBvcnQvbWV0cmljYS9vYmplY3RzL3NldC11c2VyLWlkLmh0bWxcbiAgICovXG5cblxuICB2YXIgc2V0VXNlcklEID0gbm9vcEZ1bmM7XG4gIC8qKlxuICAgKiBodHRwczovL3lhbmRleC5ydS9zdXBwb3J0L21ldHJpY2Evb2JqZWN0cy91c2VyLXBhcmFtcy5odG1sXG4gICAqL1xuXG4gIHZhciB1c2VyUGFyYW1zID0gbm9vcEZ1bmM7XG4gIHZhciBhcGkgPSB7XG4gICAgaW5pdDogaW5pdCxcbiAgICBhZGRGaWxlRXh0ZW5zaW9uOiBhZGRGaWxlRXh0ZW5zaW9uLFxuICAgIGV4dExpbms6IGV4dExpbmssXG4gICAgZmlsZTogZmlsZSxcbiAgICBnZXRDbGllbnRJRDogZ2V0Q2xpZW50SUQsXG4gICAgaGl0OiBoaXRGdW5jLFxuICAgIG5vdEJvdW5jZTogbm90Qm91bmNlLFxuICAgIHBhcmFtczogcGFyYW1zLFxuICAgIHJlYWNoR29hbDogcmVhY2hHb2FsLFxuICAgIHNldFVzZXJJRDogc2V0VXNlcklELFxuICAgIHVzZXJQYXJhbXM6IHVzZXJQYXJhbXNcbiAgfTtcblxuICBmdW5jdGlvbiB5bShpZCwgZnVuY05hbWUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBpW2Z1bmNOYW1lXSAmJiBhcGlbZnVuY05hbWVdLmFwcGx5KGFwaSwgYXJncyk7XG4gIH1cblxuICB3aW5kb3cueW0gPSB5bTtcbiAgaGl0KHNvdXJjZSk7XG59XG5tZXRyaWthWWFuZGV4VGFnLm5hbWVzID0gWydtZXRyaWthLXlhbmRleC10YWcnXTtcbm1ldHJpa2FZYW5kZXhUYWcuaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BGdW5jXTtcblxuLyoqXG4gKiBAcmVkaXJlY3QgbWV0cmlrYS15YW5kZXgtd2F0Y2hcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1vY2tzIHRoZSBvbGQgWWFuZGV4IE1ldHJpa2EgQVBJLlxuICogaHR0cHM6Ly95YW5kZXgucnUvc3VwcG9ydC9tZXRyaWNhL29iamVjdHMvX21ldGhvZC1yZWZlcmVuY2UuaHRtbFxuICpcbiAqICoqRXhhbXBsZSoqXG4gKiBgYGBcbiAqIHx8bWMueWFuZGV4LnJ1L21ldHJpa2Evd2F0Y2guanMkc2NyaXB0LHJlZGlyZWN0PW1ldHJpa2EteWFuZGV4LXdhdGNoXG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBtZXRyaWthWWFuZGV4V2F0Y2goc291cmNlKSB7XG4gIHZhciBjYk5hbWUgPSAneWFuZGV4X21ldHJpa2FfY2FsbGJhY2tzJztcbiAgLyoqXG4gICAqIEdldHMgY2FsbGJhY2sgYW5kIGl0cyBjb250ZXh0IGZyb20gb3B0aW9ucyBhbmQgY2FsbCBpdCBpbiBhc3luYyB3YXlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgWWFuZGV4IE1ldHJpa2EgQVBJIG9wdGlvbnNcbiAgICovXG5cbiAgdmFyIGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucyA9IGZ1bmN0aW9uIGFzeW5jQ2FsbGJhY2tGcm9tT3B0aW9ucygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICB2YXIgY3R4ID0gb3B0aW9ucy5jdHg7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGN0eCAhPT0gdW5kZWZpbmVkID8gY2FsbGJhY2suYmluZChjdHgpIDogY2FsbGJhY2s7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gTWV0cmlrYSgpIHt9IC8vIGNvbnN0cnVjdG9yXG4gIC8vIE1ldGhvZHMgd2l0aG91dCBvcHRpb25zXG5cblxuICBNZXRyaWthLnByb3RvdHlwZS5hZGRGaWxlRXh0ZW5zaW9uID0gbm9vcEZ1bmM7XG4gIE1ldHJpa2EucHJvdG90eXBlLmdldENsaWVudElEID0gbm9vcEZ1bmM7XG4gIE1ldHJpa2EucHJvdG90eXBlLnNldFVzZXJJRCA9IG5vb3BGdW5jO1xuICBNZXRyaWthLnByb3RvdHlwZS51c2VyUGFyYW1zID0gbm9vcEZ1bmM7IC8vIE1ldGhvZHMgd2l0aCBvcHRpb25zXG4gIC8vIFRoZSBvcmRlciBvZiBhcmd1bWVudHMgc2hvdWxkIGJlIGtlcHQgaW4gYWNjb3JkaW5nIHRvIEFQSVxuXG4gIE1ldHJpa2EucHJvdG90eXBlLmV4dExpbmsgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zKG9wdGlvbnMpO1xuICB9O1xuXG4gIE1ldHJpa2EucHJvdG90eXBlLmZpbGUgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zKG9wdGlvbnMpO1xuICB9O1xuXG4gIE1ldHJpa2EucHJvdG90eXBlLmhpdCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBhc3luY0NhbGxiYWNrRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gIH07XG5cbiAgTWV0cmlrYS5wcm90b3R5cGUucmVhY2hHb2FsID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyYW1zLCBjYiwgY3R4KSB7XG4gICAgYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zKHtcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIGN0eDogY3R4XG4gICAgfSk7XG4gIH07XG5cbiAgTWV0cmlrYS5wcm90b3R5cGUubm90Qm91bmNlID0gYXN5bmNDYWxsYmFja0Zyb21PcHRpb25zO1xuXG4gIGlmICh3aW5kb3cuWWEpIHtcbiAgICB3aW5kb3cuWWEuTWV0cmlrYSA9IE1ldHJpa2E7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LllhID0ge1xuICAgICAgTWV0cmlrYTogTWV0cmlrYVxuICAgIH07XG4gIH1cblxuICBpZiAod2luZG93W2NiTmFtZV0gJiYgQXJyYXkuaXNBcnJheSh3aW5kb3dbY2JOYW1lXSkpIHtcbiAgICB3aW5kb3dbY2JOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZnVuYygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaGl0KHNvdXJjZSk7XG59XG5tZXRyaWthWWFuZGV4V2F0Y2gubmFtZXMgPSBbJ21ldHJpa2EteWFuZGV4LXdhdGNoJ107XG5tZXRyaWthWWFuZGV4V2F0Y2guaW5qZWN0aW9ucyA9IFtoaXQsIG5vb3BGdW5jXTtcblxuLyoqXG4gKiBAcmVkaXJlY3QgYW1hem9uLWFwc3RhZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTW9ja3MgQW1hem9uJ3MgYXBzdGFnLmpzXG4gKlxuICogUmVsYXRlZCBVQk8gcmVkaXJlY3QgcmVzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29yaGlsbC91QmxvY2svYmxvYi9mODQyYWI2ZDNjMWNmMDM5NGY5NWQyNzA5MmJmNTk2MjcyNjJkYTQwL3NyYy93ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMvYW1hem9uX2Fwc3RhZy5qc1xuICpcbiAqICoqRXhhbXBsZSoqXG4gKiBgYGBcbiAqIHx8YW1hem9uLWFkc3lzdGVtLmNvbS9hYXgyL2Fwc3RhZy5qcyRzY3JpcHQscmVkaXJlY3Q9YW1hem9uLWFwc3RhZ1xuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gQW1hem9uQXBzdGFnKHNvdXJjZSkge1xuICB2YXIgYXBzdGFnV3JhcHBlciA9IHtcbiAgICBmZXRjaEJpZHM6IGZ1bmN0aW9uIGZldGNoQmlkcyhhLCBiKSB7XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYihbXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0OiBub29wRnVuYyxcbiAgICBzZXREaXNwbGF5Qmlkczogbm9vcEZ1bmMsXG4gICAgdGFyZ2V0aW5nS2V5czogbm9vcEZ1bmNcbiAgfTtcbiAgd2luZG93LmFwc3RhZyA9IGFwc3RhZ1dyYXBwZXI7XG4gIGhpdChzb3VyY2UpO1xufVxuQW1hem9uQXBzdGFnLm5hbWVzID0gWydhbWF6b24tYXBzdGFnJywgJ3Viby1hbWF6b25fYXBzdGFnLmpzJywgJ2FtYXpvbl9hcHN0YWcuanMnXTtcbkFtYXpvbkFwc3RhZy5pbmplY3Rpb25zID0gW2hpdCwgbm9vcEZ1bmNdO1xuXG52YXIgcmVkaXJlY3RzTGlzdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbm9ldmFsOiBub2V2YWwsXG4gICAgR29vZ2xlQW5hbHl0aWNzOiBHb29nbGVBbmFseXRpY3MsXG4gICAgR29vZ2xlQW5hbHl0aWNzR2E6IEdvb2dsZUFuYWx5dGljc0dhLFxuICAgIEdvb2dsZVN5bmRpY2F0aW9uQWRzQnlHb29nbGU6IEdvb2dsZVN5bmRpY2F0aW9uQWRzQnlHb29nbGUsXG4gICAgR29vZ2xlVGFnU2VydmljZXNHcHQ6IEdvb2dsZVRhZ1NlcnZpY2VzR3B0LFxuICAgIFNjb3JlQ2FyZFJlc2VhcmNoQmVhY29uOiBTY29yZUNhcmRSZXNlYXJjaEJlYWNvbixcbiAgICBtZXRyaWthWWFuZGV4VGFnOiBtZXRyaWthWWFuZGV4VGFnLFxuICAgIG1ldHJpa2FZYW5kZXhXYXRjaDogbWV0cmlrYVlhbmRleFdhdGNoLFxuICAgIHByZXZlbnRGYWI6IHByZXZlbnRGYWIsXG4gICAgcHJldmVudEJhYjogcHJldmVudEJhYixcbiAgICBzZXRQb3BhZHNEdW1teTogc2V0UG9wYWRzRHVtbXksXG4gICAgcHJldmVudFBvcGFkc05ldDogcHJldmVudFBvcGFkc05ldCxcbiAgICBBbWF6b25BcHN0YWc6IEFtYXpvbkFwc3RhZ1xufSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IF9jbGFzc0NhbGxDaGVjaztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgY3JlYXRlQ2xhc3MgPSBfY3JlYXRlQ2xhc3M7XG5cbmZ1bmN0aW9uIGlzTm90aGluZyhzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcgfHwgc3ViamVjdCA9PT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmIHN1YmplY3QgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkkMShzZXF1ZW5jZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHJldHVybiBzZXF1ZW5jZTtlbHNlIGlmIChpc05vdGhpbmcoc2VxdWVuY2UpKSByZXR1cm4gW107XG4gIHJldHVybiBbc2VxdWVuY2VdO1xufVxuXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIGtleSwgc291cmNlS2V5cztcblxuICBpZiAoc291cmNlKSB7XG4gICAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgY3ljbGU7XG5cbiAgZm9yIChjeWNsZSA9IDA7IGN5Y2xlIDwgY291bnQ7IGN5Y2xlICs9IDEpIHtcbiAgICByZXN1bHQgKz0gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNOZWdhdGl2ZVplcm8obnVtYmVyKSB7XG4gIHJldHVybiBudW1iZXIgPT09IDAgJiYgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSAxIC8gbnVtYmVyO1xufVxuXG52YXIgaXNOb3RoaW5nXzEgPSBpc05vdGhpbmc7XG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xudmFyIHRvQXJyYXlfMSA9IHRvQXJyYXkkMTtcbnZhciByZXBlYXRfMSA9IHJlcGVhdDtcbnZhciBpc05lZ2F0aXZlWmVyb18xID0gaXNOZWdhdGl2ZVplcm87XG52YXIgZXh0ZW5kXzEgPSBleHRlbmQ7XG52YXIgY29tbW9uID0ge1xuICBpc05vdGhpbmc6IGlzTm90aGluZ18xLFxuICBpc09iamVjdDogaXNPYmplY3RfMSxcbiAgdG9BcnJheTogdG9BcnJheV8xLFxuICByZXBlYXQ6IHJlcGVhdF8xLFxuICBpc05lZ2F0aXZlWmVybzogaXNOZWdhdGl2ZVplcm9fMSxcbiAgZXh0ZW5kOiBleHRlbmRfMVxufTtcblxuLy8gWUFNTCBlcnJvciBjbGFzcy4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDU4OTg0XG5cbmZ1bmN0aW9uIFlBTUxFeGNlcHRpb24ocmVhc29uLCBtYXJrKSB7XG4gIC8vIFN1cGVyIGNvbnN0cnVjdG9yXG4gIEVycm9yLmNhbGwodGhpcyk7XG4gIHRoaXMubmFtZSA9ICdZQU1MRXhjZXB0aW9uJztcbiAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gIHRoaXMubWFyayA9IG1hcms7XG4gIHRoaXMubWVzc2FnZSA9ICh0aGlzLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKScpICsgKHRoaXMubWFyayA/ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpIDogJycpOyAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIC8vIENocm9tZSBhbmQgTm9kZUpTXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gRkYsIElFIDEwKyBhbmQgU2FmYXJpIDYrLiBGYWxsYmFjayBmb3Igb3RoZXJzXG4gICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnO1xuICB9XG59IC8vIEluaGVyaXQgZnJvbSBFcnJvclxuXG5cbllBTUxFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBZQU1MRXhjZXB0aW9uO1xuXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMubmFtZSArICc6ICc7XG4gIHJlc3VsdCArPSB0aGlzLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKSc7XG5cbiAgaWYgKCFjb21wYWN0ICYmIHRoaXMubWFyaykge1xuICAgIHJlc3VsdCArPSAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZXhjZXB0aW9uID0gWUFNTEV4Y2VwdGlvbjtcblxuZnVuY3Rpb24gTWFyayhuYW1lLCBidWZmZXIsIHBvc2l0aW9uLCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdGhpcy5saW5lID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG59XG5cbk1hcmsucHJvdG90eXBlLmdldFNuaXBwZXQgPSBmdW5jdGlvbiBnZXRTbmlwcGV0KGluZGVudCwgbWF4TGVuZ3RoKSB7XG4gIHZhciBoZWFkLCBzdGFydCwgdGFpbCwgZW5kLCBzbmlwcGV0O1xuICBpZiAoIXRoaXMuYnVmZmVyKSByZXR1cm4gbnVsbDtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDQ7XG4gIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA3NTtcbiAgaGVhZCA9ICcnO1xuICBzdGFydCA9IHRoaXMucG9zaXRpb247XG5cbiAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBcIlxcMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjlcIi5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChzdGFydCAtIDEpKSA9PT0gLTEpIHtcbiAgICBzdGFydCAtPSAxO1xuXG4gICAgaWYgKHRoaXMucG9zaXRpb24gLSBzdGFydCA+IG1heExlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBoZWFkID0gJyAuLi4gJztcbiAgICAgIHN0YXJ0ICs9IDU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0YWlsID0gJyc7XG4gIGVuZCA9IHRoaXMucG9zaXRpb247XG5cbiAgd2hpbGUgKGVuZCA8IHRoaXMuYnVmZmVyLmxlbmd0aCAmJiBcIlxcMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjlcIi5pbmRleE9mKHRoaXMuYnVmZmVyLmNoYXJBdChlbmQpKSA9PT0gLTEpIHtcbiAgICBlbmQgKz0gMTtcblxuICAgIGlmIChlbmQgLSB0aGlzLnBvc2l0aW9uID4gbWF4TGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIHRhaWwgPSAnIC4uLiAnO1xuICAgICAgZW5kIC09IDU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzbmlwcGV0ID0gdGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHJldHVybiBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50KSArIGhlYWQgKyBzbmlwcGV0ICsgdGFpbCArICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIGluZGVudCArIHRoaXMucG9zaXRpb24gLSBzdGFydCArIGhlYWQubGVuZ3RoKSArICdeJztcbn07XG5cbk1hcmsucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICB2YXIgc25pcHBldCxcbiAgICAgIHdoZXJlID0gJyc7XG5cbiAgaWYgKHRoaXMubmFtZSkge1xuICAgIHdoZXJlICs9ICdpbiBcIicgKyB0aGlzLm5hbWUgKyAnXCIgJztcbiAgfVxuXG4gIHdoZXJlICs9ICdhdCBsaW5lICcgKyAodGhpcy5saW5lICsgMSkgKyAnLCBjb2x1bW4gJyArICh0aGlzLmNvbHVtbiArIDEpO1xuXG4gIGlmICghY29tcGFjdCkge1xuICAgIHNuaXBwZXQgPSB0aGlzLmdldFNuaXBwZXQoKTtcblxuICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICB3aGVyZSArPSAnOlxcbicgKyBzbmlwcGV0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aGVyZTtcbn07XG5cbnZhciBtYXJrID0gTWFyaztcblxudmFyIFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyA9IFsna2luZCcsICdyZXNvbHZlJywgJ2NvbnN0cnVjdCcsICdpbnN0YW5jZU9mJywgJ3ByZWRpY2F0ZScsICdyZXByZXNlbnQnLCAnZGVmYXVsdFN0eWxlJywgJ3N0eWxlQWxpYXNlcyddO1xudmFyIFlBTUxfTk9ERV9LSU5EUyA9IFsnc2NhbGFyJywgJ3NlcXVlbmNlJywgJ21hcHBpbmcnXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlQWxpYXNlcyhtYXApIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICBtYXBbc3R5bGVdLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICAgIHJlc3VsdFtTdHJpbmcoYWxpYXMpXSA9IHN0eWxlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBUeXBlKHRhZywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1Vua25vd24gb3B0aW9uIFwiJyArIG5hbWUgKyAnXCIgaXMgbWV0IGluIGRlZmluaXRpb24gb2YgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgICB9XG4gIH0pOyAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cblxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5raW5kID0gb3B0aW9uc1sna2luZCddIHx8IG51bGw7XG5cbiAgdGhpcy5yZXNvbHZlID0gb3B0aW9uc1sncmVzb2x2ZSddIHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB0aGlzLmNvbnN0cnVjdCA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddIHx8IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgdGhpcy5pbnN0YW5jZU9mID0gb3B0aW9uc1snaW5zdGFuY2VPZiddIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlID0gb3B0aW9uc1sncHJlZGljYXRlJ10gfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgPSBvcHRpb25zWydyZXByZXNlbnQnXSB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddIHx8IG51bGw7XG4gIHRoaXMuc3R5bGVBbGlhc2VzID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdVbmtub3duIGtpbmQgXCInICsgdGhpcy5raW5kICsgJ1wiIGlzIHNwZWNpZmllZCBmb3IgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgfVxufVxuXG52YXIgdHlwZSA9IFR5cGU7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG5cblxuZnVuY3Rpb24gY29tcGlsZUxpc3Qoc2NoZW1hLCBuYW1lLCByZXN1bHQpIHtcbiAgdmFyIGV4Y2x1ZGUgPSBbXTtcbiAgc2NoZW1hLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWRTY2hlbWEpIHtcbiAgICByZXN1bHQgPSBjb21waWxlTGlzdChpbmNsdWRlZFNjaGVtYSwgbmFtZSwgcmVzdWx0KTtcbiAgfSk7XG4gIHNjaGVtYVtuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChjdXJyZW50VHlwZSkge1xuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2aW91c1R5cGUsIHByZXZpb3VzSW5kZXgpIHtcbiAgICAgIGlmIChwcmV2aW91c1R5cGUudGFnID09PSBjdXJyZW50VHlwZS50YWcgJiYgcHJldmlvdXNUeXBlLmtpbmQgPT09IGN1cnJlbnRUeXBlLmtpbmQpIHtcbiAgICAgICAgZXhjbHVkZS5wdXNoKHByZXZpb3VzSW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRUeXBlKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQuZmlsdGVyKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBleGNsdWRlLmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVNYXAoKVxuLyogbGlzdHMuLi4gKi9cbntcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBzY2FsYXI6IHt9LFxuICAgIHNlcXVlbmNlOiB7fSxcbiAgICBtYXBwaW5nOiB7fSxcbiAgICBmYWxsYmFjazoge31cbiAgfSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUeXBlKHR5cGUpIHtcbiAgICByZXN1bHRbdHlwZS5raW5kXVt0eXBlLnRhZ10gPSByZXN1bHRbJ2ZhbGxiYWNrJ11bdHlwZS50YWddID0gdHlwZTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGFyZ3VtZW50c1tpbmRleF0uZm9yRWFjaChjb2xsZWN0VHlwZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBTY2hlbWEoZGVmaW5pdGlvbikge1xuICB0aGlzLmluY2x1ZGUgPSBkZWZpbml0aW9uLmluY2x1ZGUgfHwgW107XG4gIHRoaXMuaW1wbGljaXQgPSBkZWZpbml0aW9uLmltcGxpY2l0IHx8IFtdO1xuICB0aGlzLmV4cGxpY2l0ID0gZGVmaW5pdGlvbi5leHBsaWNpdCB8fCBbXTtcbiAgdGhpcy5pbXBsaWNpdC5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHR5cGUubG9hZEtpbmQgJiYgdHlwZS5sb2FkS2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuY29tcGlsZWRJbXBsaWNpdCA9IGNvbXBpbGVMaXN0KHRoaXMsICdpbXBsaWNpdCcsIFtdKTtcbiAgdGhpcy5jb21waWxlZEV4cGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2V4cGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkVHlwZU1hcCA9IGNvbXBpbGVNYXAodGhpcy5jb21waWxlZEltcGxpY2l0LCB0aGlzLmNvbXBpbGVkRXhwbGljaXQpO1xufVxuXG5TY2hlbWEuREVGQVVMVCA9IG51bGw7XG5cblNjaGVtYS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVTY2hlbWEoKSB7XG4gIHZhciBzY2hlbWFzLCB0eXBlcztcblxuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICBzY2hlbWFzID0gU2NoZW1hLkRFRkFVTFQ7XG4gICAgICB0eXBlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgc2NoZW1hcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHR5cGVzID0gYXJndW1lbnRzWzFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignV3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgU2NoZW1hLmNyZWF0ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgc2NoZW1hcyA9IGNvbW1vbi50b0FycmF5KHNjaGVtYXMpO1xuICB0eXBlcyA9IGNvbW1vbi50b0FycmF5KHR5cGVzKTtcblxuICBpZiAoIXNjaGVtYXMuZXZlcnkoZnVuY3Rpb24gKHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWE7XG4gIH0pKSB7XG4gICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2Ygc3VwZXIgc2NoZW1hcyAob3IgYSBzaW5nbGUgU2NoZW1hIG9iamVjdCkgY29udGFpbnMgYSBub24tU2NoZW1hIG9iamVjdC4nKTtcbiAgfVxuXG4gIGlmICghdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUkMSkge1xuICAgIHJldHVybiB0eXBlJDEgaW5zdGFuY2VvZiB0eXBlO1xuICB9KSkge1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICBpbmNsdWRlOiBzY2hlbWFzLFxuICAgIGV4cGxpY2l0OiB0eXBlc1xuICB9KTtcbn07XG5cbnZhciBzY2hlbWEgPSBTY2hlbWE7XG5cbnZhciBzdHIgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoZGF0YSkge1xuICAgIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6ICcnO1xuICB9XG59KTtcblxudmFyIHNlcSA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTtcbiAgfVxufSk7XG5cbnZhciBtYXAgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbiAgfVxufSk7XG5cbnZhciBmYWlsc2FmZSA9IG5ldyBzY2hlbWEoe1xuICBleHBsaWNpdDogW3N0ciwgc2VxLCBtYXBdXG59KTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxOdWxsKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG4gIHJldHVybiBtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nIHx8IG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PT0gbnVsbDtcbn1cblxudmFyIF9udWxsID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE51bGwsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE51bGwsXG4gIHByZWRpY2F0ZTogaXNOdWxsLFxuICByZXByZXNlbnQ6IHtcbiAgICBjYW5vbmljYWw6IGZ1bmN0aW9uIGNhbm9uaWNhbCgpIHtcbiAgICAgIHJldHVybiAnfic7XG4gICAgfSxcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIGxvd2VyY2FzZSgpIHtcbiAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIHVwcGVyY2FzZSgpIHtcbiAgICAgIHJldHVybiAnTlVMTCc7XG4gICAgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIGNhbWVsY2FzZSgpIHtcbiAgICAgIHJldHVybiAnTnVsbCc7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuICByZXR1cm4gbWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykgfHwgbWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJyk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuXG52YXIgYm9vbCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiBsb3dlcmNhc2Uob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gdXBwZXJjYXNlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7XG4gICAgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIGNhbWVsY2FzZShvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyAnVHJ1ZScgOiAnRmFsc2UnO1xuICAgIH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAweDMwXG4gIC8qIDAgKi9cbiAgPD0gYyAmJiBjIDw9IDB4MzlcbiAgLyogOSAqL1xuICB8fCAweDQxXG4gIC8qIEEgKi9cbiAgPD0gYyAmJiBjIDw9IDB4NDZcbiAgLyogRiAqL1xuICB8fCAweDYxXG4gIC8qIGEgKi9cbiAgPD0gYyAmJiBjIDw9IDB4NjZcbiAgLyogZiAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGlzT2N0Q29kZShjKSB7XG4gIHJldHVybiAweDMwXG4gIC8qIDAgKi9cbiAgPD0gYyAmJiBjIDw9IDB4MzdcbiAgLyogNyAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGlzRGVjQ29kZShjKSB7XG4gIHJldHVybiAweDMwXG4gIC8qIDAgKi9cbiAgPD0gYyAmJiBjIDw9IDB4MzlcbiAgLyogOSAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sSW50ZWdlcihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG4gIGlmICghbWF4KSByZXR1cm4gZmFsc2U7XG4gIGNoID0gZGF0YVtpbmRleF07IC8vIHNpZ25cblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICAvLyAwXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gbWF4KSByZXR1cm4gdHJ1ZTtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07IC8vIGJhc2UgMiwgYmFzZSA4LCBiYXNlIDE2XG5cbiAgICBpZiAoY2ggPT09ICdiJykge1xuICAgICAgLy8gYmFzZSAyXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc0hleENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH0gLy8gYmFzZSA4XG5cblxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgfSAvLyBiYXNlIDEwIChleGNlcHQgMCkgb3IgYmFzZSA2MFxuICAvLyB2YWx1ZSBzaG91bGQgbm90IHN0YXJ0IHdpdGggYF9gO1xuXG5cbiAgaWYgKGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICBpZiAoY2ggPT09ICc6JykgYnJlYWs7XG5cbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH0gLy8gU2hvdWxkIGhhdmUgZGlnaXRzIGFuZCBzaG91bGQgbm90IGVuZCB3aXRoIGBfYFxuXG5cbiAgaWYgKCFoYXNEaWdpdHMgfHwgY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlOyAvLyBpZiAhYmFzZTYwIC0gZG9uZTtcblxuICBpZiAoY2ggIT09ICc6JykgcmV0dXJuIHRydWU7IC8vIGJhc2U2MCBhbG1vc3Qgbm90IHVzZWQsIG5vIG5lZWRzIHRvIG9wdGltaXplXG5cbiAgcmV0dXJuIC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChkYXRhLnNsaWNlKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSxcbiAgICAgIHNpZ24gPSAxLFxuICAgICAgY2gsXG4gICAgICBiYXNlLFxuICAgICAgZGlnaXRzID0gW107XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICB9XG5cbiAgY2ggPSB2YWx1ZVswXTtcblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgaWYgKGNoID09PSAnLScpIHNpZ24gPSAtMTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcwJykgcmV0dXJuIDA7XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUludCh2LCAxMCkpO1xuICAgIH0pO1xuICAgIHZhbHVlID0gMDtcbiAgICBiYXNlID0gMTtcbiAgICBkaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFsdWUgKz0gZCAqIGJhc2U7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuICAgIHJldHVybiBzaWduICogdmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZWdlcihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBvYmplY3QgJSAxID09PSAwICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KTtcbn1cblxudmFyIGludCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEludGVnZXIsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEludGVnZXIsXG4gIHByZWRpY2F0ZTogaXNJbnRlZ2VyLFxuICByZXByZXNlbnQ6IHtcbiAgICBiaW5hcnk6IGZ1bmN0aW9uIGJpbmFyeShvYmopIHtcbiAgICAgIHJldHVybiBvYmogPj0gMCA/ICcwYicgKyBvYmoudG9TdHJpbmcoMikgOiAnLTBiJyArIG9iai50b1N0cmluZygyKS5zbGljZSgxKTtcbiAgICB9LFxuICAgIG9jdGFsOiBmdW5jdGlvbiBvY3RhbChvYmopIHtcbiAgICAgIHJldHVybiBvYmogPj0gMCA/ICcwJyArIG9iai50b1N0cmluZyg4KSA6ICctMCcgKyBvYmoudG9TdHJpbmcoOCkuc2xpY2UoMSk7XG4gICAgfSxcbiAgICBkZWNpbWFsOiBmdW5jdGlvbiBkZWNpbWFsKG9iaikge1xuICAgICAgcmV0dXJuIG9iai50b1N0cmluZygxMCk7XG4gICAgfSxcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gaGV4YWRlY2ltYWwob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID49IDAgPyAnMHgnICsgb2JqLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpIDogJy0weCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkuc2xpY2UoMSk7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiBbMiwgJ2JpbiddLFxuICAgIG9jdGFsOiBbOCwgJ29jdCddLFxuICAgIGRlY2ltYWw6IFsxMCwgJ2RlYyddLFxuICAgIGhleGFkZWNpbWFsOiBbMTYsICdoZXgnXVxuICB9XG59KTtcblxudmFyIFlBTUxfRkxPQVRfUEFUVEVSTiA9IG5ldyBSZWdFeHAoIC8vIDIuNWU0LCAyLjUgYW5kIGludGVnZXJzXG4nXig/OlstK10/KD86MHxbMS05XVswLTlfXSopKD86XFxcXC5bMC05X10qKT8oPzpbZUVdWy0rXT9bMC05XSspPycgKyAvLyAuMmU0LCAuMlxuLy8gc3BlY2lhbCBjYXNlLCBzZWVtcyBub3QgZnJvbSBzcGVjXG4nfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdP1swLTldKyk/JyArIC8vIDIwOjU5XG4nfFstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKStcXFxcLlswLTlfXSonICsgLy8gLmluZlxuJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArIC8vIC5uYW5cbid8XFxcXC4oPzpuYW58TmFOfE5BTikpJCcpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEZsb2F0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoIVlBTUxfRkxPQVRfUEFUVEVSTi50ZXN0KGRhdGEpIHx8IC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAvLyBQcm9iYWJseSBzaG91bGQgdXBkYXRlIHJlZ2V4cCAmIGNoZWNrIHNwZWVkXG4gIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gJ18nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxGbG9hdChkYXRhKSB7XG4gIHZhciB2YWx1ZSwgc2lnbiwgYmFzZSwgZGlnaXRzO1xuICB2YWx1ZSA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiA9IHZhbHVlWzBdID09PSAnLScgPyAtMSA6IDE7XG4gIGRpZ2l0cyA9IFtdO1xuXG4gIGlmICgnKy0nLmluZGV4T2YodmFsdWVbMF0pID49IDApIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnLmluZicpIHtcbiAgICByZXR1cm4gc2lnbiA9PT0gMSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJy5uYW4nKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgPj0gMCkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VGbG9hdCh2LCAxMCkpO1xuICAgIH0pO1xuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSBkICogYmFzZTtcbiAgICAgIGJhc2UgKj0gNjA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG52YXIgU0NJRU5USUZJQ19XSVRIT1VUX0RPVCA9IC9eWy0rXT9bMC05XStlLztcblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgdmFyIHJlcztcblxuICBpZiAoaXNOYU4ob2JqZWN0KSkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICAgIHJldHVybiAnLm5hbic7XG5cbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICAgIHJldHVybiAnLk5BTic7XG5cbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICAgIHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgICAgcmV0dXJuICcuaW5mJztcblxuICAgICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgICAgcmV0dXJuICcuSU5GJztcblxuICAgICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgICAgcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgICByZXR1cm4gJy0uaW5mJztcblxuICAgICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgICAgcmV0dXJuICctLklORic7XG5cbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICAgIHJldHVybiAnLS5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSkge1xuICAgIHJldHVybiAnLTAuMCc7XG4gIH1cblxuICByZXMgPSBvYmplY3QudG9TdHJpbmcoMTApOyAvLyBKUyBzdHJpbmdpZmllciBjYW4gYnVpbGQgc2NpZW50aWZpYyBmb3JtYXQgd2l0aG91dCBkb3RzOiA1ZS0xMDAsXG4gIC8vIHdoaWxlIFlBTUwgcmVxdXJlcyBkb3Q6IDUuZS0xMDAuIEZpeCBpdCB3aXRoIHNpbXBsZSBoYWNrXG5cbiAgcmV0dXJuIFNDSUVOVElGSUNfV0lUSE9VVF9ET1QudGVzdChyZXMpID8gcmVzLnJlcGxhY2UoJ2UnLCAnLmUnKSA6IHJlcztcbn1cblxuZnVuY3Rpb24gaXNGbG9hdChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAob2JqZWN0ICUgMSAhPT0gMCB8fCBjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbnZhciBmbG9hdCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sRmxvYXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEZsb2F0LFxuICBwcmVkaWNhdGU6IGlzRmxvYXQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEZsb2F0LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcblxudmFyIGpzb24gPSBuZXcgc2NoZW1hKHtcbiAgaW5jbHVkZTogW2ZhaWxzYWZlXSxcbiAgaW1wbGljaXQ6IFtfbnVsbCwgYm9vbCwgaW50LCBmbG9hdF1cbn0pO1xuXG52YXIgY29yZSA9IG5ldyBzY2hlbWEoe1xuICBpbmNsdWRlOiBbanNvbl1cbn0pO1xuXG52YXIgWUFNTF9EQVRFX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyArIC8vIFsxXSB5ZWFyXG4nLShbMC05XVswLTldKScgKyAvLyBbMl0gbW9udGhcbictKFswLTldWzAtOV0pJCcpOyAvLyBbM10gZGF5XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKCdeKFswLTldWzAtOV1bMC05XVswLTldKScgKyAvLyBbMV0geWVhclxuJy0oWzAtOV1bMC05XT8pJyArIC8vIFsyXSBtb250aFxuJy0oWzAtOV1bMC05XT8pJyArIC8vIFszXSBkYXlcbicoPzpbVHRdfFsgXFxcXHRdKyknICsgLy8gLi4uXG4nKFswLTldWzAtOV0/KScgKyAvLyBbNF0gaG91clxuJzooWzAtOV1bMC05XSknICsgLy8gWzVdIG1pbnV0ZVxuJzooWzAtOV1bMC05XSknICsgLy8gWzZdIHNlY29uZFxuJyg/OlxcXFwuKFswLTldKikpPycgKyAvLyBbN10gZnJhY3Rpb25cbicoPzpbIFxcXFx0XSooWnwoWy0rXSkoWzAtOV1bMC05XT8pJyArIC8vIFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXJcbicoPzo6KFswLTldWzAtOV0pKT8pKT8kJyk7IC8vIFsxMV0gdHpfbWludXRlXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sVGltZXN0YW1wKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIGlmIChZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIHZhciBtYXRjaCxcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheSxcbiAgICAgIGhvdXIsXG4gICAgICBtaW51dGUsXG4gICAgICBzZWNvbmQsXG4gICAgICBmcmFjdGlvbiA9IDAsXG4gICAgICBkZWx0YSA9IG51bGwsXG4gICAgICB0el9ob3VyLFxuICAgICAgdHpfbWludXRlLFxuICAgICAgZGF0ZTtcbiAgbWF0Y2ggPSBZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSk7XG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgbWF0Y2ggPSBZQU1MX1RJTUVTVEFNUF9SRUdFWFAuZXhlYyhkYXRhKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGUgcmVzb2x2ZSBlcnJvcicpOyAvLyBtYXRjaDogWzFdIHllYXIgWzJdIG1vbnRoIFszXSBkYXlcblxuICB5ZWFyID0gK21hdGNoWzFdO1xuICBtb250aCA9ICttYXRjaFsyXSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcblxuICBkYXkgPSArbWF0Y2hbM107XG5cbiAgaWYgKCFtYXRjaFs0XSkge1xuICAgIC8vIG5vIGhvdXJcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSkpO1xuICB9IC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cblxuICBob3VyID0gK21hdGNoWzRdO1xuICBtaW51dGUgPSArbWF0Y2hbNV07XG4gIHNlY29uZCA9ICttYXRjaFs2XTtcblxuICBpZiAobWF0Y2hbN10pIHtcbiAgICBmcmFjdGlvbiA9IG1hdGNoWzddLnNsaWNlKDAsIDMpO1xuXG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDMpIHtcbiAgICAgIC8vIG1pbGxpLXNlY29uZHNcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG5cbiAgICBmcmFjdGlvbiA9ICtmcmFjdGlvbjtcbiAgfSAvLyBtYXRjaDogWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91ciBbMTFdIHR6X21pbnV0ZVxuXG5cbiAgaWYgKG1hdGNoWzldKSB7XG4gICAgdHpfaG91ciA9ICttYXRjaFsxMF07XG4gICAgdHpfbWludXRlID0gKyhtYXRjaFsxMV0gfHwgMCk7XG4gICAgZGVsdGEgPSAodHpfaG91ciAqIDYwICsgdHpfbWludXRlKSAqIDYwMDAwOyAvLyBkZWx0YSBpbiBtaWxpLXNlY29uZHNcblxuICAgIGlmIChtYXRjaFs5XSA9PT0gJy0nKSBkZWx0YSA9IC1kZWx0YTtcbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcbiAgaWYgKGRlbHRhKSBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgLSBkZWx0YSk7XG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdFxuLyosIHN0eWxlKi9cbikge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbnZhciB0aW1lc3RhbXAgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxUaW1lc3RhbXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFRpbWVzdGFtcCxcbiAgaW5zdGFuY2VPZjogRGF0ZSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sVGltZXN0YW1wXG59KTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAnPDwnIHx8IGRhdGEgPT09IG51bGw7XG59XG5cbnZhciBtZXJnZSA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2Vcbn0pO1xuXG5mdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKHRhcmdldCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlIFwiJyArIHRhcmdldCArICdcIi4gUGxlYXNlIGNvbmZpZ3VyZSB0aGUgZHluYW1pY1JlcXVpcmVUYXJnZXRzIG9wdGlvbiBvZiBAcm9sbHVwL3BsdWdpbi1jb21tb25qcyBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHJlcXVpcmUgY2FsbCB0byBiZWhhdmUgcHJvcGVybHkuJyk7XG59XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG5cblxudmFyIE5vZGVCdWZmZXI7XG5cbnRyeSB7XG4gIC8vIEEgdHJpY2sgZm9yIGJyb3dzZXJpZmllZCB2ZXJzaW9uLCB0byBub3QgaW5jbHVkZSBgQnVmZmVyYCBzaGltXG4gIHZhciBfcmVxdWlyZSA9IGNvbW1vbmpzUmVxdWlyZTtcbiAgTm9kZUJ1ZmZlciA9IF9yZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG59IGNhdGNoIChfXykge30gLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxuXG5cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XFxuXFxyJztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCaW5hcnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY29kZSxcbiAgICAgIGlkeCxcbiAgICAgIGJpdGxlbiA9IDAsXG4gICAgICBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7IC8vIENvbnZlcnQgb25lIGJ5IG9uZS5cblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBjb2RlID0gbWFwLmluZGV4T2YoZGF0YS5jaGFyQXQoaWR4KSk7IC8vIFNraXAgQ1IvTEZcblxuICAgIGlmIChjb2RlID4gNjQpIGNvbnRpbnVlOyAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuXG4gICAgaWYgKGNvZGUgPCAwKSByZXR1cm4gZmFsc2U7XG4gICAgYml0bGVuICs9IDY7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG5cblxuICByZXR1cm4gYml0bGVuICUgOCA9PT0gMDtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJpbmFyeShkYXRhKSB7XG4gIHZhciBpZHgsXG4gICAgICB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLFxuICAgICAgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdOyAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmIChpZHggJSA0ID09PSAwICYmIGlkeCkge1xuICAgICAgcmVzdWx0LnB1c2goYml0cyA+PiAxNiAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goYml0cyA+PiA4ICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IGJpdHMgPDwgNiB8IG1hcC5pbmRleE9mKGlucHV0LmNoYXJBdChpZHgpKTtcbiAgfSAvLyBEdW1wIHRhaWxcblxuXG4gIHRhaWxiaXRzID0gbWF4ICUgNCAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goYml0cyA+PiAxNiAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgPj4gOCAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTgpIHtcbiAgICByZXN1bHQucHVzaChiaXRzID4+IDEwICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyA+PiAyICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goYml0cyA+PiA0ICYgMHhGRik7XG4gIH0gLy8gV3JhcCBpbnRvIEJ1ZmZlciBmb3IgTm9kZUpTIGFuZCBsZWF2ZSBBcnJheSBmb3IgYnJvd3NlclxuXG5cbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICAvLyBTdXBwb3J0IG5vZGUgNi4rIEJ1ZmZlciBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICByZXR1cm4gTm9kZUJ1ZmZlci5mcm9tID8gTm9kZUJ1ZmZlci5mcm9tKHJlc3VsdCkgOiBuZXcgTm9kZUJ1ZmZlcihyZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3Rcbi8qLCBzdHlsZSovXG4pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgYml0cyA9IDAsXG4gICAgICBpZHgsXG4gICAgICB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7IC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBBU0NJSSBjaGFyYWN0ZXJzLlxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmIChpZHggJSAzID09PSAwICYmIGlkeCkge1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzID4+IDE4ICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMTIgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbYml0cyA+PiA2ICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgOCkgKyBvYmplY3RbaWR4XTtcbiAgfSAvLyBEdW1wIHRhaWxcblxuXG4gIHRhaWwgPSBtYXggJSAzO1xuXG4gIGlmICh0YWlsID09PSAwKSB7XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzID4+IDE4ICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzID4+IDEyICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzID4+IDYgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAyKSB7XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzID4+IDEwICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzID4+IDQgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPDwgMiAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDEpIHtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgPj4gMiAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbYml0cyA8PCA0ICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gICAgcmVzdWx0ICs9IG1hcFs2NF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeShvYmplY3QpIHtcbiAgcmV0dXJuIE5vZGVCdWZmZXIgJiYgTm9kZUJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpO1xufVxuXG52YXIgYmluYXJ5ID0gbmV3IHR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sT21hcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIG9iamVjdEtleXMgPSBbXSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgcGFpcixcbiAgICAgIHBhaXJLZXksXG4gICAgICBwYWlySGFzS2V5LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBwYWlySGFzS2V5ID0gZmFsc2U7XG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChwYWlyS2V5IGluIHBhaXIpIHtcbiAgICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChwYWlyLCBwYWlyS2V5KSkge1xuICAgICAgICBpZiAoIXBhaXJIYXNLZXkpIHBhaXJIYXNLZXkgPSB0cnVlO2Vsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFpckhhc0tleSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkgPT09IC0xKSBvYmplY3RLZXlzLnB1c2gocGFpcktleSk7ZWxzZSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE9tYXAoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiBbXTtcbn1cblxudmFyIG9tYXAgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxPbWFwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxPbWFwXG59KTtcblxudmFyIF90b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgcGFpcixcbiAgICAgIGtleXMsXG4gICAgICByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgaWYgKF90b1N0cmluZyQxLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJlc3VsdFtpbmRleF0gPSBba2V5c1swXSwgcGFpcltrZXlzWzBdXV07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBbXTtcbiAgdmFyIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgcGFpcixcbiAgICAgIGtleXMsXG4gICAgICByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuICAgIHJlc3VsdFtpbmRleF0gPSBba2V5c1swXSwgcGFpcltrZXlzWzBdXV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgcGFpcnMgPSBuZXcgdHlwZSgndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sUGFpcnMsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFBhaXJzXG59KTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxTZXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciBrZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkkMS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxudmFyIHNldCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLCB7XG4gIGtpbmQ6ICdtYXBwaW5nJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxTZXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFNldFxufSk7XG5cbnZhciBkZWZhdWx0X3NhZmUgPSBuZXcgc2NoZW1hKHtcbiAgaW5jbHVkZTogW2NvcmVdLFxuICBpbXBsaWNpdDogW3RpbWVzdGFtcCwgbWVyZ2VdLFxuICBleHBsaWNpdDogW2JpbmFyeSwgb21hcCwgcGFpcnMsIHNldF1cbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFVuZGVmaW5lZCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnO1xufVxuXG52YXIgX3VuZGVmaW5lZCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy91bmRlZmluZWQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkLFxuICBwcmVkaWNhdGU6IGlzVW5kZWZpbmVkLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWRcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7IC8vIGlmIHJlZ2V4cCBzdGFydHMgd2l0aCAnLycgaXQgY2FuIGhhdmUgbW9kaWZpZXJzIGFuZCBtdXN0IGJlIHByb3Blcmx5IGNsb3NlZFxuICAvLyBgL2Zvby9naW1gIC0gbW9kaWZpZXJzIHRhaWwgY2FuIGJlIG1heGltdW0gMyBjaGFyc1xuXG4gIGlmIChyZWdleHBbMF0gPT09ICcvJykge1xuICAgIGlmICh0YWlsKSBtb2RpZmllcnMgPSB0YWlsWzFdO1xuICAgIGlmIChtb2RpZmllcnMubGVuZ3RoID4gMykgcmV0dXJuIGZhbHNlOyAvLyBpZiBleHByZXNzaW9uIHN0YXJ0cyB3aXRoIC8sIGlzIHNob3VsZCBiZSBwcm9wZXJseSB0ZXJtaW5hdGVkXG5cbiAgICBpZiAocmVnZXhwW3JlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMV0gIT09ICcvJykgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAoZGF0YSkge1xuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7IC8vIGAvZm9vL2dpbWAgLSB0YWlsIGNhbiBiZSBtYXhpbXVtIDQgY2hhcnNcblxuICBpZiAocmVnZXhwWzBdID09PSAnLycpIHtcbiAgICBpZiAodGFpbCkgbW9kaWZpZXJzID0gdGFpbFsxXTtcbiAgICByZWdleHAgPSByZWdleHAuc2xpY2UoMSwgcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cChvYmplY3Rcbi8qLCBzdHlsZSovXG4pIHtcbiAgdmFyIHJlc3VsdCA9ICcvJyArIG9iamVjdC5zb3VyY2UgKyAnLyc7XG4gIGlmIChvYmplY3QuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAob2JqZWN0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKG9iamVjdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxudmFyIHJlZ2V4cCA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9yZWdleHAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwLFxuICBwcmVkaWNhdGU6IGlzUmVnRXhwLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRSZWdFeHBcbn0pO1xuXG52YXIgZXNwcmltYTsgLy8gQnJvd3NlcmlmaWVkIHZlcnNpb24gZG9lcyBub3QgaGF2ZSBlc3ByaW1hXG4vL1xuLy8gMS4gRm9yIG5vZGUuanMganVzdCByZXF1aXJlIG1vZHVsZSBhcyBkZXBzXG4vLyAyLiBGb3IgYnJvd3NlciB0cnkgdG8gcmVxdWlyZSBtdWR1bGUgdmlhIGV4dGVybmFsIEFNRCBzeXN0ZW0uXG4vLyAgICBJZiBub3QgZm91bmQgLSB0cnkgdG8gZmFsbGJhY2sgdG8gd2luZG93LmVzcHJpbWEuIElmIG5vdFxuLy8gICAgZm91bmQgdG9vIC0gdGhlbiBmYWlsIHRvIHBhcnNlLlxuLy9cblxudHJ5IHtcbiAgLy8gd29ya2Fyb3VuZCB0byBleGNsdWRlIHBhY2thZ2UgZnJvbSBicm93c2VyaWZ5IGxpc3QuXG4gIHZhciBfcmVxdWlyZSQxID0gY29tbW9uanNSZXF1aXJlO1xuICBlc3ByaW1hID0gX3JlcXVpcmUkMSgnZXNwcmltYScpO1xufSBjYXRjaCAoXykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cblxuICAvKiBnbG9iYWwgd2luZG93ICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgZXNwcmltYSA9IHdpbmRvdy5lc3ByaW1hO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlSmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgICBhc3QgPSBlc3ByaW1hLnBhcnNlKHNvdXJjZSwge1xuICAgICAgcmFuZ2U6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChhc3QudHlwZSAhPT0gJ1Byb2dyYW0nIHx8IGFzdC5ib2R5Lmxlbmd0aCAhPT0gMSB8fCBhc3QuYm9keVswXS50eXBlICE9PSAnRXhwcmVzc2lvblN0YXRlbWVudCcgfHwgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nICYmIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIC8qanNsaW50IGV2aWw6dHJ1ZSovXG4gIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgYXN0ID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHtcbiAgICByYW5nZTogdHJ1ZVxuICB9KSxcbiAgICAgIHBhcmFtcyA9IFtdLFxuICAgICAgYm9keTtcblxuICBpZiAoYXN0LnR5cGUgIT09ICdQcm9ncmFtJyB8fCBhc3QuYm9keS5sZW5ndGggIT09IDEgfHwgYXN0LmJvZHlbMF0udHlwZSAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnIHx8IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyAmJiBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdGdW5jdGlvbkV4cHJlc3Npb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBwYXJhbXMucHVzaChwYXJhbS5uYW1lKTtcbiAgfSk7XG4gIGJvZHkgPSBhc3QuYm9keVswXS5leHByZXNzaW9uLmJvZHkucmFuZ2U7IC8vIEVzcHJpbWEncyByYW5nZXMgaW5jbHVkZSB0aGUgZmlyc3QgJ3snIGFuZCB0aGUgbGFzdCAnfScgY2hhcmFjdGVycyBvblxuICAvLyBmdW5jdGlvbiBleHByZXNzaW9ucy4gU28gY3V0IHRoZW0gb3V0LlxuXG4gIGlmIChhc3QuYm9keVswXS5leHByZXNzaW9uLmJvZHkudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMqL1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCBzb3VyY2Uuc2xpY2UoYm9keVswXSArIDEsIGJvZHlbMV0gLSAxKSk7XG4gIH0gLy8gRVM2IGFycm93IGZ1bmN0aW9ucyBjYW4gb21pdCB0aGUgQmxvY2tTdGF0ZW1lbnQuIEluIHRoYXQgY2FzZSwganVzdCByZXR1cm5cbiAgLy8gdGhlIGJvZHkuXG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG5cblxuICByZXR1cm4gbmV3IEZ1bmN0aW9uKHBhcmFtcywgJ3JldHVybiAnICsgc291cmNlLnNsaWNlKGJvZHlbMF0sIGJvZHlbMV0pKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uKG9iamVjdFxuLyosIHN0eWxlKi9cbikge1xuICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxudmFyIF9mdW5jdGlvbiA9IG5ldyB0eXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9mdW5jdGlvbicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBwcmVkaWNhdGU6IGlzRnVuY3Rpb24sXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uXG59KTtcblxudmFyIGRlZmF1bHRfZnVsbCA9IHNjaGVtYS5ERUZBVUxUID0gbmV3IHNjaGVtYSh7XG4gIGluY2x1ZGU6IFtkZWZhdWx0X3NhZmVdLFxuICBleHBsaWNpdDogW191bmRlZmluZWQsIHJlZ2V4cCwgX2Z1bmN0aW9uXVxufSk7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbixuby11c2UtYmVmb3JlLWRlZmluZSovXG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBDT05URVhUX0ZMT1dfSU4gPSAxO1xudmFyIENPTlRFWFRfRkxPV19PVVQgPSAyO1xudmFyIENPTlRFWFRfQkxPQ0tfSU4gPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcbnZhciBDSE9NUElOR19DTElQID0gMTtcbnZhciBDSE9NUElOR19TVFJJUCA9IDI7XG52YXIgQ0hPTVBJTkdfS0VFUCA9IDM7XG52YXIgUEFUVEVSTl9OT05fUFJJTlRBQkxFID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgPSAvXig/OiF8ISF8IVthLXpcXC1dKyEpJC9pO1xudmFyIFBBVFRFUk5fVEFHX1VSSSA9IC9eKD86IXxbXixcXFtcXF1cXHtcXH1dKSg/OiVbMC05YS1mXXsyfXxbMC05YS16XFwtIztcXC9cXD86QCY9XFwrXFwkLF9cXC4hflxcKidcXChcXClcXFtcXF1dKSokL2k7XG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5mdW5jdGlvbiBpc19FT0woYykge1xuICByZXR1cm4gYyA9PT0gMHgwQVxuICAvKiBMRiAqL1xuICB8fCBjID09PSAweDBEXG4gIC8qIENSICovXG4gIDtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gYyA9PT0gMHgwOVxuICAvKiBUYWIgKi9cbiAgfHwgYyA9PT0gMHgyMFxuICAvKiBTcGFjZSAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGlzX1dTX09SX0VPTChjKSB7XG4gIHJldHVybiBjID09PSAweDA5XG4gIC8qIFRhYiAqL1xuICB8fCBjID09PSAweDIwXG4gIC8qIFNwYWNlICovXG4gIHx8IGMgPT09IDB4MEFcbiAgLyogTEYgKi9cbiAgfHwgYyA9PT0gMHgwRFxuICAvKiBDUiAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGlzX0ZMT1dfSU5ESUNBVE9SKGMpIHtcbiAgcmV0dXJuIGMgPT09IDB4MkNcbiAgLyogLCAqL1xuICB8fCBjID09PSAweDVCXG4gIC8qIFsgKi9cbiAgfHwgYyA9PT0gMHg1RFxuICAvKiBdICovXG4gIHx8IGMgPT09IDB4N0JcbiAgLyogeyAqL1xuICB8fCBjID09PSAweDdEXG4gIC8qIH0gKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBmcm9tSGV4Q29kZShjKSB7XG4gIHZhciBsYztcblxuICBpZiAoMHgzMFxuICAvKiAwICovXG4gIDw9IGMgJiYgYyA8PSAweDM5XG4gIC8qIDkgKi9cbiAgKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG4gIC8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG5cblxuICBsYyA9IGMgfCAweDIwO1xuXG4gIGlmICgweDYxXG4gIC8qIGEgKi9cbiAgPD0gbGMgJiYgbGMgPD0gMHg2NlxuICAvKiBmICovXG4gICkge1xuICAgIHJldHVybiBsYyAtIDB4NjEgKyAxMDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZEhleExlbihjKSB7XG4gIGlmIChjID09PSAweDc4XG4gIC8qIHggKi9cbiAgKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG5cbiAgaWYgKGMgPT09IDB4NzVcbiAgLyogdSAqL1xuICApIHtcbiAgICAgIHJldHVybiA0O1xuICAgIH1cblxuICBpZiAoYyA9PT0gMHg1NVxuICAvKiBVICovXG4gICkge1xuICAgICAgcmV0dXJuIDg7XG4gICAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVjaW1hbENvZGUoYykge1xuICBpZiAoMHgzMFxuICAvKiAwICovXG4gIDw9IGMgJiYgYyA8PSAweDM5XG4gIC8qIDkgKi9cbiAgKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuICByZXR1cm4gYyA9PT0gMHgzMFxuICAvKiAwICovXG4gID8gJ1xceDAwJyA6IGMgPT09IDB4NjFcbiAgLyogYSAqL1xuICA/ICdcXHgwNycgOiBjID09PSAweDYyXG4gIC8qIGIgKi9cbiAgPyAnXFx4MDgnIDogYyA9PT0gMHg3NFxuICAvKiB0ICovXG4gID8gJ1xceDA5JyA6IGMgPT09IDB4MDlcbiAgLyogVGFiICovXG4gID8gJ1xceDA5JyA6IGMgPT09IDB4NkVcbiAgLyogbiAqL1xuICA/ICdcXHgwQScgOiBjID09PSAweDc2XG4gIC8qIHYgKi9cbiAgPyAnXFx4MEInIDogYyA9PT0gMHg2NlxuICAvKiBmICovXG4gID8gJ1xceDBDJyA6IGMgPT09IDB4NzJcbiAgLyogciAqL1xuICA/ICdcXHgwRCcgOiBjID09PSAweDY1XG4gIC8qIGUgKi9cbiAgPyAnXFx4MUInIDogYyA9PT0gMHgyMFxuICAvKiBTcGFjZSAqL1xuICA/ICcgJyA6IGMgPT09IDB4MjJcbiAgLyogXCIgKi9cbiAgPyAnXFx4MjInIDogYyA9PT0gMHgyRlxuICAvKiAvICovXG4gID8gJy8nIDogYyA9PT0gMHg1Q1xuICAvKiBcXCAqL1xuICA/ICdcXHg1QycgOiBjID09PSAweDRFXG4gIC8qIE4gKi9cbiAgPyAnXFx4ODUnIDogYyA9PT0gMHg1RlxuICAvKiBfICovXG4gID8gJ1xceEEwJyA6IGMgPT09IDB4NENcbiAgLyogTCAqL1xuICA/IFwiXFx1MjAyOFwiIDogYyA9PT0gMHg1MFxuICAvKiBQICovXG4gID8gXCJcXHUyMDI5XCIgOiAnJztcbn1cblxuZnVuY3Rpb24gY2hhckZyb21Db2RlcG9pbnQoYykge1xuICBpZiAoYyA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgfSAvLyBFbmNvZGUgVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyXG4gIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi0xNiNDb2RlX3BvaW50c19VLjJCMDEwMDAwX3RvX1UuMkIxMEZGRkZcblxuXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjIC0gMHgwMTAwMDAgPj4gMTApICsgMHhEODAwLCAoYyAtIDB4MDEwMDAwICYgMHgwM0ZGKSArIDB4REMwMCk7XG59XG5cbnZhciBzaW1wbGVFc2NhcGVDaGVjayA9IG5ldyBBcnJheSgyNTYpOyAvLyBpbnRlZ2VyLCBmb3IgZmFzdCBhY2Nlc3NcblxudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIHNpbXBsZUVzY2FwZUNoZWNrW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSkgPyAxIDogMDtcbiAgc2ltcGxlRXNjYXBlTWFwW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSk7XG59XG5cbmZ1bmN0aW9uIFN0YXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5maWxlbmFtZSA9IG9wdGlvbnNbJ2ZpbGVuYW1lJ10gfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBkZWZhdWx0X2Z1bGw7XG4gIHRoaXMub25XYXJuaW5nID0gb3B0aW9uc1snb25XYXJuaW5nJ10gfHwgbnVsbDtcbiAgdGhpcy5sZWdhY3kgPSBvcHRpb25zWydsZWdhY3knXSB8fCBmYWxzZTtcbiAgdGhpcy5qc29uID0gb3B0aW9uc1snanNvbiddIHx8IGZhbHNlO1xuICB0aGlzLmxpc3RlbmVyID0gb3B0aW9uc1snbGlzdGVuZXInXSB8fCBudWxsO1xuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG4gIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgdGhpcy5saW5lID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgZXhjZXB0aW9uKG1lc3NhZ2UsIG5ldyBtYXJrKHN0YXRlLmZpbGVuYW1lLCBzdGF0ZS5pbnB1dCwgc3RhdGUucG9zaXRpb24sIHN0YXRlLmxpbmUsIHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0KSk7XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Ioc3RhdGUsIG1lc3NhZ2UpIHtcbiAgdGhyb3cgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIHRocm93V2FybmluZyhzdGF0ZSwgbWVzc2FnZSkge1xuICBpZiAoc3RhdGUub25XYXJuaW5nKSB7XG4gICAgc3RhdGUub25XYXJuaW5nLmNhbGwobnVsbCwgZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVIYW5kbGVycyA9IHtcbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuICAgIHZhciBtYXRjaCwgbWFqb3IsIG1pbm9yO1xuXG4gICAgaWYgKHN0YXRlLnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiAlWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdZQU1MIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgb25lIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSAvXihbMC05XSspXFwuKFswLTldKykkLy5leGVjKGFyZ3NbMF0pO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCBhcmd1bWVudCBvZiB0aGUgWUFNTCBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBtYWpvciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgbWlub3IgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuXG4gICAgaWYgKG1ham9yICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS52ZXJzaW9uID0gYXJnc1swXTtcbiAgICBzdGF0ZS5jaGVja0xpbmVCcmVha3MgPSBtaW5vciA8IDI7XG5cbiAgICBpZiAobWlub3IgIT09IDEgJiYgbWlub3IgIT09IDIpIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG4gIH0sXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG4gICAgdmFyIGhhbmRsZSwgcHJlZml4O1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnVEFHIGRpcmVjdGl2ZSBhY2NlcHRzIGV4YWN0bHkgdHdvIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGhhbmRsZSA9IGFyZ3NbMF07XG4gICAgcHJlZml4ID0gYXJnc1sxXTtcblxuICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QoaGFuZGxlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIGhhbmRsZSAoZmlyc3QgYXJndW1lbnQpIG9mIHRoZSBUQUcgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwoc3RhdGUudGFnTWFwLCBoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHByZWZpeCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS50YWdNYXBbaGFuZGxlXSA9IHByZWZpeDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKCEoX2NoYXJhY3RlciA9PT0gMHgwOSB8fCAweDIwIDw9IF9jaGFyYWN0ZXIgJiYgX2NoYXJhY3RlciA8PSAweDEwRkZGRikpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5JDIuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBzdGFydExpbmUsIHN0YXJ0UG9zKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7IC8vIFRoZSBvdXRwdXQgaXMgYSBwbGFpbiBvYmplY3QgaGVyZSwgc28ga2V5cyBjYW4gb25seSBiZSBzdHJpbmdzLlxuICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQga2V5Tm9kZSB0byBhIHN0cmluZywgYnV0IGRvaW5nIHNvIGNhbiBoYW5nIHRoZSBwcm9jZXNzXG4gIC8vIChkZWVwbHkgbmVzdGVkIGFycmF5cyB0aGF0IGV4cGxvZGUgZXhwb25lbnRpYWxseSB1c2luZyBhbGlhc2VzKS5cblxuICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlKSkge1xuICAgIGtleU5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXlOb2RlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IGtleU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZVtpbmRleF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBrZXlOb2RlW2luZGV4XSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBBdm9pZCBjb2RlIGV4ZWN1dGlvbiBpbiBsb2FkKCkgdmlhIHRvU3RyaW5nIHByb3BlcnR5XG4gIC8vIChzdGlsbCB1c2UgaXRzIG93biB0b1N0cmluZyBmb3IgYXJyYXlzLCB0aW1lc3RhbXBzLFxuICAvLyBhbmQgd2hhdGV2ZXIgdXNlciBzY2hlbWEgZXh0ZW5zaW9ucyBoYXBwZW4gdG8gaGF2ZSBAQHRvU3RyaW5nVGFnKVxuXG5cbiAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAga2V5Tm9kZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICB9XG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmICFfaGFzT3duUHJvcGVydHkkMi5jYWxsKG92ZXJyaWRhYmxlS2V5cywga2V5Tm9kZSkgJiYgX2hhc093blByb3BlcnR5JDIuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuXG4gICAgX3Jlc3VsdFtrZXlOb2RlXSA9IHZhbHVlTm9kZTtcbiAgICBkZWxldGUgb3ZlcnJpZGFibGVLZXlzW2tleU5vZGVdO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQVxuICAvKiBMRiAqL1xuICApIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRFxuICAvKiBDUiAqL1xuICApIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgwQVxuICAgICAgLyogTEYgKi9cbiAgICAgICkge1xuICAgICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIGxpbmUgYnJlYWsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIHN0YXRlLmxpbmUgKz0gMTtcbiAgc3RhdGUubGluZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGFsbG93Q29tbWVudHMsIGNoZWNrSW5kZW50KSB7XG4gIHZhciBsaW5lQnJlYWtzID0gMCxcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgd2hpbGUgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChhbGxvd0NvbW1lbnRzICYmIGNoID09PSAweDIzXG4gICAgLyogIyAqL1xuICAgICkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9IHdoaWxlIChjaCAhPT0gMHgwQVxuICAgICAgICAvKiBMRiAqL1xuICAgICAgICAmJiBjaCAhPT0gMHgwRFxuICAgICAgICAvKiBDUiAqL1xuICAgICAgICAmJiBjaCAhPT0gMCk7XG4gICAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMFxuICAgICAgLyogU3BhY2UgKi9cbiAgICAgICkge1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrSW5kZW50ICE9PSAtMSAmJiBsaW5lQnJlYWtzICE9PSAwICYmIHN0YXRlLmxpbmVJbmRlbnQgPCBjaGVja0luZGVudCkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ2RlZmljaWVudCBpbmRlbnRhdGlvbicpO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVCcmVha3M7XG59XG5cbmZ1bmN0aW9uIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24sXG4gICAgICBjaDtcbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7IC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuXG4gIGlmICgoY2ggPT09IDB4MkRcbiAgLyogLSAqL1xuICB8fCBjaCA9PT0gMHgyRVxuICAvKiAuICovXG4gICkgJiYgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMSkgJiYgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcbiAgICBfcG9zaXRpb24gKz0gMztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSB8fCBpc19GTE9XX0lORElDQVRPUihjaCkgfHwgY2ggPT09IDB4MjNcbiAgLyogIyAqL1xuICB8fCBjaCA9PT0gMHgyNlxuICAvKiAmICovXG4gIHx8IGNoID09PSAweDJBXG4gIC8qICogKi9cbiAgfHwgY2ggPT09IDB4MjFcbiAgLyogISAqL1xuICB8fCBjaCA9PT0gMHg3Q1xuICAvKiB8ICovXG4gIHx8IGNoID09PSAweDNFXG4gIC8qID4gKi9cbiAgfHwgY2ggPT09IDB4MjdcbiAgLyogJyAqL1xuICB8fCBjaCA9PT0gMHgyMlxuICAvKiBcIiAqL1xuICB8fCBjaCA9PT0gMHgyNVxuICAvKiAlICovXG4gIHx8IGNoID09PSAweDQwXG4gIC8qIEAgKi9cbiAgfHwgY2ggPT09IDB4NjBcbiAgLyogYCAqL1xuICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgaWYgKGNoID09PSAweDNGXG4gIC8qID8gKi9cbiAgfHwgY2ggPT09IDB4MkRcbiAgLyogLSAqL1xuICApIHtcbiAgICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8IHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBXG4gICAgLyogOiAqL1xuICAgICkge1xuICAgICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8IHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyM1xuICAgIC8qICMgKi9cbiAgICApIHtcbiAgICAgICAgcHJlY2VkaW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiAtIDEpO1xuXG4gICAgICAgIGlmIChpc19XU19PUl9FT0wocHJlY2VkaW5nKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB8fCB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kO1xuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyN1xuICAvKiAnICovXG4gICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyN1xuICAgIC8qICcgKi9cbiAgICApIHtcbiAgICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDI3XG4gICAgICAgIC8qICcgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIGhleExlbmd0aCwgaGV4UmVzdWx0LCB0bXAsIGNoO1xuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMlxuICAvKiBcIiAqL1xuICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjJcbiAgICAvKiBcIiAqL1xuICAgICkge1xuICAgICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1Q1xuICAgIC8qIFxcICovXG4gICAgKSB7XG4gICAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpOyAvLyBUT0RPOiByZXdvcmsgdG8gaW5saW5lIGZuIHdpdGggbm8gdHlwZSBjYXN0P1xuICAgICAgICB9IGVsc2UgaWYgKGNoIDwgMjU2ICYmIHNpbXBsZUVzY2FwZUNoZWNrW2NoXSkge1xuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIH0gZWxzZSBpZiAoKHRtcCA9IGVzY2FwZWRIZXhMZW4oY2gpKSA+IDApIHtcbiAgICAgICAgICBoZXhMZW5ndGggPSB0bXA7XG4gICAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICAgIGZvciAoOyBoZXhMZW5ndGggPiAwOyBoZXhMZW5ndGgtLSkge1xuICAgICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgICBoZXhSZXN1bHQgPSAoaGV4UmVzdWx0IDw8IDQpICsgdG1wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2V4cGVjdGVkIGhleGFkZWNpbWFsIGNoYXJhY3RlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSBjaGFyRnJvbUNvZGVwb2ludChoZXhSZXN1bHQpO1xuICAgICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfdGFnID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICB0ZXJtaW5hdG9yLFxuICAgICAgaXNQYWlyLFxuICAgICAgaXNFeHBsaWNpdFBhaXIsXG4gICAgICBpc01hcHBpbmcsXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSB7fSxcbiAgICAgIGtleU5vZGUsXG4gICAgICBrZXlUYWcsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg1QlxuICAvKiBbICovXG4gICkge1xuICAgICAgdGVybWluYXRvciA9IDB4NUQ7XG4gICAgICAvKiBdICovXG5cbiAgICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgICAgX3Jlc3VsdCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4N0JcbiAgLyogeyAqL1xuICApIHtcbiAgICAgIHRlcm1pbmF0b3IgPSAweDdEO1xuICAgICAgLyogfSAqL1xuXG4gICAgICBpc01hcHBpbmcgPSB0cnVlO1xuICAgICAgX3Jlc3VsdCA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICBzdGF0ZS5raW5kID0gaXNNYXBwaW5nID8gJ21hcHBpbmcnIDogJ3NlcXVlbmNlJztcbiAgICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFyZWFkTmV4dCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ21pc3NlZCBjb21tYSBiZXR3ZWVuIGZsb3cgY29sbGVjdGlvbiBlbnRyaWVzJyk7XG4gICAgfVxuXG4gICAga2V5VGFnID0ga2V5Tm9kZSA9IHZhbHVlTm9kZSA9IG51bGw7XG4gICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSBmYWxzZTtcblxuICAgIGlmIChjaCA9PT0gMHgzRlxuICAgIC8qID8gKi9cbiAgICApIHtcbiAgICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgICAgIGlzUGFpciA9IGlzRXhwbGljaXRQYWlyID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKGlzRXhwbGljaXRQYWlyIHx8IHN0YXRlLmxpbmUgPT09IF9saW5lKSAmJiBjaCA9PT0gMHgzQVxuICAgIC8qIDogKi9cbiAgICApIHtcbiAgICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICB9XG5cbiAgICBpZiAoaXNNYXBwaW5nKSB7XG4gICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFpcikge1xuICAgICAgX3Jlc3VsdC5wdXNoKHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIG51bGwsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkNcbiAgICAvKiAsICovXG4gICAgKSB7XG4gICAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIHJlYWROZXh0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgY2FwdHVyZVN0YXJ0LFxuICAgICAgZm9sZGluZyxcbiAgICAgIGNob21waW5nID0gQ0hPTVBJTkdfQ0xJUCxcbiAgICAgIGRpZFJlYWRDb250ZW50ID0gZmFsc2UsXG4gICAgICBkZXRlY3RlZEluZGVudCA9IGZhbHNlLFxuICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzID0gMCxcbiAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2UsXG4gICAgICB0bXAsXG4gICAgICBjaDtcbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0NcbiAgLyogfCAqL1xuICApIHtcbiAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDNFXG4gIC8qID4gKi9cbiAgKSB7XG4gICAgICBmb2xkaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCXG4gICAgLyogKyAqL1xuICAgIHx8IGNoID09PSAweDJEXG4gICAgLyogLSAqL1xuICAgICkge1xuICAgICAgICBpZiAoQ0hPTVBJTkdfQ0xJUCA9PT0gY2hvbXBpbmcpIHtcbiAgICAgICAgICBjaG9tcGluZyA9IGNoID09PSAweDJCXG4gICAgICAgICAgLyogKyAqL1xuICAgICAgICAgID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYSBjaG9tcGluZyBtb2RlIGlkZW50aWZpZXInKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgIGRvIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpO1xuXG4gICAgaWYgKGNoID09PSAweDIzXG4gICAgLyogIyAqL1xuICAgICkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgICB9IHdoaWxlICghaXNfRU9MKGNoKSAmJiBjaCAhPT0gMCk7XG4gICAgICB9XG4gIH1cblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmIGNoID09PSAweDIwXG4gICAgLyogU3BhY2UgKi9cbiAgICApIHtcbiAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIWRldGVjdGVkSW5kZW50ICYmIHN0YXRlLmxpbmVJbmRlbnQgPiB0ZXh0SW5kZW50KSB7XG4gICAgICB0ZXh0SW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgZW1wdHlMaW5lcysrO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBFbmQgb2YgdGhlIHNjYWxhci5cblxuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCB0ZXh0SW5kZW50KSB7XG4gICAgICAvLyBQZXJmb3JtIHRoZSBjaG9tcGluZy5cbiAgICAgIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfS0VFUCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHtcbiAgICAgICAgICAvLyBpLmUuIG9ubHkgaWYgdGhlIHNjYWxhciBpcyBub3QgZW1wdHkuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9IC8vIEJyZWFrIHRoaXMgYHdoaWxlYCBjeWNsZSBhbmQgZ28gdG8gdGhlIGZ1bmNpdG9uJ3MgZXBpbG9ndWUuXG5cblxuICAgICAgYnJlYWs7XG4gICAgfSAvLyBGb2xkZWQgc3R5bGU6IHVzZSBmYW5jeSBydWxlcyB0byBoYW5kbGUgbGluZSBicmVha3MuXG5cblxuICAgIGlmIChmb2xkaW5nKSB7XG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7IC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7IC8vIEVuZCBvZiBtb3JlLWluZGVudGVkIGJsb2NrLlxuICAgICAgfSBlbHNlIGlmIChhdE1vcmVJbmRlbnRlZCkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpOyAvLyBKdXN0IG9uZSBsaW5lIGJyZWFrIC0gcGVyY2VpdmUgYXMgdGhlIHNhbWUgbGluZS5cbiAgICAgIH0gZWxzZSBpZiAoZW1wdHlMaW5lcyA9PT0gMCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHtcbiAgICAgICAgICAvLyBpLmUuIG9ubHkgaWYgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgc29tZSBzY2FsYXIgY29udGVudC5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICAgICAgICB9IC8vIFNldmVyYWwgbGluZSBicmVha3MgLSBwZXJjZWl2ZSBhcyBkaWZmZXJlbnQgbGluZXMuXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH0gLy8gTGl0ZXJhbCBzdHlsZToganVzdCBhZGQgZXhhY3QgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIGJldHdlZW4gY29udGVudCBsaW5lcy5cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBLZWVwIGFsbCBsaW5lIGJyZWFrcyBleGNlcHQgdGhlIGhlYWRlciBsaW5lIGJyZWFrLlxuICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICB9XG5cbiAgICBkaWRSZWFkQ29udGVudCA9IHRydWU7XG4gICAgZGV0ZWN0ZWRJbmRlbnQgPSB0cnVlO1xuICAgIGVtcHR5TGluZXMgPSAwO1xuICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKCFpc19FT0woY2gpICYmIGNoICE9PSAwKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgX2xpbmUsXG4gICAgICBfdGFnID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgPSBbXSxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGRldGVjdGVkID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoY2ggIT09IDB4MkRcbiAgICAvKiAtICovXG4gICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcblxuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfSU4sIGZhbHNlLCB0cnVlKTtcblxuICAgIF9yZXN1bHQucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiBjaCAhPT0gMCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIHNlcXVlbmNlIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnc2VxdWVuY2UnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIG5vZGVJbmRlbnQsIGZsb3dJbmRlbnQpIHtcbiAgdmFyIGZvbGxvd2luZyxcbiAgICAgIGFsbG93Q29tcGFjdCxcbiAgICAgIF9saW5lLFxuICAgICAgX3BvcyxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCA9IHt9LFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0ge30sXG4gICAgICBrZXlUYWcgPSBudWxsLFxuICAgICAga2V5Tm9kZSA9IG51bGwsXG4gICAgICB2YWx1ZU5vZGUgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IF9yZXN1bHQ7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIGZvbGxvd2luZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKTtcbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cblxuICAgIF9wb3MgPSBzdGF0ZS5wb3NpdGlvbjsgLy9cbiAgICAvLyBFeHBsaWNpdCBub3RhdGlvbiBjYXNlLiBUaGVyZSBhcmUgdHdvIHNlcGFyYXRlIGJsb2NrczpcbiAgICAvLyBmaXJzdCBmb3IgdGhlIGtleSAoZGVub3RlZCBieSBcIj9cIikgYW5kIHNlY29uZCBmb3IgdGhlIHZhbHVlIChkZW5vdGVkIGJ5IFwiOlwiKVxuICAgIC8vXG5cbiAgICBpZiAoKGNoID09PSAweDNGXG4gICAgLyogPyAqL1xuICAgIHx8IGNoID09PSAweDNBXG4gICAgLyogOiAqL1xuICAgICkgJiYgaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgzRlxuICAgICAgLyogPyAqL1xuICAgICAgKSB7XG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgLy8gaS5lLiAweDNBLyogOiAqLyA9PT0gY2hhcmFjdGVyIGFmdGVyIHRoZSBleHBsaWNpdCBrZXkuXG4gICAgICAgIGF0RXhwbGljaXRLZXkgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQ7IG9yIGZvbGxvd2VkIGJ5IGEgbm9uLXRhYnVsYXRlZCBlbXB0eSBsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZzsgLy9cbiAgICAgIC8vIEltcGxpY2l0IG5vdGF0aW9uIGNhc2UuIEZsb3ctc3R5bGUgbm9kZSBhcyB0aGUga2V5IGZpcnN0LCB0aGVuIFwiOlwiLCBhbmQgdGhlIHZhbHVlLlxuICAgICAgLy9cbiAgICB9IGVsc2UgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBmbG93SW5kZW50LCBDT05URVhUX0ZMT1dfT1VULCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4M0FcbiAgICAgICAgLyogOiAqL1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhIHdoaXRlc3BhY2UgY2hhcmFjdGVyIGlzIGV4cGVjdGVkIGFmdGVyIHRoZSBrZXktdmFsdWUgc2VwYXJhdG9yIHdpdGhpbiBhIGJsb2NrIG1hcHBpbmcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICAgICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgICAgYWxsb3dDb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAgICBrZXlUYWcgPSBzdGF0ZS50YWc7XG4gICAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBicmVhazsgLy8gUmVhZGluZyBpcyBkb25lLiBHbyB0byB0aGUgZXBpbG9ndWUuXG4gICAgICB9IC8vXG4gICAgLy8gQ29tbW9uIHJlYWRpbmcgY29kZSBmb3IgYm90aCBleHBsaWNpdCBhbmQgaW1wbGljaXQgbm90YXRpb25zLlxuICAgIC8vXG5cblxuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX09VVCwgdHJ1ZSwgYWxsb3dDb21wYWN0KSkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX3Bvcyk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCAmJiBjaCAhPT0gMCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIG1hcHBpbmcgZW50cnknKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBub2RlSW5kZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy9cbiAgLy8gRXBpbG9ndWUuXG4gIC8vXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG5cblxuICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgfSAvLyBFeHBvc2UgdGhlIHJlc3VsdGluZyBtYXBwaW5nLlxuXG5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgaWYgKGNoICE9PSAweDIxXG4gIC8qICEgKi9cbiAgKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgzQ1xuICAvKiA8ICovXG4gICkge1xuICAgICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMVxuICAvKiAhICovXG4gICkge1xuICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgdGFnSGFuZGxlID0gJyEnO1xuICB9XG5cbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBkbyB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfSB3aGlsZSAoY2ggIT09IDAgJiYgY2ggIT09IDB4M0VcbiAgICAvKiA+ICovXG4gICAgKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MjFcbiAgICAgIC8qICEgKi9cbiAgICAgICkge1xuICAgICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdCh0YWdIYW5kbGUpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZXhjbGFtYXRpb24gbWFya3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwoc3RhdGUudGFnTWFwLCB0YWdIYW5kbGUpKSB7XG4gICAgc3RhdGUudGFnID0gc3RhdGUudGFnTWFwW3RhZ0hhbmRsZV0gKyB0YWdOYW1lO1xuICB9IGVsc2UgaWYgKHRhZ0hhbmRsZSA9PT0gJyEnKSB7XG4gICAgc3RhdGUudGFnID0gJyEnICsgdGFnTmFtZTtcbiAgfSBlbHNlIGlmICh0YWdIYW5kbGUgPT09ICchIScpIHtcbiAgICBzdGF0ZS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6JyArIHRhZ05hbWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicgKyB0YWdIYW5kbGUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiwgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgaWYgKGNoICE9PSAweDI2XG4gIC8qICYgKi9cbiAgKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhbiBhbmNob3IgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFuY2hvciBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBzdGF0ZS5hbmNob3IgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlYWRBbGlhcyhzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLCBhbGlhcywgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgaWYgKGNoICE9PSAweDJBXG4gIC8qICogKi9cbiAgKSByZXR1cm4gZmFsc2U7XG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpICYmICFpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IF9wb3NpdGlvbikge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lIG9mIGFuIGFsaWFzIG5vZGUgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXInKTtcbiAgfVxuXG4gIGFsaWFzID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKCFfaGFzT3duUHJvcGVydHkkMi5jYWxsKHN0YXRlLmFuY2hvck1hcCwgYWxpYXMpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuaWRlbnRpZmllZCBhbGlhcyBcIicgKyBhbGlhcyArICdcIicpO1xuICB9XG5cbiAgc3RhdGUucmVzdWx0ID0gc3RhdGUuYW5jaG9yTWFwW2FsaWFzXTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZU5vZGUoc3RhdGUsIHBhcmVudEluZGVudCwgbm9kZUNvbnRleHQsIGFsbG93VG9TZWVrLCBhbGxvd0NvbXBhY3QpIHtcbiAgdmFyIGFsbG93QmxvY2tTdHlsZXMsXG4gICAgICBhbGxvd0Jsb2NrU2NhbGFycyxcbiAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyxcbiAgICAgIGluZGVudFN0YXR1cyA9IDEsXG4gICAgICAvLyAxOiB0aGlzPnBhcmVudCwgMDogdGhpcz1wYXJlbnQsIC0xOiB0aGlzPHBhcmVudFxuICBhdE5ld0xpbmUgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kID0gbnVsbDtcbiAgc3RhdGUucmVzdWx0ID0gbnVsbDtcbiAgYWxsb3dCbG9ja1N0eWxlcyA9IGFsbG93QmxvY2tTY2FsYXJzID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8IENPTlRFWFRfQkxPQ0tfSU4gPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIChyZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgYmxvY2tJbmRlbnQpIHx8IHJlYWRCbG9ja01hcHBpbmcoc3RhdGUsIGJsb2NrSW5kZW50LCBmbG93SW5kZW50KSkgfHwgcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbGxvd0Jsb2NrU2NhbGFycyAmJiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8IHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8IHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocmVhZEFsaWFzKHN0YXRlKSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCB8fCBzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhbGlhcyBub2RlIHNob3VsZCBub3QgaGF2ZSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICc/Jykge1xuICAgICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAgIC8vIHRhZywgZm9yIGV4YW1wbGUgbGlrZSB0aGlzOiBcIiE8Pz4gWzBdXCJcbiAgICAgIC8vXG4gICAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPD8+IHRhZzsgaXQgc2hvdWxkIGJlIFwic2NhbGFyXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbdHlwZUluZGV4XTtcblxuICAgICAgICBpZiAodHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHtcbiAgICAgICAgICAvLyBgc3RhdGUucmVzdWx0YCB1cGRhdGVkIGluIHJlc29sdmVyIGlmIG1hdGNoZWRcbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICAgIHN0YXRlLnRhZyA9IHR5cGUudGFnO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eSQyLmNhbGwoc3RhdGUudHlwZU1hcFtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddLCBzdGF0ZS50YWcpKSB7XG4gICAgICB0eXBlID0gc3RhdGUudHlwZU1hcFtzdGF0ZS5raW5kIHx8ICdmYWxsYmFjayddW3N0YXRlLnRhZ107XG5cbiAgICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgdHlwZS5raW5kICE9PSBzdGF0ZS5raW5kKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPCcgKyBzdGF0ZS50YWcgKyAnPiB0YWc7IGl0IHNob3VsZCBiZSBcIicgKyB0eXBlLmtpbmQgKyAnXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHtcbiAgICAgICAgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgcmVzb2x2ZSBhIG5vZGUgd2l0aCAhPCcgKyBzdGF0ZS50YWcgKyAnPiBleHBsaWNpdCB0YWcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmtub3duIHRhZyAhPCcgKyBzdGF0ZS50YWcgKyAnPicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5saXN0ZW5lciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmxpc3RlbmVyKCdjbG9zZScsIHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsIHx8IGhhc0NvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlYWREb2N1bWVudChzdGF0ZSkge1xuICB2YXIgZG9jdW1lbnRTdGFydCA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgX3Bvc2l0aW9uLFxuICAgICAgZGlyZWN0aXZlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUFyZ3MsXG4gICAgICBoYXNEaXJlY3RpdmVzID0gZmFsc2UsXG4gICAgICBjaDtcblxuICBzdGF0ZS52ZXJzaW9uID0gbnVsbDtcbiAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gc3RhdGUubGVnYWN5O1xuICBzdGF0ZS50YWdNYXAgPSB7fTtcbiAgc3RhdGUuYW5jaG9yTWFwID0ge307XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IGNoICE9PSAweDI1XG4gICAgLyogJSAqL1xuICAgICkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzXG4gICAgICAvKiAjICovXG4gICAgICApIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgICAgfSB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG5cbiAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGl2ZUFyZ3MucHVzaChzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAwKSByZWFkTGluZUJyZWFrKHN0YXRlKTtcblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkkMi5jYWxsKGRpcmVjdGl2ZUhhbmRsZXJzLCBkaXJlY3RpdmVOYW1lKSkge1xuICAgICAgZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlTmFtZV0oc3RhdGUsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bmtub3duIGRvY3VtZW50IGRpcmVjdGl2ZSBcIicgKyBkaXJlY3RpdmVOYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSAwICYmIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDJEXG4gIC8qIC0gKi9cbiAgJiYgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpID09PSAweDJEXG4gIC8qIC0gKi9cbiAgJiYgc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDIpID09PSAweDJEXG4gIC8qIC0gKi9cbiAgKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIH0gZWxzZSBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmVzIGVuZCBtYXJrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBjb21wb3NlTm9kZShzdGF0ZSwgc3RhdGUubGluZUluZGVudCAtIDEsIENPTlRFWFRfQkxPQ0tfT1VULCBmYWxzZSwgdHJ1ZSk7XG4gIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICBpZiAoc3RhdGUuY2hlY2tMaW5lQnJlYWtzICYmIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTLnRlc3Qoc3RhdGUuaW5wdXQuc2xpY2UoZG9jdW1lbnRTdGFydCwgc3RhdGUucG9zaXRpb24pKSkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ25vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudCcpO1xuICB9XG5cbiAgc3RhdGUuZG9jdW1lbnRzLnB1c2goc3RhdGUucmVzdWx0KTtcblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgaWYgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDJFXG4gICAgLyogLiAqL1xuICAgICkge1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGggLSAxKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2VuZCBvZiB0aGUgc3RyZWFtIG9yIGEgZG9jdW1lbnQgc2VwYXJhdG9yIGlzIGV4cGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5wdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgLy8gQWRkIHRhaWxpbmcgYFxcbmAgaWYgbm90IGV4aXN0c1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBBXG4gICAgLyogTEYgKi9cbiAgICAmJiBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBEXG4gICAgLyogQ1IgKi9cbiAgICApIHtcbiAgICAgICAgaW5wdXQgKz0gJ1xcbic7XG4gICAgICB9IC8vIFN0cmlwIEJPTVxuXG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShpbnB1dCwgb3B0aW9ucyk7XG4gIHZhciBudWxscG9zID0gaW5wdXQuaW5kZXhPZignXFwwJyk7XG5cbiAgaWYgKG51bGxwb3MgIT09IC0xKSB7XG4gICAgc3RhdGUucG9zaXRpb24gPSBudWxscG9zO1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdudWxsIGJ5dGUgaXMgbm90IGFsbG93ZWQgaW4gaW5wdXQnKTtcbiAgfSAvLyBVc2UgMCBhcyBzdHJpbmcgdGVybWluYXRvci4gVGhhdCBzaWduaWZpY2FudGx5IHNpbXBsaWZpZXMgYm91bmRzIGNoZWNrLlxuXG5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDIwXG4gIC8qIFNwYWNlICovXG4gICkge1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgKz0gMTtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBvc2l0aW9uIDwgc3RhdGUubGVuZ3RoIC0gMSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5mdW5jdGlvbiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgb3B0aW9ucykge1xuICBpZiAoaXRlcmF0b3IgIT09IG51bGwgJiYgdHlwZW9mIGl0ZXJhdG9yID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zID0gaXRlcmF0b3I7XG4gICAgaXRlcmF0b3IgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmICh0eXBlb2YgaXRlcmF0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzO1xuICB9XG5cbiAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBkb2N1bWVudHMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIGl0ZXJhdG9yKGRvY3VtZW50c1tpbmRleF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvYWQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cblxuICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5mdW5jdGlvbiBzYWZlTG9hZEFsbChpbnB1dCwgaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvciA9PT0gJ29iamVjdCcgJiYgaXRlcmF0b3IgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGl0ZXJhdG9yO1xuICAgIGl0ZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBsb2FkQWxsKGlucHV0LCBpdGVyYXRvciwgY29tbW9uLmV4dGVuZCh7XG4gICAgc2NoZW1hOiBkZWZhdWx0X3NhZmVcbiAgfSwgb3B0aW9ucykpO1xufVxuXG5mdW5jdGlvbiBzYWZlTG9hZChpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbG9hZChpbnB1dCwgY29tbW9uLmV4dGVuZCh7XG4gICAgc2NoZW1hOiBkZWZhdWx0X3NhZmVcbiAgfSwgb3B0aW9ucykpO1xufVxuXG52YXIgbG9hZEFsbF8xID0gbG9hZEFsbDtcbnZhciBsb2FkXzEgPSBsb2FkO1xudmFyIHNhZmVMb2FkQWxsXzEgPSBzYWZlTG9hZEFsbDtcbnZhciBzYWZlTG9hZF8xID0gc2FmZUxvYWQ7XG52YXIgbG9hZGVyID0ge1xuICBsb2FkQWxsOiBsb2FkQWxsXzEsXG4gIGxvYWQ6IGxvYWRfMSxcbiAgc2FmZUxvYWRBbGw6IHNhZmVMb2FkQWxsXzEsXG4gIHNhZmVMb2FkOiBzYWZlTG9hZF8xXG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lKi9cblxuXG52YXIgX3RvU3RyaW5nJDIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSQzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBDSEFSX1RBQiA9IDB4MDk7XG4vKiBUYWIgKi9cblxudmFyIENIQVJfTElORV9GRUVEID0gMHgwQTtcbi8qIExGICovXG5cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiA9IDB4MEQ7XG4vKiBDUiAqL1xuXG52YXIgQ0hBUl9TUEFDRSA9IDB4MjA7XG4vKiBTcGFjZSAqL1xuXG52YXIgQ0hBUl9FWENMQU1BVElPTiA9IDB4MjE7XG4vKiAhICovXG5cbnZhciBDSEFSX0RPVUJMRV9RVU9URSA9IDB4MjI7XG4vKiBcIiAqL1xuXG52YXIgQ0hBUl9TSEFSUCA9IDB4MjM7XG4vKiAjICovXG5cbnZhciBDSEFSX1BFUkNFTlQgPSAweDI1O1xuLyogJSAqL1xuXG52YXIgQ0hBUl9BTVBFUlNBTkQgPSAweDI2O1xuLyogJiAqL1xuXG52YXIgQ0hBUl9TSU5HTEVfUVVPVEUgPSAweDI3O1xuLyogJyAqL1xuXG52YXIgQ0hBUl9BU1RFUklTSyA9IDB4MkE7XG4vKiAqICovXG5cbnZhciBDSEFSX0NPTU1BID0gMHgyQztcbi8qICwgKi9cblxudmFyIENIQVJfTUlOVVMgPSAweDJEO1xuLyogLSAqL1xuXG52YXIgQ0hBUl9DT0xPTiA9IDB4M0E7XG4vKiA6ICovXG5cbnZhciBDSEFSX0VRVUFMUyA9IDB4M0Q7XG4vKiA9ICovXG5cbnZhciBDSEFSX0dSRUFURVJfVEhBTiA9IDB4M0U7XG4vKiA+ICovXG5cbnZhciBDSEFSX1FVRVNUSU9OID0gMHgzRjtcbi8qID8gKi9cblxudmFyIENIQVJfQ09NTUVSQ0lBTF9BVCA9IDB4NDA7XG4vKiBAICovXG5cbnZhciBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgPSAweDVCO1xuLyogWyAqL1xuXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7XG4vKiBdICovXG5cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCA9IDB4NjA7XG4vKiBgICovXG5cbnZhciBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCA9IDB4N0I7XG4vKiB7ICovXG5cbnZhciBDSEFSX1ZFUlRJQ0FMX0xJTkUgPSAweDdDO1xuLyogfCAqL1xuXG52YXIgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUID0gMHg3RDtcbi8qIH0gKi9cblxudmFyIEVTQ0FQRV9TRVFVRU5DRVMgPSB7fTtcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSA9ICdcXFxcYSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDhdID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSA9ICdcXFxcbic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEJdID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSA9ICdcXFxccic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MUJdID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gPSAnXFxcXFxcXFwnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDg1XSA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xudmFyIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYID0gWyd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLCAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ107XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZU1hcChzY2hlbWEsIG1hcCkge1xuICB2YXIgcmVzdWx0LCBrZXlzLCBpbmRleCwgbGVuZ3RoLCB0YWcsIHN0eWxlLCB0eXBlO1xuICBpZiAobWFwID09PSBudWxsKSByZXR1cm4ge307XG4gIHJlc3VsdCA9IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdGFnID0ga2V5c1tpbmRleF07XG4gICAgc3R5bGUgPSBTdHJpbmcobWFwW3RhZ10pO1xuXG4gICAgaWYgKHRhZy5zbGljZSgwLCAyKSA9PT0gJyEhJykge1xuICAgICAgdGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWcuc2xpY2UoMik7XG4gICAgfVxuXG4gICAgdHlwZSA9IHNjaGVtYS5jb21waWxlZFR5cGVNYXBbJ2ZhbGxiYWNrJ11bdGFnXTtcblxuICAgIGlmICh0eXBlICYmIF9oYXNPd25Qcm9wZXJ0eSQzLmNhbGwodHlwZS5zdHlsZUFsaWFzZXMsIHN0eWxlKSkge1xuICAgICAgc3R5bGUgPSB0eXBlLnN0eWxlQWxpYXNlc1tzdHlsZV07XG4gICAgfVxuXG4gICAgcmVzdWx0W3RhZ10gPSBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhleChjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0cmluZywgaGFuZGxlLCBsZW5ndGg7XG4gIHN0cmluZyA9IGNoYXJhY3Rlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuICBpZiAoY2hhcmFjdGVyIDw9IDB4RkYpIHtcbiAgICBoYW5kbGUgPSAneCc7XG4gICAgbGVuZ3RoID0gMjtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGKSB7XG4gICAgaGFuZGxlID0gJ3UnO1xuICAgIGxlbmd0aCA9IDQ7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRkZGRkYpIHtcbiAgICBoYW5kbGUgPSAnVSc7XG4gICAgbGVuZ3RoID0gODtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBTdGF0ZSQxKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBkZWZhdWx0X2Z1bGw7XG4gIHRoaXMuaW5kZW50ID0gTWF0aC5tYXgoMSwgb3B0aW9uc1snaW5kZW50J10gfHwgMik7XG4gIHRoaXMubm9BcnJheUluZGVudCA9IG9wdGlvbnNbJ25vQXJyYXlJbmRlbnQnXSB8fCBmYWxzZTtcbiAgdGhpcy5za2lwSW52YWxpZCA9IG9wdGlvbnNbJ3NraXBJbnZhbGlkJ10gfHwgZmFsc2U7XG4gIHRoaXMuZmxvd0xldmVsID0gY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddO1xuICB0aGlzLnN0eWxlTWFwID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyA9IG9wdGlvbnNbJ3NvcnRLZXlzJ10gfHwgZmFsc2U7XG4gIHRoaXMubGluZVdpZHRoID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzID0gb3B0aW9uc1snbm9SZWZzJ10gfHwgZmFsc2U7XG4gIHRoaXMubm9Db21wYXRNb2RlID0gb3B0aW9uc1snbm9Db21wYXRNb2RlJ10gfHwgZmFsc2U7XG4gIHRoaXMuY29uZGVuc2VGbG93ID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG4gIHRoaXMuaW1wbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkSW1wbGljaXQ7XG4gIHRoaXMuZXhwbGljaXRUeXBlcyA9IHRoaXMuc2NoZW1hLmNvbXBpbGVkRXhwbGljaXQ7XG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcbiAgdGhpcy5kdXBsaWNhdGVzID0gW107XG4gIHRoaXMudXNlZER1cGxpY2F0ZXMgPSBudWxsO1xufSAvLyBJbmRlbnRzIGV2ZXJ5IGxpbmUgaW4gYSBzdHJpbmcuIEVtcHR5IGxpbmVzIChcXG4gb25seSkgYXJlIG5vdCBpbmRlbnRlZC5cblxuXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RyaW5nLCBzcGFjZXMpIHtcbiAgdmFyIGluZCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBzcGFjZXMpLFxuICAgICAgcG9zaXRpb24gPSAwLFxuICAgICAgbmV4dCA9IC0xLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBsaW5lLFxuICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAocG9zaXRpb24gPCBsZW5ndGgpIHtcbiAgICBuZXh0ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIHBvc2l0aW9uKTtcblxuICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbiwgbmV4dCArIDEpO1xuICAgICAgcG9zaXRpb24gPSBuZXh0ICsgMTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5sZW5ndGggJiYgbGluZSAhPT0gJ1xcbicpIHJlc3VsdCArPSBpbmQ7XG4gICAgcmVzdWx0ICs9IGxpbmU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCkge1xuICByZXR1cm4gJ1xcbicgKyBjb21tb24ucmVwZWF0KCcgJywgc3RhdGUuaW5kZW50ICogbGV2ZWwpO1xufVxuXG5mdW5jdGlvbiB0ZXN0SW1wbGljaXRSZXNvbHZpbmcoc3RhdGUsIHN0cikge1xuICB2YXIgaW5kZXgsIGxlbmd0aCwgdHlwZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbaW5kZXhdO1xuXG4gICAgaWYgKHR5cGUucmVzb2x2ZShzdHIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFszM10gcy13aGl0ZSA6Oj0gcy1zcGFjZSB8IHMtdGFiXG5cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGMgPT09IENIQVJfU1BBQ0UgfHwgYyA9PT0gQ0hBUl9UQUI7XG59IC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNhbiBiZSBwcmludGVkIHdpdGhvdXQgZXNjYXBpbmcuXG4vLyBGcm9tIFlBTUwgMS4yOiBcImFueSBhbGxvd2VkIGNoYXJhY3RlcnMga25vd24gdG8gYmUgbm9uLXByaW50YWJsZVxuLy8gc2hvdWxkIGFsc28gYmUgZXNjYXBlZC4gW0hvd2V2ZXIsXSBUaGlzIGlzbuKAmXQgbWFuZGF0b3J5XCJcbi8vIERlcml2ZWQgZnJvbSBuYi1jaGFyIC0gXFx0IC0gI3g4NSAtICN4QTAgLSAjeDIwMjggLSAjeDIwMjkuXG5cblxuZnVuY3Rpb24gaXNQcmludGFibGUoYykge1xuICByZXR1cm4gMHgwMDAyMCA8PSBjICYmIGMgPD0gMHgwMDAwN0UgfHwgMHgwMDBBMSA8PSBjICYmIGMgPD0gMHgwMEQ3RkYgJiYgYyAhPT0gMHgyMDI4ICYmIGMgIT09IDB4MjAyOSB8fCAweDBFMDAwIDw9IGMgJiYgYyA8PSAweDAwRkZGRCAmJiBjICE9PSAweEZFRkZcbiAgLyogQk9NICovXG4gIHx8IDB4MTAwMDAgPD0gYyAmJiBjIDw9IDB4MTBGRkZGO1xufSAvLyBbMzRdIG5zLWNoYXIgOjo9IG5iLWNoYXIgLSBzLXdoaXRlXG4vLyBbMjddIG5iLWNoYXIgOjo9IGMtcHJpbnRhYmxlIC0gYi1jaGFyIC0gYy1ieXRlLW9yZGVyLW1hcmtcbi8vIFsyNl0gYi1jaGFyICA6Oj0gYi1saW5lLWZlZWQgfCBiLWNhcnJpYWdlLXJldHVyblxuLy8gWzI0XSBiLWxpbmUtZmVlZCAgICAgICA6Oj0gICAgICN4QSAgICAvKiBMRiAqL1xuLy8gWzI1XSBiLWNhcnJpYWdlLXJldHVybiA6Oj0gICAgICN4RCAgICAvKiBDUiAqL1xuLy8gWzNdICBjLWJ5dGUtb3JkZXItbWFyayA6Oj0gICAgICN4RkVGRlxuXG5cbmZ1bmN0aW9uIGlzTnNDaGFyKGMpIHtcbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmICFpc1doaXRlc3BhY2UoYykgLy8gYnl0ZS1vcmRlci1tYXJrXG4gICYmIGMgIT09IDB4RkVGRiAvLyBiLWNoYXJcbiAgJiYgYyAhPT0gQ0hBUl9DQVJSSUFHRV9SRVRVUk4gJiYgYyAhPT0gQ0hBUl9MSU5FX0ZFRUQ7XG59IC8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYWZ0ZXIgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cblxuXG5mdW5jdGlvbiBpc1BsYWluU2FmZShjLCBwcmV2KSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbmItY2hhciAtIGMtZmxvdy1pbmRpY2F0b3IgLSBcIjpcIiAtIFwiI1wiXG4gIC8vIHdoZXJlIG5iLWNoYXIgOjo9IGMtcHJpbnRhYmxlIC0gYi1jaGFyIC0gYy1ieXRlLW9yZGVyLW1hcmsuXG4gIHJldHVybiBpc1ByaW50YWJsZShjKSAmJiBjICE9PSAweEZFRkYgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICYmIGMgIT09IENIQVJfQ09NTUEgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUIC8vIC0gXCI6XCIgLSBcIiNcIlxuICAvLyAvKiBBbiBucy1jaGFyIHByZWNlZGluZyAqLyBcIiNcIlxuICAmJiBjICE9PSBDSEFSX0NPTE9OICYmIChjICE9PSBDSEFSX1NIQVJQIHx8IHByZXYgJiYgaXNOc0NoYXIocHJldikpO1xufSAvLyBTaW1wbGlmaWVkIHRlc3QgZm9yIHZhbHVlcyBhbGxvd2VkIGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5cblxuZnVuY3Rpb24gaXNQbGFpblNhZmVGaXJzdChjKSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbnMtY2hhciAtIGMtaW5kaWNhdG9yXG4gIC8vIHdoZXJlIG5zLWNoYXIgPSBuYi1jaGFyIC0gcy13aGl0ZS5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRiAmJiAhaXNXaGl0ZXNwYWNlKGMpIC8vIC0gcy13aGl0ZVxuICAvLyAtIChjLWluZGljYXRvciA6Oj1cbiAgLy8g4oCcLeKAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLOKAnSB8IOKAnFvigJ0gfCDigJxd4oCdIHwg4oCce+KAnSB8IOKAnH3igJ1cbiAgJiYgYyAhPT0gQ0hBUl9NSU5VUyAmJiBjICE9PSBDSEFSX1FVRVNUSU9OICYmIGMgIT09IENIQVJfQ09MT04gJiYgYyAhPT0gQ0hBUl9DT01NQSAmJiBjICE9PSBDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVCAmJiBjICE9PSBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgLy8gfCDigJwj4oCdIHwg4oCcJuKAnSB8IOKAnCrigJ0gfCDigJwh4oCdIHwg4oCcfOKAnSB8IOKAnD3igJ0gfCDigJw+4oCdIHwg4oCcJ+KAnSB8IOKAnFwi4oCdXG4gICYmIGMgIT09IENIQVJfU0hBUlAgJiYgYyAhPT0gQ0hBUl9BTVBFUlNBTkQgJiYgYyAhPT0gQ0hBUl9BU1RFUklTSyAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OICYmIGMgIT09IENIQVJfVkVSVElDQUxfTElORSAmJiBjICE9PSBDSEFSX0VRVUFMUyAmJiBjICE9PSBDSEFSX0dSRUFURVJfVEhBTiAmJiBjICE9PSBDSEFSX1NJTkdMRV9RVU9URSAmJiBjICE9PSBDSEFSX0RPVUJMRV9RVU9URSAvLyB8IOKAnCXigJ0gfCDigJxA4oCdIHwg4oCcYOKAnSlcbiAgJiYgYyAhPT0gQ0hBUl9QRVJDRU5UICYmIGMgIT09IENIQVJfQ09NTUVSQ0lBTF9BVCAmJiBjICE9PSBDSEFSX0dSQVZFX0FDQ0VOVDtcbn0gLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBpcyByZXF1aXJlZC5cblxuXG5mdW5jdGlvbiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykge1xuICB2YXIgbGVhZGluZ1NwYWNlUmUgPSAvXlxcbiogLztcbiAgcmV0dXJuIGxlYWRpbmdTcGFjZVJlLnRlc3Qoc3RyaW5nKTtcbn1cblxudmFyIFNUWUxFX1BMQUlOID0gMSxcbiAgICBTVFlMRV9TSU5HTEUgPSAyLFxuICAgIFNUWUxFX0xJVEVSQUwgPSAzLFxuICAgIFNUWUxFX0ZPTERFRCA9IDQsXG4gICAgU1RZTEVfRE9VQkxFID0gNTsgLy8gRGV0ZXJtaW5lcyB3aGljaCBzY2FsYXIgc3R5bGVzIGFyZSBwb3NzaWJsZSBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIHN0eWxlLlxuLy8gbGluZVdpZHRoID0gLTEgPT4gbm8gbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyLmxlbmd0aCA+IDAuXG4vLyBQb3N0LWNvbmRpdGlvbnM6XG4vLyAgICBTVFlMRV9QTEFJTiBvciBTVFlMRV9TSU5HTEUgPT4gbm8gXFxuIGFyZSBpbiB0aGUgc3RyaW5nLlxuLy8gICAgU1RZTEVfTElURVJBTCA9PiBubyBsaW5lcyBhcmUgc3VpdGFibGUgZm9yIGZvbGRpbmcgKG9yIGxpbmVXaWR0aCBpcyAtMSkuXG4vLyAgICBTVFlMRV9GT0xERUQgPT4gYSBsaW5lID4gbGluZVdpZHRoIGFuZCBjYW4gYmUgZm9sZGVkIChhbmQgbGluZVdpZHRoICE9IC0xKS5cblxuZnVuY3Rpb24gY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgaW5kZW50UGVyTGV2ZWwsIGxpbmVXaWR0aCwgdGVzdEFtYmlndW91c1R5cGUpIHtcbiAgdmFyIGk7XG4gIHZhciBjaGFyLCBwcmV2X2NoYXI7XG4gIHZhciBoYXNMaW5lQnJlYWsgPSBmYWxzZTtcbiAgdmFyIGhhc0ZvbGRhYmxlTGluZSA9IGZhbHNlOyAvLyBvbmx5IGNoZWNrZWQgaWYgc2hvdWxkVHJhY2tXaWR0aFxuXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuXG4gIHZhciBwbGFpbiA9IGlzUGxhaW5TYWZlRmlyc3Qoc3RyaW5nLmNoYXJDb2RlQXQoMCkpICYmICFpc1doaXRlc3BhY2Uoc3RyaW5nLmNoYXJDb2RlQXQoc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuXG4gICAgICBwcmV2X2NoYXIgPSBpID4gMCA/IHN0cmluZy5jaGFyQ29kZUF0KGkgLSAxKSA6IG51bGw7XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZfY2hhcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENhc2U6IGJsb2NrIHN0eWxlcyBwZXJtaXR0ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoY2hhciA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgICAgaGFzTGluZUJyZWFrID0gdHJ1ZTsgLy8gQ2hlY2sgaWYgYW55IGxpbmUgY2FuIGJlIGZvbGRlZC5cblxuICAgICAgICBpZiAoc2hvdWxkVHJhY2tXaWR0aCkge1xuICAgICAgICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fCAvLyBGb2xkYWJsZSBsaW5lID0gdG9vIGxvbmcsIGFuZCBub3QgbW9yZS1pbmRlbnRlZC5cbiAgICAgICAgICBpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICc7XG4gICAgICAgICAgcHJldmlvdXNMaW5lQnJlYWsgPSBpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuXG4gICAgICBwcmV2X2NoYXIgPSBpID4gMCA/IHN0cmluZy5jaGFyQ29kZUF0KGkgLSAxKSA6IG51bGw7XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZfY2hhcik7XG4gICAgfSAvLyBpbiBjYXNlIHRoZSBlbmQgaXMgbWlzc2luZyBhIFxcblxuXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgc2hvdWxkVHJhY2tXaWR0aCAmJiBpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICc7XG4gIH0gLy8gQWx0aG91Z2ggZXZlcnkgc3R5bGUgY2FuIHJlcHJlc2VudCBcXG4gd2l0aG91dCBlc2NhcGluZywgcHJlZmVyIGJsb2NrIHN0eWxlc1xuICAvLyBmb3IgbXVsdGlsaW5lLCBzaW5jZSB0aGV5J3JlIG1vcmUgcmVhZGFibGUgYW5kIHRoZXkgZG9uJ3QgYWRkIGVtcHR5IGxpbmVzLlxuICAvLyBBbHNvIHByZWZlciBmb2xkaW5nIGEgc3VwZXItbG9uZyBsaW5lLlxuXG5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICByZXR1cm4gcGxhaW4gJiYgIXRlc3RBbWJpZ3VvdXNUeXBlKHN0cmluZykgPyBTVFlMRV9QTEFJTiA6IFNUWUxFX1NJTkdMRTtcbiAgfSAvLyBFZGdlIGNhc2U6IGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBjYW4gb25seSBoYXZlIG9uZSBkaWdpdC5cblxuXG4gIGlmIChpbmRlbnRQZXJMZXZlbCA+IDkgJiYgbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgfSAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYmxvY2sgc3R5bGVzIGFyZSB2YWxpZC5cbiAgLy8gUHJlZmVyIGxpdGVyYWwgc3R5bGUgdW5sZXNzIHdlIHdhbnQgdG8gZm9sZC5cblxuXG4gIHJldHVybiBoYXNGb2xkYWJsZUxpbmUgPyBTVFlMRV9GT0xERUQgOiBTVFlMRV9MSVRFUkFMO1xufSAvLyBOb3RlOiBsaW5lIGJyZWFraW5nL2ZvbGRpbmcgaXMgaW1wbGVtZW50ZWQgZm9yIG9ubHkgdGhlIGZvbGRlZCBzdHlsZS5cbi8vIE5CLiBXZSBkcm9wIHRoZSBsYXN0IHRyYWlsaW5nIG5ld2xpbmUgKGlmIGFueSkgb2YgYSByZXR1cm5lZCBibG9jayBzY2FsYXJcbi8vICBzaW5jZSB0aGUgZHVtcGVyIGFkZHMgaXRzIG93biBuZXdsaW5lLiBUaGlzIGFsd2F5cyB3b3Jrczpcbi8vICAgIOKAoiBObyBlbmRpbmcgbmV3bGluZSA9PiB1bmFmZmVjdGVkOyBhbHJlYWR5IHVzaW5nIHN0cmlwIFwiLVwiIGNob21waW5nLlxuLy8gICAg4oCiIEVuZGluZyBuZXdsaW5lICAgID0+IHJlbW92ZWQgdGhlbiByZXN0b3JlZC5cbi8vICBJbXBvcnRhbnRseSwgdGhpcyBrZWVwcyB0aGUgXCIrXCIgY2hvbXAgaW5kaWNhdG9yIGZyb20gZ2FpbmluZyBhbiBleHRyYSBsaW5lLlxuXG5cbmZ1bmN0aW9uIHdyaXRlU2NhbGFyKHN0YXRlLCBzdHJpbmcsIGxldmVsLCBpc2tleSkge1xuICBzdGF0ZS5kdW1wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gXCInJ1wiO1xuICAgIH1cblxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlICYmIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYLmluZGV4T2Yoc3RyaW5nKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHN0cmluZyArIFwiJ1wiO1xuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQgKiBNYXRoLm1heCgxLCBsZXZlbCk7IC8vIG5vIDAtaW5kZW50IHNjYWxhcnNcbiAgICAvLyBBcyBpbmRlbnRhdGlvbiBnZXRzIGRlZXBlciwgbGV0IHRoZSB3aWR0aCBkZWNyZWFzZSBtb25vdG9uaWNhbGx5XG4gICAgLy8gdG8gdGhlIGxvd2VyIGJvdW5kIG1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbXBsaWVzXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCDiiaQgNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGlzIGZpeGVkIGF0IHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyAgc3RhdGUubGluZVdpZHRoID4gNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGRlY3JlYXNlcyB1bnRpbCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gVGhpcyBiZWhhdmVzIGJldHRlciB0aGFuIGEgY29uc3RhbnQgbWluaW11bSB3aWR0aCB3aGljaCBkaXNhbGxvd3MgbmFycm93ZXIgb3B0aW9ucyxcbiAgICAvLyBvciBhbiBpbmRlbnQgdGhyZXNob2xkIHdoaWNoIGNhdXNlcyB0aGUgd2lkdGggdG8gc3VkZGVubHkgaW5jcmVhc2UuXG5cbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoID09PSAtMSA/IC0xIDogTWF0aC5tYXgoTWF0aC5taW4oc3RhdGUubGluZVdpZHRoLCA0MCksIHN0YXRlLmxpbmVXaWR0aCAtIGluZGVudCk7IC8vIFdpdGhvdXQga25vd2luZyBpZiBrZXlzIGFyZSBpbXBsaWNpdC9leHBsaWNpdCwgYXNzdW1lIGltcGxpY2l0IGZvciBzYWZldHkuXG5cbiAgICB2YXIgc2luZ2xlTGluZU9ubHkgPSBpc2tleSAvLyBObyBibG9jayBzdHlsZXMgaW4gZmxvdyBtb2RlLlxuICAgIHx8IHN0YXRlLmZsb3dMZXZlbCA+IC0xICYmIGxldmVsID49IHN0YXRlLmZsb3dMZXZlbDtcblxuICAgIGZ1bmN0aW9uIHRlc3RBbWJpZ3VpdHkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHJpbmcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgc3RhdGUuaW5kZW50LCBsaW5lV2lkdGgsIHRlc3RBbWJpZ3VpdHkpKSB7XG4gICAgICBjYXNlIFNUWUxFX1BMQUlOOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuXG4gICAgICBjYXNlIFNUWUxFX1NJTkdMRTpcbiAgICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyaW5nLnJlcGxhY2UoLycvZywgXCInJ1wiKSArIFwiJ1wiO1xuXG4gICAgICBjYXNlIFNUWUxFX0xJVEVSQUw6XG4gICAgICAgIHJldHVybiAnfCcgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudCkgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoc3RyaW5nLCBpbmRlbnQpKTtcblxuICAgICAgY2FzZSBTVFlMRV9GT0xERUQ6XG4gICAgICAgIHJldHVybiAnPicgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudCkgKyBkcm9wRW5kaW5nTmV3bGluZShpbmRlbnRTdHJpbmcoZm9sZFN0cmluZyhzdHJpbmcsIGxpbmVXaWR0aCksIGluZGVudCkpO1xuXG4gICAgICBjYXNlIFNUWUxFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVTdHJpbmcoc3RyaW5nKSArICdcIic7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb24oJ2ltcG9zc2libGUgZXJyb3I6IGludmFsaWQgc2NhbGFyIHN0eWxlJyk7XG4gICAgfVxuICB9KCk7XG59IC8vIFByZS1jb25kaXRpb25zOiBzdHJpbmcgaXMgdmFsaWQgZm9yIGEgYmxvY2sgc2NhbGFyLCAxIDw9IGluZGVudFBlckxldmVsIDw9IDkuXG5cblxuZnVuY3Rpb24gYmxvY2tIZWFkZXIoc3RyaW5nLCBpbmRlbnRQZXJMZXZlbCkge1xuICB2YXIgaW5kZW50SW5kaWNhdG9yID0gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpID8gU3RyaW5nKGluZGVudFBlckxldmVsKSA6ICcnOyAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2U6IHRoZSBzdHJpbmcgJ1xcbicgY291bnRzIGFzIGEgXCJ0cmFpbGluZ1wiIGVtcHR5IGxpbmUuXG5cbiAgdmFyIGNsaXAgPSBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJztcbiAgdmFyIGtlZXAgPSBjbGlwICYmIChzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDJdID09PSAnXFxuJyB8fCBzdHJpbmcgPT09ICdcXG4nKTtcbiAgdmFyIGNob21wID0ga2VlcCA/ICcrJyA6IGNsaXAgPyAnJyA6ICctJztcbiAgcmV0dXJuIGluZGVudEluZGljYXRvciArIGNob21wICsgJ1xcbic7XG59IC8vIChTZWUgdGhlIG5vdGUgZm9yIHdyaXRlU2NhbGFyLilcblxuXG5mdW5jdGlvbiBkcm9wRW5kaW5nTmV3bGluZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nID8gc3RyaW5nLnNsaWNlKDAsIC0xKSA6IHN0cmluZztcbn0gLy8gTm90ZTogYSBsb25nIGxpbmUgd2l0aG91dCBhIHN1aXRhYmxlIGJyZWFrIHBvaW50IHdpbGwgZXhjZWVkIHRoZSB3aWR0aCBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBldmVyeSBjaGFyIGluIHN0ciBpc1ByaW50YWJsZSwgc3RyLmxlbmd0aCA+IDAsIHdpZHRoID4gMC5cblxuXG5mdW5jdGlvbiBmb2xkU3RyaW5nKHN0cmluZywgd2lkdGgpIHtcbiAgLy8gSW4gZm9sZGVkIHN0eWxlLCAkayQgY29uc2VjdXRpdmUgbmV3bGluZXMgb3V0cHV0IGFzICRrKzEkIG5ld2xpbmVz4oCUXG4gIC8vIHVubGVzcyB0aGV5J3JlIGJlZm9yZSBvciBhZnRlciBhIG1vcmUtaW5kZW50ZWQgbGluZSwgb3IgYXQgdGhlIHZlcnlcbiAgLy8gYmVnaW5uaW5nIG9yIGVuZCwgaW4gd2hpY2ggY2FzZSAkayQgbWFwcyB0byAkayQuXG4gIC8vIFRoZXJlZm9yZSwgcGFyc2UgZWFjaCBjaHVuayBhcyBuZXdsaW5lKHMpIGZvbGxvd2VkIGJ5IGEgY29udGVudCBsaW5lLlxuICB2YXIgbGluZVJlID0gLyhcXG4rKShbXlxcbl0qKS9nOyAvLyBmaXJzdCBsaW5lIChwb3NzaWJseSBhbiBlbXB0eSBsaW5lKVxuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRMRiA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcbiAgICBuZXh0TEYgPSBuZXh0TEYgIT09IC0xID8gbmV4dExGIDogc3RyaW5nLmxlbmd0aDtcbiAgICBsaW5lUmUubGFzdEluZGV4ID0gbmV4dExGO1xuICAgIHJldHVybiBmb2xkTGluZShzdHJpbmcuc2xpY2UoMCwgbmV4dExGKSwgd2lkdGgpO1xuICB9KCk7IC8vIElmIHdlIGhhdmVuJ3QgcmVhY2hlZCB0aGUgZmlyc3QgY29udGVudCBsaW5lIHlldCwgZG9uJ3QgYWRkIGFuIGV4dHJhIFxcbi5cblxuXG4gIHZhciBwcmV2TW9yZUluZGVudGVkID0gc3RyaW5nWzBdID09PSAnXFxuJyB8fCBzdHJpbmdbMF0gPT09ICcgJztcbiAgdmFyIG1vcmVJbmRlbnRlZDsgLy8gcmVzdCBvZiB0aGUgbGluZXNcblxuICB2YXIgbWF0Y2g7XG5cbiAgd2hpbGUgKG1hdGNoID0gbGluZVJlLmV4ZWMoc3RyaW5nKSkge1xuICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXSxcbiAgICAgICAgbGluZSA9IG1hdGNoWzJdO1xuICAgIG1vcmVJbmRlbnRlZCA9IGxpbmVbMF0gPT09ICcgJztcbiAgICByZXN1bHQgKz0gcHJlZml4ICsgKCFwcmV2TW9yZUluZGVudGVkICYmICFtb3JlSW5kZW50ZWQgJiYgbGluZSAhPT0gJycgPyAnXFxuJyA6ICcnKSArIGZvbGRMaW5lKGxpbmUsIHdpZHRoKTtcbiAgICBwcmV2TW9yZUluZGVudGVkID0gbW9yZUluZGVudGVkO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0gLy8gR3JlZWR5IGxpbmUgYnJlYWtpbmcuXG4vLyBQaWNrcyB0aGUgbG9uZ2VzdCBsaW5lIHVuZGVyIHRoZSBsaW1pdCBlYWNoIHRpbWUsXG4vLyBvdGhlcndpc2Ugc2V0dGxlcyBmb3IgdGhlIHNob3J0ZXN0IGxpbmUgb3ZlciB0aGUgbGltaXQuXG4vLyBOQi4gTW9yZS1pbmRlbnRlZCBsaW5lcyAqY2Fubm90KiBiZSBmb2xkZWQsIGFzIHRoYXQgd291bGQgYWRkIGFuIGV4dHJhIFxcbi5cblxuXG5mdW5jdGlvbiBmb2xkTGluZShsaW5lLCB3aWR0aCkge1xuICBpZiAobGluZSA9PT0gJycgfHwgbGluZVswXSA9PT0gJyAnKSByZXR1cm4gbGluZTsgLy8gU2luY2UgYSBtb3JlLWluZGVudGVkIGxpbmUgYWRkcyBhIFxcbiwgYnJlYWtzIGNhbid0IGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2UuXG5cbiAgdmFyIGJyZWFrUmUgPSAvIFteIF0vZzsgLy8gbm90ZTogdGhlIG1hdGNoIGluZGV4IHdpbGwgYWx3YXlzIGJlIDw9IGxlbmd0aC0yLlxuXG4gIHZhciBtYXRjaDsgLy8gc3RhcnQgaXMgYW4gaW5jbHVzaXZlIGluZGV4LiBlbmQsIGN1cnIsIGFuZCBuZXh0IGFyZSBleGNsdXNpdmUuXG5cbiAgdmFyIHN0YXJ0ID0gMCxcbiAgICAgIGVuZCxcbiAgICAgIGN1cnIgPSAwLFxuICAgICAgbmV4dCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJzsgLy8gSW52YXJpYW50czogMCA8PSBzdGFydCA8PSBsZW5ndGgtMS5cbiAgLy8gICAwIDw9IGN1cnIgPD0gbmV4dCA8PSBtYXgoMCwgbGVuZ3RoLTIpLiBjdXJyIC0gc3RhcnQgPD0gd2lkdGguXG4gIC8vIEluc2lkZSB0aGUgbG9vcDpcbiAgLy8gICBBIG1hdGNoIGltcGxpZXMgbGVuZ3RoID49IDIsIHNvIGN1cnIgYW5kIG5leHQgYXJlIDw9IGxlbmd0aC0yLlxuXG4gIHdoaWxlIChtYXRjaCA9IGJyZWFrUmUuZXhlYyhsaW5lKSkge1xuICAgIG5leHQgPSBtYXRjaC5pbmRleDsgLy8gbWFpbnRhaW4gaW52YXJpYW50OiBjdXJyIC0gc3RhcnQgPD0gd2lkdGhcblxuICAgIGlmIChuZXh0IC0gc3RhcnQgPiB3aWR0aCkge1xuICAgICAgZW5kID0gY3VyciA+IHN0YXJ0ID8gY3VyciA6IG5leHQ7IC8vIGRlcml2ZSBlbmQgPD0gbGVuZ3RoLTJcblxuICAgICAgcmVzdWx0ICs9ICdcXG4nICsgbGluZS5zbGljZShzdGFydCwgZW5kKTsgLy8gc2tpcCB0aGUgc3BhY2UgdGhhdCB3YXMgb3V0cHV0IGFzIFxcblxuXG4gICAgICBzdGFydCA9IGVuZCArIDE7IC8vIGRlcml2ZSBzdGFydCA8PSBsZW5ndGgtMVxuICAgIH1cblxuICAgIGN1cnIgPSBuZXh0O1xuICB9IC8vIEJ5IHRoZSBpbnZhcmlhbnRzLCBzdGFydCA8PSBsZW5ndGgtMSwgc28gdGhlcmUgaXMgc29tZXRoaW5nIGxlZnQgb3Zlci5cbiAgLy8gSXQgaXMgZWl0aGVyIHRoZSB3aG9sZSBzdHJpbmcgb3IgYSBwYXJ0IHN0YXJ0aW5nIGZyb20gbm9uLXdoaXRlc3BhY2UuXG5cblxuICByZXN1bHQgKz0gJ1xcbic7IC8vIEluc2VydCBhIGJyZWFrIGlmIHRoZSByZW1haW5kZXIgaXMgdG9vIGxvbmcgYW5kIHRoZXJlIGlzIGEgYnJlYWsgYXZhaWxhYmxlLlxuXG4gIGlmIChsaW5lLmxlbmd0aCAtIHN0YXJ0ID4gd2lkdGggJiYgY3VyciA+IHN0YXJ0KSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQsIGN1cnIpICsgJ1xcbicgKyBsaW5lLnNsaWNlKGN1cnIgKyAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpOyAvLyBkcm9wIGV4dHJhIFxcbiBqb2luZXJcbn0gLy8gRXNjYXBlcyBhIGRvdWJsZS1xdW90ZWQgc3RyaW5nLlxuXG5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY2hhciwgbmV4dENoYXI7XG4gIHZhciBlc2NhcGVTZXE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7IC8vIENoZWNrIGZvciBzdXJyb2dhdGUgcGFpcnMgKHJlZmVyZW5jZSBVbmljb2RlIDMuMCBzZWN0aW9uIFwiMy43IFN1cnJvZ2F0ZXNcIikuXG5cbiAgICBpZiAoY2hhciA+PSAweEQ4MDAgJiYgY2hhciA8PSAweERCRkZcbiAgICAvKiBoaWdoIHN1cnJvZ2F0ZSAqL1xuICAgICkge1xuICAgICAgICBuZXh0Q2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcblxuICAgICAgICBpZiAobmV4dENoYXIgPj0gMHhEQzAwICYmIG5leHRDaGFyIDw9IDB4REZGRlxuICAgICAgICAvKiBsb3cgc3Vycm9nYXRlICovXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gQ29tYmluZSB0aGUgc3Vycm9nYXRlIHBhaXIgYW5kIHN0b3JlIGl0IGVzY2FwZWQuXG4gICAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlSGV4KChjaGFyIC0gMHhEODAwKSAqIDB4NDAwICsgbmV4dENoYXIgLSAweERDMDAgKyAweDEwMDAwKTsgLy8gQWR2YW5jZSBpbmRleCBvbmUgZXh0cmEgc2luY2Ugd2UgYWxyZWFkeSB1c2VkIHRoYXQgY2hhciBoZXJlLlxuXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuICAgIHJlc3VsdCArPSAhZXNjYXBlU2VxICYmIGlzUHJpbnRhYmxlKGNoYXIpID8gc3RyaW5nW2ldIDogZXNjYXBlU2VxIHx8IGVuY29kZUhleChjaGFyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgLy8gV3JpdGUgb25seSB2YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0W2luZGV4XSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgaWYgKGluZGV4ICE9PSAwKSBfcmVzdWx0ICs9ICcsJyArICghc3RhdGUuY29uZGVuc2VGbG93ID8gJyAnIDogJycpO1xuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSAnWycgKyBfcmVzdWx0ICsgJ10nO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0W2luZGV4XSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgIGlmICghY29tcGFjdCB8fCBpbmRleCAhPT0gMCkge1xuICAgICAgICBfcmVzdWx0ICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBfcmVzdWx0ICs9ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0gJztcbiAgICAgIH1cblxuICAgICAgX3Jlc3VsdCArPSBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnRhZyA9IF90YWc7XG4gIHN0YXRlLmR1bXAgPSBfcmVzdWx0IHx8ICdbXSc7IC8vIEVtcHR5IHNlcXVlbmNlIGlmIG5vIHZhbGlkIHZhbHVlcy5cbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93TWFwcGluZyhzdGF0ZSwgbGV2ZWwsIG9iamVjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyA9IHN0YXRlLnRhZyxcbiAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICBvYmplY3RLZXksXG4gICAgICBvYmplY3RWYWx1ZSxcbiAgICAgIHBhaXJCdWZmZXI7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSAnJztcbiAgICBpZiAoaW5kZXggIT09IDApIHBhaXJCdWZmZXIgKz0gJywgJztcbiAgICBpZiAoc3RhdGUuY29uZGVuc2VGbG93KSBwYWlyQnVmZmVyICs9ICdcIic7XG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICdcIicgOiAnJykgKyAnOicgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJycgOiAnICcpO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RWYWx1ZSwgZmFsc2UsIGZhbHNlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7IC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyOyAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuXG4gIGlmIChzdGF0ZS5zb3J0S2V5cyA9PT0gdHJ1ZSkge1xuICAgIC8vIERlZmF1bHQgc29ydGluZ1xuICAgIG9iamVjdEtleUxpc3Quc29ydCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZS5zb3J0S2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KHN0YXRlLnNvcnRLZXlzKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zb3J0S2V5cykge1xuICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZ1xuICAgIHRocm93IG5ldyBleGNlcHRpb24oJ3NvcnRLZXlzIG11c3QgYmUgYSBib29sZWFuIG9yIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyQnVmZmVyID0gJyc7XG5cbiAgICBpZiAoIWNvbXBhY3QgfHwgaW5kZXggIT09IDApIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RLZXksIHRydWUsIHRydWUsIHRydWUpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleS5cbiAgICB9XG5cbiAgICBleHBsaWNpdFBhaXIgPSBzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycgfHwgc3RhdGUuZHVtcCAmJiBzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQ7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFpckJ1ZmZlciArPSAnPyAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIGlmIChleHBsaWNpdFBhaXIpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCArIDEsIG9iamVjdFZhbHVlLCB0cnVlLCBleHBsaWNpdFBhaXIpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIHBhaXJCdWZmZXIgKz0gJzonO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6ICc7XG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wOyAvLyBCb3RoIGtleSBhbmQgdmFsdWUgYXJlIHZhbGlkLlxuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ3t9JzsgLy8gRW1wdHkgbWFwcGluZyBpZiBubyB2YWxpZCBwYWlycy5cbn1cblxuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBleHBsaWNpdCkge1xuICB2YXIgX3Jlc3VsdCwgdHlwZUxpc3QsIGluZGV4LCBsZW5ndGgsIHR5cGUsIHN0eWxlO1xuXG4gIHR5cGVMaXN0ID0gZXhwbGljaXQgPyBzdGF0ZS5leHBsaWNpdFR5cGVzIDogc3RhdGUuaW1wbGljaXRUeXBlcztcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdHlwZUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSB0eXBlTGlzdFtpbmRleF07XG5cbiAgICBpZiAoKHR5cGUuaW5zdGFuY2VPZiB8fCB0eXBlLnByZWRpY2F0ZSkgJiYgKCF0eXBlLmluc3RhbmNlT2YgfHwgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0IGluc3RhbmNlb2YgdHlwZS5pbnN0YW5jZU9mKSAmJiAoIXR5cGUucHJlZGljYXRlIHx8IHR5cGUucHJlZGljYXRlKG9iamVjdCkpKSB7XG4gICAgICBzdGF0ZS50YWcgPSBleHBsaWNpdCA/IHR5cGUudGFnIDogJz8nO1xuXG4gICAgICBpZiAodHlwZS5yZXByZXNlbnQpIHtcbiAgICAgICAgc3R5bGUgPSBzdGF0ZS5zdHlsZU1hcFt0eXBlLnRhZ10gfHwgdHlwZS5kZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgaWYgKF90b1N0cmluZyQyLmNhbGwodHlwZS5yZXByZXNlbnQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50KG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eSQzLmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbignITwnICsgdHlwZS50YWcgKyAnPiB0YWcgcmVzb2x2ZXIgYWNjZXB0cyBub3QgXCInICsgc3R5bGUgKyAnXCIgc3R5bGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmR1bXAgPSBfcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFNlcmlhbGl6ZXMgYG9iamVjdGAgYW5kIHdyaXRlcyBpdCB0byBnbG9iYWwgYHJlc3VsdGAuXG4vLyBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcywgb3IgZmFsc2Ugb24gaW52YWxpZCBvYmplY3QuXG4vL1xuXG5cbmZ1bmN0aW9uIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgYmxvY2ssIGNvbXBhY3QsIGlza2V5KSB7XG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmR1bXAgPSBvYmplY3Q7XG5cbiAgaWYgKCFkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGZhbHNlKSkge1xuICAgIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgdHJ1ZSk7XG4gIH1cblxuICB2YXIgdHlwZSA9IF90b1N0cmluZyQyLmNhbGwoc3RhdGUuZHVtcCk7XG5cbiAgaWYgKGJsb2NrKSB7XG4gICAgYmxvY2sgPSBzdGF0ZS5mbG93TGV2ZWwgPCAwIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsO1xuICB9XG5cbiAgdmFyIG9iamVjdE9yQXJyYXkgPSB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgZHVwbGljYXRlSW5kZXgsXG4gICAgICBkdXBsaWNhdGU7XG5cbiAgaWYgKG9iamVjdE9yQXJyYXkpIHtcbiAgICBkdXBsaWNhdGVJbmRleCA9IHN0YXRlLmR1cGxpY2F0ZXMuaW5kZXhPZihvYmplY3QpO1xuICAgIGR1cGxpY2F0ZSA9IGR1cGxpY2F0ZUluZGV4ICE9PSAtMTtcbiAgfVxuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycgfHwgZHVwbGljYXRlIHx8IHN0YXRlLmluZGVudCAhPT0gMiAmJiBsZXZlbCA+IDApIHtcbiAgICBjb21wYWN0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoZHVwbGljYXRlICYmIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgIHN0YXRlLmR1bXAgPSAnKnJlZl8nICsgZHVwbGljYXRlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9iamVjdE9yQXJyYXkgJiYgZHVwbGljYXRlICYmICFzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICAgIHN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgT2JqZWN0LmtleXMoc3RhdGUuZHVtcCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCwgY29tcGFjdCk7XG5cbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG5cbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB2YXIgYXJyYXlMZXZlbCA9IHN0YXRlLm5vQXJyYXlJbmRlbnQgJiYgbGV2ZWwgPiAwID8gbGV2ZWwgLSAxIDogbGV2ZWw7XG5cbiAgICAgIGlmIChibG9jayAmJiBzdGF0ZS5kdW1wLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB3cml0ZUJsb2NrU2VxdWVuY2Uoc3RhdGUsIGFycmF5TGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuXG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGFycmF5TGV2ZWwsIHN0YXRlLmR1bXApO1xuXG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uKCd1bmFjY2VwdGFibGUga2luZCBvZiBhbiBvYmplY3QgdG8gZHVtcCAnICsgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgc3RhdGUuZHVtcCA9ICchPCcgKyBzdGF0ZS50YWcgKyAnPiAnICsgc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhvYmplY3QsIHN0YXRlKSB7XG4gIHZhciBvYmplY3RzID0gW10sXG4gICAgICBkdXBsaWNhdGVzSW5kZXhlcyA9IFtdLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGg7XG4gIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkdXBsaWNhdGVzSW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgc3RhdGUuZHVwbGljYXRlcy5wdXNoKG9iamVjdHNbZHVwbGljYXRlc0luZGV4ZXNbaW5kZXhdXSk7XG4gIH1cblxuICBzdGF0ZS51c2VkRHVwbGljYXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKSB7XG4gIHZhciBvYmplY3RLZXlMaXN0LCBpbmRleCwgbGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGR1cGxpY2F0ZXNJbmRleGVzLmluZGV4T2YoaW5kZXgpID09PSAtMSkge1xuICAgICAgICBkdXBsaWNhdGVzSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0cy5wdXNoKG9iamVjdCk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W2luZGV4XSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgaW5zcGVjdE5vZGUob2JqZWN0W29iamVjdEtleUxpc3RbaW5kZXhdXSwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZSQxKG9wdGlvbnMpO1xuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuICBpZiAod3JpdGVOb2RlKHN0YXRlLCAwLCBpbnB1dCwgdHJ1ZSwgdHJ1ZSkpIHJldHVybiBzdGF0ZS5kdW1wICsgJ1xcbic7XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gc2FmZUR1bXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGR1bXAoaW5wdXQsIGNvbW1vbi5leHRlbmQoe1xuICAgIHNjaGVtYTogZGVmYXVsdF9zYWZlXG4gIH0sIG9wdGlvbnMpKTtcbn1cblxudmFyIGR1bXBfMSA9IGR1bXA7XG52YXIgc2FmZUR1bXBfMSA9IHNhZmVEdW1wO1xudmFyIGR1bXBlciA9IHtcbiAgZHVtcDogZHVtcF8xLFxuICBzYWZlRHVtcDogc2FmZUR1bXBfMVxufTtcblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cbnZhciBUeXBlJDEgPSB0eXBlO1xudmFyIFNjaGVtYSQxID0gc2NoZW1hO1xudmFyIEZBSUxTQUZFX1NDSEVNQSA9IGZhaWxzYWZlO1xudmFyIEpTT05fU0NIRU1BID0ganNvbjtcbnZhciBDT1JFX1NDSEVNQSA9IGNvcmU7XG52YXIgREVGQVVMVF9TQUZFX1NDSEVNQSA9IGRlZmF1bHRfc2FmZTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gZGVmYXVsdF9mdWxsO1xudmFyIGxvYWQkMSA9IGxvYWRlci5sb2FkO1xudmFyIGxvYWRBbGwkMSA9IGxvYWRlci5sb2FkQWxsO1xudmFyIHNhZmVMb2FkJDEgPSBsb2FkZXIuc2FmZUxvYWQ7XG52YXIgc2FmZUxvYWRBbGwkMSA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbnZhciBkdW1wJDEgPSBkdW1wZXIuZHVtcDtcbnZhciBzYWZlRHVtcCQxID0gZHVtcGVyLnNhZmVEdW1wO1xudmFyIFlBTUxFeGNlcHRpb24kMSA9IGV4Y2VwdGlvbjsgLy8gRGVwcmVjYXRlZCBzY2hlbWEgbmFtZXMgZnJvbSBKUy1ZQU1MIDIuMC54XG5cbnZhciBNSU5JTUFMX1NDSEVNQSA9IGZhaWxzYWZlO1xudmFyIFNBRkVfU0NIRU1BID0gZGVmYXVsdF9zYWZlO1xudmFyIERFRkFVTFRfU0NIRU1BID0gZGVmYXVsdF9mdWxsOyAvLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54LnhcblxudmFyIHNjYW4gPSBkZXByZWNhdGVkKCdzY2FuJyk7XG52YXIgcGFyc2UgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xudmFyIGNvbXBvc2UgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG52YXIgYWRkQ29uc3RydWN0b3IgPSBkZXByZWNhdGVkKCdhZGRDb25zdHJ1Y3RvcicpO1xudmFyIGpzWWFtbCA9IHtcbiAgVHlwZTogVHlwZSQxLFxuICBTY2hlbWE6IFNjaGVtYSQxLFxuICBGQUlMU0FGRV9TQ0hFTUE6IEZBSUxTQUZFX1NDSEVNQSxcbiAgSlNPTl9TQ0hFTUE6IEpTT05fU0NIRU1BLFxuICBDT1JFX1NDSEVNQTogQ09SRV9TQ0hFTUEsXG4gIERFRkFVTFRfU0FGRV9TQ0hFTUE6IERFRkFVTFRfU0FGRV9TQ0hFTUEsXG4gIERFRkFVTFRfRlVMTF9TQ0hFTUE6IERFRkFVTFRfRlVMTF9TQ0hFTUEsXG4gIGxvYWQ6IGxvYWQkMSxcbiAgbG9hZEFsbDogbG9hZEFsbCQxLFxuICBzYWZlTG9hZDogc2FmZUxvYWQkMSxcbiAgc2FmZUxvYWRBbGw6IHNhZmVMb2FkQWxsJDEsXG4gIGR1bXA6IGR1bXAkMSxcbiAgc2FmZUR1bXA6IHNhZmVEdW1wJDEsXG4gIFlBTUxFeGNlcHRpb246IFlBTUxFeGNlcHRpb24kMSxcbiAgTUlOSU1BTF9TQ0hFTUE6IE1JTklNQUxfU0NIRU1BLFxuICBTQUZFX1NDSEVNQTogU0FGRV9TQ0hFTUEsXG4gIERFRkFVTFRfU0NIRU1BOiBERUZBVUxUX1NDSEVNQSxcbiAgc2Nhbjogc2NhbixcbiAgcGFyc2U6IHBhcnNlLFxuICBjb21wb3NlOiBjb21wb3NlLFxuICBhZGRDb25zdHJ1Y3RvcjogYWRkQ29uc3RydWN0b3Jcbn07XG5cbnZhciBqc1lhbWwkMSA9IGpzWWFtbDtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxuICogUmVkaXJlY3QgLSBvYmplY3QgdXNlZCB0byByZWRpcmVjdCBzb21lIHJlcXVlc3RzXG4gKiBlLmcuXG4gKiB7XG4gKiAgICAgIHRpdGxlOiAxeDEtdHJhbnNwYXJlbnQuZ2lmXG4gKiAgICAgIGNvbW1lbnQ6IGh0dHA6Ly9wcm9iYWJseXByb2dyYW1taW5nLmNvbS8yMDA5LzAzLzE1L3RoZS10aW5pZXN0LWdpZi1ldmVyXG4gKiAgICAgIGNvbnRlbnRUeXBlOiBpbWFnZS9naWY7YmFzZTY0XG4gKiAgICAgIGNvbnRlbnQ6IFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cbiAqIH1cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZGlyZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGl0bGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb21tZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGVudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRlbnRUeXBlXG4gKi9cblxudmFyIFJlZGlyZWN0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyByYXdZYW1sIGludG8gSlMgb2JqZWN0IHdpdGggc291cmNlcyB0aXRsZXMgdXNlZCBhcyBrZXlzXG4gICAqIEBwYXJhbSByYXdZYW1sXG4gICAqIEByZXR1cm5zIHtPYmplY3Q8UmVkaXJlY3Q+fSAtIHJldHVybiBvYmplY3Qgd2l0aCB0aXRsZXMgaW4gdGhlIGtleXMgYW5kIFJlZGlyZWN0U291cmNlc1xuICAgKiBpbiB0aGUgdmFsdWVzXG4gICAqL1xuICBmdW5jdGlvbiBSZWRpcmVjdHMocmF3WWFtbCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZGlyZWN0cyk7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGFyck9mUmVkaXJlY3RzID0ganNZYW1sJDEuc2FmZUxvYWQocmF3WWFtbCk7XG4gICAgICB0aGlzLnJlZGlyZWN0cyA9IGFyck9mUmVkaXJlY3RzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCByZWRpcmVjdCkge1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBhY2MpLCB7fSwgZGVmaW5lUHJvcGVydHkoe30sIHJlZGlyZWN0LnRpdGxlLCByZWRpcmVjdCkpO1xuICAgICAgfSwge30pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhcIldhcyB1bmFibGUgdG8gbG9hZCBZQU1MIGludG8gSlMgZHVlIHRvOiBcIi5jb25jYXQoZS5tZXNzYWdlKSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyByZWRpcmVjdCBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICAgKiBAcmV0dXJuIHtSZWRpcmVjdH1cbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhSZWRpcmVjdHMsIFt7XG4gICAga2V5OiBcImdldFJlZGlyZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZGlyZWN0KHRpdGxlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucmVkaXJlY3RzLCB0aXRsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkaXJlY3RzW3RpdGxlXTtcbiAgICAgIH0gLy8gbG9vayB0aXRsZSBhbW9uZyBhbGlhc2VzXG5cblxuICAgICAgdmFyIHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMucmVkaXJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gX3RoaXMucmVkaXJlY3RzW2tleV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2YWx1ZXMuZmluZChmdW5jdGlvbiAocmVkaXJlY3QpIHtcbiAgICAgICAgdmFyIGFsaWFzZXMgPSByZWRpcmVjdC5hbGlhc2VzO1xuXG4gICAgICAgIGlmICghYWxpYXNlcykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGlhc2VzLmluZGV4T2YodGl0bGUpID4gLTE7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVkaXJlY3RzO1xufSgpO1xuXG4vKipcbiAqIEZpbmRzIHJlZGlyZWN0IHJlc291cmNlIGJ5IGl0J3MgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSByZWRpcmVjdCBuYW1lXG4gKi9cblxudmFyIGdldFJlZGlyZWN0QnlOYW1lID0gZnVuY3Rpb24gZ2V0UmVkaXJlY3RCeU5hbWUobmFtZSkge1xuICB2YXIgcmVkaXJlY3RzID0gT2JqZWN0LmtleXMocmVkaXJlY3RzTGlzdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gcmVkaXJlY3RzTGlzdFtrZXldO1xuICB9KTtcbiAgcmV0dXJuIHJlZGlyZWN0cy5maW5kKGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIHIubmFtZXMgJiYgci5uYW1lcy5pbmRleE9mKG5hbWUpID4gLTE7XG4gIH0pO1xufTtcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU291cmNlIC0gcmVkaXJlY3QgcHJvcGVydGllc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgcmVkaXJlY3QgbmFtZVxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBhcmdzIEFyZ3VtZW50cyBmb3IgcmVkaXJlY3QgZnVuY3Rpb25cbiAqIEBwcm9wZXJ0eSB7J2V4dGVuc2lvbid8J3Rlc3QnfSBbZW5naW5lXSAtXG4gKiBEZWZpbmVzIHRoZSBmaW5hbCBmb3JtIG9mIHJlZGlyZWN0IHN0cmluZyBwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZlcmJvc2VdIGZsYWcgdG8gZW5hYmxlIHByaW50aW5nIHRvIGNvbnNvbGUgZGVidWcgaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgcmVkaXJlY3QgY29kZSBieSBwYXJhbVxuICogQHBhcmFtIHtTb3VyY2V9IHNvdXJjZVxuICogQHJldHVybnMge3N0cmluZ30gcmVkaXJlY3QgY29kZVxuICovXG5cblxudmFyIGdldFJlZGlyZWN0Q29kZSA9IGZ1bmN0aW9uIGdldFJlZGlyZWN0Q29kZShzb3VyY2UpIHtcbiAgdmFyIHJlZGlyZWN0ID0gZ2V0UmVkaXJlY3RCeU5hbWUoc291cmNlLm5hbWUpO1xuICB2YXIgcmVzdWx0ID0gYXR0YWNoRGVwZW5kZW5jaWVzKHJlZGlyZWN0KTtcbiAgcmVzdWx0ID0gYWRkQ2FsbChyZWRpcmVjdCwgcmVzdWx0KTsgLy8gcmVkaXJlY3QgY29kZSBmb3IgZGlmZmVyZW50IHNvdXJjZXMgaXMgY2hlY2tlZCBpbiB0ZXN0c1xuICAvLyBzbyBpdCBzaG91bGQgYmUganVzdCBhIGNvZGUgd2l0aG91dCBhbnkgc291cmNlIGFuZCBwcm9wcyBwYXNzZWRcblxuICByZXN1bHQgPSBzb3VyY2UuZW5naW5lID09PSAndGVzdCcgPyB3cmFwSW5Ob25hbWVGdW5jKHJlc3VsdCkgOiBwYXNzU291cmNlQW5kUHJvcHMoc291cmNlLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHJlZGlyZWN0c0NqcyA9IHtcbiAgUmVkaXJlY3RzOiBSZWRpcmVjdHMsXG4gIGdldENvZGU6IGdldFJlZGlyZWN0Q29kZSxcbiAgaXNBZGdSZWRpcmVjdFJ1bGU6IHZhbGlkYXRvci5pc0FkZ1JlZGlyZWN0UnVsZSxcbiAgaXNWYWxpZEFkZ1JlZGlyZWN0UnVsZTogdmFsaWRhdG9yLmlzVmFsaWRBZGdSZWRpcmVjdFJ1bGUsXG4gIGlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibzogdmFsaWRhdG9yLmlzQWRnUmVkaXJlY3RDb21wYXRpYmxlV2l0aFVibyxcbiAgaXNVYm9SZWRpcmVjdENvbXBhdGlibGVXaXRoQWRnOiB2YWxpZGF0b3IuaXNVYm9SZWRpcmVjdENvbXBhdGlibGVXaXRoQWRnLFxuICBpc0FicFJlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGc6IHZhbGlkYXRvci5pc0FicFJlZGlyZWN0Q29tcGF0aWJsZVdpdGhBZGcsXG4gIGNvbnZlcnRVYm9SZWRpcmVjdFRvQWRnOiBjb252ZXJ0VWJvUmVkaXJlY3RUb0FkZyxcbiAgY29udmVydEFicFJlZGlyZWN0VG9BZGc6IGNvbnZlcnRBYnBSZWRpcmVjdFRvQWRnLFxuICBjb252ZXJ0UmVkaXJlY3RUb0FkZzogY29udmVydFJlZGlyZWN0VG9BZGcsXG4gIGNvbnZlcnRBZGdSZWRpcmVjdFRvVWJvOiBjb252ZXJ0QWRnUmVkaXJlY3RUb1Vib1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTb3VyY2UgLSBzY3JpcHRsZXQgcHJvcGVydGllc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgU2NyaXB0bGV0IG5hbWVcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gYXJncyBBcmd1bWVudHMgZm9yIHNjcmlwdGxldCBmdW5jdGlvblxuICogQHByb3BlcnR5IHsnZXh0ZW5zaW9uJ3wnY29yZWxpYnMnfCd0ZXN0J30gZW5naW5lIC1cbiAqIERlZmluZXMgdGhlIGZpbmFsIGZvcm0gb2Ygc2NyaXB0bGV0IHN0cmluZyBwcmVzZW50YXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmVyc2lvbl1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZlcmJvc2VdIGZsYWcgdG8gZW5hYmxlIHByaW50aW5nIHRvIGNvbnNvbGUgZGVidWcgaW5mb3JtYXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcnVsZVRleHRdIFNvdXJjZSBydWxlIHRleHQgaXMgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2RvbWFpbk5hbWVdIGRvbWFpbiBuYW1lIHdoZXJlIHNjcmlwdGxldCBpcyBhcHBsaWVkOyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHNjcmlwdGxldCBjb2RlIGJ5IHBhcmFtXG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBzY3JpcHRsZXQgY29kZVxuICovXG5cbmZ1bmN0aW9uIGdldFNjcmlwdGxldENvZGUoc291cmNlKSB7XG4gIGlmICghdmFsaWRhdG9yLmlzVmFsaWRTY3JpcHRsZXROYW1lKHNvdXJjZS5uYW1lKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjcmlwdGxldCA9IHZhbGlkYXRvci5nZXRTY3JpcHRsZXRCeU5hbWUoc291cmNlLm5hbWUpO1xuICB2YXIgcmVzdWx0ID0gYXR0YWNoRGVwZW5kZW5jaWVzKHNjcmlwdGxldCk7XG4gIHJlc3VsdCA9IGFkZENhbGwoc2NyaXB0bGV0LCByZXN1bHQpO1xuICByZXN1bHQgPSBzb3VyY2UuZW5naW5lID09PSAnY29yZWxpYnMnIHx8IHNvdXJjZS5lbmdpbmUgPT09ICd0ZXN0JyA/IHdyYXBJbk5vbmFtZUZ1bmMocmVzdWx0KSA6IHBhc3NTb3VyY2VBbmRQcm9wcyhzb3VyY2UsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFNjcmlwdGxldHMgdmFyaWFibGVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBtZXRob2RzOlxuICogYGludm9rZWAgbWV0aG9kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCB3aXRoIGBTb3VyY2VgIHR5cGVcbiAqIGB2YWxpZGF0ZWAgbWV0aG9kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCB3aXRoIGBTdHJpbmdgIHR5cGVcbiAqL1xuXG5cbnZhciBzY3JpcHRsZXRzT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGludm9rZTogZ2V0U2NyaXB0bGV0Q29kZSxcbiAgICBpc1ZhbGlkU2NyaXB0bGV0TmFtZTogdmFsaWRhdG9yLmlzVmFsaWRTY3JpcHRsZXROYW1lLFxuICAgIGlzVmFsaWRTY3JpcHRsZXRSdWxlOiBpc1ZhbGlkU2NyaXB0bGV0UnVsZSxcbiAgICBpc0FkZ1NjcmlwdGxldFJ1bGU6IHZhbGlkYXRvci5pc0FkZ1NjcmlwdGxldFJ1bGUsXG4gICAgaXNVYm9TY3JpcHRsZXRSdWxlOiB2YWxpZGF0b3IuaXNVYm9TY3JpcHRsZXRSdWxlLFxuICAgIGlzQWJwU25pcHBldFJ1bGU6IHZhbGlkYXRvci5pc0FicFNuaXBwZXRSdWxlLFxuICAgIGNvbnZlcnRVYm9Ub0FkZzogY29udmVydFVib1NjcmlwdGxldFRvQWRnLFxuICAgIGNvbnZlcnRBYnBUb0FkZzogY29udmVydEFicFNuaXBwZXRUb0FkZyxcbiAgICBjb252ZXJ0U2NyaXB0bGV0VG9BZGc6IGNvbnZlcnRTY3JpcHRsZXRUb0FkZyxcbiAgICBjb252ZXJ0QWRnVG9VYm86IGNvbnZlcnRBZGdTY3JpcHRsZXRUb1VibyxcbiAgICByZWRpcmVjdHM6IHJlZGlyZWN0c0Nqc1xuICB9O1xufSgpO1xuXG4vKipcbiAqIEFkZCBtb2R1bGUgZXhwb3J0cyB0byBiZSB1c2VkIGFzIG5vZGUgcGFja2FnZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gc2NyaXB0bGV0c09iamVjdDtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICBJZiB5b3Ugd2FudCB0byBhZGQgeW91ciBvd24gc2NyaXB0bGV0ICB8XG4gKiB8ICBwbGVhc2UgcHV0IHlvdXIgY29kZSBiZWxvdyAgICAgICAgICAgICB8XG4gKiB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/scriptlets/dist/cjs/scriptlets.cjs.js\n");

/***/ }),

/***/ "./node_modules/webextension-polyfill-ts/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/webextension-polyfill-ts/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nexports.browser = __webpack_require__(/*! webextension-polyfill */ \"./node_modules/webextension-polyfill/dist/browser-polyfill.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy93ZWJleHRlbnNpb24tcG9seWZpbGwtdHMvbGliL2luZGV4LmpzPzcyOGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELG1JQUFrRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy93ZWJleHRlbnNpb24tcG9seWZpbGwtdHMvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmV4cG9ydHMuYnJvd3NlciA9IHJlcXVpcmUoXCJ3ZWJleHRlbnNpb24tcG9seWZpbGxcIik7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webextension-polyfill-ts/lib/index.js\n");

/***/ }),

/***/ "./node_modules/webextension-polyfill/dist/browser-polyfill.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webextension-polyfill/dist/browser-polyfill.js ***!
  \*********************************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (module) {\n  /* webextension-polyfill - v0.7.0 - Tue Nov 10 2020 20:24:04 */\n\n  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n\n  /* vim: set sts=2 sw=2 et tw=80: */\n\n  /* This Source Code Form is subject to the terms of the Mozilla Public\n   * License, v. 2.0. If a copy of the MPL was not distributed with this\n   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n  \"use strict\";\n\n  if (typeof browser === \"undefined\" || Object.getPrototypeOf(browser) !== Object.prototype) {\n    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n    const SEND_RESPONSE_DEPRECATION_WARNING = \"Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)\"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n    // optimization for Firefox. Since Spidermonkey does not fully parse the\n    // contents of a function until the first time it's called, and since it will\n    // never actually need to be called, this allows the polyfill to be included\n    // in Firefox nearly for free.\n\n    const wrapAPIs = extensionAPIs => {\n      // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n      // at build time by replacing the following \"include\" with the content of the\n      // JSON file.\n      const apiMetadata = {\n        \"alarms\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"clearAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"bookmarks\": {\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getChildren\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getRecent\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getSubTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTree\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"browserAction\": {\n          \"disable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"enable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"getBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"openPopup\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"browsingData\": {\n          \"remove\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"removeCache\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCookies\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeDownloads\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFormData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeHistory\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeLocalStorage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePasswords\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePluginData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"settings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"commands\": {\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"contextMenus\": {\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"cookies\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAllCookieStores\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"devtools\": {\n          \"inspectedWindow\": {\n            \"eval\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 2,\n              \"singleCallbackArg\": false\n            }\n          },\n          \"panels\": {\n            \"create\": {\n              \"minArgs\": 3,\n              \"maxArgs\": 3,\n              \"singleCallbackArg\": true\n            },\n            \"elements\": {\n              \"createSidebarPane\": {\n                \"minArgs\": 1,\n                \"maxArgs\": 1\n              }\n            }\n          }\n        },\n        \"downloads\": {\n          \"cancel\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"download\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"erase\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFileIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"open\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"pause\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFile\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"resume\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"extension\": {\n          \"isAllowedFileSchemeAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"isAllowedIncognitoAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"history\": {\n          \"addUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"deleteRange\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getVisits\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"i18n\": {\n          \"detectLanguage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAcceptLanguages\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"identity\": {\n          \"launchWebAuthFlow\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"idle\": {\n          \"queryState\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"management\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setEnabled\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"uninstallSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"notifications\": {\n          \"clear\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPermissionLevel\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"pageAction\": {\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"hide\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"permissions\": {\n          \"contains\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"request\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"runtime\": {\n          \"getBackgroundPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPlatformInfo\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"openOptionsPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"requestUpdateCheck\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"sendMessage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 3\n          },\n          \"sendNativeMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"setUninstallURL\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"sessions\": {\n          \"getDevices\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getRecentlyClosed\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"restore\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"storage\": {\n          \"local\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          },\n          \"managed\": {\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            }\n          },\n          \"sync\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        },\n        \"tabs\": {\n          \"captureVisibleTab\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"detectLanguage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"discard\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"duplicate\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"executeScript\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getZoom\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getZoomSettings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goBack\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goForward\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"highlight\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"insertCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"query\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"reload\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"sendMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 3\n          },\n          \"setZoom\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"setZoomSettings\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"update\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          }\n        },\n        \"topSites\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"webNavigation\": {\n          \"getAllFrames\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFrame\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"webRequest\": {\n          \"handlerBehaviorChanged\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"windows\": {\n          \"create\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getLastFocused\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        }\n      };\n\n      if (Object.keys(apiMetadata).length === 0) {\n        throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n      }\n      /**\n       * A WeakMap subclass which creates and stores a value for any key which does\n       * not exist when accessed, but behaves exactly as an ordinary WeakMap\n       * otherwise.\n       *\n       * @param {function} createItem\n       *        A function which will be called in order to create the value for any\n       *        key which does not exist, the first time it is accessed. The\n       *        function receives, as its only argument, the key being created.\n       */\n\n\n      class DefaultWeakMap extends WeakMap {\n        constructor(createItem, items = undefined) {\n          super(items);\n          this.createItem = createItem;\n        }\n\n        get(key) {\n          if (!this.has(key)) {\n            this.set(key, this.createItem(key));\n          }\n\n          return super.get(key);\n        }\n\n      }\n      /**\n       * Returns true if the given object is an object with a `then` method, and can\n       * therefore be assumed to behave as a Promise.\n       *\n       * @param {*} value The value to test.\n       * @returns {boolean} True if the value is thenable.\n       */\n\n\n      const isThenable = value => {\n        return value && typeof value === \"object\" && typeof value.then === \"function\";\n      };\n      /**\n       * Creates and returns a function which, when called, will resolve or reject\n       * the given promise based on how it is called:\n       *\n       * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n       *   the promise is rejected with that value.\n       * - If the function is called with exactly one argument, the promise is\n       *   resolved to that value.\n       * - Otherwise, the promise is resolved to an array containing all of the\n       *   function's arguments.\n       *\n       * @param {object} promise\n       *        An object containing the resolution and rejection functions of a\n       *        promise.\n       * @param {function} promise.resolve\n       *        The promise's resolution function.\n       * @param {function} promise.rejection\n       *        The promise's rejection function.\n       * @param {object} metadata\n       *        Metadata about the wrapped method which has created the callback.\n       * @param {integer} metadata.maxResolvedArgs\n       *        The maximum number of arguments which may be passed to the\n       *        callback created by the wrapped async function.\n       *\n       * @returns {function}\n       *        The generated callback function.\n       */\n\n\n      const makeCallback = (promise, metadata) => {\n        return (...callbackArgs) => {\n          if (extensionAPIs.runtime.lastError) {\n            promise.reject(extensionAPIs.runtime.lastError);\n          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {\n            promise.resolve(callbackArgs[0]);\n          } else {\n            promise.resolve(callbackArgs);\n          }\n        };\n      };\n\n      const pluralizeArguments = numArgs => numArgs == 1 ? \"argument\" : \"arguments\";\n      /**\n       * Creates a wrapper function for a method with the given name and metadata.\n       *\n       * @param {string} name\n       *        The name of the method which is being wrapped.\n       * @param {object} metadata\n       *        Metadata about the method being wrapped.\n       * @param {integer} metadata.minArgs\n       *        The minimum number of arguments which must be passed to the\n       *        function. If called with fewer than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxArgs\n       *        The maximum number of arguments which may be passed to the\n       *        function. If called with more than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxResolvedArgs\n       *        The maximum number of arguments which may be passed to the\n       *        callback created by the wrapped async function.\n       *\n       * @returns {function(object, ...*)}\n       *       The generated wrapper function.\n       */\n\n\n      const wrapAsyncFunction = (name, metadata) => {\n        return function asyncFunctionWrapper(target, ...args) {\n          if (args.length < metadata.minArgs) {\n            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          if (args.length > metadata.maxArgs) {\n            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          return new Promise((resolve, reject) => {\n            if (metadata.fallbackToNoCallback) {\n              // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n              // and so the polyfill will try to call it with a callback first, and it will fallback\n              // to not passing the callback if the first call fails.\n              try {\n                target[name](...args, makeCallback({\n                  resolve,\n                  reject\n                }, metadata));\n              } catch (cbError) {\n                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + \"falling back to call it without a callback: \", cbError);\n                target[name](...args); // Update the API method metadata, so that the next API calls will not try to\n                // use the unsupported callback anymore.\n\n                metadata.fallbackToNoCallback = false;\n                metadata.noCallback = true;\n                resolve();\n              }\n            } else if (metadata.noCallback) {\n              target[name](...args);\n              resolve();\n            } else {\n              target[name](...args, makeCallback({\n                resolve,\n                reject\n              }, metadata));\n            }\n          });\n        };\n      };\n      /**\n       * Wraps an existing method of the target object, so that calls to it are\n       * intercepted by the given wrapper function. The wrapper function receives,\n       * as its first argument, the original `target` object, followed by each of\n       * the arguments passed to the original method.\n       *\n       * @param {object} target\n       *        The original target object that the wrapped method belongs to.\n       * @param {function} method\n       *        The method being wrapped. This is used as the target of the Proxy\n       *        object which is created to wrap the method.\n       * @param {function} wrapper\n       *        The wrapper function which is called in place of a direct invocation\n       *        of the wrapped method.\n       *\n       * @returns {Proxy<function>}\n       *        A Proxy object for the given method, which invokes the given wrapper\n       *        method in its place.\n       */\n\n\n      const wrapMethod = (target, method, wrapper) => {\n        return new Proxy(method, {\n          apply(targetMethod, thisObj, args) {\n            return wrapper.call(thisObj, target, ...args);\n          }\n\n        });\n      };\n\n      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n      /**\n       * Wraps an object in a Proxy which intercepts and wraps certain methods\n       * based on the given `wrappers` and `metadata` objects.\n       *\n       * @param {object} target\n       *        The target object to wrap.\n       *\n       * @param {object} [wrappers = {}]\n       *        An object tree containing wrapper functions for special cases. Any\n       *        function present in this object tree is called in place of the\n       *        method in the same location in the `target` object tree. These\n       *        wrapper methods are invoked as described in {@see wrapMethod}.\n       *\n       * @param {object} [metadata = {}]\n       *        An object tree containing metadata used to automatically generate\n       *        Promise-based wrapper functions for asynchronous. Any function in\n       *        the `target` object tree which has a corresponding metadata object\n       *        in the same location in the `metadata` tree is replaced with an\n       *        automatically-generated wrapper function, as described in\n       *        {@see wrapAsyncFunction}\n       *\n       * @returns {Proxy<object>}\n       */\n\n      const wrapObject = (target, wrappers = {}, metadata = {}) => {\n        let cache = Object.create(null);\n        let handlers = {\n          has(proxyTarget, prop) {\n            return prop in target || prop in cache;\n          },\n\n          get(proxyTarget, prop, receiver) {\n            if (prop in cache) {\n              return cache[prop];\n            }\n\n            if (!(prop in target)) {\n              return undefined;\n            }\n\n            let value = target[prop];\n\n            if (typeof value === \"function\") {\n              // This is a method on the underlying object. Check if we need to do\n              // any wrapping.\n              if (typeof wrappers[prop] === \"function\") {\n                // We have a special-case wrapper for this method.\n                value = wrapMethod(target, target[prop], wrappers[prop]);\n              } else if (hasOwnProperty(metadata, prop)) {\n                // This is an async method that we have metadata for. Create a\n                // Promise wrapper for it.\n                let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n                value = wrapMethod(target, target[prop], wrapper);\n              } else {\n                // This is a method that we don't know or care about. Return the\n                // original method, bound to the underlying object.\n                value = value.bind(target);\n              }\n            } else if (typeof value === \"object\" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {\n              // This is an object that we need to do some wrapping for the children\n              // of. Create a sub-object wrapper for it with the appropriate child\n              // metadata.\n              value = wrapObject(value, wrappers[prop], metadata[prop]);\n            } else if (hasOwnProperty(metadata, \"*\")) {\n              // Wrap all properties in * namespace.\n              value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n            } else {\n              // We don't need to do any wrapping for this property,\n              // so just forward all access to the underlying object.\n              Object.defineProperty(cache, prop, {\n                configurable: true,\n                enumerable: true,\n\n                get() {\n                  return target[prop];\n                },\n\n                set(value) {\n                  target[prop] = value;\n                }\n\n              });\n              return value;\n            }\n\n            cache[prop] = value;\n            return value;\n          },\n\n          set(proxyTarget, prop, value, receiver) {\n            if (prop in cache) {\n              cache[prop] = value;\n            } else {\n              target[prop] = value;\n            }\n\n            return true;\n          },\n\n          defineProperty(proxyTarget, prop, desc) {\n            return Reflect.defineProperty(cache, prop, desc);\n          },\n\n          deleteProperty(proxyTarget, prop) {\n            return Reflect.deleteProperty(cache, prop);\n          }\n\n        }; // Per contract of the Proxy API, the \"get\" proxy handler must return the\n        // original value of the target if that value is declared read-only and\n        // non-configurable. For this reason, we create an object with the\n        // prototype set to `target` instead of using `target` directly.\n        // Otherwise we cannot return a custom object for APIs that\n        // are declared read-only and non-configurable, such as `chrome.devtools`.\n        //\n        // The proxy handlers themselves will still use the original `target`\n        // instead of the `proxyTarget`, so that the methods and properties are\n        // dereferenced via the original targets.\n\n        let proxyTarget = Object.create(target);\n        return new Proxy(proxyTarget, handlers);\n      };\n      /**\n       * Creates a set of wrapper functions for an event object, which handles\n       * wrapping of listener functions that those messages are passed.\n       *\n       * A single wrapper is created for each listener function, and stored in a\n       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n       * retrieve the original wrapper, so that  attempts to remove a\n       * previously-added listener work as expected.\n       *\n       * @param {DefaultWeakMap<function, function>} wrapperMap\n       *        A DefaultWeakMap object which will create the appropriate wrapper\n       *        for a given listener function when one does not exist, and retrieve\n       *        an existing one when it does.\n       *\n       * @returns {object}\n       */\n\n\n      const wrapEvent = wrapperMap => ({\n        addListener(target, listener, ...args) {\n          target.addListener(wrapperMap.get(listener), ...args);\n        },\n\n        hasListener(target, listener) {\n          return target.hasListener(wrapperMap.get(listener));\n        },\n\n        removeListener(target, listener) {\n          target.removeListener(wrapperMap.get(listener));\n        }\n\n      }); // Keep track if the deprecation warning has been logged at least once.\n\n\n      let loggedSendResponseDeprecationWarning = false;\n      const onMessageWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n        /**\n         * Wraps a message listener function so that it may send responses based on\n         * its return value, rather than by returning a sentinel value and calling a\n         * callback. If the listener function returns a Promise, the response is\n         * sent when the promise either resolves or rejects.\n         *\n         * @param {*} message\n         *        The message sent by the other end of the channel.\n         * @param {object} sender\n         *        Details about the sender of the message.\n         * @param {function(*)} sendResponse\n         *        A callback which, when called with an arbitrary argument, sends\n         *        that value as a response.\n         * @returns {boolean}\n         *        True if the wrapped listener returned a Promise, which will later\n         *        yield a response. False otherwise.\n         */\n\n\n        return function onMessage(message, sender, sendResponse) {\n          let didCallSendResponse = false;\n          let wrappedSendResponse;\n          let sendResponsePromise = new Promise(resolve => {\n            wrappedSendResponse = function (response) {\n              if (!loggedSendResponseDeprecationWarning) {\n                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);\n                loggedSendResponseDeprecationWarning = true;\n              }\n\n              didCallSendResponse = true;\n              resolve(response);\n            };\n          });\n          let result;\n\n          try {\n            result = listener(message, sender, wrappedSendResponse);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n\n          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called\n          // wrappedSendResponse synchronously, we can exit earlier\n          // because there will be no response sent from this listener.\n\n          if (result !== true && !isResultThenable && !didCallSendResponse) {\n            return false;\n          } // A small helper to send the message if the promise resolves\n          // and an error if the promise rejects (a wrapped sendMessage has\n          // to translate the message into a resolved promise or a rejected\n          // promise).\n\n\n          const sendPromisedResult = promise => {\n            promise.then(msg => {\n              // send the message value.\n              sendResponse(msg);\n            }, error => {\n              // Send a JSON representation of the error if the rejected value\n              // is an instance of error, or the object itself otherwise.\n              let message;\n\n              if (error && (error instanceof Error || typeof error.message === \"string\")) {\n                message = error.message;\n              } else {\n                message = \"An unexpected error occurred\";\n              }\n\n              sendResponse({\n                __mozWebExtensionPolyfillReject__: true,\n                message\n              });\n            }).catch(err => {\n              // Print an error on the console if unable to send the response.\n              console.error(\"Failed to send onMessage rejected reply\", err);\n            });\n          }; // If the listener returned a Promise, send the resolved value as a\n          // result, otherwise wait the promise related to the wrappedSendResponse\n          // callback to resolve and send it as a response.\n\n\n          if (isResultThenable) {\n            sendPromisedResult(result);\n          } else {\n            sendPromisedResult(sendResponsePromise);\n          } // Let Chrome know that the listener is replying.\n\n\n          return true;\n        };\n      });\n\n      const wrappedSendMessageCallback = ({\n        reject,\n        resolve\n      }, reply) => {\n        if (extensionAPIs.runtime.lastError) {\n          // Detect when none of the listeners replied to the sendMessage call and resolve\n          // the promise to undefined as in Firefox.\n          // See https://github.com/mozilla/webextension-polyfill/issues/130\n          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n            resolve();\n          } else {\n            reject(extensionAPIs.runtime.lastError);\n          }\n        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n          // Convert back the JSON representation of the error into\n          // an Error instance.\n          reject(new Error(reply.message));\n        } else {\n          resolve(reply);\n        }\n      };\n\n      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        return new Promise((resolve, reject) => {\n          const wrappedCb = wrappedSendMessageCallback.bind(null, {\n            resolve,\n            reject\n          });\n          args.push(wrappedCb);\n          apiNamespaceObj.sendMessage(...args);\n        });\n      };\n\n      const staticWrappers = {\n        runtime: {\n          onMessage: wrapEvent(onMessageWrappers),\n          onMessageExternal: wrapEvent(onMessageWrappers),\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 1,\n            maxArgs: 3\n          })\n        },\n        tabs: {\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 2,\n            maxArgs: 3\n          })\n        }\n      };\n      const settingMetadata = {\n        clear: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        get: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        set: {\n          minArgs: 1,\n          maxArgs: 1\n        }\n      };\n      apiMetadata.privacy = {\n        network: {\n          \"*\": settingMetadata\n        },\n        services: {\n          \"*\": settingMetadata\n        },\n        websites: {\n          \"*\": settingMetadata\n        }\n      };\n      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n    };\n\n    if (typeof chrome != \"object\" || !chrome || !chrome.runtime || !chrome.runtime.id) {\n      throw new Error(\"This script should only be loaded in a browser extension.\");\n    } // The build process adds a UMD wrapper around this file, which makes the\n    // `module` variable available.\n\n\n    module.exports = wrapAPIs(chrome);\n  } else {\n    module.exports = browser;\n  }\n});\n//# sourceMappingURL=browser-polyfill.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZHZhbmNlZC1hZGJsb2NrZXItd2ViLWV4dGVuc2lvbi8uL25vZGVfbW9kdWxlcy93ZWJleHRlbnNpb24tcG9seWZpbGwvZGlzdC9icm93c2VyLXBvbHlmaWxsLmpzPzk4NDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hELElBQUksaUNBQWdDLENBQUMsTUFBUSxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDeEQsR0FBRyxNQUFNLFlBUU47QUFDSCxDQUFDO0FBQ0Q7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdVNBQXVTO0FBQ3ZTO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQixHQUFHLHFDQUFxQyxPQUFPLEtBQUssVUFBVSxZQUFZO0FBQzFJOztBQUVBO0FBQ0EsOENBQThDLGlCQUFpQixHQUFHLHFDQUFxQyxPQUFPLEtBQUssVUFBVSxZQUFZO0FBQ3pJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoXCJ3ZWJleHRlbnNpb24tcG9seWZpbGxcIiwgW1wibW9kdWxlXCJdLCBmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGZhY3RvcnkobW9kdWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbW9kID0ge1xuICAgICAgZXhwb3J0czoge31cbiAgICB9O1xuICAgIGZhY3RvcnkobW9kKTtcbiAgICBnbG9iYWwuYnJvd3NlciA9IG1vZC5leHBvcnRzO1xuICB9XG59KSh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAobW9kdWxlKSB7XG4gIC8qIHdlYmV4dGVuc2lvbi1wb2x5ZmlsbCAtIHYwLjcuMCAtIFR1ZSBOb3YgMTAgMjAyMCAyMDoyNDowNCAqL1xuXG4gIC8qIC0qLSBNb2RlOiBpbmRlbnQtdGFicy1tb2RlOiBuaWw7IGpzLWluZGVudC1sZXZlbDogMiAtKi0gKi9cblxuICAvKiB2aW06IHNldCBzdHM9MiBzdz0yIGV0IHR3PTgwOiAqL1xuXG4gIC8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAgICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICAgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLiAqL1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZiAodHlwZW9mIGJyb3dzZXIgPT09IFwidW5kZWZpbmVkXCIgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGJyb3dzZXIpICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgY29uc3QgQ0hST01FX1NFTkRfTUVTU0FHRV9DQUxMQkFDS19OT19SRVNQT05TRV9NRVNTQUdFID0gXCJUaGUgbWVzc2FnZSBwb3J0IGNsb3NlZCBiZWZvcmUgYSByZXNwb25zZSB3YXMgcmVjZWl2ZWQuXCI7XG4gICAgY29uc3QgU0VORF9SRVNQT05TRV9ERVBSRUNBVElPTl9XQVJOSU5HID0gXCJSZXR1cm5pbmcgYSBQcm9taXNlIGlzIHRoZSBwcmVmZXJyZWQgd2F5IHRvIHNlbmQgYSByZXBseSBmcm9tIGFuIG9uTWVzc2FnZS9vbk1lc3NhZ2VFeHRlcm5hbCBsaXN0ZW5lciwgYXMgdGhlIHNlbmRSZXNwb25zZSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgc3BlY3MgKFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL01vemlsbGEvQWRkLW9ucy9XZWJFeHRlbnNpb25zL0FQSS9ydW50aW1lL29uTWVzc2FnZSlcIjsgLy8gV3JhcHBpbmcgdGhlIGJ1bGsgb2YgdGhpcyBwb2x5ZmlsbCBpbiBhIG9uZS10aW1lLXVzZSBmdW5jdGlvbiBpcyBhIG1pbm9yXG4gICAgLy8gb3B0aW1pemF0aW9uIGZvciBGaXJlZm94LiBTaW5jZSBTcGlkZXJtb25rZXkgZG9lcyBub3QgZnVsbHkgcGFyc2UgdGhlXG4gICAgLy8gY29udGVudHMgb2YgYSBmdW5jdGlvbiB1bnRpbCB0aGUgZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHNpbmNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBhY3R1YWxseSBuZWVkIHRvIGJlIGNhbGxlZCwgdGhpcyBhbGxvd3MgdGhlIHBvbHlmaWxsIHRvIGJlIGluY2x1ZGVkXG4gICAgLy8gaW4gRmlyZWZveCBuZWFybHkgZm9yIGZyZWUuXG5cbiAgICBjb25zdCB3cmFwQVBJcyA9IGV4dGVuc2lvbkFQSXMgPT4ge1xuICAgICAgLy8gTk9URTogYXBpTWV0YWRhdGEgaXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGVudCBvZiB0aGUgYXBpLW1ldGFkYXRhLmpzb24gZmlsZVxuICAgICAgLy8gYXQgYnVpbGQgdGltZSBieSByZXBsYWNpbmcgdGhlIGZvbGxvd2luZyBcImluY2x1ZGVcIiB3aXRoIHRoZSBjb250ZW50IG9mIHRoZVxuICAgICAgLy8gSlNPTiBmaWxlLlxuICAgICAgY29uc3QgYXBpTWV0YWRhdGEgPSB7XG4gICAgICAgIFwiYWxhcm1zXCI6IHtcbiAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY2xlYXJBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJib29rbWFya3NcIjoge1xuICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Q2hpbGRyZW5cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRSZWNlbnRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRTdWJUcmVlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VHJlZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVUcmVlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VhcmNoXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnJvd3NlckFjdGlvblwiOiB7XG4gICAgICAgICAgXCJkaXNhYmxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZW5hYmxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3JcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRCYWRnZVRleHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3BlblBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3JcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRCYWRnZVRleHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0UG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRUaXRsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJyb3dzaW5nRGF0YVwiOiB7XG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDYWNoZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNvb2tpZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVEb3dubG9hZHNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVGb3JtRGF0YVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUhpc3RvcnlcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVMb2NhbFN0b3JhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVQYXNzd29yZHNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVQbHVnaW5EYXRhXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjb21tYW5kc1wiOiB7XG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjb250ZXh0TWVudXNcIjoge1xuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiY29va2llc1wiOiB7XG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxDb29raWVTdG9yZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJkZXZ0b29sc1wiOiB7XG4gICAgICAgICAgXCJpbnNwZWN0ZWRXaW5kb3dcIjoge1xuICAgICAgICAgICAgXCJldmFsXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyLFxuICAgICAgICAgICAgICBcInNpbmdsZUNhbGxiYWNrQXJnXCI6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInBhbmVsc1wiOiB7XG4gICAgICAgICAgICBcImNyZWF0ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAzLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMyxcbiAgICAgICAgICAgICAgXCJzaW5nbGVDYWxsYmFja0FyZ1wiOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJlbGVtZW50c1wiOiB7XG4gICAgICAgICAgICAgIFwiY3JlYXRlU2lkZWJhclBhbmVcIjoge1xuICAgICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZG93bmxvYWRzXCI6IHtcbiAgICAgICAgICBcImNhbmNlbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRvd25sb2FkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZXJhc2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRGaWxlSWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwYXVzZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUZpbGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXN1bWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaG93XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZXh0ZW5zaW9uXCI6IHtcbiAgICAgICAgICBcImlzQWxsb3dlZEZpbGVTY2hlbWVBY2Nlc3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpc0FsbG93ZWRJbmNvZ25pdG9BY2Nlc3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJoaXN0b3J5XCI6IHtcbiAgICAgICAgICBcImFkZFVybFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlbGV0ZUFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRlbGV0ZVJhbmdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlVXJsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VmlzaXRzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VhcmNoXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaTE4blwiOiB7XG4gICAgICAgICAgXCJkZXRlY3RMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFjY2VwdExhbmd1YWdlc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImlkZW50aXR5XCI6IHtcbiAgICAgICAgICBcImxhdW5jaFdlYkF1dGhGbG93XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRsZVwiOiB7XG4gICAgICAgICAgXCJxdWVyeVN0YXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwibWFuYWdlbWVudFwiOiB7XG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRTZWxmXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0RW5hYmxlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInVuaW5zdGFsbFNlbGZcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJub3RpZmljYXRpb25zXCI6IHtcbiAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UGVybWlzc2lvbkxldmVsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGFnZUFjdGlvblwiOiB7XG4gICAgICAgICAgXCJnZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaGlkZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2hvd1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBlcm1pc3Npb25zXCI6IHtcbiAgICAgICAgICBcImNvbnRhaW5zXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVxdWVzdFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInJ1bnRpbWVcIjoge1xuICAgICAgICAgIFwiZ2V0QmFja2dyb3VuZFBhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRQbGF0Zm9ybUluZm9cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuT3B0aW9uc1BhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXF1ZXN0VXBkYXRlQ2hlY2tcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmROYXRpdmVNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VW5pbnN0YWxsVVJMXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic2Vzc2lvbnNcIjoge1xuICAgICAgICAgIFwiZ2V0RGV2aWNlc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFJlY2VudGx5Q2xvc2VkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVzdG9yZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInN0b3JhZ2VcIjoge1xuICAgICAgICAgIFwibG9jYWxcIjoge1xuICAgICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRCeXRlc0luVXNlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtYW5hZ2VkXCI6IHtcbiAgICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRCeXRlc0luVXNlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInN5bmNcIjoge1xuICAgICAgICAgICAgXCJjbGVhclwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRCeXRlc0luVXNlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInNldFwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0YWJzXCI6IHtcbiAgICAgICAgICBcImNhcHR1cmVWaXNpYmxlVGFiXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGV0ZWN0TGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkaXNjYXJkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZHVwbGljYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZXhlY3V0ZVNjcmlwdFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEN1cnJlbnRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRab29tXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Wm9vbVNldHRpbmdzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ29CYWNrXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ29Gb3J3YXJkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaGlnaGxpZ2h0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaW5zZXJ0Q1NTXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInF1ZXJ5XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVsb2FkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ1NTXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogM1xuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRab29tXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0Wm9vbVNldHRpbmdzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwidG9wU2l0ZXNcIjoge1xuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2ViTmF2aWdhdGlvblwiOiB7XG4gICAgICAgICAgXCJnZXRBbGxGcmFtZXNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRGcmFtZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIndlYlJlcXVlc3RcIjoge1xuICAgICAgICAgIFwiaGFuZGxlckJlaGF2aW9yQ2hhbmdlZFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIndpbmRvd3NcIjoge1xuICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Q3VycmVudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldExhc3RGb2N1c2VkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidXBkYXRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhhcGlNZXRhZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFwaS1tZXRhZGF0YS5qc29uIGhhcyBub3QgYmVlbiBpbmNsdWRlZCBpbiBicm93c2VyLXBvbHlmaWxsXCIpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBIFdlYWtNYXAgc3ViY2xhc3Mgd2hpY2ggY3JlYXRlcyBhbmQgc3RvcmVzIGEgdmFsdWUgZm9yIGFueSBrZXkgd2hpY2ggZG9lc1xuICAgICAgICogbm90IGV4aXN0IHdoZW4gYWNjZXNzZWQsIGJ1dCBiZWhhdmVzIGV4YWN0bHkgYXMgYW4gb3JkaW5hcnkgV2Vha01hcFxuICAgICAgICogb3RoZXJ3aXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNyZWF0ZUl0ZW1cbiAgICAgICAqICAgICAgICBBIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGluIG9yZGVyIHRvIGNyZWF0ZSB0aGUgdmFsdWUgZm9yIGFueVxuICAgICAgICogICAgICAgIGtleSB3aGljaCBkb2VzIG5vdCBleGlzdCwgdGhlIGZpcnN0IHRpbWUgaXQgaXMgYWNjZXNzZWQuIFRoZVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVzLCBhcyBpdHMgb25seSBhcmd1bWVudCwgdGhlIGtleSBiZWluZyBjcmVhdGVkLlxuICAgICAgICovXG5cblxuICAgICAgY2xhc3MgRGVmYXVsdFdlYWtNYXAgZXh0ZW5kcyBXZWFrTWFwIHtcbiAgICAgICAgY29uc3RydWN0b3IoY3JlYXRlSXRlbSwgaXRlbXMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdXBlcihpdGVtcyk7XG4gICAgICAgICAgdGhpcy5jcmVhdGVJdGVtID0gY3JlYXRlSXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdGhpcy5jcmVhdGVJdGVtKGtleSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIG9iamVjdCB3aXRoIGEgYHRoZW5gIG1ldGhvZCwgYW5kIGNhblxuICAgICAgICogdGhlcmVmb3JlIGJlIGFzc3VtZWQgdG8gYmVoYXZlIGFzIGEgUHJvbWlzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHRoZW5hYmxlLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgaXNUaGVuYWJsZSA9IHZhbHVlID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoLCB3aGVuIGNhbGxlZCwgd2lsbCByZXNvbHZlIG9yIHJlamVjdFxuICAgICAgICogdGhlIGdpdmVuIHByb21pc2UgYmFzZWQgb24gaG93IGl0IGlzIGNhbGxlZDpcbiAgICAgICAqXG4gICAgICAgKiAtIElmLCB3aGVuIGNhbGxlZCwgYGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcmAgY29udGFpbnMgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgKiAgIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIHdpdGggdGhhdCB2YWx1ZS5cbiAgICAgICAqIC0gSWYgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGV4YWN0bHkgb25lIGFyZ3VtZW50LCB0aGUgcHJvbWlzZSBpc1xuICAgICAgICogICByZXNvbHZlZCB0byB0aGF0IHZhbHVlLlxuICAgICAgICogLSBPdGhlcndpc2UsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG9mIHRoZVxuICAgICAgICogICBmdW5jdGlvbidzIGFyZ3VtZW50cy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvbWlzZVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXNvbHV0aW9uIGFuZCByZWplY3Rpb24gZnVuY3Rpb25zIG9mIGFcbiAgICAgICAqICAgICAgICBwcm9taXNlLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvbWlzZS5yZXNvbHZlXG4gICAgICAgKiAgICAgICAgVGhlIHByb21pc2UncyByZXNvbHV0aW9uIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvbWlzZS5yZWplY3Rpb25cbiAgICAgICAqICAgICAgICBUaGUgcHJvbWlzZSdzIHJlamVjdGlvbiBmdW5jdGlvbi5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YVxuICAgICAgICogICAgICAgIE1ldGFkYXRhIGFib3V0IHRoZSB3cmFwcGVkIG1ldGhvZCB3aGljaCBoYXMgY3JlYXRlZCB0aGUgY2FsbGJhY2suXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heFJlc29sdmVkQXJnc1xuICAgICAgICogICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBjYWxsYmFjayBjcmVhdGVkIGJ5IHRoZSB3cmFwcGVkIGFzeW5jIGZ1bmN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICAgICAqICAgICAgICBUaGUgZ2VuZXJhdGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgbWFrZUNhbGxiYWNrID0gKHByb21pc2UsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uY2FsbGJhY2tBcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmcgfHwgY2FsbGJhY2tBcmdzLmxlbmd0aCA8PSAxICYmIG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGNhbGxiYWNrQXJnc1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShjYWxsYmFja0FyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBsdXJhbGl6ZUFyZ3VtZW50cyA9IG51bUFyZ3MgPT4gbnVtQXJncyA9PSAxID8gXCJhcmd1bWVudFwiIDogXCJhcmd1bWVudHNcIjtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIG1ldGFkYXRhLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgKiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB3aGljaCBpcyBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBtZXRhZGF0YS5taW5BcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtdXN0IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBmdW5jdGlvbi4gSWYgY2FsbGVkIHdpdGggZmV3ZXIgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heEFyZ3NcbiAgICAgICAqICAgICAgICBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHdoaWNoIG1heSBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24uIElmIGNhbGxlZCB3aXRoIG1vcmUgdGhhbiB0aGlzIG51bWJlciBvZiBhcmd1bWVudHMsIHRoZVxuICAgICAgICogICAgICAgIHdyYXBwZXIgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG1ldGFkYXRhLm1heFJlc29sdmVkQXJnc1xuICAgICAgICogICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAqICAgICAgICBjYWxsYmFjayBjcmVhdGVkIGJ5IHRoZSB3cmFwcGVkIGFzeW5jIGZ1bmN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihvYmplY3QsIC4uLiopfVxuICAgICAgICogICAgICAgVGhlIGdlbmVyYXRlZCB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3Qgd3JhcEFzeW5jRnVuY3Rpb24gPSAobmFtZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFzeW5jRnVuY3Rpb25XcmFwcGVyKHRhcmdldCwgLi4uYXJncykge1xuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IG1ldGFkYXRhLm1pbkFyZ3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgJHttZXRhZGF0YS5taW5BcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5taW5BcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gbWV0YWRhdGEubWF4QXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBtb3N0ICR7bWV0YWRhdGEubWF4QXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWF4QXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEuZmFsbGJhY2tUb05vQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBBUEkgbWV0aG9kIGhhcyBjdXJyZW50bHkgbm8gY2FsbGJhY2sgb24gQ2hyb21lLCBidXQgaXQgcmV0dXJuIGEgcHJvbWlzZSBvbiBGaXJlZm94LFxuICAgICAgICAgICAgICAvLyBhbmQgc28gdGhlIHBvbHlmaWxsIHdpbGwgdHJ5IHRvIGNhbGwgaXQgd2l0aCBhIGNhbGxiYWNrIGZpcnN0LCBhbmQgaXQgd2lsbCBmYWxsYmFja1xuICAgICAgICAgICAgICAvLyB0byBub3QgcGFzc2luZyB0aGUgY2FsbGJhY2sgaWYgdGhlIGZpcnN0IGNhbGwgZmFpbHMuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MsIG1ha2VDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICAgICAgfSwgbWV0YWRhdGEpKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoY2JFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtuYW1lfSBBUEkgbWV0aG9kIGRvZXNuJ3Qgc2VlbSB0byBzdXBwb3J0IHRoZSBjYWxsYmFjayBwYXJhbWV0ZXIsIGAgKyBcImZhbGxpbmcgYmFjayB0byBjYWxsIGl0IHdpdGhvdXQgYSBjYWxsYmFjazogXCIsIGNiRXJyb3IpO1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzKTsgLy8gVXBkYXRlIHRoZSBBUEkgbWV0aG9kIG1ldGFkYXRhLCBzbyB0aGF0IHRoZSBuZXh0IEFQSSBjYWxscyB3aWxsIG5vdCB0cnkgdG9cbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHVuc3VwcG9ydGVkIGNhbGxiYWNrIGFueW1vcmUuXG5cbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5mYWxsYmFja1RvTm9DYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLm5vQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRhZGF0YS5ub0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHRhcmdldFtuYW1lXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MsIG1ha2VDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgfSwgbWV0YWRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIGFuIGV4aXN0aW5nIG1ldGhvZCBvZiB0aGUgdGFyZ2V0IG9iamVjdCwgc28gdGhhdCBjYWxscyB0byBpdCBhcmVcbiAgICAgICAqIGludGVyY2VwdGVkIGJ5IHRoZSBnaXZlbiB3cmFwcGVyIGZ1bmN0aW9uLiBUaGUgd3JhcHBlciBmdW5jdGlvbiByZWNlaXZlcyxcbiAgICAgICAqIGFzIGl0cyBmaXJzdCBhcmd1bWVudCwgdGhlIG9yaWdpbmFsIGB0YXJnZXRgIG9iamVjdCwgZm9sbG93ZWQgYnkgZWFjaCBvZlxuICAgICAgICogdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0XG4gICAgICAgKiAgICAgICAgVGhlIG9yaWdpbmFsIHRhcmdldCBvYmplY3QgdGhhdCB0aGUgd3JhcHBlZCBtZXRob2QgYmVsb25ncyB0by5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZFxuICAgICAgICogICAgICAgIFRoZSBtZXRob2QgYmVpbmcgd3JhcHBlZC4gVGhpcyBpcyB1c2VkIGFzIHRoZSB0YXJnZXQgb2YgdGhlIFByb3h5XG4gICAgICAgKiAgICAgICAgb2JqZWN0IHdoaWNoIGlzIGNyZWF0ZWQgdG8gd3JhcCB0aGUgbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gd3JhcHBlclxuICAgICAgICogICAgICAgIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBpbiBwbGFjZSBvZiBhIGRpcmVjdCBpbnZvY2F0aW9uXG4gICAgICAgKiAgICAgICAgb2YgdGhlIHdyYXBwZWQgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtQcm94eTxmdW5jdGlvbj59XG4gICAgICAgKiAgICAgICAgQSBQcm94eSBvYmplY3QgZm9yIHRoZSBnaXZlbiBtZXRob2QsIHdoaWNoIGludm9rZXMgdGhlIGdpdmVuIHdyYXBwZXJcbiAgICAgICAqICAgICAgICBtZXRob2QgaW4gaXRzIHBsYWNlLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3Qgd3JhcE1ldGhvZCA9ICh0YXJnZXQsIG1ldGhvZCwgd3JhcHBlcikgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KG1ldGhvZCwge1xuICAgICAgICAgIGFwcGx5KHRhcmdldE1ldGhvZCwgdGhpc09iaiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2FsbCh0aGlzT2JqLCB0YXJnZXQsIC4uLmFyZ3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGxldCBoYXNPd25Qcm9wZXJ0eSA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgYW4gb2JqZWN0IGluIGEgUHJveHkgd2hpY2ggaW50ZXJjZXB0cyBhbmQgd3JhcHMgY2VydGFpbiBtZXRob2RzXG4gICAgICAgKiBiYXNlZCBvbiB0aGUgZ2l2ZW4gYHdyYXBwZXJzYCBhbmQgYG1ldGFkYXRhYCBvYmplY3RzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAgICAgICAqICAgICAgICBUaGUgdGFyZ2V0IG9iamVjdCB0byB3cmFwLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbd3JhcHBlcnMgPSB7fV1cbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgdHJlZSBjb250YWluaW5nIHdyYXBwZXIgZnVuY3Rpb25zIGZvciBzcGVjaWFsIGNhc2VzLiBBbnlcbiAgICAgICAqICAgICAgICBmdW5jdGlvbiBwcmVzZW50IGluIHRoaXMgb2JqZWN0IHRyZWUgaXMgY2FsbGVkIGluIHBsYWNlIG9mIHRoZVxuICAgICAgICogICAgICAgIG1ldGhvZCBpbiB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgYHRhcmdldGAgb2JqZWN0IHRyZWUuIFRoZXNlXG4gICAgICAgKiAgICAgICAgd3JhcHBlciBtZXRob2RzIGFyZSBpbnZva2VkIGFzIGRlc2NyaWJlZCBpbiB7QHNlZSB3cmFwTWV0aG9kfS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gW21ldGFkYXRhID0ge31dXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IHRyZWUgY29udGFpbmluZyBtZXRhZGF0YSB1c2VkIHRvIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVcbiAgICAgICAqICAgICAgICBQcm9taXNlLWJhc2VkIHdyYXBwZXIgZnVuY3Rpb25zIGZvciBhc3luY2hyb25vdXMuIEFueSBmdW5jdGlvbiBpblxuICAgICAgICogICAgICAgIHRoZSBgdGFyZ2V0YCBvYmplY3QgdHJlZSB3aGljaCBoYXMgYSBjb3JyZXNwb25kaW5nIG1ldGFkYXRhIG9iamVjdFxuICAgICAgICogICAgICAgIGluIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBgbWV0YWRhdGFgIHRyZWUgaXMgcmVwbGFjZWQgd2l0aCBhblxuICAgICAgICogICAgICAgIGF1dG9tYXRpY2FsbHktZ2VuZXJhdGVkIHdyYXBwZXIgZnVuY3Rpb24sIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICogICAgICAgIHtAc2VlIHdyYXBBc3luY0Z1bmN0aW9ufVxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtQcm94eTxvYmplY3Q+fVxuICAgICAgICovXG5cbiAgICAgIGNvbnN0IHdyYXBPYmplY3QgPSAodGFyZ2V0LCB3cmFwcGVycyA9IHt9LCBtZXRhZGF0YSA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IHtcbiAgICAgICAgICBoYXMocHJveHlUYXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldCB8fCBwcm9wIGluIGNhY2hlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXQocHJveHlUYXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBjYWNoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbcHJvcF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKHByb3AgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWV0aG9kIG9uIHRoZSB1bmRlcmx5aW5nIG9iamVjdC4gQ2hlY2sgaWYgd2UgbmVlZCB0byBkb1xuICAgICAgICAgICAgICAvLyBhbnkgd3JhcHBpbmcuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlcnNbcHJvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzcGVjaWFsLWNhc2Ugd3JhcHBlciBmb3IgdGhpcyBtZXRob2QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwTWV0aG9kKHRhcmdldCwgdGFyZ2V0W3Byb3BdLCB3cmFwcGVyc1twcm9wXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyBtZXRob2QgdGhhdCB3ZSBoYXZlIG1ldGFkYXRhIGZvci4gQ3JlYXRlIGFcbiAgICAgICAgICAgICAgICAvLyBQcm9taXNlIHdyYXBwZXIgZm9yIGl0LlxuICAgICAgICAgICAgICAgIGxldCB3cmFwcGVyID0gd3JhcEFzeW5jRnVuY3Rpb24ocHJvcCwgbWV0YWRhdGFbcHJvcF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcE1ldGhvZCh0YXJnZXQsIHRhcmdldFtwcm9wXSwgd3JhcHBlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1ldGhvZCB0aGF0IHdlIGRvbid0IGtub3cgb3IgY2FyZSBhYm91dC4gUmV0dXJuIHRoZVxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIG1ldGhvZCwgYm91bmQgdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuYmluZCh0YXJnZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAoaGFzT3duUHJvcGVydHkod3JhcHBlcnMsIHByb3ApIHx8IGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBwcm9wKSkpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBvYmplY3QgdGhhdCB3ZSBuZWVkIHRvIGRvIHNvbWUgd3JhcHBpbmcgZm9yIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAvLyBvZi4gQ3JlYXRlIGEgc3ViLW9iamVjdCB3cmFwcGVyIGZvciBpdCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjaGlsZFxuICAgICAgICAgICAgICAvLyBtZXRhZGF0YS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwT2JqZWN0KHZhbHVlLCB3cmFwcGVyc1twcm9wXSwgbWV0YWRhdGFbcHJvcF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgXCIqXCIpKSB7XG4gICAgICAgICAgICAgIC8vIFdyYXAgYWxsIHByb3BlcnRpZXMgaW4gKiBuYW1lc3BhY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gd3JhcE9iamVjdCh2YWx1ZSwgd3JhcHBlcnNbcHJvcF0sIG1ldGFkYXRhW1wiKlwiXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGRvIGFueSB3cmFwcGluZyBmb3IgdGhpcyBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgLy8gc28ganVzdCBmb3J3YXJkIGFsbCBhY2Nlc3MgdG8gdGhlIHVuZGVybHlpbmcgb2JqZWN0LlxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FjaGUsIHByb3AsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhY2hlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNldChwcm94eVRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBjYWNoZSkge1xuICAgICAgICAgICAgICBjYWNoZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShwcm94eVRhcmdldCwgcHJvcCwgZGVzYykge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoY2FjaGUsIHByb3AsIGRlc2MpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBkZWxldGVQcm9wZXJ0eShwcm94eVRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkoY2FjaGUsIHByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICB9OyAvLyBQZXIgY29udHJhY3Qgb2YgdGhlIFByb3h5IEFQSSwgdGhlIFwiZ2V0XCIgcHJveHkgaGFuZGxlciBtdXN0IHJldHVybiB0aGVcbiAgICAgICAgLy8gb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHRhcmdldCBpZiB0aGF0IHZhbHVlIGlzIGRlY2xhcmVkIHJlYWQtb25seSBhbmRcbiAgICAgICAgLy8gbm9uLWNvbmZpZ3VyYWJsZS4gRm9yIHRoaXMgcmVhc29uLCB3ZSBjcmVhdGUgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICAgIC8vIHByb3RvdHlwZSBzZXQgdG8gYHRhcmdldGAgaW5zdGVhZCBvZiB1c2luZyBgdGFyZ2V0YCBkaXJlY3RseS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbm5vdCByZXR1cm4gYSBjdXN0b20gb2JqZWN0IGZvciBBUElzIHRoYXRcbiAgICAgICAgLy8gYXJlIGRlY2xhcmVkIHJlYWQtb25seSBhbmQgbm9uLWNvbmZpZ3VyYWJsZSwgc3VjaCBhcyBgY2hyb21lLmRldnRvb2xzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIHByb3h5IGhhbmRsZXJzIHRoZW1zZWx2ZXMgd2lsbCBzdGlsbCB1c2UgdGhlIG9yaWdpbmFsIGB0YXJnZXRgXG4gICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIGBwcm94eVRhcmdldGAsIHNvIHRoYXQgdGhlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXJlXG4gICAgICAgIC8vIGRlcmVmZXJlbmNlZCB2aWEgdGhlIG9yaWdpbmFsIHRhcmdldHMuXG5cbiAgICAgICAgbGV0IHByb3h5VGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZSh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHByb3h5VGFyZ2V0LCBoYW5kbGVycyk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgc2V0IG9mIHdyYXBwZXIgZnVuY3Rpb25zIGZvciBhbiBldmVudCBvYmplY3QsIHdoaWNoIGhhbmRsZXNcbiAgICAgICAqIHdyYXBwaW5nIG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0aGF0IHRob3NlIG1lc3NhZ2VzIGFyZSBwYXNzZWQuXG4gICAgICAgKlxuICAgICAgICogQSBzaW5nbGUgd3JhcHBlciBpcyBjcmVhdGVkIGZvciBlYWNoIGxpc3RlbmVyIGZ1bmN0aW9uLCBhbmQgc3RvcmVkIGluIGFcbiAgICAgICAqIG1hcC4gU3Vic2VxdWVudCBjYWxscyB0byBgYWRkTGlzdGVuZXJgLCBgaGFzTGlzdGVuZXJgLCBvciBgcmVtb3ZlTGlzdGVuZXJgXG4gICAgICAgKiByZXRyaWV2ZSB0aGUgb3JpZ2luYWwgd3JhcHBlciwgc28gdGhhdCAgYXR0ZW1wdHMgdG8gcmVtb3ZlIGFcbiAgICAgICAqIHByZXZpb3VzbHktYWRkZWQgbGlzdGVuZXIgd29yayBhcyBleHBlY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0RlZmF1bHRXZWFrTWFwPGZ1bmN0aW9uLCBmdW5jdGlvbj59IHdyYXBwZXJNYXBcbiAgICAgICAqICAgICAgICBBIERlZmF1bHRXZWFrTWFwIG9iamVjdCB3aGljaCB3aWxsIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgd3JhcHBlclxuICAgICAgICogICAgICAgIGZvciBhIGdpdmVuIGxpc3RlbmVyIGZ1bmN0aW9uIHdoZW4gb25lIGRvZXMgbm90IGV4aXN0LCBhbmQgcmV0cmlldmVcbiAgICAgICAqICAgICAgICBhbiBleGlzdGluZyBvbmUgd2hlbiBpdCBkb2VzLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwRXZlbnQgPSB3cmFwcGVyTWFwID0+ICh7XG4gICAgICAgIGFkZExpc3RlbmVyKHRhcmdldCwgbGlzdGVuZXIsIC4uLmFyZ3MpIHtcbiAgICAgICAgICB0YXJnZXQuYWRkTGlzdGVuZXIod3JhcHBlck1hcC5nZXQobGlzdGVuZXIpLCAuLi5hcmdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYXNMaXN0ZW5lcih0YXJnZXQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5oYXNMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lcikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlTGlzdGVuZXIod3JhcHBlck1hcC5nZXQobGlzdGVuZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTsgLy8gS2VlcCB0cmFjayBpZiB0aGUgZGVwcmVjYXRpb24gd2FybmluZyBoYXMgYmVlbiBsb2dnZWQgYXQgbGVhc3Qgb25jZS5cblxuXG4gICAgICBsZXQgbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBvbk1lc3NhZ2VXcmFwcGVycyA9IG5ldyBEZWZhdWx0V2Vha01hcChsaXN0ZW5lciA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcHMgYSBtZXNzYWdlIGxpc3RlbmVyIGZ1bmN0aW9uIHNvIHRoYXQgaXQgbWF5IHNlbmQgcmVzcG9uc2VzIGJhc2VkIG9uXG4gICAgICAgICAqIGl0cyByZXR1cm4gdmFsdWUsIHJhdGhlciB0aGFuIGJ5IHJldHVybmluZyBhIHNlbnRpbmVsIHZhbHVlIGFuZCBjYWxsaW5nIGFcbiAgICAgICAgICogY2FsbGJhY2suIElmIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiByZXR1cm5zIGEgUHJvbWlzZSwgdGhlIHJlc3BvbnNlIGlzXG4gICAgICAgICAqIHNlbnQgd2hlbiB0aGUgcHJvbWlzZSBlaXRoZXIgcmVzb2x2ZXMgb3IgcmVqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSBtZXNzYWdlXG4gICAgICAgICAqICAgICAgICBUaGUgbWVzc2FnZSBzZW50IGJ5IHRoZSBvdGhlciBlbmQgb2YgdGhlIGNoYW5uZWwuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZW5kZXJcbiAgICAgICAgICogICAgICAgIERldGFpbHMgYWJvdXQgdGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZS5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbigqKX0gc2VuZFJlc3BvbnNlXG4gICAgICAgICAqICAgICAgICBBIGNhbGxiYWNrIHdoaWNoLCB3aGVuIGNhbGxlZCB3aXRoIGFuIGFyYml0cmFyeSBhcmd1bWVudCwgc2VuZHNcbiAgICAgICAgICogICAgICAgIHRoYXQgdmFsdWUgYXMgYSByZXNwb25zZS5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqICAgICAgICBUcnVlIGlmIHRoZSB3cmFwcGVkIGxpc3RlbmVyIHJldHVybmVkIGEgUHJvbWlzZSwgd2hpY2ggd2lsbCBsYXRlclxuICAgICAgICAgKiAgICAgICAgeWllbGQgYSByZXNwb25zZS4gRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBvbk1lc3NhZ2UobWVzc2FnZSwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICBsZXQgZGlkQ2FsbFNlbmRSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgIGxldCB3cmFwcGVkU2VuZFJlc3BvbnNlO1xuICAgICAgICAgIGxldCBzZW5kUmVzcG9uc2VQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB3cmFwcGVkU2VuZFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGlmICghbG9nZ2VkU2VuZFJlc3BvbnNlRGVwcmVjYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFNFTkRfUkVTUE9OU0VfREVQUkVDQVRJT05fV0FSTklORywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaWRDYWxsU2VuZFJlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIobWVzc2FnZSwgc2VuZGVyLCB3cmFwcGVkU2VuZFJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNSZXN1bHRUaGVuYWJsZSA9IHJlc3VsdCAhPT0gdHJ1ZSAmJiBpc1RoZW5hYmxlKHJlc3VsdCk7IC8vIElmIHRoZSBsaXN0ZW5lciBkaWRuJ3QgcmV0dXJuZWQgdHJ1ZSBvciBhIFByb21pc2UsIG9yIGNhbGxlZFxuICAgICAgICAgIC8vIHdyYXBwZWRTZW5kUmVzcG9uc2Ugc3luY2hyb25vdXNseSwgd2UgY2FuIGV4aXQgZWFybGllclxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgd2lsbCBiZSBubyByZXNwb25zZSBzZW50IGZyb20gdGhpcyBsaXN0ZW5lci5cblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHRydWUgJiYgIWlzUmVzdWx0VGhlbmFibGUgJiYgIWRpZENhbGxTZW5kUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IC8vIEEgc21hbGwgaGVscGVyIHRvIHNlbmQgdGhlIG1lc3NhZ2UgaWYgdGhlIHByb21pc2UgcmVzb2x2ZXNcbiAgICAgICAgICAvLyBhbmQgYW4gZXJyb3IgaWYgdGhlIHByb21pc2UgcmVqZWN0cyAoYSB3cmFwcGVkIHNlbmRNZXNzYWdlIGhhc1xuICAgICAgICAgIC8vIHRvIHRyYW5zbGF0ZSB0aGUgbWVzc2FnZSBpbnRvIGEgcmVzb2x2ZWQgcHJvbWlzZSBvciBhIHJlamVjdGVkXG4gICAgICAgICAgLy8gcHJvbWlzZSkuXG5cblxuICAgICAgICAgIGNvbnN0IHNlbmRQcm9taXNlZFJlc3VsdCA9IHByb21pc2UgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKG1zZyA9PiB7XG4gICAgICAgICAgICAgIC8vIHNlbmQgdGhlIG1lc3NhZ2UgdmFsdWUuXG4gICAgICAgICAgICAgIHNlbmRSZXNwb25zZShtc2cpO1xuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAvLyBTZW5kIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaWYgdGhlIHJlamVjdGVkIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGlzIGFuIGluc3RhbmNlIG9mIGVycm9yLCBvciB0aGUgb2JqZWN0IGl0c2VsZiBvdGhlcndpc2UuXG4gICAgICAgICAgICAgIGxldCBtZXNzYWdlO1xuXG4gICAgICAgICAgICAgIGlmIChlcnJvciAmJiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIF9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgLy8gUHJpbnQgYW4gZXJyb3Igb24gdGhlIGNvbnNvbGUgaWYgdW5hYmxlIHRvIHNlbmQgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgb25NZXNzYWdlIHJlamVjdGVkIHJlcGx5XCIsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9OyAvLyBJZiB0aGUgbGlzdGVuZXIgcmV0dXJuZWQgYSBQcm9taXNlLCBzZW5kIHRoZSByZXNvbHZlZCB2YWx1ZSBhcyBhXG4gICAgICAgICAgLy8gcmVzdWx0LCBvdGhlcndpc2Ugd2FpdCB0aGUgcHJvbWlzZSByZWxhdGVkIHRvIHRoZSB3cmFwcGVkU2VuZFJlc3BvbnNlXG4gICAgICAgICAgLy8gY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbmQgc2VuZCBpdCBhcyBhIHJlc3BvbnNlLlxuXG5cbiAgICAgICAgICBpZiAoaXNSZXN1bHRUaGVuYWJsZSkge1xuICAgICAgICAgICAgc2VuZFByb21pc2VkUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRQcm9taXNlZFJlc3VsdChzZW5kUmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgICB9IC8vIExldCBDaHJvbWUga25vdyB0aGF0IHRoZSBsaXN0ZW5lciBpcyByZXBseWluZy5cblxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgd3JhcHBlZFNlbmRNZXNzYWdlQ2FsbGJhY2sgPSAoe1xuICAgICAgICByZWplY3QsXG4gICAgICAgIHJlc29sdmVcbiAgICAgIH0sIHJlcGx5KSA9PiB7XG4gICAgICAgIGlmIChleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IHdoZW4gbm9uZSBvZiB0aGUgbGlzdGVuZXJzIHJlcGxpZWQgdG8gdGhlIHNlbmRNZXNzYWdlIGNhbGwgYW5kIHJlc29sdmVcbiAgICAgICAgICAvLyB0aGUgcHJvbWlzZSB0byB1bmRlZmluZWQgYXMgaW4gRmlyZWZveC5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvd2ViZXh0ZW5zaW9uLXBvbHlmaWxsL2lzc3Vlcy8xMzBcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlID09PSBDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyZXBseSAmJiByZXBseS5fX21veldlYkV4dGVuc2lvblBvbHlmaWxsUmVqZWN0X18pIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yIGludG9cbiAgICAgICAgICAvLyBhbiBFcnJvciBpbnN0YW5jZS5cbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKHJlcGx5Lm1lc3NhZ2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHJlcGx5KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgd3JhcHBlZFNlbmRNZXNzYWdlID0gKG5hbWUsIG1ldGFkYXRhLCBhcGlOYW1lc3BhY2VPYmosIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgbWV0YWRhdGEubWluQXJncykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXQgbGVhc3QgJHttZXRhZGF0YS5taW5BcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5taW5BcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBtZXRhZGF0YS5tYXhBcmdzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBtb3N0ICR7bWV0YWRhdGEubWF4QXJnc30gJHtwbHVyYWxpemVBcmd1bWVudHMobWV0YWRhdGEubWF4QXJncyl9IGZvciAke25hbWV9KCksIGdvdCAke2FyZ3MubGVuZ3RofWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVkQ2IgPSB3cmFwcGVkU2VuZE1lc3NhZ2VDYWxsYmFjay5iaW5kKG51bGwsIHtcbiAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICByZWplY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcmdzLnB1c2god3JhcHBlZENiKTtcbiAgICAgICAgICBhcGlOYW1lc3BhY2VPYmouc2VuZE1lc3NhZ2UoLi4uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RhdGljV3JhcHBlcnMgPSB7XG4gICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICBvbk1lc3NhZ2U6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgb25NZXNzYWdlRXh0ZXJuYWw6IHdyYXBFdmVudChvbk1lc3NhZ2VXcmFwcGVycyksXG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB0YWJzOiB7XG4gICAgICAgICAgc2VuZE1lc3NhZ2U6IHdyYXBwZWRTZW5kTWVzc2FnZS5iaW5kKG51bGwsIFwic2VuZE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgbWluQXJnczogMixcbiAgICAgICAgICAgIG1heEFyZ3M6IDNcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2V0dGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjbGVhcjoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhcGlNZXRhZGF0YS5wcml2YWN5ID0ge1xuICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9LFxuICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgd2Vic2l0ZXM6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gd3JhcE9iamVjdChleHRlbnNpb25BUElzLCBzdGF0aWNXcmFwcGVycywgYXBpTWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNocm9tZSAhPSBcIm9iamVjdFwiIHx8ICFjaHJvbWUgfHwgIWNocm9tZS5ydW50aW1lIHx8ICFjaHJvbWUucnVudGltZS5pZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzY3JpcHQgc2hvdWxkIG9ubHkgYmUgbG9hZGVkIGluIGEgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgIH0gLy8gVGhlIGJ1aWxkIHByb2Nlc3MgYWRkcyBhIFVNRCB3cmFwcGVyIGFyb3VuZCB0aGlzIGZpbGUsIHdoaWNoIG1ha2VzIHRoZVxuICAgIC8vIGBtb2R1bGVgIHZhcmlhYmxlIGF2YWlsYWJsZS5cblxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3cmFwQVBJcyhjaHJvbWUpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gYnJvd3NlcjtcbiAgfVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLXBvbHlmaWxsLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webextension-polyfill/dist/browser-polyfill.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/content.ts");
/******/ 	
/******/ })()
;